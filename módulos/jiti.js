var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};

// node_modules/jiti/dist/jiti.cjs
var require_jiti = __commonJS({
  "node_modules/jiti/dist/jiti.cjs"(exports2, module2) {
    (() => {
      var e = { "./node_modules/.pnpm/mlly@1.8.0/node_modules/mlly/dist lazy recursive": function(e2) {
        function webpackEmptyAsyncContext(e3) {
          return Promise.resolve().then(function() {
            var t2 = new Error("Cannot find module '" + e3 + "'");
            throw t2.code = "MODULE_NOT_FOUND", t2;
          });
        }
        webpackEmptyAsyncContext.keys = () => [], webpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext, webpackEmptyAsyncContext.id = "./node_modules/.pnpm/mlly@1.8.0/node_modules/mlly/dist lazy recursive", e2.exports = webpackEmptyAsyncContext;
      } }, t = {};
      function __webpack_require__(i2) {
        var s = t[i2];
        if (void 0 !== s) return s.exports;
        var r = t[i2] = { exports: {} };
        return e[i2](r, r.exports, __webpack_require__), r.exports;
      }
      __webpack_require__.n = (e2) => {
        var t2 = e2 && e2.__esModule ? () => e2.default : () => e2;
        return __webpack_require__.d(t2, { a: t2 }), t2;
      }, __webpack_require__.d = (e2, t2) => {
        for (var i2 in t2) __webpack_require__.o(t2, i2) && !__webpack_require__.o(e2, i2) && Object.defineProperty(e2, i2, { enumerable: true, get: t2[i2] });
      }, __webpack_require__.o = (e2, t2) => Object.prototype.hasOwnProperty.call(e2, t2);
      var i = {};
      (() => {
        "use strict";
        __webpack_require__.d(i, { default: () => createJiti2 });
        const e2 = require("node:os");
        var t2 = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239], s = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], r = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC", n = { 3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile", 5: "class enum extends super const export import", 6: "enum", strict: "implements interface let package private protected public static yield", strictBind: "eval arguments" }, a = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this", o = { 5: a, "5module": a + " export import", 6: a + " const class extends export import super" }, h = /^in(stanceof)?$/, c = new RegExp("[" + r + "]"), p = new RegExp("[" + r + "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65]");
        function isInAstralSet(e3, t3) {
          for (var i2 = 65536, s2 = 0; s2 < t3.length; s2 += 2) {
            if ((i2 += t3[s2]) > e3) return false;
            if ((i2 += t3[s2 + 1]) >= e3) return true;
          }
          return false;
        }
        function isIdentifierStart(e3, t3) {
          return e3 < 65 ? 36 === e3 : e3 < 91 || (e3 < 97 ? 95 === e3 : e3 < 123 || (e3 <= 65535 ? e3 >= 170 && c.test(String.fromCharCode(e3)) : false !== t3 && isInAstralSet(e3, s)));
        }
        function isIdentifierChar(e3, i2) {
          return e3 < 48 ? 36 === e3 : e3 < 58 || !(e3 < 65) && (e3 < 91 || (e3 < 97 ? 95 === e3 : e3 < 123 || (e3 <= 65535 ? e3 >= 170 && p.test(String.fromCharCode(e3)) : false !== i2 && (isInAstralSet(e3, s) || isInAstralSet(e3, t2)))));
        }
        var acorn_TokenType = function(e3, t3) {
          void 0 === t3 && (t3 = {}), this.label = e3, this.keyword = t3.keyword, this.beforeExpr = !!t3.beforeExpr, this.startsExpr = !!t3.startsExpr, this.isLoop = !!t3.isLoop, this.isAssign = !!t3.isAssign, this.prefix = !!t3.prefix, this.postfix = !!t3.postfix, this.binop = t3.binop || null, this.updateContext = null;
        };
        function binop(e3, t3) {
          return new acorn_TokenType(e3, { beforeExpr: true, binop: t3 });
        }
        var l = { beforeExpr: true }, u = { startsExpr: true }, d = {};
        function kw(e3, t3) {
          return void 0 === t3 && (t3 = {}), t3.keyword = e3, d[e3] = new acorn_TokenType(e3, t3);
        }
        var f = { num: new acorn_TokenType("num", u), regexp: new acorn_TokenType("regexp", u), string: new acorn_TokenType("string", u), name: new acorn_TokenType("name", u), privateId: new acorn_TokenType("privateId", u), eof: new acorn_TokenType("eof"), bracketL: new acorn_TokenType("[", { beforeExpr: true, startsExpr: true }), bracketR: new acorn_TokenType("]"), braceL: new acorn_TokenType("{", { beforeExpr: true, startsExpr: true }), braceR: new acorn_TokenType("}"), parenL: new acorn_TokenType("(", { beforeExpr: true, startsExpr: true }), parenR: new acorn_TokenType(")"), comma: new acorn_TokenType(",", l), semi: new acorn_TokenType(";", l), colon: new acorn_TokenType(":", l), dot: new acorn_TokenType("."), question: new acorn_TokenType("?", l), questionDot: new acorn_TokenType("?."), arrow: new acorn_TokenType("=>", l), template: new acorn_TokenType("template"), invalidTemplate: new acorn_TokenType("invalidTemplate"), ellipsis: new acorn_TokenType("...", l), backQuote: new acorn_TokenType("`", u), dollarBraceL: new acorn_TokenType("${", { beforeExpr: true, startsExpr: true }), eq: new acorn_TokenType("=", { beforeExpr: true, isAssign: true }), assign: new acorn_TokenType("_=", { beforeExpr: true, isAssign: true }), incDec: new acorn_TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }), prefix: new acorn_TokenType("!/~", { beforeExpr: true, prefix: true, startsExpr: true }), logicalOR: binop("||", 1), logicalAND: binop("&&", 2), bitwiseOR: binop("|", 3), bitwiseXOR: binop("^", 4), bitwiseAND: binop("&", 5), equality: binop("==/!=/===/!==", 6), relational: binop("</>/<=/>=", 7), bitShift: binop("<</>>/>>>", 8), plusMin: new acorn_TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }), modulo: binop("%", 10), star: binop("*", 10), slash: binop("/", 10), starstar: new acorn_TokenType("**", { beforeExpr: true }), coalesce: binop("??", 1), _break: kw("break"), _case: kw("case", l), _catch: kw("catch"), _continue: kw("continue"), _debugger: kw("debugger"), _default: kw("default", l), _do: kw("do", { isLoop: true, beforeExpr: true }), _else: kw("else", l), _finally: kw("finally"), _for: kw("for", { isLoop: true }), _function: kw("function", u), _if: kw("if"), _return: kw("return", l), _switch: kw("switch"), _throw: kw("throw", l), _try: kw("try"), _var: kw("var"), _const: kw("const"), _while: kw("while", { isLoop: true }), _with: kw("with"), _new: kw("new", { beforeExpr: true, startsExpr: true }), _this: kw("this", u), _super: kw("super", u), _class: kw("class", u), _extends: kw("extends", l), _export: kw("export"), _import: kw("import", u), _null: kw("null", u), _true: kw("true", u), _false: kw("false", u), _in: kw("in", { beforeExpr: true, binop: 7 }), _instanceof: kw("instanceof", { beforeExpr: true, binop: 7 }), _typeof: kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true }), _void: kw("void", { beforeExpr: true, prefix: true, startsExpr: true }), _delete: kw("delete", { beforeExpr: true, prefix: true, startsExpr: true }) }, m = /\r\n?|\n|\u2028|\u2029/, g = new RegExp(m.source, "g");
        function isNewLine(e3) {
          return 10 === e3 || 13 === e3 || 8232 === e3 || 8233 === e3;
        }
        function nextLineBreak(e3, t3, i2) {
          void 0 === i2 && (i2 = e3.length);
          for (var s2 = t3; s2 < i2; s2++) {
            var r2 = e3.charCodeAt(s2);
            if (isNewLine(r2)) return s2 < i2 - 1 && 13 === r2 && 10 === e3.charCodeAt(s2 + 1) ? s2 + 2 : s2 + 1;
          }
          return -1;
        }
        var x = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/, v = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, y = Object.prototype, _ = y.hasOwnProperty, E = y.toString, b = Object.hasOwn || function(e3, t3) {
          return _.call(e3, t3);
        }, S = Array.isArray || function(e3) {
          return "[object Array]" === E.call(e3);
        }, k = /* @__PURE__ */ Object.create(null);
        function wordsRegexp(e3) {
          return k[e3] || (k[e3] = new RegExp("^(?:" + e3.replace(/ /g, "|") + ")$"));
        }
        function codePointToString(e3) {
          return e3 <= 65535 ? String.fromCharCode(e3) : (e3 -= 65536, String.fromCharCode(55296 + (e3 >> 10), 56320 + (1023 & e3)));
        }
        var w = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/, acorn_Position = function(e3, t3) {
          this.line = e3, this.column = t3;
        };
        acorn_Position.prototype.offset = function(e3) {
          return new acorn_Position(this.line, this.column + e3);
        };
        var acorn_SourceLocation = function(e3, t3, i2) {
          this.start = t3, this.end = i2, null !== e3.sourceFile && (this.source = e3.sourceFile);
        };
        function getLineInfo(e3, t3) {
          for (var i2 = 1, s2 = 0; ; ) {
            var r2 = nextLineBreak(e3, s2, t3);
            if (r2 < 0) return new acorn_Position(i2, t3 - s2);
            ++i2, s2 = r2;
          }
        }
        var I = { ecmaVersion: null, sourceType: "script", onInsertedSemicolon: null, onTrailingComma: null, allowReserved: null, allowReturnOutsideFunction: false, allowImportExportEverywhere: false, allowAwaitOutsideFunction: null, allowSuperOutsideMethod: null, allowHashBang: false, checkPrivateFields: true, locations: false, onToken: null, onComment: null, ranges: false, program: null, sourceFile: null, directSourceFile: null, preserveParens: false }, C = false;
        function getOptions(e3) {
          var t3 = {};
          for (var i2 in I) t3[i2] = e3 && b(e3, i2) ? e3[i2] : I[i2];
          if ("latest" === t3.ecmaVersion ? t3.ecmaVersion = 1e8 : null == t3.ecmaVersion ? (!C && "object" == typeof console && console.warn && (C = true, console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.")), t3.ecmaVersion = 11) : t3.ecmaVersion >= 2015 && (t3.ecmaVersion -= 2009), null == t3.allowReserved && (t3.allowReserved = t3.ecmaVersion < 5), e3 && null != e3.allowHashBang || (t3.allowHashBang = t3.ecmaVersion >= 14), S(t3.onToken)) {
            var s2 = t3.onToken;
            t3.onToken = function(e4) {
              return s2.push(e4);
            };
          }
          return S(t3.onComment) && (t3.onComment = /* @__PURE__ */ (function(e4, t4) {
            return function(i3, s3, r2, n2, a2, o2) {
              var h2 = { type: i3 ? "Block" : "Line", value: s3, start: r2, end: n2 };
              e4.locations && (h2.loc = new acorn_SourceLocation(this, a2, o2)), e4.ranges && (h2.range = [r2, n2]), t4.push(h2);
            };
          })(t3, t3.onComment)), t3;
        }
        var R = 256, P = 259;
        function functionFlags(e3, t3) {
          return 2 | (e3 ? 4 : 0) | (t3 ? 8 : 0);
        }
        var acorn_Parser = function(e3, t3, i2) {
          this.options = e3 = getOptions(e3), this.sourceFile = e3.sourceFile, this.keywords = wordsRegexp(o[e3.ecmaVersion >= 6 ? 6 : "module" === e3.sourceType ? "5module" : 5]);
          var s2 = "";
          true !== e3.allowReserved && (s2 = n[e3.ecmaVersion >= 6 ? 6 : 5 === e3.ecmaVersion ? 5 : 3], "module" === e3.sourceType && (s2 += " await")), this.reservedWords = wordsRegexp(s2);
          var r2 = (s2 ? s2 + " " : "") + n.strict;
          this.reservedWordsStrict = wordsRegexp(r2), this.reservedWordsStrictBind = wordsRegexp(r2 + " " + n.strictBind), this.input = String(t3), this.containsEsc = false, i2 ? (this.pos = i2, this.lineStart = this.input.lastIndexOf("\n", i2 - 1) + 1, this.curLine = this.input.slice(0, this.lineStart).split(m).length) : (this.pos = this.lineStart = 0, this.curLine = 1), this.type = f.eof, this.value = null, this.start = this.end = this.pos, this.startLoc = this.endLoc = this.curPosition(), this.lastTokEndLoc = this.lastTokStartLoc = null, this.lastTokStart = this.lastTokEnd = this.pos, this.context = this.initialContext(), this.exprAllowed = true, this.inModule = "module" === e3.sourceType, this.strict = this.inModule || this.strictDirective(this.pos), this.potentialArrowAt = -1, this.potentialArrowInForAwait = false, this.yieldPos = this.awaitPos = this.awaitIdentPos = 0, this.labels = [], this.undefinedExports = /* @__PURE__ */ Object.create(null), 0 === this.pos && e3.allowHashBang && "#!" === this.input.slice(0, 2) && this.skipLineComment(2), this.scopeStack = [], this.enterScope(1), this.regexpState = null, this.privateNameStack = [];
        }, T = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, allowNewDotTarget: { configurable: true }, inClassStaticBlock: { configurable: true } };
        acorn_Parser.prototype.parse = function() {
          var e3 = this.options.program || this.startNode();
          return this.nextToken(), this.parseTopLevel(e3);
        }, T.inFunction.get = function() {
          return (2 & this.currentVarScope().flags) > 0;
        }, T.inGenerator.get = function() {
          return (8 & this.currentVarScope().flags) > 0;
        }, T.inAsync.get = function() {
          return (4 & this.currentVarScope().flags) > 0;
        }, T.canAwait.get = function() {
          for (var e3 = this.scopeStack.length - 1; e3 >= 0; e3--) {
            var t3 = this.scopeStack[e3].flags;
            if (768 & t3) return false;
            if (2 & t3) return (4 & t3) > 0;
          }
          return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
        }, T.allowSuper.get = function() {
          return (64 & this.currentThisScope().flags) > 0 || this.options.allowSuperOutsideMethod;
        }, T.allowDirectSuper.get = function() {
          return (128 & this.currentThisScope().flags) > 0;
        }, T.treatFunctionsAsVar.get = function() {
          return this.treatFunctionsAsVarInScope(this.currentScope());
        }, T.allowNewDotTarget.get = function() {
          for (var e3 = this.scopeStack.length - 1; e3 >= 0; e3--) {
            var t3 = this.scopeStack[e3].flags;
            if (768 & t3 || 2 & t3 && !(16 & t3)) return true;
          }
          return false;
        }, T.inClassStaticBlock.get = function() {
          return (this.currentVarScope().flags & R) > 0;
        }, acorn_Parser.extend = function() {
          for (var e3 = [], t3 = arguments.length; t3--; ) e3[t3] = arguments[t3];
          for (var i2 = this, s2 = 0; s2 < e3.length; s2++) i2 = e3[s2](i2);
          return i2;
        }, acorn_Parser.parse = function(e3, t3) {
          return new this(t3, e3).parse();
        }, acorn_Parser.parseExpressionAt = function(e3, t3, i2) {
          var s2 = new this(i2, e3, t3);
          return s2.nextToken(), s2.parseExpression();
        }, acorn_Parser.tokenizer = function(e3, t3) {
          return new this(t3, e3);
        }, Object.defineProperties(acorn_Parser.prototype, T);
        var A = acorn_Parser.prototype, N = /^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/;
        A.strictDirective = function(e3) {
          if (this.options.ecmaVersion < 5) return false;
          for (; ; ) {
            v.lastIndex = e3, e3 += v.exec(this.input)[0].length;
            var t3 = N.exec(this.input.slice(e3));
            if (!t3) return false;
            if ("use strict" === (t3[1] || t3[2])) {
              v.lastIndex = e3 + t3[0].length;
              var i2 = v.exec(this.input), s2 = i2.index + i2[0].length, r2 = this.input.charAt(s2);
              return ";" === r2 || "}" === r2 || m.test(i2[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(r2) || "!" === r2 && "=" === this.input.charAt(s2 + 1));
            }
            e3 += t3[0].length, v.lastIndex = e3, e3 += v.exec(this.input)[0].length, ";" === this.input[e3] && e3++;
          }
        }, A.eat = function(e3) {
          return this.type === e3 && (this.next(), true);
        }, A.isContextual = function(e3) {
          return this.type === f.name && this.value === e3 && !this.containsEsc;
        }, A.eatContextual = function(e3) {
          return !!this.isContextual(e3) && (this.next(), true);
        }, A.expectContextual = function(e3) {
          this.eatContextual(e3) || this.unexpected();
        }, A.canInsertSemicolon = function() {
          return this.type === f.eof || this.type === f.braceR || m.test(this.input.slice(this.lastTokEnd, this.start));
        }, A.insertSemicolon = function() {
          if (this.canInsertSemicolon()) return this.options.onInsertedSemicolon && this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc), true;
        }, A.semicolon = function() {
          this.eat(f.semi) || this.insertSemicolon() || this.unexpected();
        }, A.afterTrailingComma = function(e3, t3) {
          if (this.type === e3) return this.options.onTrailingComma && this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc), t3 || this.next(), true;
        }, A.expect = function(e3) {
          this.eat(e3) || this.unexpected();
        }, A.unexpected = function(e3) {
          this.raise(null != e3 ? e3 : this.start, "Unexpected token");
        };
        var acorn_DestructuringErrors = function() {
          this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
        };
        A.checkPatternErrors = function(e3, t3) {
          if (e3) {
            e3.trailingComma > -1 && this.raiseRecoverable(e3.trailingComma, "Comma is not permitted after the rest element");
            var i2 = t3 ? e3.parenthesizedAssign : e3.parenthesizedBind;
            i2 > -1 && this.raiseRecoverable(i2, t3 ? "Assigning to rvalue" : "Parenthesized pattern");
          }
        }, A.checkExpressionErrors = function(e3, t3) {
          if (!e3) return false;
          var i2 = e3.shorthandAssign, s2 = e3.doubleProto;
          if (!t3) return i2 >= 0 || s2 >= 0;
          i2 >= 0 && this.raise(i2, "Shorthand property assignments are valid only in destructuring patterns"), s2 >= 0 && this.raiseRecoverable(s2, "Redefinition of __proto__ property");
        }, A.checkYieldAwaitInDefaultParams = function() {
          this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos) && this.raise(this.yieldPos, "Yield expression cannot be a default value"), this.awaitPos && this.raise(this.awaitPos, "Await expression cannot be a default value");
        }, A.isSimpleAssignTarget = function(e3) {
          return "ParenthesizedExpression" === e3.type ? this.isSimpleAssignTarget(e3.expression) : "Identifier" === e3.type || "MemberExpression" === e3.type;
        };
        var L = acorn_Parser.prototype;
        L.parseTopLevel = function(e3) {
          var t3 = /* @__PURE__ */ Object.create(null);
          for (e3.body || (e3.body = []); this.type !== f.eof; ) {
            var i2 = this.parseStatement(null, true, t3);
            e3.body.push(i2);
          }
          if (this.inModule) for (var s2 = 0, r2 = Object.keys(this.undefinedExports); s2 < r2.length; s2 += 1) {
            var n2 = r2[s2];
            this.raiseRecoverable(this.undefinedExports[n2].start, "Export '" + n2 + "' is not defined");
          }
          return this.adaptDirectivePrologue(e3.body), this.next(), e3.sourceType = this.options.sourceType, this.finishNode(e3, "Program");
        };
        var O = { kind: "loop" }, D = { kind: "switch" };
        L.isLet = function(e3) {
          if (this.options.ecmaVersion < 6 || !this.isContextual("let")) return false;
          v.lastIndex = this.pos;
          var t3 = v.exec(this.input), i2 = this.pos + t3[0].length, s2 = this.input.charCodeAt(i2);
          if (91 === s2 || 92 === s2) return true;
          if (e3) return false;
          if (123 === s2 || s2 > 55295 && s2 < 56320) return true;
          if (isIdentifierStart(s2, true)) {
            for (var r2 = i2 + 1; isIdentifierChar(s2 = this.input.charCodeAt(r2), true); ) ++r2;
            if (92 === s2 || s2 > 55295 && s2 < 56320) return true;
            var n2 = this.input.slice(i2, r2);
            if (!h.test(n2)) return true;
          }
          return false;
        }, L.isAsyncFunction = function() {
          if (this.options.ecmaVersion < 8 || !this.isContextual("async")) return false;
          v.lastIndex = this.pos;
          var e3, t3 = v.exec(this.input), i2 = this.pos + t3[0].length;
          return !(m.test(this.input.slice(this.pos, i2)) || "function" !== this.input.slice(i2, i2 + 8) || i2 + 8 !== this.input.length && (isIdentifierChar(e3 = this.input.charCodeAt(i2 + 8)) || e3 > 55295 && e3 < 56320));
        }, L.isUsingKeyword = function(e3, t3) {
          if (this.options.ecmaVersion < 17 || !this.isContextual(e3 ? "await" : "using")) return false;
          v.lastIndex = this.pos;
          var i2 = v.exec(this.input), s2 = this.pos + i2[0].length;
          if (m.test(this.input.slice(this.pos, s2))) return false;
          if (e3) {
            var r2, n2 = s2 + 5;
            if ("using" !== this.input.slice(s2, n2) || n2 === this.input.length || isIdentifierChar(r2 = this.input.charCodeAt(n2)) || r2 > 55295 && r2 < 56320) return false;
            v.lastIndex = n2;
            var a2 = v.exec(this.input);
            if (a2 && m.test(this.input.slice(n2, n2 + a2[0].length))) return false;
          }
          if (t3) {
            var o2, h2 = s2 + 2;
            if (!("of" !== this.input.slice(s2, h2) || h2 !== this.input.length && (isIdentifierChar(o2 = this.input.charCodeAt(h2)) || o2 > 55295 && o2 < 56320))) return false;
          }
          var c2 = this.input.charCodeAt(s2);
          return isIdentifierStart(c2, true) || 92 === c2;
        }, L.isAwaitUsing = function(e3) {
          return this.isUsingKeyword(true, e3);
        }, L.isUsing = function(e3) {
          return this.isUsingKeyword(false, e3);
        }, L.parseStatement = function(e3, t3, i2) {
          var s2, r2 = this.type, n2 = this.startNode();
          switch (this.isLet(e3) && (r2 = f._var, s2 = "let"), r2) {
            case f._break:
            case f._continue:
              return this.parseBreakContinueStatement(n2, r2.keyword);
            case f._debugger:
              return this.parseDebuggerStatement(n2);
            case f._do:
              return this.parseDoStatement(n2);
            case f._for:
              return this.parseForStatement(n2);
            case f._function:
              return e3 && (this.strict || "if" !== e3 && "label" !== e3) && this.options.ecmaVersion >= 6 && this.unexpected(), this.parseFunctionStatement(n2, false, !e3);
            case f._class:
              return e3 && this.unexpected(), this.parseClass(n2, true);
            case f._if:
              return this.parseIfStatement(n2);
            case f._return:
              return this.parseReturnStatement(n2);
            case f._switch:
              return this.parseSwitchStatement(n2);
            case f._throw:
              return this.parseThrowStatement(n2);
            case f._try:
              return this.parseTryStatement(n2);
            case f._const:
            case f._var:
              return s2 = s2 || this.value, e3 && "var" !== s2 && this.unexpected(), this.parseVarStatement(n2, s2);
            case f._while:
              return this.parseWhileStatement(n2);
            case f._with:
              return this.parseWithStatement(n2);
            case f.braceL:
              return this.parseBlock(true, n2);
            case f.semi:
              return this.parseEmptyStatement(n2);
            case f._export:
            case f._import:
              if (this.options.ecmaVersion > 10 && r2 === f._import) {
                v.lastIndex = this.pos;
                var a2 = v.exec(this.input), o2 = this.pos + a2[0].length, h2 = this.input.charCodeAt(o2);
                if (40 === h2 || 46 === h2) return this.parseExpressionStatement(n2, this.parseExpression());
              }
              return this.options.allowImportExportEverywhere || (t3 || this.raise(this.start, "'import' and 'export' may only appear at the top level"), this.inModule || this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'")), r2 === f._import ? this.parseImport(n2) : this.parseExport(n2, i2);
            default:
              if (this.isAsyncFunction()) return e3 && this.unexpected(), this.next(), this.parseFunctionStatement(n2, true, !e3);
              var c2 = this.isAwaitUsing(false) ? "await using" : this.isUsing(false) ? "using" : null;
              if (c2) return t3 && "script" === this.options.sourceType && this.raise(this.start, "Using declaration cannot appear in the top level when source type is `script`"), "await using" === c2 && (this.canAwait || this.raise(this.start, "Await using cannot appear outside of async function"), this.next()), this.next(), this.parseVar(n2, false, c2), this.semicolon(), this.finishNode(n2, "VariableDeclaration");
              var p2 = this.value, l2 = this.parseExpression();
              return r2 === f.name && "Identifier" === l2.type && this.eat(f.colon) ? this.parseLabeledStatement(n2, p2, l2, e3) : this.parseExpressionStatement(n2, l2);
          }
        }, L.parseBreakContinueStatement = function(e3, t3) {
          var i2 = "break" === t3;
          this.next(), this.eat(f.semi) || this.insertSemicolon() ? e3.label = null : this.type !== f.name ? this.unexpected() : (e3.label = this.parseIdent(), this.semicolon());
          for (var s2 = 0; s2 < this.labels.length; ++s2) {
            var r2 = this.labels[s2];
            if (null == e3.label || r2.name === e3.label.name) {
              if (null != r2.kind && (i2 || "loop" === r2.kind)) break;
              if (e3.label && i2) break;
            }
          }
          return s2 === this.labels.length && this.raise(e3.start, "Unsyntactic " + t3), this.finishNode(e3, i2 ? "BreakStatement" : "ContinueStatement");
        }, L.parseDebuggerStatement = function(e3) {
          return this.next(), this.semicolon(), this.finishNode(e3, "DebuggerStatement");
        }, L.parseDoStatement = function(e3) {
          return this.next(), this.labels.push(O), e3.body = this.parseStatement("do"), this.labels.pop(), this.expect(f._while), e3.test = this.parseParenExpression(), this.options.ecmaVersion >= 6 ? this.eat(f.semi) : this.semicolon(), this.finishNode(e3, "DoWhileStatement");
        }, L.parseForStatement = function(e3) {
          this.next();
          var t3 = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
          if (this.labels.push(O), this.enterScope(0), this.expect(f.parenL), this.type === f.semi) return t3 > -1 && this.unexpected(t3), this.parseFor(e3, null);
          var i2 = this.isLet();
          if (this.type === f._var || this.type === f._const || i2) {
            var s2 = this.startNode(), r2 = i2 ? "let" : this.value;
            return this.next(), this.parseVar(s2, true, r2), this.finishNode(s2, "VariableDeclaration"), this.parseForAfterInit(e3, s2, t3);
          }
          var n2 = this.isContextual("let"), a2 = false, o2 = this.isUsing(true) ? "using" : this.isAwaitUsing(true) ? "await using" : null;
          if (o2) {
            var h2 = this.startNode();
            return this.next(), "await using" === o2 && this.next(), this.parseVar(h2, true, o2), this.finishNode(h2, "VariableDeclaration"), this.parseForAfterInit(e3, h2, t3);
          }
          var c2 = this.containsEsc, p2 = new acorn_DestructuringErrors(), l2 = this.start, u2 = t3 > -1 ? this.parseExprSubscripts(p2, "await") : this.parseExpression(true, p2);
          return this.type === f._in || (a2 = this.options.ecmaVersion >= 6 && this.isContextual("of")) ? (t3 > -1 ? (this.type === f._in && this.unexpected(t3), e3.await = true) : a2 && this.options.ecmaVersion >= 8 && (u2.start !== l2 || c2 || "Identifier" !== u2.type || "async" !== u2.name ? this.options.ecmaVersion >= 9 && (e3.await = false) : this.unexpected()), n2 && a2 && this.raise(u2.start, "The left-hand side of a for-of loop may not start with 'let'."), this.toAssignable(u2, false, p2), this.checkLValPattern(u2), this.parseForIn(e3, u2)) : (this.checkExpressionErrors(p2, true), t3 > -1 && this.unexpected(t3), this.parseFor(e3, u2));
        }, L.parseForAfterInit = function(e3, t3, i2) {
          return (this.type === f._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && 1 === t3.declarations.length ? (this.options.ecmaVersion >= 9 && (this.type === f._in ? i2 > -1 && this.unexpected(i2) : e3.await = i2 > -1), this.parseForIn(e3, t3)) : (i2 > -1 && this.unexpected(i2), this.parseFor(e3, t3));
        }, L.parseFunctionStatement = function(e3, t3, i2) {
          return this.next(), this.parseFunction(e3, U | (i2 ? 0 : M), false, t3);
        }, L.parseIfStatement = function(e3) {
          return this.next(), e3.test = this.parseParenExpression(), e3.consequent = this.parseStatement("if"), e3.alternate = this.eat(f._else) ? this.parseStatement("if") : null, this.finishNode(e3, "IfStatement");
        }, L.parseReturnStatement = function(e3) {
          return this.inFunction || this.options.allowReturnOutsideFunction || this.raise(this.start, "'return' outside of function"), this.next(), this.eat(f.semi) || this.insertSemicolon() ? e3.argument = null : (e3.argument = this.parseExpression(), this.semicolon()), this.finishNode(e3, "ReturnStatement");
        }, L.parseSwitchStatement = function(e3) {
          var t3;
          this.next(), e3.discriminant = this.parseParenExpression(), e3.cases = [], this.expect(f.braceL), this.labels.push(D), this.enterScope(0);
          for (var i2 = false; this.type !== f.braceR; ) if (this.type === f._case || this.type === f._default) {
            var s2 = this.type === f._case;
            t3 && this.finishNode(t3, "SwitchCase"), e3.cases.push(t3 = this.startNode()), t3.consequent = [], this.next(), s2 ? t3.test = this.parseExpression() : (i2 && this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"), i2 = true, t3.test = null), this.expect(f.colon);
          } else t3 || this.unexpected(), t3.consequent.push(this.parseStatement(null));
          return this.exitScope(), t3 && this.finishNode(t3, "SwitchCase"), this.next(), this.labels.pop(), this.finishNode(e3, "SwitchStatement");
        }, L.parseThrowStatement = function(e3) {
          return this.next(), m.test(this.input.slice(this.lastTokEnd, this.start)) && this.raise(this.lastTokEnd, "Illegal newline after throw"), e3.argument = this.parseExpression(), this.semicolon(), this.finishNode(e3, "ThrowStatement");
        };
        var V = [];
        L.parseCatchClauseParam = function() {
          var e3 = this.parseBindingAtom(), t3 = "Identifier" === e3.type;
          return this.enterScope(t3 ? 32 : 0), this.checkLValPattern(e3, t3 ? 4 : 2), this.expect(f.parenR), e3;
        }, L.parseTryStatement = function(e3) {
          if (this.next(), e3.block = this.parseBlock(), e3.handler = null, this.type === f._catch) {
            var t3 = this.startNode();
            this.next(), this.eat(f.parenL) ? t3.param = this.parseCatchClauseParam() : (this.options.ecmaVersion < 10 && this.unexpected(), t3.param = null, this.enterScope(0)), t3.body = this.parseBlock(false), this.exitScope(), e3.handler = this.finishNode(t3, "CatchClause");
          }
          return e3.finalizer = this.eat(f._finally) ? this.parseBlock() : null, e3.handler || e3.finalizer || this.raise(e3.start, "Missing catch or finally clause"), this.finishNode(e3, "TryStatement");
        }, L.parseVarStatement = function(e3, t3, i2) {
          return this.next(), this.parseVar(e3, false, t3, i2), this.semicolon(), this.finishNode(e3, "VariableDeclaration");
        }, L.parseWhileStatement = function(e3) {
          return this.next(), e3.test = this.parseParenExpression(), this.labels.push(O), e3.body = this.parseStatement("while"), this.labels.pop(), this.finishNode(e3, "WhileStatement");
        }, L.parseWithStatement = function(e3) {
          return this.strict && this.raise(this.start, "'with' in strict mode"), this.next(), e3.object = this.parseParenExpression(), e3.body = this.parseStatement("with"), this.finishNode(e3, "WithStatement");
        }, L.parseEmptyStatement = function(e3) {
          return this.next(), this.finishNode(e3, "EmptyStatement");
        }, L.parseLabeledStatement = function(e3, t3, i2, s2) {
          for (var r2 = 0, n2 = this.labels; r2 < n2.length; r2 += 1) {
            n2[r2].name === t3 && this.raise(i2.start, "Label '" + t3 + "' is already declared");
          }
          for (var a2 = this.type.isLoop ? "loop" : this.type === f._switch ? "switch" : null, o2 = this.labels.length - 1; o2 >= 0; o2--) {
            var h2 = this.labels[o2];
            if (h2.statementStart !== e3.start) break;
            h2.statementStart = this.start, h2.kind = a2;
          }
          return this.labels.push({ name: t3, kind: a2, statementStart: this.start }), e3.body = this.parseStatement(s2 ? -1 === s2.indexOf("label") ? s2 + "label" : s2 : "label"), this.labels.pop(), e3.label = i2, this.finishNode(e3, "LabeledStatement");
        }, L.parseExpressionStatement = function(e3, t3) {
          return e3.expression = t3, this.semicolon(), this.finishNode(e3, "ExpressionStatement");
        }, L.parseBlock = function(e3, t3, i2) {
          for (void 0 === e3 && (e3 = true), void 0 === t3 && (t3 = this.startNode()), t3.body = [], this.expect(f.braceL), e3 && this.enterScope(0); this.type !== f.braceR; ) {
            var s2 = this.parseStatement(null);
            t3.body.push(s2);
          }
          return i2 && (this.strict = false), this.next(), e3 && this.exitScope(), this.finishNode(t3, "BlockStatement");
        }, L.parseFor = function(e3, t3) {
          return e3.init = t3, this.expect(f.semi), e3.test = this.type === f.semi ? null : this.parseExpression(), this.expect(f.semi), e3.update = this.type === f.parenR ? null : this.parseExpression(), this.expect(f.parenR), e3.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(e3, "ForStatement");
        }, L.parseForIn = function(e3, t3) {
          var i2 = this.type === f._in;
          return this.next(), "VariableDeclaration" === t3.type && null != t3.declarations[0].init && (!i2 || this.options.ecmaVersion < 8 || this.strict || "var" !== t3.kind || "Identifier" !== t3.declarations[0].id.type) && this.raise(t3.start, (i2 ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"), e3.left = t3, e3.right = i2 ? this.parseExpression() : this.parseMaybeAssign(), this.expect(f.parenR), e3.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(e3, i2 ? "ForInStatement" : "ForOfStatement");
        }, L.parseVar = function(e3, t3, i2, s2) {
          for (e3.declarations = [], e3.kind = i2; ; ) {
            var r2 = this.startNode();
            if (this.parseVarId(r2, i2), this.eat(f.eq) ? r2.init = this.parseMaybeAssign(t3) : s2 || "const" !== i2 || this.type === f._in || this.options.ecmaVersion >= 6 && this.isContextual("of") ? s2 || "using" !== i2 && "await using" !== i2 || !(this.options.ecmaVersion >= 17) || this.type === f._in || this.isContextual("of") ? s2 || "Identifier" === r2.id.type || t3 && (this.type === f._in || this.isContextual("of")) ? r2.init = null : this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value") : this.raise(this.lastTokEnd, "Missing initializer in " + i2 + " declaration") : this.unexpected(), e3.declarations.push(this.finishNode(r2, "VariableDeclarator")), !this.eat(f.comma)) break;
          }
          return e3;
        }, L.parseVarId = function(e3, t3) {
          e3.id = "using" === t3 || "await using" === t3 ? this.parseIdent() : this.parseBindingAtom(), this.checkLValPattern(e3.id, "var" === t3 ? 1 : 2, false);
        };
        var U = 1, M = 2;
        function isPrivateNameConflicted(e3, t3) {
          var i2 = t3.key.name, s2 = e3[i2], r2 = "true";
          return "MethodDefinition" !== t3.type || "get" !== t3.kind && "set" !== t3.kind || (r2 = (t3.static ? "s" : "i") + t3.kind), "iget" === s2 && "iset" === r2 || "iset" === s2 && "iget" === r2 || "sget" === s2 && "sset" === r2 || "sset" === s2 && "sget" === r2 ? (e3[i2] = "true", false) : !!s2 || (e3[i2] = r2, false);
        }
        function checkKeyName(e3, t3) {
          var i2 = e3.computed, s2 = e3.key;
          return !i2 && ("Identifier" === s2.type && s2.name === t3 || "Literal" === s2.type && s2.value === t3);
        }
        L.parseFunction = function(e3, t3, i2, s2, r2) {
          this.initFunction(e3), (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !s2) && (this.type === f.star && t3 & M && this.unexpected(), e3.generator = this.eat(f.star)), this.options.ecmaVersion >= 8 && (e3.async = !!s2), t3 & U && (e3.id = 4 & t3 && this.type !== f.name ? null : this.parseIdent(), !e3.id || t3 & M || this.checkLValSimple(e3.id, this.strict || e3.generator || e3.async ? this.treatFunctionsAsVar ? 1 : 2 : 3));
          var n2 = this.yieldPos, a2 = this.awaitPos, o2 = this.awaitIdentPos;
          return this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(functionFlags(e3.async, e3.generator)), t3 & U || (e3.id = this.type === f.name ? this.parseIdent() : null), this.parseFunctionParams(e3), this.parseFunctionBody(e3, i2, false, r2), this.yieldPos = n2, this.awaitPos = a2, this.awaitIdentPos = o2, this.finishNode(e3, t3 & U ? "FunctionDeclaration" : "FunctionExpression");
        }, L.parseFunctionParams = function(e3) {
          this.expect(f.parenL), e3.params = this.parseBindingList(f.parenR, false, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams();
        }, L.parseClass = function(e3, t3) {
          this.next();
          var i2 = this.strict;
          this.strict = true, this.parseClassId(e3, t3), this.parseClassSuper(e3);
          var s2 = this.enterClassBody(), r2 = this.startNode(), n2 = false;
          for (r2.body = [], this.expect(f.braceL); this.type !== f.braceR; ) {
            var a2 = this.parseClassElement(null !== e3.superClass);
            a2 && (r2.body.push(a2), "MethodDefinition" === a2.type && "constructor" === a2.kind ? (n2 && this.raiseRecoverable(a2.start, "Duplicate constructor in the same class"), n2 = true) : a2.key && "PrivateIdentifier" === a2.key.type && isPrivateNameConflicted(s2, a2) && this.raiseRecoverable(a2.key.start, "Identifier '#" + a2.key.name + "' has already been declared"));
          }
          return this.strict = i2, this.next(), e3.body = this.finishNode(r2, "ClassBody"), this.exitClassBody(), this.finishNode(e3, t3 ? "ClassDeclaration" : "ClassExpression");
        }, L.parseClassElement = function(e3) {
          if (this.eat(f.semi)) return null;
          var t3 = this.options.ecmaVersion, i2 = this.startNode(), s2 = "", r2 = false, n2 = false, a2 = "method", o2 = false;
          if (this.eatContextual("static")) {
            if (t3 >= 13 && this.eat(f.braceL)) return this.parseClassStaticBlock(i2), i2;
            this.isClassElementNameStart() || this.type === f.star ? o2 = true : s2 = "static";
          }
          if (i2.static = o2, !s2 && t3 >= 8 && this.eatContextual("async") && (!this.isClassElementNameStart() && this.type !== f.star || this.canInsertSemicolon() ? s2 = "async" : n2 = true), !s2 && (t3 >= 9 || !n2) && this.eat(f.star) && (r2 = true), !s2 && !n2 && !r2) {
            var h2 = this.value;
            (this.eatContextual("get") || this.eatContextual("set")) && (this.isClassElementNameStart() ? a2 = h2 : s2 = h2);
          }
          if (s2 ? (i2.computed = false, i2.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc), i2.key.name = s2, this.finishNode(i2.key, "Identifier")) : this.parseClassElementName(i2), t3 < 13 || this.type === f.parenL || "method" !== a2 || r2 || n2) {
            var c2 = !i2.static && checkKeyName(i2, "constructor"), p2 = c2 && e3;
            c2 && "method" !== a2 && this.raise(i2.key.start, "Constructor can't have get/set modifier"), i2.kind = c2 ? "constructor" : a2, this.parseClassMethod(i2, r2, n2, p2);
          } else this.parseClassField(i2);
          return i2;
        }, L.isClassElementNameStart = function() {
          return this.type === f.name || this.type === f.privateId || this.type === f.num || this.type === f.string || this.type === f.bracketL || this.type.keyword;
        }, L.parseClassElementName = function(e3) {
          this.type === f.privateId ? ("constructor" === this.value && this.raise(this.start, "Classes can't have an element named '#constructor'"), e3.computed = false, e3.key = this.parsePrivateIdent()) : this.parsePropertyName(e3);
        }, L.parseClassMethod = function(e3, t3, i2, s2) {
          var r2 = e3.key;
          "constructor" === e3.kind ? (t3 && this.raise(r2.start, "Constructor can't be a generator"), i2 && this.raise(r2.start, "Constructor can't be an async method")) : e3.static && checkKeyName(e3, "prototype") && this.raise(r2.start, "Classes may not have a static property named prototype");
          var n2 = e3.value = this.parseMethod(t3, i2, s2);
          return "get" === e3.kind && 0 !== n2.params.length && this.raiseRecoverable(n2.start, "getter should have no params"), "set" === e3.kind && 1 !== n2.params.length && this.raiseRecoverable(n2.start, "setter should have exactly one param"), "set" === e3.kind && "RestElement" === n2.params[0].type && this.raiseRecoverable(n2.params[0].start, "Setter cannot use rest params"), this.finishNode(e3, "MethodDefinition");
        }, L.parseClassField = function(e3) {
          return checkKeyName(e3, "constructor") ? this.raise(e3.key.start, "Classes can't have a field named 'constructor'") : e3.static && checkKeyName(e3, "prototype") && this.raise(e3.key.start, "Classes can't have a static field named 'prototype'"), this.eat(f.eq) ? (this.enterScope(576), e3.value = this.parseMaybeAssign(), this.exitScope()) : e3.value = null, this.semicolon(), this.finishNode(e3, "PropertyDefinition");
        }, L.parseClassStaticBlock = function(e3) {
          e3.body = [];
          var t3 = this.labels;
          for (this.labels = [], this.enterScope(320); this.type !== f.braceR; ) {
            var i2 = this.parseStatement(null);
            e3.body.push(i2);
          }
          return this.next(), this.exitScope(), this.labels = t3, this.finishNode(e3, "StaticBlock");
        }, L.parseClassId = function(e3, t3) {
          this.type === f.name ? (e3.id = this.parseIdent(), t3 && this.checkLValSimple(e3.id, 2, false)) : (true === t3 && this.unexpected(), e3.id = null);
        }, L.parseClassSuper = function(e3) {
          e3.superClass = this.eat(f._extends) ? this.parseExprSubscripts(null, false) : null;
        }, L.enterClassBody = function() {
          var e3 = { declared: /* @__PURE__ */ Object.create(null), used: [] };
          return this.privateNameStack.push(e3), e3.declared;
        }, L.exitClassBody = function() {
          var e3 = this.privateNameStack.pop(), t3 = e3.declared, i2 = e3.used;
          if (this.options.checkPrivateFields) for (var s2 = this.privateNameStack.length, r2 = 0 === s2 ? null : this.privateNameStack[s2 - 1], n2 = 0; n2 < i2.length; ++n2) {
            var a2 = i2[n2];
            b(t3, a2.name) || (r2 ? r2.used.push(a2) : this.raiseRecoverable(a2.start, "Private field '#" + a2.name + "' must be declared in an enclosing class"));
          }
        }, L.parseExportAllDeclaration = function(e3, t3) {
          return this.options.ecmaVersion >= 11 && (this.eatContextual("as") ? (e3.exported = this.parseModuleExportName(), this.checkExport(t3, e3.exported, this.lastTokStart)) : e3.exported = null), this.expectContextual("from"), this.type !== f.string && this.unexpected(), e3.source = this.parseExprAtom(), this.options.ecmaVersion >= 16 && (e3.attributes = this.parseWithClause()), this.semicolon(), this.finishNode(e3, "ExportAllDeclaration");
        }, L.parseExport = function(e3, t3) {
          if (this.next(), this.eat(f.star)) return this.parseExportAllDeclaration(e3, t3);
          if (this.eat(f._default)) return this.checkExport(t3, "default", this.lastTokStart), e3.declaration = this.parseExportDefaultDeclaration(), this.finishNode(e3, "ExportDefaultDeclaration");
          if (this.shouldParseExportStatement()) e3.declaration = this.parseExportDeclaration(e3), "VariableDeclaration" === e3.declaration.type ? this.checkVariableExport(t3, e3.declaration.declarations) : this.checkExport(t3, e3.declaration.id, e3.declaration.id.start), e3.specifiers = [], e3.source = null, this.options.ecmaVersion >= 16 && (e3.attributes = []);
          else {
            if (e3.declaration = null, e3.specifiers = this.parseExportSpecifiers(t3), this.eatContextual("from")) this.type !== f.string && this.unexpected(), e3.source = this.parseExprAtom(), this.options.ecmaVersion >= 16 && (e3.attributes = this.parseWithClause());
            else {
              for (var i2 = 0, s2 = e3.specifiers; i2 < s2.length; i2 += 1) {
                var r2 = s2[i2];
                this.checkUnreserved(r2.local), this.checkLocalExport(r2.local), "Literal" === r2.local.type && this.raise(r2.local.start, "A string literal cannot be used as an exported binding without `from`.");
              }
              e3.source = null, this.options.ecmaVersion >= 16 && (e3.attributes = []);
            }
            this.semicolon();
          }
          return this.finishNode(e3, "ExportNamedDeclaration");
        }, L.parseExportDeclaration = function(e3) {
          return this.parseStatement(null);
        }, L.parseExportDefaultDeclaration = function() {
          var e3;
          if (this.type === f._function || (e3 = this.isAsyncFunction())) {
            var t3 = this.startNode();
            return this.next(), e3 && this.next(), this.parseFunction(t3, 4 | U, false, e3);
          }
          if (this.type === f._class) {
            var i2 = this.startNode();
            return this.parseClass(i2, "nullableID");
          }
          var s2 = this.parseMaybeAssign();
          return this.semicolon(), s2;
        }, L.checkExport = function(e3, t3, i2) {
          e3 && ("string" != typeof t3 && (t3 = "Identifier" === t3.type ? t3.name : t3.value), b(e3, t3) && this.raiseRecoverable(i2, "Duplicate export '" + t3 + "'"), e3[t3] = true);
        }, L.checkPatternExport = function(e3, t3) {
          var i2 = t3.type;
          if ("Identifier" === i2) this.checkExport(e3, t3, t3.start);
          else if ("ObjectPattern" === i2) for (var s2 = 0, r2 = t3.properties; s2 < r2.length; s2 += 1) {
            var n2 = r2[s2];
            this.checkPatternExport(e3, n2);
          }
          else if ("ArrayPattern" === i2) for (var a2 = 0, o2 = t3.elements; a2 < o2.length; a2 += 1) {
            var h2 = o2[a2];
            h2 && this.checkPatternExport(e3, h2);
          }
          else "Property" === i2 ? this.checkPatternExport(e3, t3.value) : "AssignmentPattern" === i2 ? this.checkPatternExport(e3, t3.left) : "RestElement" === i2 && this.checkPatternExport(e3, t3.argument);
        }, L.checkVariableExport = function(e3, t3) {
          if (e3) for (var i2 = 0, s2 = t3; i2 < s2.length; i2 += 1) {
            var r2 = s2[i2];
            this.checkPatternExport(e3, r2.id);
          }
        }, L.shouldParseExportStatement = function() {
          return "var" === this.type.keyword || "const" === this.type.keyword || "class" === this.type.keyword || "function" === this.type.keyword || this.isLet() || this.isAsyncFunction();
        }, L.parseExportSpecifier = function(e3) {
          var t3 = this.startNode();
          return t3.local = this.parseModuleExportName(), t3.exported = this.eatContextual("as") ? this.parseModuleExportName() : t3.local, this.checkExport(e3, t3.exported, t3.exported.start), this.finishNode(t3, "ExportSpecifier");
        }, L.parseExportSpecifiers = function(e3) {
          var t3 = [], i2 = true;
          for (this.expect(f.braceL); !this.eat(f.braceR); ) {
            if (i2) i2 = false;
            else if (this.expect(f.comma), this.afterTrailingComma(f.braceR)) break;
            t3.push(this.parseExportSpecifier(e3));
          }
          return t3;
        }, L.parseImport = function(e3) {
          return this.next(), this.type === f.string ? (e3.specifiers = V, e3.source = this.parseExprAtom()) : (e3.specifiers = this.parseImportSpecifiers(), this.expectContextual("from"), e3.source = this.type === f.string ? this.parseExprAtom() : this.unexpected()), this.options.ecmaVersion >= 16 && (e3.attributes = this.parseWithClause()), this.semicolon(), this.finishNode(e3, "ImportDeclaration");
        }, L.parseImportSpecifier = function() {
          var e3 = this.startNode();
          return e3.imported = this.parseModuleExportName(), this.eatContextual("as") ? e3.local = this.parseIdent() : (this.checkUnreserved(e3.imported), e3.local = e3.imported), this.checkLValSimple(e3.local, 2), this.finishNode(e3, "ImportSpecifier");
        }, L.parseImportDefaultSpecifier = function() {
          var e3 = this.startNode();
          return e3.local = this.parseIdent(), this.checkLValSimple(e3.local, 2), this.finishNode(e3, "ImportDefaultSpecifier");
        }, L.parseImportNamespaceSpecifier = function() {
          var e3 = this.startNode();
          return this.next(), this.expectContextual("as"), e3.local = this.parseIdent(), this.checkLValSimple(e3.local, 2), this.finishNode(e3, "ImportNamespaceSpecifier");
        }, L.parseImportSpecifiers = function() {
          var e3 = [], t3 = true;
          if (this.type === f.name && (e3.push(this.parseImportDefaultSpecifier()), !this.eat(f.comma))) return e3;
          if (this.type === f.star) return e3.push(this.parseImportNamespaceSpecifier()), e3;
          for (this.expect(f.braceL); !this.eat(f.braceR); ) {
            if (t3) t3 = false;
            else if (this.expect(f.comma), this.afterTrailingComma(f.braceR)) break;
            e3.push(this.parseImportSpecifier());
          }
          return e3;
        }, L.parseWithClause = function() {
          var e3 = [];
          if (!this.eat(f._with)) return e3;
          this.expect(f.braceL);
          for (var t3 = {}, i2 = true; !this.eat(f.braceR); ) {
            if (i2) i2 = false;
            else if (this.expect(f.comma), this.afterTrailingComma(f.braceR)) break;
            var s2 = this.parseImportAttribute(), r2 = "Identifier" === s2.key.type ? s2.key.name : s2.key.value;
            b(t3, r2) && this.raiseRecoverable(s2.key.start, "Duplicate attribute key '" + r2 + "'"), t3[r2] = true, e3.push(s2);
          }
          return e3;
        }, L.parseImportAttribute = function() {
          var e3 = this.startNode();
          return e3.key = this.type === f.string ? this.parseExprAtom() : this.parseIdent("never" !== this.options.allowReserved), this.expect(f.colon), this.type !== f.string && this.unexpected(), e3.value = this.parseExprAtom(), this.finishNode(e3, "ImportAttribute");
        }, L.parseModuleExportName = function() {
          if (this.options.ecmaVersion >= 13 && this.type === f.string) {
            var e3 = this.parseLiteral(this.value);
            return w.test(e3.value) && this.raise(e3.start, "An export name cannot include a lone surrogate."), e3;
          }
          return this.parseIdent(true);
        }, L.adaptDirectivePrologue = function(e3) {
          for (var t3 = 0; t3 < e3.length && this.isDirectiveCandidate(e3[t3]); ++t3) e3[t3].directive = e3[t3].expression.raw.slice(1, -1);
        }, L.isDirectiveCandidate = function(e3) {
          return this.options.ecmaVersion >= 5 && "ExpressionStatement" === e3.type && "Literal" === e3.expression.type && "string" == typeof e3.expression.value && ('"' === this.input[e3.start] || "'" === this.input[e3.start]);
        };
        var j = acorn_Parser.prototype;
        j.toAssignable = function(e3, t3, i2) {
          if (this.options.ecmaVersion >= 6 && e3) switch (e3.type) {
            case "Identifier":
              this.inAsync && "await" === e3.name && this.raise(e3.start, "Cannot use 'await' as identifier inside an async function");
              break;
            case "ObjectPattern":
            case "ArrayPattern":
            case "AssignmentPattern":
            case "RestElement":
              break;
            case "ObjectExpression":
              e3.type = "ObjectPattern", i2 && this.checkPatternErrors(i2, true);
              for (var s2 = 0, r2 = e3.properties; s2 < r2.length; s2 += 1) {
                var n2 = r2[s2];
                this.toAssignable(n2, t3), "RestElement" !== n2.type || "ArrayPattern" !== n2.argument.type && "ObjectPattern" !== n2.argument.type || this.raise(n2.argument.start, "Unexpected token");
              }
              break;
            case "Property":
              "init" !== e3.kind && this.raise(e3.key.start, "Object pattern can't contain getter or setter"), this.toAssignable(e3.value, t3);
              break;
            case "ArrayExpression":
              e3.type = "ArrayPattern", i2 && this.checkPatternErrors(i2, true), this.toAssignableList(e3.elements, t3);
              break;
            case "SpreadElement":
              e3.type = "RestElement", this.toAssignable(e3.argument, t3), "AssignmentPattern" === e3.argument.type && this.raise(e3.argument.start, "Rest elements cannot have a default value");
              break;
            case "AssignmentExpression":
              "=" !== e3.operator && this.raise(e3.left.end, "Only '=' operator can be used for specifying default value."), e3.type = "AssignmentPattern", delete e3.operator, this.toAssignable(e3.left, t3);
              break;
            case "ParenthesizedExpression":
              this.toAssignable(e3.expression, t3, i2);
              break;
            case "ChainExpression":
              this.raiseRecoverable(e3.start, "Optional chaining cannot appear in left-hand side");
              break;
            case "MemberExpression":
              if (!t3) break;
            default:
              this.raise(e3.start, "Assigning to rvalue");
          }
          else i2 && this.checkPatternErrors(i2, true);
          return e3;
        }, j.toAssignableList = function(e3, t3) {
          for (var i2 = e3.length, s2 = 0; s2 < i2; s2++) {
            var r2 = e3[s2];
            r2 && this.toAssignable(r2, t3);
          }
          if (i2) {
            var n2 = e3[i2 - 1];
            6 === this.options.ecmaVersion && t3 && n2 && "RestElement" === n2.type && "Identifier" !== n2.argument.type && this.unexpected(n2.argument.start);
          }
          return e3;
        }, j.parseSpread = function(e3) {
          var t3 = this.startNode();
          return this.next(), t3.argument = this.parseMaybeAssign(false, e3), this.finishNode(t3, "SpreadElement");
        }, j.parseRestBinding = function() {
          var e3 = this.startNode();
          return this.next(), 6 === this.options.ecmaVersion && this.type !== f.name && this.unexpected(), e3.argument = this.parseBindingAtom(), this.finishNode(e3, "RestElement");
        }, j.parseBindingAtom = function() {
          if (this.options.ecmaVersion >= 6) switch (this.type) {
            case f.bracketL:
              var e3 = this.startNode();
              return this.next(), e3.elements = this.parseBindingList(f.bracketR, true, true), this.finishNode(e3, "ArrayPattern");
            case f.braceL:
              return this.parseObj(true);
          }
          return this.parseIdent();
        }, j.parseBindingList = function(e3, t3, i2, s2) {
          for (var r2 = [], n2 = true; !this.eat(e3); ) if (n2 ? n2 = false : this.expect(f.comma), t3 && this.type === f.comma) r2.push(null);
          else {
            if (i2 && this.afterTrailingComma(e3)) break;
            if (this.type === f.ellipsis) {
              var a2 = this.parseRestBinding();
              this.parseBindingListItem(a2), r2.push(a2), this.type === f.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"), this.expect(e3);
              break;
            }
            r2.push(this.parseAssignableListItem(s2));
          }
          return r2;
        }, j.parseAssignableListItem = function(e3) {
          var t3 = this.parseMaybeDefault(this.start, this.startLoc);
          return this.parseBindingListItem(t3), t3;
        }, j.parseBindingListItem = function(e3) {
          return e3;
        }, j.parseMaybeDefault = function(e3, t3, i2) {
          if (i2 = i2 || this.parseBindingAtom(), this.options.ecmaVersion < 6 || !this.eat(f.eq)) return i2;
          var s2 = this.startNodeAt(e3, t3);
          return s2.left = i2, s2.right = this.parseMaybeAssign(), this.finishNode(s2, "AssignmentPattern");
        }, j.checkLValSimple = function(e3, t3, i2) {
          void 0 === t3 && (t3 = 0);
          var s2 = 0 !== t3;
          switch (e3.type) {
            case "Identifier":
              this.strict && this.reservedWordsStrictBind.test(e3.name) && this.raiseRecoverable(e3.start, (s2 ? "Binding " : "Assigning to ") + e3.name + " in strict mode"), s2 && (2 === t3 && "let" === e3.name && this.raiseRecoverable(e3.start, "let is disallowed as a lexically bound name"), i2 && (b(i2, e3.name) && this.raiseRecoverable(e3.start, "Argument name clash"), i2[e3.name] = true), 5 !== t3 && this.declareName(e3.name, t3, e3.start));
              break;
            case "ChainExpression":
              this.raiseRecoverable(e3.start, "Optional chaining cannot appear in left-hand side");
              break;
            case "MemberExpression":
              s2 && this.raiseRecoverable(e3.start, "Binding member expression");
              break;
            case "ParenthesizedExpression":
              return s2 && this.raiseRecoverable(e3.start, "Binding parenthesized expression"), this.checkLValSimple(e3.expression, t3, i2);
            default:
              this.raise(e3.start, (s2 ? "Binding" : "Assigning to") + " rvalue");
          }
        }, j.checkLValPattern = function(e3, t3, i2) {
          switch (void 0 === t3 && (t3 = 0), e3.type) {
            case "ObjectPattern":
              for (var s2 = 0, r2 = e3.properties; s2 < r2.length; s2 += 1) {
                var n2 = r2[s2];
                this.checkLValInnerPattern(n2, t3, i2);
              }
              break;
            case "ArrayPattern":
              for (var a2 = 0, o2 = e3.elements; a2 < o2.length; a2 += 1) {
                var h2 = o2[a2];
                h2 && this.checkLValInnerPattern(h2, t3, i2);
              }
              break;
            default:
              this.checkLValSimple(e3, t3, i2);
          }
        }, j.checkLValInnerPattern = function(e3, t3, i2) {
          switch (void 0 === t3 && (t3 = 0), e3.type) {
            case "Property":
              this.checkLValInnerPattern(e3.value, t3, i2);
              break;
            case "AssignmentPattern":
              this.checkLValPattern(e3.left, t3, i2);
              break;
            case "RestElement":
              this.checkLValPattern(e3.argument, t3, i2);
              break;
            default:
              this.checkLValPattern(e3, t3, i2);
          }
        };
        var acorn_TokContext = function(e3, t3, i2, s2, r2) {
          this.token = e3, this.isExpr = !!t3, this.preserveSpace = !!i2, this.override = s2, this.generator = !!r2;
        }, F = { b_stat: new acorn_TokContext("{", false), b_expr: new acorn_TokContext("{", true), b_tmpl: new acorn_TokContext("${", false), p_stat: new acorn_TokContext("(", false), p_expr: new acorn_TokContext("(", true), q_tmpl: new acorn_TokContext("`", true, true, function(e3) {
          return e3.tryReadTemplateToken();
        }), f_stat: new acorn_TokContext("function", false), f_expr: new acorn_TokContext("function", true), f_expr_gen: new acorn_TokContext("function", true, false, null, true), f_gen: new acorn_TokContext("function", false, false, null, true) }, B = acorn_Parser.prototype;
        B.initialContext = function() {
          return [F.b_stat];
        }, B.curContext = function() {
          return this.context[this.context.length - 1];
        }, B.braceIsBlock = function(e3) {
          var t3 = this.curContext();
          return t3 === F.f_expr || t3 === F.f_stat || (e3 !== f.colon || t3 !== F.b_stat && t3 !== F.b_expr ? e3 === f._return || e3 === f.name && this.exprAllowed ? m.test(this.input.slice(this.lastTokEnd, this.start)) : e3 === f._else || e3 === f.semi || e3 === f.eof || e3 === f.parenR || e3 === f.arrow || (e3 === f.braceL ? t3 === F.b_stat : e3 !== f._var && e3 !== f._const && e3 !== f.name && !this.exprAllowed) : !t3.isExpr);
        }, B.inGeneratorContext = function() {
          for (var e3 = this.context.length - 1; e3 >= 1; e3--) {
            var t3 = this.context[e3];
            if ("function" === t3.token) return t3.generator;
          }
          return false;
        }, B.updateContext = function(e3) {
          var t3, i2 = this.type;
          i2.keyword && e3 === f.dot ? this.exprAllowed = false : (t3 = i2.updateContext) ? t3.call(this, e3) : this.exprAllowed = i2.beforeExpr;
        }, B.overrideContext = function(e3) {
          this.curContext() !== e3 && (this.context[this.context.length - 1] = e3);
        }, f.parenR.updateContext = f.braceR.updateContext = function() {
          if (1 !== this.context.length) {
            var e3 = this.context.pop();
            e3 === F.b_stat && "function" === this.curContext().token && (e3 = this.context.pop()), this.exprAllowed = !e3.isExpr;
          } else this.exprAllowed = true;
        }, f.braceL.updateContext = function(e3) {
          this.context.push(this.braceIsBlock(e3) ? F.b_stat : F.b_expr), this.exprAllowed = true;
        }, f.dollarBraceL.updateContext = function() {
          this.context.push(F.b_tmpl), this.exprAllowed = true;
        }, f.parenL.updateContext = function(e3) {
          var t3 = e3 === f._if || e3 === f._for || e3 === f._with || e3 === f._while;
          this.context.push(t3 ? F.p_stat : F.p_expr), this.exprAllowed = true;
        }, f.incDec.updateContext = function() {
        }, f._function.updateContext = f._class.updateContext = function(e3) {
          !e3.beforeExpr || e3 === f._else || e3 === f.semi && this.curContext() !== F.p_stat || e3 === f._return && m.test(this.input.slice(this.lastTokEnd, this.start)) || (e3 === f.colon || e3 === f.braceL) && this.curContext() === F.b_stat ? this.context.push(F.f_stat) : this.context.push(F.f_expr), this.exprAllowed = false;
        }, f.colon.updateContext = function() {
          "function" === this.curContext().token && this.context.pop(), this.exprAllowed = true;
        }, f.backQuote.updateContext = function() {
          this.curContext() === F.q_tmpl ? this.context.pop() : this.context.push(F.q_tmpl), this.exprAllowed = false;
        }, f.star.updateContext = function(e3) {
          if (e3 === f._function) {
            var t3 = this.context.length - 1;
            this.context[t3] === F.f_expr ? this.context[t3] = F.f_expr_gen : this.context[t3] = F.f_gen;
          }
          this.exprAllowed = true;
        }, f.name.updateContext = function(e3) {
          var t3 = false;
          this.options.ecmaVersion >= 6 && e3 !== f.dot && ("of" === this.value && !this.exprAllowed || "yield" === this.value && this.inGeneratorContext()) && (t3 = true), this.exprAllowed = t3;
        };
        var $ = acorn_Parser.prototype;
        function isLocalVariableAccess(e3) {
          return "Identifier" === e3.type || "ParenthesizedExpression" === e3.type && isLocalVariableAccess(e3.expression);
        }
        function isPrivateFieldAccess(e3) {
          return "MemberExpression" === e3.type && "PrivateIdentifier" === e3.property.type || "ChainExpression" === e3.type && isPrivateFieldAccess(e3.expression) || "ParenthesizedExpression" === e3.type && isPrivateFieldAccess(e3.expression);
        }
        $.checkPropClash = function(e3, t3, i2) {
          if (!(this.options.ecmaVersion >= 9 && "SpreadElement" === e3.type || this.options.ecmaVersion >= 6 && (e3.computed || e3.method || e3.shorthand))) {
            var s2, r2 = e3.key;
            switch (r2.type) {
              case "Identifier":
                s2 = r2.name;
                break;
              case "Literal":
                s2 = String(r2.value);
                break;
              default:
                return;
            }
            var n2 = e3.kind;
            if (this.options.ecmaVersion >= 6) "__proto__" === s2 && "init" === n2 && (t3.proto && (i2 ? i2.doubleProto < 0 && (i2.doubleProto = r2.start) : this.raiseRecoverable(r2.start, "Redefinition of __proto__ property")), t3.proto = true);
            else {
              var a2 = t3[s2 = "$" + s2];
              if (a2) ("init" === n2 ? this.strict && a2.init || a2.get || a2.set : a2.init || a2[n2]) && this.raiseRecoverable(r2.start, "Redefinition of property");
              else a2 = t3[s2] = { init: false, get: false, set: false };
              a2[n2] = true;
            }
          }
        }, $.parseExpression = function(e3, t3) {
          var i2 = this.start, s2 = this.startLoc, r2 = this.parseMaybeAssign(e3, t3);
          if (this.type === f.comma) {
            var n2 = this.startNodeAt(i2, s2);
            for (n2.expressions = [r2]; this.eat(f.comma); ) n2.expressions.push(this.parseMaybeAssign(e3, t3));
            return this.finishNode(n2, "SequenceExpression");
          }
          return r2;
        }, $.parseMaybeAssign = function(e3, t3, i2) {
          if (this.isContextual("yield")) {
            if (this.inGenerator) return this.parseYield(e3);
            this.exprAllowed = false;
          }
          var s2 = false, r2 = -1, n2 = -1, a2 = -1;
          t3 ? (r2 = t3.parenthesizedAssign, n2 = t3.trailingComma, a2 = t3.doubleProto, t3.parenthesizedAssign = t3.trailingComma = -1) : (t3 = new acorn_DestructuringErrors(), s2 = true);
          var o2 = this.start, h2 = this.startLoc;
          this.type !== f.parenL && this.type !== f.name || (this.potentialArrowAt = this.start, this.potentialArrowInForAwait = "await" === e3);
          var c2 = this.parseMaybeConditional(e3, t3);
          if (i2 && (c2 = i2.call(this, c2, o2, h2)), this.type.isAssign) {
            var p2 = this.startNodeAt(o2, h2);
            return p2.operator = this.value, this.type === f.eq && (c2 = this.toAssignable(c2, false, t3)), s2 || (t3.parenthesizedAssign = t3.trailingComma = t3.doubleProto = -1), t3.shorthandAssign >= c2.start && (t3.shorthandAssign = -1), this.type === f.eq ? this.checkLValPattern(c2) : this.checkLValSimple(c2), p2.left = c2, this.next(), p2.right = this.parseMaybeAssign(e3), a2 > -1 && (t3.doubleProto = a2), this.finishNode(p2, "AssignmentExpression");
          }
          return s2 && this.checkExpressionErrors(t3, true), r2 > -1 && (t3.parenthesizedAssign = r2), n2 > -1 && (t3.trailingComma = n2), c2;
        }, $.parseMaybeConditional = function(e3, t3) {
          var i2 = this.start, s2 = this.startLoc, r2 = this.parseExprOps(e3, t3);
          if (this.checkExpressionErrors(t3)) return r2;
          if (this.eat(f.question)) {
            var n2 = this.startNodeAt(i2, s2);
            return n2.test = r2, n2.consequent = this.parseMaybeAssign(), this.expect(f.colon), n2.alternate = this.parseMaybeAssign(e3), this.finishNode(n2, "ConditionalExpression");
          }
          return r2;
        }, $.parseExprOps = function(e3, t3) {
          var i2 = this.start, s2 = this.startLoc, r2 = this.parseMaybeUnary(t3, false, false, e3);
          return this.checkExpressionErrors(t3) || r2.start === i2 && "ArrowFunctionExpression" === r2.type ? r2 : this.parseExprOp(r2, i2, s2, -1, e3);
        }, $.parseExprOp = function(e3, t3, i2, s2, r2) {
          var n2 = this.type.binop;
          if (null != n2 && (!r2 || this.type !== f._in) && n2 > s2) {
            var a2 = this.type === f.logicalOR || this.type === f.logicalAND, o2 = this.type === f.coalesce;
            o2 && (n2 = f.logicalAND.binop);
            var h2 = this.value;
            this.next();
            var c2 = this.start, p2 = this.startLoc, l2 = this.parseExprOp(this.parseMaybeUnary(null, false, false, r2), c2, p2, n2, r2), u2 = this.buildBinary(t3, i2, e3, l2, h2, a2 || o2);
            return (a2 && this.type === f.coalesce || o2 && (this.type === f.logicalOR || this.type === f.logicalAND)) && this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses"), this.parseExprOp(u2, t3, i2, s2, r2);
          }
          return e3;
        }, $.buildBinary = function(e3, t3, i2, s2, r2, n2) {
          "PrivateIdentifier" === s2.type && this.raise(s2.start, "Private identifier can only be left side of binary expression");
          var a2 = this.startNodeAt(e3, t3);
          return a2.left = i2, a2.operator = r2, a2.right = s2, this.finishNode(a2, n2 ? "LogicalExpression" : "BinaryExpression");
        }, $.parseMaybeUnary = function(e3, t3, i2, s2) {
          var r2, n2 = this.start, a2 = this.startLoc;
          if (this.isContextual("await") && this.canAwait) r2 = this.parseAwait(s2), t3 = true;
          else if (this.type.prefix) {
            var o2 = this.startNode(), h2 = this.type === f.incDec;
            o2.operator = this.value, o2.prefix = true, this.next(), o2.argument = this.parseMaybeUnary(null, true, h2, s2), this.checkExpressionErrors(e3, true), h2 ? this.checkLValSimple(o2.argument) : this.strict && "delete" === o2.operator && isLocalVariableAccess(o2.argument) ? this.raiseRecoverable(o2.start, "Deleting local variable in strict mode") : "delete" === o2.operator && isPrivateFieldAccess(o2.argument) ? this.raiseRecoverable(o2.start, "Private fields can not be deleted") : t3 = true, r2 = this.finishNode(o2, h2 ? "UpdateExpression" : "UnaryExpression");
          } else if (t3 || this.type !== f.privateId) {
            if (r2 = this.parseExprSubscripts(e3, s2), this.checkExpressionErrors(e3)) return r2;
            for (; this.type.postfix && !this.canInsertSemicolon(); ) {
              var c2 = this.startNodeAt(n2, a2);
              c2.operator = this.value, c2.prefix = false, c2.argument = r2, this.checkLValSimple(r2), this.next(), r2 = this.finishNode(c2, "UpdateExpression");
            }
          } else (s2 || 0 === this.privateNameStack.length) && this.options.checkPrivateFields && this.unexpected(), r2 = this.parsePrivateIdent(), this.type !== f._in && this.unexpected();
          return i2 || !this.eat(f.starstar) ? r2 : t3 ? void this.unexpected(this.lastTokStart) : this.buildBinary(n2, a2, r2, this.parseMaybeUnary(null, false, false, s2), "**", false);
        }, $.parseExprSubscripts = function(e3, t3) {
          var i2 = this.start, s2 = this.startLoc, r2 = this.parseExprAtom(e3, t3);
          if ("ArrowFunctionExpression" === r2.type && ")" !== this.input.slice(this.lastTokStart, this.lastTokEnd)) return r2;
          var n2 = this.parseSubscripts(r2, i2, s2, false, t3);
          return e3 && "MemberExpression" === n2.type && (e3.parenthesizedAssign >= n2.start && (e3.parenthesizedAssign = -1), e3.parenthesizedBind >= n2.start && (e3.parenthesizedBind = -1), e3.trailingComma >= n2.start && (e3.trailingComma = -1)), n2;
        }, $.parseSubscripts = function(e3, t3, i2, s2, r2) {
          for (var n2 = this.options.ecmaVersion >= 8 && "Identifier" === e3.type && "async" === e3.name && this.lastTokEnd === e3.end && !this.canInsertSemicolon() && e3.end - e3.start === 5 && this.potentialArrowAt === e3.start, a2 = false; ; ) {
            var o2 = this.parseSubscript(e3, t3, i2, s2, n2, a2, r2);
            if (o2.optional && (a2 = true), o2 === e3 || "ArrowFunctionExpression" === o2.type) {
              if (a2) {
                var h2 = this.startNodeAt(t3, i2);
                h2.expression = o2, o2 = this.finishNode(h2, "ChainExpression");
              }
              return o2;
            }
            e3 = o2;
          }
        }, $.shouldParseAsyncArrow = function() {
          return !this.canInsertSemicolon() && this.eat(f.arrow);
        }, $.parseSubscriptAsyncArrow = function(e3, t3, i2, s2) {
          return this.parseArrowExpression(this.startNodeAt(e3, t3), i2, true, s2);
        }, $.parseSubscript = function(e3, t3, i2, s2, r2, n2, a2) {
          var o2 = this.options.ecmaVersion >= 11, h2 = o2 && this.eat(f.questionDot);
          s2 && h2 && this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
          var c2 = this.eat(f.bracketL);
          if (c2 || h2 && this.type !== f.parenL && this.type !== f.backQuote || this.eat(f.dot)) {
            var p2 = this.startNodeAt(t3, i2);
            p2.object = e3, c2 ? (p2.property = this.parseExpression(), this.expect(f.bracketR)) : this.type === f.privateId && "Super" !== e3.type ? p2.property = this.parsePrivateIdent() : p2.property = this.parseIdent("never" !== this.options.allowReserved), p2.computed = !!c2, o2 && (p2.optional = h2), e3 = this.finishNode(p2, "MemberExpression");
          } else if (!s2 && this.eat(f.parenL)) {
            var l2 = new acorn_DestructuringErrors(), u2 = this.yieldPos, d2 = this.awaitPos, m2 = this.awaitIdentPos;
            this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0;
            var g2 = this.parseExprList(f.parenR, this.options.ecmaVersion >= 8, false, l2);
            if (r2 && !h2 && this.shouldParseAsyncArrow()) return this.checkPatternErrors(l2, false), this.checkYieldAwaitInDefaultParams(), this.awaitIdentPos > 0 && this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"), this.yieldPos = u2, this.awaitPos = d2, this.awaitIdentPos = m2, this.parseSubscriptAsyncArrow(t3, i2, g2, a2);
            this.checkExpressionErrors(l2, true), this.yieldPos = u2 || this.yieldPos, this.awaitPos = d2 || this.awaitPos, this.awaitIdentPos = m2 || this.awaitIdentPos;
            var x2 = this.startNodeAt(t3, i2);
            x2.callee = e3, x2.arguments = g2, o2 && (x2.optional = h2), e3 = this.finishNode(x2, "CallExpression");
          } else if (this.type === f.backQuote) {
            (h2 || n2) && this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
            var v2 = this.startNodeAt(t3, i2);
            v2.tag = e3, v2.quasi = this.parseTemplate({ isTagged: true }), e3 = this.finishNode(v2, "TaggedTemplateExpression");
          }
          return e3;
        }, $.parseExprAtom = function(e3, t3, i2) {
          this.type === f.slash && this.readRegexp();
          var s2, r2 = this.potentialArrowAt === this.start;
          switch (this.type) {
            case f._super:
              return this.allowSuper || this.raise(this.start, "'super' keyword outside a method"), s2 = this.startNode(), this.next(), this.type !== f.parenL || this.allowDirectSuper || this.raise(s2.start, "super() call outside constructor of a subclass"), this.type !== f.dot && this.type !== f.bracketL && this.type !== f.parenL && this.unexpected(), this.finishNode(s2, "Super");
            case f._this:
              return s2 = this.startNode(), this.next(), this.finishNode(s2, "ThisExpression");
            case f.name:
              var n2 = this.start, a2 = this.startLoc, o2 = this.containsEsc, h2 = this.parseIdent(false);
              if (this.options.ecmaVersion >= 8 && !o2 && "async" === h2.name && !this.canInsertSemicolon() && this.eat(f._function)) return this.overrideContext(F.f_expr), this.parseFunction(this.startNodeAt(n2, a2), 0, false, true, t3);
              if (r2 && !this.canInsertSemicolon()) {
                if (this.eat(f.arrow)) return this.parseArrowExpression(this.startNodeAt(n2, a2), [h2], false, t3);
                if (this.options.ecmaVersion >= 8 && "async" === h2.name && this.type === f.name && !o2 && (!this.potentialArrowInForAwait || "of" !== this.value || this.containsEsc)) return h2 = this.parseIdent(false), !this.canInsertSemicolon() && this.eat(f.arrow) || this.unexpected(), this.parseArrowExpression(this.startNodeAt(n2, a2), [h2], true, t3);
              }
              return h2;
            case f.regexp:
              var c2 = this.value;
              return (s2 = this.parseLiteral(c2.value)).regex = { pattern: c2.pattern, flags: c2.flags }, s2;
            case f.num:
            case f.string:
              return this.parseLiteral(this.value);
            case f._null:
            case f._true:
            case f._false:
              return (s2 = this.startNode()).value = this.type === f._null ? null : this.type === f._true, s2.raw = this.type.keyword, this.next(), this.finishNode(s2, "Literal");
            case f.parenL:
              var p2 = this.start, l2 = this.parseParenAndDistinguishExpression(r2, t3);
              return e3 && (e3.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(l2) && (e3.parenthesizedAssign = p2), e3.parenthesizedBind < 0 && (e3.parenthesizedBind = p2)), l2;
            case f.bracketL:
              return s2 = this.startNode(), this.next(), s2.elements = this.parseExprList(f.bracketR, true, true, e3), this.finishNode(s2, "ArrayExpression");
            case f.braceL:
              return this.overrideContext(F.b_expr), this.parseObj(false, e3);
            case f._function:
              return s2 = this.startNode(), this.next(), this.parseFunction(s2, 0);
            case f._class:
              return this.parseClass(this.startNode(), false);
            case f._new:
              return this.parseNew();
            case f.backQuote:
              return this.parseTemplate();
            case f._import:
              return this.options.ecmaVersion >= 11 ? this.parseExprImport(i2) : this.unexpected();
            default:
              return this.parseExprAtomDefault();
          }
        }, $.parseExprAtomDefault = function() {
          this.unexpected();
        }, $.parseExprImport = function(e3) {
          var t3 = this.startNode();
          if (this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword import"), this.next(), this.type === f.parenL && !e3) return this.parseDynamicImport(t3);
          if (this.type === f.dot) {
            var i2 = this.startNodeAt(t3.start, t3.loc && t3.loc.start);
            return i2.name = "import", t3.meta = this.finishNode(i2, "Identifier"), this.parseImportMeta(t3);
          }
          this.unexpected();
        }, $.parseDynamicImport = function(e3) {
          if (this.next(), e3.source = this.parseMaybeAssign(), this.options.ecmaVersion >= 16) this.eat(f.parenR) ? e3.options = null : (this.expect(f.comma), this.afterTrailingComma(f.parenR) ? e3.options = null : (e3.options = this.parseMaybeAssign(), this.eat(f.parenR) || (this.expect(f.comma), this.afterTrailingComma(f.parenR) || this.unexpected())));
          else if (!this.eat(f.parenR)) {
            var t3 = this.start;
            this.eat(f.comma) && this.eat(f.parenR) ? this.raiseRecoverable(t3, "Trailing comma is not allowed in import()") : this.unexpected(t3);
          }
          return this.finishNode(e3, "ImportExpression");
        }, $.parseImportMeta = function(e3) {
          this.next();
          var t3 = this.containsEsc;
          return e3.property = this.parseIdent(true), "meta" !== e3.property.name && this.raiseRecoverable(e3.property.start, "The only valid meta property for import is 'import.meta'"), t3 && this.raiseRecoverable(e3.start, "'import.meta' must not contain escaped characters"), "module" === this.options.sourceType || this.options.allowImportExportEverywhere || this.raiseRecoverable(e3.start, "Cannot use 'import.meta' outside a module"), this.finishNode(e3, "MetaProperty");
        }, $.parseLiteral = function(e3) {
          var t3 = this.startNode();
          return t3.value = e3, t3.raw = this.input.slice(this.start, this.end), 110 === t3.raw.charCodeAt(t3.raw.length - 1) && (t3.bigint = null != t3.value ? t3.value.toString() : t3.raw.slice(0, -1).replace(/_/g, "")), this.next(), this.finishNode(t3, "Literal");
        }, $.parseParenExpression = function() {
          this.expect(f.parenL);
          var e3 = this.parseExpression();
          return this.expect(f.parenR), e3;
        }, $.shouldParseArrow = function(e3) {
          return !this.canInsertSemicolon();
        }, $.parseParenAndDistinguishExpression = function(e3, t3) {
          var i2, s2 = this.start, r2 = this.startLoc, n2 = this.options.ecmaVersion >= 8;
          if (this.options.ecmaVersion >= 6) {
            this.next();
            var a2, o2 = this.start, h2 = this.startLoc, c2 = [], p2 = true, l2 = false, u2 = new acorn_DestructuringErrors(), d2 = this.yieldPos, m2 = this.awaitPos;
            for (this.yieldPos = 0, this.awaitPos = 0; this.type !== f.parenR; ) {
              if (p2 ? p2 = false : this.expect(f.comma), n2 && this.afterTrailingComma(f.parenR, true)) {
                l2 = true;
                break;
              }
              if (this.type === f.ellipsis) {
                a2 = this.start, c2.push(this.parseParenItem(this.parseRestBinding())), this.type === f.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
                break;
              }
              c2.push(this.parseMaybeAssign(false, u2, this.parseParenItem));
            }
            var g2 = this.lastTokEnd, x2 = this.lastTokEndLoc;
            if (this.expect(f.parenR), e3 && this.shouldParseArrow(c2) && this.eat(f.arrow)) return this.checkPatternErrors(u2, false), this.checkYieldAwaitInDefaultParams(), this.yieldPos = d2, this.awaitPos = m2, this.parseParenArrowList(s2, r2, c2, t3);
            c2.length && !l2 || this.unexpected(this.lastTokStart), a2 && this.unexpected(a2), this.checkExpressionErrors(u2, true), this.yieldPos = d2 || this.yieldPos, this.awaitPos = m2 || this.awaitPos, c2.length > 1 ? ((i2 = this.startNodeAt(o2, h2)).expressions = c2, this.finishNodeAt(i2, "SequenceExpression", g2, x2)) : i2 = c2[0];
          } else i2 = this.parseParenExpression();
          if (this.options.preserveParens) {
            var v2 = this.startNodeAt(s2, r2);
            return v2.expression = i2, this.finishNode(v2, "ParenthesizedExpression");
          }
          return i2;
        }, $.parseParenItem = function(e3) {
          return e3;
        }, $.parseParenArrowList = function(e3, t3, i2, s2) {
          return this.parseArrowExpression(this.startNodeAt(e3, t3), i2, false, s2);
        };
        var q = [];
        $.parseNew = function() {
          this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword new");
          var e3 = this.startNode();
          if (this.next(), this.options.ecmaVersion >= 6 && this.type === f.dot) {
            var t3 = this.startNodeAt(e3.start, e3.loc && e3.loc.start);
            t3.name = "new", e3.meta = this.finishNode(t3, "Identifier"), this.next();
            var i2 = this.containsEsc;
            return e3.property = this.parseIdent(true), "target" !== e3.property.name && this.raiseRecoverable(e3.property.start, "The only valid meta property for new is 'new.target'"), i2 && this.raiseRecoverable(e3.start, "'new.target' must not contain escaped characters"), this.allowNewDotTarget || this.raiseRecoverable(e3.start, "'new.target' can only be used in functions and class static block"), this.finishNode(e3, "MetaProperty");
          }
          var s2 = this.start, r2 = this.startLoc;
          return e3.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), s2, r2, true, false), this.eat(f.parenL) ? e3.arguments = this.parseExprList(f.parenR, this.options.ecmaVersion >= 8, false) : e3.arguments = q, this.finishNode(e3, "NewExpression");
        }, $.parseTemplateElement = function(e3) {
          var t3 = e3.isTagged, i2 = this.startNode();
          return this.type === f.invalidTemplate ? (t3 || this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal"), i2.value = { raw: this.value.replace(/\r\n?/g, "\n"), cooked: null }) : i2.value = { raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"), cooked: this.value }, this.next(), i2.tail = this.type === f.backQuote, this.finishNode(i2, "TemplateElement");
        }, $.parseTemplate = function(e3) {
          void 0 === e3 && (e3 = {});
          var t3 = e3.isTagged;
          void 0 === t3 && (t3 = false);
          var i2 = this.startNode();
          this.next(), i2.expressions = [];
          var s2 = this.parseTemplateElement({ isTagged: t3 });
          for (i2.quasis = [s2]; !s2.tail; ) this.type === f.eof && this.raise(this.pos, "Unterminated template literal"), this.expect(f.dollarBraceL), i2.expressions.push(this.parseExpression()), this.expect(f.braceR), i2.quasis.push(s2 = this.parseTemplateElement({ isTagged: t3 }));
          return this.next(), this.finishNode(i2, "TemplateLiteral");
        }, $.isAsyncProp = function(e3) {
          return !e3.computed && "Identifier" === e3.key.type && "async" === e3.key.name && (this.type === f.name || this.type === f.num || this.type === f.string || this.type === f.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === f.star) && !m.test(this.input.slice(this.lastTokEnd, this.start));
        }, $.parseObj = function(e3, t3) {
          var i2 = this.startNode(), s2 = true, r2 = {};
          for (i2.properties = [], this.next(); !this.eat(f.braceR); ) {
            if (s2) s2 = false;
            else if (this.expect(f.comma), this.options.ecmaVersion >= 5 && this.afterTrailingComma(f.braceR)) break;
            var n2 = this.parseProperty(e3, t3);
            e3 || this.checkPropClash(n2, r2, t3), i2.properties.push(n2);
          }
          return this.finishNode(i2, e3 ? "ObjectPattern" : "ObjectExpression");
        }, $.parseProperty = function(e3, t3) {
          var i2, s2, r2, n2, a2 = this.startNode();
          if (this.options.ecmaVersion >= 9 && this.eat(f.ellipsis)) return e3 ? (a2.argument = this.parseIdent(false), this.type === f.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"), this.finishNode(a2, "RestElement")) : (a2.argument = this.parseMaybeAssign(false, t3), this.type === f.comma && t3 && t3.trailingComma < 0 && (t3.trailingComma = this.start), this.finishNode(a2, "SpreadElement"));
          this.options.ecmaVersion >= 6 && (a2.method = false, a2.shorthand = false, (e3 || t3) && (r2 = this.start, n2 = this.startLoc), e3 || (i2 = this.eat(f.star)));
          var o2 = this.containsEsc;
          return this.parsePropertyName(a2), !e3 && !o2 && this.options.ecmaVersion >= 8 && !i2 && this.isAsyncProp(a2) ? (s2 = true, i2 = this.options.ecmaVersion >= 9 && this.eat(f.star), this.parsePropertyName(a2)) : s2 = false, this.parsePropertyValue(a2, e3, i2, s2, r2, n2, t3, o2), this.finishNode(a2, "Property");
        }, $.parseGetterSetter = function(e3) {
          var t3 = e3.key.name;
          this.parsePropertyName(e3), e3.value = this.parseMethod(false), e3.kind = t3;
          var i2 = "get" === e3.kind ? 0 : 1;
          if (e3.value.params.length !== i2) {
            var s2 = e3.value.start;
            "get" === e3.kind ? this.raiseRecoverable(s2, "getter should have no params") : this.raiseRecoverable(s2, "setter should have exactly one param");
          } else "set" === e3.kind && "RestElement" === e3.value.params[0].type && this.raiseRecoverable(e3.value.params[0].start, "Setter cannot use rest params");
        }, $.parsePropertyValue = function(e3, t3, i2, s2, r2, n2, a2, o2) {
          (i2 || s2) && this.type === f.colon && this.unexpected(), this.eat(f.colon) ? (e3.value = t3 ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, a2), e3.kind = "init") : this.options.ecmaVersion >= 6 && this.type === f.parenL ? (t3 && this.unexpected(), e3.method = true, e3.value = this.parseMethod(i2, s2), e3.kind = "init") : t3 || o2 || !(this.options.ecmaVersion >= 5) || e3.computed || "Identifier" !== e3.key.type || "get" !== e3.key.name && "set" !== e3.key.name || this.type === f.comma || this.type === f.braceR || this.type === f.eq ? this.options.ecmaVersion >= 6 && !e3.computed && "Identifier" === e3.key.type ? ((i2 || s2) && this.unexpected(), this.checkUnreserved(e3.key), "await" !== e3.key.name || this.awaitIdentPos || (this.awaitIdentPos = r2), t3 ? e3.value = this.parseMaybeDefault(r2, n2, this.copyNode(e3.key)) : this.type === f.eq && a2 ? (a2.shorthandAssign < 0 && (a2.shorthandAssign = this.start), e3.value = this.parseMaybeDefault(r2, n2, this.copyNode(e3.key))) : e3.value = this.copyNode(e3.key), e3.kind = "init", e3.shorthand = true) : this.unexpected() : ((i2 || s2) && this.unexpected(), this.parseGetterSetter(e3));
        }, $.parsePropertyName = function(e3) {
          if (this.options.ecmaVersion >= 6) {
            if (this.eat(f.bracketL)) return e3.computed = true, e3.key = this.parseMaybeAssign(), this.expect(f.bracketR), e3.key;
            e3.computed = false;
          }
          return e3.key = this.type === f.num || this.type === f.string ? this.parseExprAtom() : this.parseIdent("never" !== this.options.allowReserved);
        }, $.initFunction = function(e3) {
          e3.id = null, this.options.ecmaVersion >= 6 && (e3.generator = e3.expression = false), this.options.ecmaVersion >= 8 && (e3.async = false);
        }, $.parseMethod = function(e3, t3, i2) {
          var s2 = this.startNode(), r2 = this.yieldPos, n2 = this.awaitPos, a2 = this.awaitIdentPos;
          return this.initFunction(s2), this.options.ecmaVersion >= 6 && (s2.generator = e3), this.options.ecmaVersion >= 8 && (s2.async = !!t3), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(64 | functionFlags(t3, s2.generator) | (i2 ? 128 : 0)), this.expect(f.parenL), s2.params = this.parseBindingList(f.parenR, false, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams(), this.parseFunctionBody(s2, false, true, false), this.yieldPos = r2, this.awaitPos = n2, this.awaitIdentPos = a2, this.finishNode(s2, "FunctionExpression");
        }, $.parseArrowExpression = function(e3, t3, i2, s2) {
          var r2 = this.yieldPos, n2 = this.awaitPos, a2 = this.awaitIdentPos;
          return this.enterScope(16 | functionFlags(i2, false)), this.initFunction(e3), this.options.ecmaVersion >= 8 && (e3.async = !!i2), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, e3.params = this.toAssignableList(t3, true), this.parseFunctionBody(e3, true, false, s2), this.yieldPos = r2, this.awaitPos = n2, this.awaitIdentPos = a2, this.finishNode(e3, "ArrowFunctionExpression");
        }, $.parseFunctionBody = function(e3, t3, i2, s2) {
          var r2 = t3 && this.type !== f.braceL, n2 = this.strict, a2 = false;
          if (r2) e3.body = this.parseMaybeAssign(s2), e3.expression = true, this.checkParams(e3, false);
          else {
            var o2 = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(e3.params);
            n2 && !o2 || (a2 = this.strictDirective(this.end)) && o2 && this.raiseRecoverable(e3.start, "Illegal 'use strict' directive in function with non-simple parameter list");
            var h2 = this.labels;
            this.labels = [], a2 && (this.strict = true), this.checkParams(e3, !n2 && !a2 && !t3 && !i2 && this.isSimpleParamList(e3.params)), this.strict && e3.id && this.checkLValSimple(e3.id, 5), e3.body = this.parseBlock(false, void 0, a2 && !n2), e3.expression = false, this.adaptDirectivePrologue(e3.body.body), this.labels = h2;
          }
          this.exitScope();
        }, $.isSimpleParamList = function(e3) {
          for (var t3 = 0, i2 = e3; t3 < i2.length; t3 += 1) {
            if ("Identifier" !== i2[t3].type) return false;
          }
          return true;
        }, $.checkParams = function(e3, t3) {
          for (var i2 = /* @__PURE__ */ Object.create(null), s2 = 0, r2 = e3.params; s2 < r2.length; s2 += 1) {
            var n2 = r2[s2];
            this.checkLValInnerPattern(n2, 1, t3 ? null : i2);
          }
        }, $.parseExprList = function(e3, t3, i2, s2) {
          for (var r2 = [], n2 = true; !this.eat(e3); ) {
            if (n2) n2 = false;
            else if (this.expect(f.comma), t3 && this.afterTrailingComma(e3)) break;
            var a2 = void 0;
            i2 && this.type === f.comma ? a2 = null : this.type === f.ellipsis ? (a2 = this.parseSpread(s2), s2 && this.type === f.comma && s2.trailingComma < 0 && (s2.trailingComma = this.start)) : a2 = this.parseMaybeAssign(false, s2), r2.push(a2);
          }
          return r2;
        }, $.checkUnreserved = function(e3) {
          var t3 = e3.start, i2 = e3.end, s2 = e3.name;
          (this.inGenerator && "yield" === s2 && this.raiseRecoverable(t3, "Cannot use 'yield' as identifier inside a generator"), this.inAsync && "await" === s2 && this.raiseRecoverable(t3, "Cannot use 'await' as identifier inside an async function"), this.currentThisScope().flags & P || "arguments" !== s2 || this.raiseRecoverable(t3, "Cannot use 'arguments' in class field initializer"), !this.inClassStaticBlock || "arguments" !== s2 && "await" !== s2 || this.raise(t3, "Cannot use " + s2 + " in class static initialization block"), this.keywords.test(s2) && this.raise(t3, "Unexpected keyword '" + s2 + "'"), this.options.ecmaVersion < 6 && -1 !== this.input.slice(t3, i2).indexOf("\\")) || (this.strict ? this.reservedWordsStrict : this.reservedWords).test(s2) && (this.inAsync || "await" !== s2 || this.raiseRecoverable(t3, "Cannot use keyword 'await' outside an async function"), this.raiseRecoverable(t3, "The keyword '" + s2 + "' is reserved"));
        }, $.parseIdent = function(e3) {
          var t3 = this.parseIdentNode();
          return this.next(!!e3), this.finishNode(t3, "Identifier"), e3 || (this.checkUnreserved(t3), "await" !== t3.name || this.awaitIdentPos || (this.awaitIdentPos = t3.start)), t3;
        }, $.parseIdentNode = function() {
          var e3 = this.startNode();
          return this.type === f.name ? e3.name = this.value : this.type.keyword ? (e3.name = this.type.keyword, "class" !== e3.name && "function" !== e3.name || this.lastTokEnd === this.lastTokStart + 1 && 46 === this.input.charCodeAt(this.lastTokStart) || this.context.pop(), this.type = f.name) : this.unexpected(), e3;
        }, $.parsePrivateIdent = function() {
          var e3 = this.startNode();
          return this.type === f.privateId ? e3.name = this.value : this.unexpected(), this.next(), this.finishNode(e3, "PrivateIdentifier"), this.options.checkPrivateFields && (0 === this.privateNameStack.length ? this.raise(e3.start, "Private field '#" + e3.name + "' must be declared in an enclosing class") : this.privateNameStack[this.privateNameStack.length - 1].used.push(e3)), e3;
        }, $.parseYield = function(e3) {
          this.yieldPos || (this.yieldPos = this.start);
          var t3 = this.startNode();
          return this.next(), this.type === f.semi || this.canInsertSemicolon() || this.type !== f.star && !this.type.startsExpr ? (t3.delegate = false, t3.argument = null) : (t3.delegate = this.eat(f.star), t3.argument = this.parseMaybeAssign(e3)), this.finishNode(t3, "YieldExpression");
        }, $.parseAwait = function(e3) {
          this.awaitPos || (this.awaitPos = this.start);
          var t3 = this.startNode();
          return this.next(), t3.argument = this.parseMaybeUnary(null, true, false, e3), this.finishNode(t3, "AwaitExpression");
        };
        var W = acorn_Parser.prototype;
        W.raise = function(e3, t3) {
          var i2 = getLineInfo(this.input, e3);
          t3 += " (" + i2.line + ":" + i2.column + ")", this.sourceFile && (t3 += " in " + this.sourceFile);
          var s2 = new SyntaxError(t3);
          throw s2.pos = e3, s2.loc = i2, s2.raisedAt = this.pos, s2;
        }, W.raiseRecoverable = W.raise, W.curPosition = function() {
          if (this.options.locations) return new acorn_Position(this.curLine, this.pos - this.lineStart);
        };
        var G = acorn_Parser.prototype, acorn_Scope = function(e3) {
          this.flags = e3, this.var = [], this.lexical = [], this.functions = [];
        };
        G.enterScope = function(e3) {
          this.scopeStack.push(new acorn_Scope(e3));
        }, G.exitScope = function() {
          this.scopeStack.pop();
        }, G.treatFunctionsAsVarInScope = function(e3) {
          return 2 & e3.flags || !this.inModule && 1 & e3.flags;
        }, G.declareName = function(e3, t3, i2) {
          var s2 = false;
          if (2 === t3) {
            var r2 = this.currentScope();
            s2 = r2.lexical.indexOf(e3) > -1 || r2.functions.indexOf(e3) > -1 || r2.var.indexOf(e3) > -1, r2.lexical.push(e3), this.inModule && 1 & r2.flags && delete this.undefinedExports[e3];
          } else if (4 === t3) {
            this.currentScope().lexical.push(e3);
          } else if (3 === t3) {
            var n2 = this.currentScope();
            s2 = this.treatFunctionsAsVar ? n2.lexical.indexOf(e3) > -1 : n2.lexical.indexOf(e3) > -1 || n2.var.indexOf(e3) > -1, n2.functions.push(e3);
          } else for (var a2 = this.scopeStack.length - 1; a2 >= 0; --a2) {
            var o2 = this.scopeStack[a2];
            if (o2.lexical.indexOf(e3) > -1 && !(32 & o2.flags && o2.lexical[0] === e3) || !this.treatFunctionsAsVarInScope(o2) && o2.functions.indexOf(e3) > -1) {
              s2 = true;
              break;
            }
            if (o2.var.push(e3), this.inModule && 1 & o2.flags && delete this.undefinedExports[e3], o2.flags & P) break;
          }
          s2 && this.raiseRecoverable(i2, "Identifier '" + e3 + "' has already been declared");
        }, G.checkLocalExport = function(e3) {
          -1 === this.scopeStack[0].lexical.indexOf(e3.name) && -1 === this.scopeStack[0].var.indexOf(e3.name) && (this.undefinedExports[e3.name] = e3);
        }, G.currentScope = function() {
          return this.scopeStack[this.scopeStack.length - 1];
        }, G.currentVarScope = function() {
          for (var e3 = this.scopeStack.length - 1; ; e3--) {
            var t3 = this.scopeStack[e3];
            if (771 & t3.flags) return t3;
          }
        }, G.currentThisScope = function() {
          for (var e3 = this.scopeStack.length - 1; ; e3--) {
            var t3 = this.scopeStack[e3];
            if (771 & t3.flags && !(16 & t3.flags)) return t3;
          }
        };
        var acorn_Node = function(e3, t3, i2) {
          this.type = "", this.start = t3, this.end = 0, e3.options.locations && (this.loc = new acorn_SourceLocation(e3, i2)), e3.options.directSourceFile && (this.sourceFile = e3.options.directSourceFile), e3.options.ranges && (this.range = [t3, 0]);
        }, H = acorn_Parser.prototype;
        function finishNodeAt(e3, t3, i2, s2) {
          return e3.type = t3, e3.end = i2, this.options.locations && (e3.loc.end = s2), this.options.ranges && (e3.range[1] = i2), e3;
        }
        H.startNode = function() {
          return new acorn_Node(this, this.start, this.startLoc);
        }, H.startNodeAt = function(e3, t3) {
          return new acorn_Node(this, e3, t3);
        }, H.finishNode = function(e3, t3) {
          return finishNodeAt.call(this, e3, t3, this.lastTokEnd, this.lastTokEndLoc);
        }, H.finishNodeAt = function(e3, t3, i2, s2) {
          return finishNodeAt.call(this, e3, t3, i2, s2);
        }, H.copyNode = function(e3) {
          var t3 = new acorn_Node(this, e3.start, this.startLoc);
          for (var i2 in e3) t3[i2] = e3[i2];
          return t3;
        };
        var K = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS", z = K + " Extended_Pictographic", J = z + " EBase EComp EMod EPres ExtPict", Y = { 9: K, 10: z, 11: z, 12: J, 13: J, 14: J }, Q = { 9: "", 10: "", 11: "", 12: "", 13: "", 14: "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji" }, Z = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu", X = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb", ee = X + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd", te = ee + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho", ie = te + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi", se = ie + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith", re = { 9: X, 10: ee, 11: te, 12: ie, 13: se, 14: se + " Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz" }, ne = {};
        function buildUnicodeData(e3) {
          var t3 = ne[e3] = { binary: wordsRegexp(Y[e3] + " " + Z), binaryOfStrings: wordsRegexp(Q[e3]), nonBinary: { General_Category: wordsRegexp(Z), Script: wordsRegexp(re[e3]) } };
          t3.nonBinary.Script_Extensions = t3.nonBinary.Script, t3.nonBinary.gc = t3.nonBinary.General_Category, t3.nonBinary.sc = t3.nonBinary.Script, t3.nonBinary.scx = t3.nonBinary.Script_Extensions;
        }
        for (var ae = 0, oe = [9, 10, 11, 12, 13, 14]; ae < oe.length; ae += 1) {
          buildUnicodeData(oe[ae]);
        }
        var he = acorn_Parser.prototype, acorn_BranchID = function(e3, t3) {
          this.parent = e3, this.base = t3 || this;
        };
        acorn_BranchID.prototype.separatedFrom = function(e3) {
          for (var t3 = this; t3; t3 = t3.parent) for (var i2 = e3; i2; i2 = i2.parent) if (t3.base === i2.base && t3 !== i2) return true;
          return false;
        }, acorn_BranchID.prototype.sibling = function() {
          return new acorn_BranchID(this.parent, this.base);
        };
        var acorn_RegExpValidationState = function(e3) {
          this.parser = e3, this.validFlags = "gim" + (e3.options.ecmaVersion >= 6 ? "uy" : "") + (e3.options.ecmaVersion >= 9 ? "s" : "") + (e3.options.ecmaVersion >= 13 ? "d" : "") + (e3.options.ecmaVersion >= 15 ? "v" : ""), this.unicodeProperties = ne[e3.options.ecmaVersion >= 14 ? 14 : e3.options.ecmaVersion], this.source = "", this.flags = "", this.start = 0, this.switchU = false, this.switchV = false, this.switchN = false, this.pos = 0, this.lastIntValue = 0, this.lastStringValue = "", this.lastAssertionIsQuantifiable = false, this.numCapturingParens = 0, this.maxBackReference = 0, this.groupNames = /* @__PURE__ */ Object.create(null), this.backReferenceNames = [], this.branchID = null;
        };
        function isRegularExpressionModifier(e3) {
          return 105 === e3 || 109 === e3 || 115 === e3;
        }
        function isSyntaxCharacter(e3) {
          return 36 === e3 || e3 >= 40 && e3 <= 43 || 46 === e3 || 63 === e3 || e3 >= 91 && e3 <= 94 || e3 >= 123 && e3 <= 125;
        }
        function isControlLetter(e3) {
          return e3 >= 65 && e3 <= 90 || e3 >= 97 && e3 <= 122;
        }
        acorn_RegExpValidationState.prototype.reset = function(e3, t3, i2) {
          var s2 = -1 !== i2.indexOf("v"), r2 = -1 !== i2.indexOf("u");
          this.start = 0 | e3, this.source = t3 + "", this.flags = i2, s2 && this.parser.options.ecmaVersion >= 15 ? (this.switchU = true, this.switchV = true, this.switchN = true) : (this.switchU = r2 && this.parser.options.ecmaVersion >= 6, this.switchV = false, this.switchN = r2 && this.parser.options.ecmaVersion >= 9);
        }, acorn_RegExpValidationState.prototype.raise = function(e3) {
          this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + e3);
        }, acorn_RegExpValidationState.prototype.at = function(e3, t3) {
          void 0 === t3 && (t3 = false);
          var i2 = this.source, s2 = i2.length;
          if (e3 >= s2) return -1;
          var r2 = i2.charCodeAt(e3);
          if (!t3 && !this.switchU || r2 <= 55295 || r2 >= 57344 || e3 + 1 >= s2) return r2;
          var n2 = i2.charCodeAt(e3 + 1);
          return n2 >= 56320 && n2 <= 57343 ? (r2 << 10) + n2 - 56613888 : r2;
        }, acorn_RegExpValidationState.prototype.nextIndex = function(e3, t3) {
          void 0 === t3 && (t3 = false);
          var i2 = this.source, s2 = i2.length;
          if (e3 >= s2) return s2;
          var r2, n2 = i2.charCodeAt(e3);
          return !t3 && !this.switchU || n2 <= 55295 || n2 >= 57344 || e3 + 1 >= s2 || (r2 = i2.charCodeAt(e3 + 1)) < 56320 || r2 > 57343 ? e3 + 1 : e3 + 2;
        }, acorn_RegExpValidationState.prototype.current = function(e3) {
          return void 0 === e3 && (e3 = false), this.at(this.pos, e3);
        }, acorn_RegExpValidationState.prototype.lookahead = function(e3) {
          return void 0 === e3 && (e3 = false), this.at(this.nextIndex(this.pos, e3), e3);
        }, acorn_RegExpValidationState.prototype.advance = function(e3) {
          void 0 === e3 && (e3 = false), this.pos = this.nextIndex(this.pos, e3);
        }, acorn_RegExpValidationState.prototype.eat = function(e3, t3) {
          return void 0 === t3 && (t3 = false), this.current(t3) === e3 && (this.advance(t3), true);
        }, acorn_RegExpValidationState.prototype.eatChars = function(e3, t3) {
          void 0 === t3 && (t3 = false);
          for (var i2 = this.pos, s2 = 0, r2 = e3; s2 < r2.length; s2 += 1) {
            var n2 = r2[s2], a2 = this.at(i2, t3);
            if (-1 === a2 || a2 !== n2) return false;
            i2 = this.nextIndex(i2, t3);
          }
          return this.pos = i2, true;
        }, he.validateRegExpFlags = function(e3) {
          for (var t3 = e3.validFlags, i2 = e3.flags, s2 = false, r2 = false, n2 = 0; n2 < i2.length; n2++) {
            var a2 = i2.charAt(n2);
            -1 === t3.indexOf(a2) && this.raise(e3.start, "Invalid regular expression flag"), i2.indexOf(a2, n2 + 1) > -1 && this.raise(e3.start, "Duplicate regular expression flag"), "u" === a2 && (s2 = true), "v" === a2 && (r2 = true);
          }
          this.options.ecmaVersion >= 15 && s2 && r2 && this.raise(e3.start, "Invalid regular expression flag");
        }, he.validateRegExpPattern = function(e3) {
          this.regexp_pattern(e3), !e3.switchN && this.options.ecmaVersion >= 9 && (function(e4) {
            for (var t3 in e4) return true;
            return false;
          })(e3.groupNames) && (e3.switchN = true, this.regexp_pattern(e3));
        }, he.regexp_pattern = function(e3) {
          e3.pos = 0, e3.lastIntValue = 0, e3.lastStringValue = "", e3.lastAssertionIsQuantifiable = false, e3.numCapturingParens = 0, e3.maxBackReference = 0, e3.groupNames = /* @__PURE__ */ Object.create(null), e3.backReferenceNames.length = 0, e3.branchID = null, this.regexp_disjunction(e3), e3.pos !== e3.source.length && (e3.eat(41) && e3.raise("Unmatched ')'"), (e3.eat(93) || e3.eat(125)) && e3.raise("Lone quantifier brackets")), e3.maxBackReference > e3.numCapturingParens && e3.raise("Invalid escape");
          for (var t3 = 0, i2 = e3.backReferenceNames; t3 < i2.length; t3 += 1) {
            var s2 = i2[t3];
            e3.groupNames[s2] || e3.raise("Invalid named capture referenced");
          }
        }, he.regexp_disjunction = function(e3) {
          var t3 = this.options.ecmaVersion >= 16;
          for (t3 && (e3.branchID = new acorn_BranchID(e3.branchID, null)), this.regexp_alternative(e3); e3.eat(124); ) t3 && (e3.branchID = e3.branchID.sibling()), this.regexp_alternative(e3);
          t3 && (e3.branchID = e3.branchID.parent), this.regexp_eatQuantifier(e3, true) && e3.raise("Nothing to repeat"), e3.eat(123) && e3.raise("Lone quantifier brackets");
        }, he.regexp_alternative = function(e3) {
          for (; e3.pos < e3.source.length && this.regexp_eatTerm(e3); ) ;
        }, he.regexp_eatTerm = function(e3) {
          return this.regexp_eatAssertion(e3) ? (e3.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(e3) && e3.switchU && e3.raise("Invalid quantifier"), true) : !!(e3.switchU ? this.regexp_eatAtom(e3) : this.regexp_eatExtendedAtom(e3)) && (this.regexp_eatQuantifier(e3), true);
        }, he.regexp_eatAssertion = function(e3) {
          var t3 = e3.pos;
          if (e3.lastAssertionIsQuantifiable = false, e3.eat(94) || e3.eat(36)) return true;
          if (e3.eat(92)) {
            if (e3.eat(66) || e3.eat(98)) return true;
            e3.pos = t3;
          }
          if (e3.eat(40) && e3.eat(63)) {
            var i2 = false;
            if (this.options.ecmaVersion >= 9 && (i2 = e3.eat(60)), e3.eat(61) || e3.eat(33)) return this.regexp_disjunction(e3), e3.eat(41) || e3.raise("Unterminated group"), e3.lastAssertionIsQuantifiable = !i2, true;
          }
          return e3.pos = t3, false;
        }, he.regexp_eatQuantifier = function(e3, t3) {
          return void 0 === t3 && (t3 = false), !!this.regexp_eatQuantifierPrefix(e3, t3) && (e3.eat(63), true);
        }, he.regexp_eatQuantifierPrefix = function(e3, t3) {
          return e3.eat(42) || e3.eat(43) || e3.eat(63) || this.regexp_eatBracedQuantifier(e3, t3);
        }, he.regexp_eatBracedQuantifier = function(e3, t3) {
          var i2 = e3.pos;
          if (e3.eat(123)) {
            var s2 = 0, r2 = -1;
            if (this.regexp_eatDecimalDigits(e3) && (s2 = e3.lastIntValue, e3.eat(44) && this.regexp_eatDecimalDigits(e3) && (r2 = e3.lastIntValue), e3.eat(125))) return -1 !== r2 && r2 < s2 && !t3 && e3.raise("numbers out of order in {} quantifier"), true;
            e3.switchU && !t3 && e3.raise("Incomplete quantifier"), e3.pos = i2;
          }
          return false;
        }, he.regexp_eatAtom = function(e3) {
          return this.regexp_eatPatternCharacters(e3) || e3.eat(46) || this.regexp_eatReverseSolidusAtomEscape(e3) || this.regexp_eatCharacterClass(e3) || this.regexp_eatUncapturingGroup(e3) || this.regexp_eatCapturingGroup(e3);
        }, he.regexp_eatReverseSolidusAtomEscape = function(e3) {
          var t3 = e3.pos;
          if (e3.eat(92)) {
            if (this.regexp_eatAtomEscape(e3)) return true;
            e3.pos = t3;
          }
          return false;
        }, he.regexp_eatUncapturingGroup = function(e3) {
          var t3 = e3.pos;
          if (e3.eat(40)) {
            if (e3.eat(63)) {
              if (this.options.ecmaVersion >= 16) {
                var i2 = this.regexp_eatModifiers(e3), s2 = e3.eat(45);
                if (i2 || s2) {
                  for (var r2 = 0; r2 < i2.length; r2++) {
                    var n2 = i2.charAt(r2);
                    i2.indexOf(n2, r2 + 1) > -1 && e3.raise("Duplicate regular expression modifiers");
                  }
                  if (s2) {
                    var a2 = this.regexp_eatModifiers(e3);
                    i2 || a2 || 58 !== e3.current() || e3.raise("Invalid regular expression modifiers");
                    for (var o2 = 0; o2 < a2.length; o2++) {
                      var h2 = a2.charAt(o2);
                      (a2.indexOf(h2, o2 + 1) > -1 || i2.indexOf(h2) > -1) && e3.raise("Duplicate regular expression modifiers");
                    }
                  }
                }
              }
              if (e3.eat(58)) {
                if (this.regexp_disjunction(e3), e3.eat(41)) return true;
                e3.raise("Unterminated group");
              }
            }
            e3.pos = t3;
          }
          return false;
        }, he.regexp_eatCapturingGroup = function(e3) {
          if (e3.eat(40)) {
            if (this.options.ecmaVersion >= 9 ? this.regexp_groupSpecifier(e3) : 63 === e3.current() && e3.raise("Invalid group"), this.regexp_disjunction(e3), e3.eat(41)) return e3.numCapturingParens += 1, true;
            e3.raise("Unterminated group");
          }
          return false;
        }, he.regexp_eatModifiers = function(e3) {
          for (var t3 = "", i2 = 0; -1 !== (i2 = e3.current()) && isRegularExpressionModifier(i2); ) t3 += codePointToString(i2), e3.advance();
          return t3;
        }, he.regexp_eatExtendedAtom = function(e3) {
          return e3.eat(46) || this.regexp_eatReverseSolidusAtomEscape(e3) || this.regexp_eatCharacterClass(e3) || this.regexp_eatUncapturingGroup(e3) || this.regexp_eatCapturingGroup(e3) || this.regexp_eatInvalidBracedQuantifier(e3) || this.regexp_eatExtendedPatternCharacter(e3);
        }, he.regexp_eatInvalidBracedQuantifier = function(e3) {
          return this.regexp_eatBracedQuantifier(e3, true) && e3.raise("Nothing to repeat"), false;
        }, he.regexp_eatSyntaxCharacter = function(e3) {
          var t3 = e3.current();
          return !!isSyntaxCharacter(t3) && (e3.lastIntValue = t3, e3.advance(), true);
        }, he.regexp_eatPatternCharacters = function(e3) {
          for (var t3 = e3.pos, i2 = 0; -1 !== (i2 = e3.current()) && !isSyntaxCharacter(i2); ) e3.advance();
          return e3.pos !== t3;
        }, he.regexp_eatExtendedPatternCharacter = function(e3) {
          var t3 = e3.current();
          return !(-1 === t3 || 36 === t3 || t3 >= 40 && t3 <= 43 || 46 === t3 || 63 === t3 || 91 === t3 || 94 === t3 || 124 === t3) && (e3.advance(), true);
        }, he.regexp_groupSpecifier = function(e3) {
          if (e3.eat(63)) {
            this.regexp_eatGroupName(e3) || e3.raise("Invalid group");
            var t3 = this.options.ecmaVersion >= 16, i2 = e3.groupNames[e3.lastStringValue];
            if (i2) if (t3) for (var s2 = 0, r2 = i2; s2 < r2.length; s2 += 1) {
              r2[s2].separatedFrom(e3.branchID) || e3.raise("Duplicate capture group name");
            }
            else e3.raise("Duplicate capture group name");
            t3 ? (i2 || (e3.groupNames[e3.lastStringValue] = [])).push(e3.branchID) : e3.groupNames[e3.lastStringValue] = true;
          }
        }, he.regexp_eatGroupName = function(e3) {
          if (e3.lastStringValue = "", e3.eat(60)) {
            if (this.regexp_eatRegExpIdentifierName(e3) && e3.eat(62)) return true;
            e3.raise("Invalid capture group name");
          }
          return false;
        }, he.regexp_eatRegExpIdentifierName = function(e3) {
          if (e3.lastStringValue = "", this.regexp_eatRegExpIdentifierStart(e3)) {
            for (e3.lastStringValue += codePointToString(e3.lastIntValue); this.regexp_eatRegExpIdentifierPart(e3); ) e3.lastStringValue += codePointToString(e3.lastIntValue);
            return true;
          }
          return false;
        }, he.regexp_eatRegExpIdentifierStart = function(e3) {
          var t3 = e3.pos, i2 = this.options.ecmaVersion >= 11, s2 = e3.current(i2);
          return e3.advance(i2), 92 === s2 && this.regexp_eatRegExpUnicodeEscapeSequence(e3, i2) && (s2 = e3.lastIntValue), (function(e4) {
            return isIdentifierStart(e4, true) || 36 === e4 || 95 === e4;
          })(s2) ? (e3.lastIntValue = s2, true) : (e3.pos = t3, false);
        }, he.regexp_eatRegExpIdentifierPart = function(e3) {
          var t3 = e3.pos, i2 = this.options.ecmaVersion >= 11, s2 = e3.current(i2);
          return e3.advance(i2), 92 === s2 && this.regexp_eatRegExpUnicodeEscapeSequence(e3, i2) && (s2 = e3.lastIntValue), (function(e4) {
            return isIdentifierChar(e4, true) || 36 === e4 || 95 === e4 || 8204 === e4 || 8205 === e4;
          })(s2) ? (e3.lastIntValue = s2, true) : (e3.pos = t3, false);
        }, he.regexp_eatAtomEscape = function(e3) {
          return !!(this.regexp_eatBackReference(e3) || this.regexp_eatCharacterClassEscape(e3) || this.regexp_eatCharacterEscape(e3) || e3.switchN && this.regexp_eatKGroupName(e3)) || (e3.switchU && (99 === e3.current() && e3.raise("Invalid unicode escape"), e3.raise("Invalid escape")), false);
        }, he.regexp_eatBackReference = function(e3) {
          var t3 = e3.pos;
          if (this.regexp_eatDecimalEscape(e3)) {
            var i2 = e3.lastIntValue;
            if (e3.switchU) return i2 > e3.maxBackReference && (e3.maxBackReference = i2), true;
            if (i2 <= e3.numCapturingParens) return true;
            e3.pos = t3;
          }
          return false;
        }, he.regexp_eatKGroupName = function(e3) {
          if (e3.eat(107)) {
            if (this.regexp_eatGroupName(e3)) return e3.backReferenceNames.push(e3.lastStringValue), true;
            e3.raise("Invalid named reference");
          }
          return false;
        }, he.regexp_eatCharacterEscape = function(e3) {
          return this.regexp_eatControlEscape(e3) || this.regexp_eatCControlLetter(e3) || this.regexp_eatZero(e3) || this.regexp_eatHexEscapeSequence(e3) || this.regexp_eatRegExpUnicodeEscapeSequence(e3, false) || !e3.switchU && this.regexp_eatLegacyOctalEscapeSequence(e3) || this.regexp_eatIdentityEscape(e3);
        }, he.regexp_eatCControlLetter = function(e3) {
          var t3 = e3.pos;
          if (e3.eat(99)) {
            if (this.regexp_eatControlLetter(e3)) return true;
            e3.pos = t3;
          }
          return false;
        }, he.regexp_eatZero = function(e3) {
          return 48 === e3.current() && !isDecimalDigit(e3.lookahead()) && (e3.lastIntValue = 0, e3.advance(), true);
        }, he.regexp_eatControlEscape = function(e3) {
          var t3 = e3.current();
          return 116 === t3 ? (e3.lastIntValue = 9, e3.advance(), true) : 110 === t3 ? (e3.lastIntValue = 10, e3.advance(), true) : 118 === t3 ? (e3.lastIntValue = 11, e3.advance(), true) : 102 === t3 ? (e3.lastIntValue = 12, e3.advance(), true) : 114 === t3 && (e3.lastIntValue = 13, e3.advance(), true);
        }, he.regexp_eatControlLetter = function(e3) {
          var t3 = e3.current();
          return !!isControlLetter(t3) && (e3.lastIntValue = t3 % 32, e3.advance(), true);
        }, he.regexp_eatRegExpUnicodeEscapeSequence = function(e3, t3) {
          void 0 === t3 && (t3 = false);
          var i2, s2 = e3.pos, r2 = t3 || e3.switchU;
          if (e3.eat(117)) {
            if (this.regexp_eatFixedHexDigits(e3, 4)) {
              var n2 = e3.lastIntValue;
              if (r2 && n2 >= 55296 && n2 <= 56319) {
                var a2 = e3.pos;
                if (e3.eat(92) && e3.eat(117) && this.regexp_eatFixedHexDigits(e3, 4)) {
                  var o2 = e3.lastIntValue;
                  if (o2 >= 56320 && o2 <= 57343) return e3.lastIntValue = 1024 * (n2 - 55296) + (o2 - 56320) + 65536, true;
                }
                e3.pos = a2, e3.lastIntValue = n2;
              }
              return true;
            }
            if (r2 && e3.eat(123) && this.regexp_eatHexDigits(e3) && e3.eat(125) && ((i2 = e3.lastIntValue) >= 0 && i2 <= 1114111)) return true;
            r2 && e3.raise("Invalid unicode escape"), e3.pos = s2;
          }
          return false;
        }, he.regexp_eatIdentityEscape = function(e3) {
          if (e3.switchU) return !!this.regexp_eatSyntaxCharacter(e3) || !!e3.eat(47) && (e3.lastIntValue = 47, true);
          var t3 = e3.current();
          return !(99 === t3 || e3.switchN && 107 === t3) && (e3.lastIntValue = t3, e3.advance(), true);
        }, he.regexp_eatDecimalEscape = function(e3) {
          e3.lastIntValue = 0;
          var t3 = e3.current();
          if (t3 >= 49 && t3 <= 57) {
            do {
              e3.lastIntValue = 10 * e3.lastIntValue + (t3 - 48), e3.advance();
            } while ((t3 = e3.current()) >= 48 && t3 <= 57);
            return true;
          }
          return false;
        };
        function isUnicodePropertyNameCharacter(e3) {
          return isControlLetter(e3) || 95 === e3;
        }
        function isUnicodePropertyValueCharacter(e3) {
          return isUnicodePropertyNameCharacter(e3) || isDecimalDigit(e3);
        }
        function isDecimalDigit(e3) {
          return e3 >= 48 && e3 <= 57;
        }
        function isHexDigit(e3) {
          return e3 >= 48 && e3 <= 57 || e3 >= 65 && e3 <= 70 || e3 >= 97 && e3 <= 102;
        }
        function hexToInt(e3) {
          return e3 >= 65 && e3 <= 70 ? e3 - 65 + 10 : e3 >= 97 && e3 <= 102 ? e3 - 97 + 10 : e3 - 48;
        }
        function isOctalDigit(e3) {
          return e3 >= 48 && e3 <= 55;
        }
        he.regexp_eatCharacterClassEscape = function(e3) {
          var t3 = e3.current();
          if (/* @__PURE__ */ (function(e4) {
            return 100 === e4 || 68 === e4 || 115 === e4 || 83 === e4 || 119 === e4 || 87 === e4;
          })(t3)) return e3.lastIntValue = -1, e3.advance(), 1;
          var i2 = false;
          if (e3.switchU && this.options.ecmaVersion >= 9 && ((i2 = 80 === t3) || 112 === t3)) {
            var s2;
            if (e3.lastIntValue = -1, e3.advance(), e3.eat(123) && (s2 = this.regexp_eatUnicodePropertyValueExpression(e3)) && e3.eat(125)) return i2 && 2 === s2 && e3.raise("Invalid property name"), s2;
            e3.raise("Invalid property name");
          }
          return 0;
        }, he.regexp_eatUnicodePropertyValueExpression = function(e3) {
          var t3 = e3.pos;
          if (this.regexp_eatUnicodePropertyName(e3) && e3.eat(61)) {
            var i2 = e3.lastStringValue;
            if (this.regexp_eatUnicodePropertyValue(e3)) {
              var s2 = e3.lastStringValue;
              return this.regexp_validateUnicodePropertyNameAndValue(e3, i2, s2), 1;
            }
          }
          if (e3.pos = t3, this.regexp_eatLoneUnicodePropertyNameOrValue(e3)) {
            var r2 = e3.lastStringValue;
            return this.regexp_validateUnicodePropertyNameOrValue(e3, r2);
          }
          return 0;
        }, he.regexp_validateUnicodePropertyNameAndValue = function(e3, t3, i2) {
          b(e3.unicodeProperties.nonBinary, t3) || e3.raise("Invalid property name"), e3.unicodeProperties.nonBinary[t3].test(i2) || e3.raise("Invalid property value");
        }, he.regexp_validateUnicodePropertyNameOrValue = function(e3, t3) {
          return e3.unicodeProperties.binary.test(t3) ? 1 : e3.switchV && e3.unicodeProperties.binaryOfStrings.test(t3) ? 2 : void e3.raise("Invalid property name");
        }, he.regexp_eatUnicodePropertyName = function(e3) {
          var t3 = 0;
          for (e3.lastStringValue = ""; isUnicodePropertyNameCharacter(t3 = e3.current()); ) e3.lastStringValue += codePointToString(t3), e3.advance();
          return "" !== e3.lastStringValue;
        }, he.regexp_eatUnicodePropertyValue = function(e3) {
          var t3 = 0;
          for (e3.lastStringValue = ""; isUnicodePropertyValueCharacter(t3 = e3.current()); ) e3.lastStringValue += codePointToString(t3), e3.advance();
          return "" !== e3.lastStringValue;
        }, he.regexp_eatLoneUnicodePropertyNameOrValue = function(e3) {
          return this.regexp_eatUnicodePropertyValue(e3);
        }, he.regexp_eatCharacterClass = function(e3) {
          if (e3.eat(91)) {
            var t3 = e3.eat(94), i2 = this.regexp_classContents(e3);
            return e3.eat(93) || e3.raise("Unterminated character class"), t3 && 2 === i2 && e3.raise("Negated character class may contain strings"), true;
          }
          return false;
        }, he.regexp_classContents = function(e3) {
          return 93 === e3.current() ? 1 : e3.switchV ? this.regexp_classSetExpression(e3) : (this.regexp_nonEmptyClassRanges(e3), 1);
        }, he.regexp_nonEmptyClassRanges = function(e3) {
          for (; this.regexp_eatClassAtom(e3); ) {
            var t3 = e3.lastIntValue;
            if (e3.eat(45) && this.regexp_eatClassAtom(e3)) {
              var i2 = e3.lastIntValue;
              !e3.switchU || -1 !== t3 && -1 !== i2 || e3.raise("Invalid character class"), -1 !== t3 && -1 !== i2 && t3 > i2 && e3.raise("Range out of order in character class");
            }
          }
        }, he.regexp_eatClassAtom = function(e3) {
          var t3 = e3.pos;
          if (e3.eat(92)) {
            if (this.regexp_eatClassEscape(e3)) return true;
            if (e3.switchU) {
              var i2 = e3.current();
              (99 === i2 || isOctalDigit(i2)) && e3.raise("Invalid class escape"), e3.raise("Invalid escape");
            }
            e3.pos = t3;
          }
          var s2 = e3.current();
          return 93 !== s2 && (e3.lastIntValue = s2, e3.advance(), true);
        }, he.regexp_eatClassEscape = function(e3) {
          var t3 = e3.pos;
          if (e3.eat(98)) return e3.lastIntValue = 8, true;
          if (e3.switchU && e3.eat(45)) return e3.lastIntValue = 45, true;
          if (!e3.switchU && e3.eat(99)) {
            if (this.regexp_eatClassControlLetter(e3)) return true;
            e3.pos = t3;
          }
          return this.regexp_eatCharacterClassEscape(e3) || this.regexp_eatCharacterEscape(e3);
        }, he.regexp_classSetExpression = function(e3) {
          var t3, i2 = 1;
          if (this.regexp_eatClassSetRange(e3)) ;
          else if (t3 = this.regexp_eatClassSetOperand(e3)) {
            2 === t3 && (i2 = 2);
            for (var s2 = e3.pos; e3.eatChars([38, 38]); ) 38 !== e3.current() && (t3 = this.regexp_eatClassSetOperand(e3)) ? 2 !== t3 && (i2 = 1) : e3.raise("Invalid character in character class");
            if (s2 !== e3.pos) return i2;
            for (; e3.eatChars([45, 45]); ) this.regexp_eatClassSetOperand(e3) || e3.raise("Invalid character in character class");
            if (s2 !== e3.pos) return i2;
          } else e3.raise("Invalid character in character class");
          for (; ; ) if (!this.regexp_eatClassSetRange(e3)) {
            if (!(t3 = this.regexp_eatClassSetOperand(e3))) return i2;
            2 === t3 && (i2 = 2);
          }
        }, he.regexp_eatClassSetRange = function(e3) {
          var t3 = e3.pos;
          if (this.regexp_eatClassSetCharacter(e3)) {
            var i2 = e3.lastIntValue;
            if (e3.eat(45) && this.regexp_eatClassSetCharacter(e3)) {
              var s2 = e3.lastIntValue;
              return -1 !== i2 && -1 !== s2 && i2 > s2 && e3.raise("Range out of order in character class"), true;
            }
            e3.pos = t3;
          }
          return false;
        }, he.regexp_eatClassSetOperand = function(e3) {
          return this.regexp_eatClassSetCharacter(e3) ? 1 : this.regexp_eatClassStringDisjunction(e3) || this.regexp_eatNestedClass(e3);
        }, he.regexp_eatNestedClass = function(e3) {
          var t3 = e3.pos;
          if (e3.eat(91)) {
            var i2 = e3.eat(94), s2 = this.regexp_classContents(e3);
            if (e3.eat(93)) return i2 && 2 === s2 && e3.raise("Negated character class may contain strings"), s2;
            e3.pos = t3;
          }
          if (e3.eat(92)) {
            var r2 = this.regexp_eatCharacterClassEscape(e3);
            if (r2) return r2;
            e3.pos = t3;
          }
          return null;
        }, he.regexp_eatClassStringDisjunction = function(e3) {
          var t3 = e3.pos;
          if (e3.eatChars([92, 113])) {
            if (e3.eat(123)) {
              var i2 = this.regexp_classStringDisjunctionContents(e3);
              if (e3.eat(125)) return i2;
            } else e3.raise("Invalid escape");
            e3.pos = t3;
          }
          return null;
        }, he.regexp_classStringDisjunctionContents = function(e3) {
          for (var t3 = this.regexp_classString(e3); e3.eat(124); ) 2 === this.regexp_classString(e3) && (t3 = 2);
          return t3;
        }, he.regexp_classString = function(e3) {
          for (var t3 = 0; this.regexp_eatClassSetCharacter(e3); ) t3++;
          return 1 === t3 ? 1 : 2;
        }, he.regexp_eatClassSetCharacter = function(e3) {
          var t3 = e3.pos;
          if (e3.eat(92)) return !(!this.regexp_eatCharacterEscape(e3) && !this.regexp_eatClassSetReservedPunctuator(e3)) || (e3.eat(98) ? (e3.lastIntValue = 8, true) : (e3.pos = t3, false));
          var i2 = e3.current();
          return !(i2 < 0 || i2 === e3.lookahead() && (function(e4) {
            return 33 === e4 || e4 >= 35 && e4 <= 38 || e4 >= 42 && e4 <= 44 || 46 === e4 || e4 >= 58 && e4 <= 64 || 94 === e4 || 96 === e4 || 126 === e4;
          })(i2)) && (!(function(e4) {
            return 40 === e4 || 41 === e4 || 45 === e4 || 47 === e4 || e4 >= 91 && e4 <= 93 || e4 >= 123 && e4 <= 125;
          })(i2) && (e3.advance(), e3.lastIntValue = i2, true));
        }, he.regexp_eatClassSetReservedPunctuator = function(e3) {
          var t3 = e3.current();
          return !!(function(e4) {
            return 33 === e4 || 35 === e4 || 37 === e4 || 38 === e4 || 44 === e4 || 45 === e4 || e4 >= 58 && e4 <= 62 || 64 === e4 || 96 === e4 || 126 === e4;
          })(t3) && (e3.lastIntValue = t3, e3.advance(), true);
        }, he.regexp_eatClassControlLetter = function(e3) {
          var t3 = e3.current();
          return !(!isDecimalDigit(t3) && 95 !== t3) && (e3.lastIntValue = t3 % 32, e3.advance(), true);
        }, he.regexp_eatHexEscapeSequence = function(e3) {
          var t3 = e3.pos;
          if (e3.eat(120)) {
            if (this.regexp_eatFixedHexDigits(e3, 2)) return true;
            e3.switchU && e3.raise("Invalid escape"), e3.pos = t3;
          }
          return false;
        }, he.regexp_eatDecimalDigits = function(e3) {
          var t3 = e3.pos, i2 = 0;
          for (e3.lastIntValue = 0; isDecimalDigit(i2 = e3.current()); ) e3.lastIntValue = 10 * e3.lastIntValue + (i2 - 48), e3.advance();
          return e3.pos !== t3;
        }, he.regexp_eatHexDigits = function(e3) {
          var t3 = e3.pos, i2 = 0;
          for (e3.lastIntValue = 0; isHexDigit(i2 = e3.current()); ) e3.lastIntValue = 16 * e3.lastIntValue + hexToInt(i2), e3.advance();
          return e3.pos !== t3;
        }, he.regexp_eatLegacyOctalEscapeSequence = function(e3) {
          if (this.regexp_eatOctalDigit(e3)) {
            var t3 = e3.lastIntValue;
            if (this.regexp_eatOctalDigit(e3)) {
              var i2 = e3.lastIntValue;
              t3 <= 3 && this.regexp_eatOctalDigit(e3) ? e3.lastIntValue = 64 * t3 + 8 * i2 + e3.lastIntValue : e3.lastIntValue = 8 * t3 + i2;
            } else e3.lastIntValue = t3;
            return true;
          }
          return false;
        }, he.regexp_eatOctalDigit = function(e3) {
          var t3 = e3.current();
          return isOctalDigit(t3) ? (e3.lastIntValue = t3 - 48, e3.advance(), true) : (e3.lastIntValue = 0, false);
        }, he.regexp_eatFixedHexDigits = function(e3, t3) {
          var i2 = e3.pos;
          e3.lastIntValue = 0;
          for (var s2 = 0; s2 < t3; ++s2) {
            var r2 = e3.current();
            if (!isHexDigit(r2)) return e3.pos = i2, false;
            e3.lastIntValue = 16 * e3.lastIntValue + hexToInt(r2), e3.advance();
          }
          return true;
        };
        var acorn_Token = function(e3) {
          this.type = e3.type, this.value = e3.value, this.start = e3.start, this.end = e3.end, e3.options.locations && (this.loc = new acorn_SourceLocation(e3, e3.startLoc, e3.endLoc)), e3.options.ranges && (this.range = [e3.start, e3.end]);
        }, ce = acorn_Parser.prototype;
        function stringToBigInt(e3) {
          return "function" != typeof BigInt ? null : BigInt(e3.replace(/_/g, ""));
        }
        ce.next = function(e3) {
          !e3 && this.type.keyword && this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword), this.options.onToken && this.options.onToken(new acorn_Token(this)), this.lastTokEnd = this.end, this.lastTokStart = this.start, this.lastTokEndLoc = this.endLoc, this.lastTokStartLoc = this.startLoc, this.nextToken();
        }, ce.getToken = function() {
          return this.next(), new acorn_Token(this);
        }, "undefined" != typeof Symbol && (ce[Symbol.iterator] = function() {
          var e3 = this;
          return { next: function() {
            var t3 = e3.getToken();
            return { done: t3.type === f.eof, value: t3 };
          } };
        }), ce.nextToken = function() {
          var e3 = this.curContext();
          return e3 && e3.preserveSpace || this.skipSpace(), this.start = this.pos, this.options.locations && (this.startLoc = this.curPosition()), this.pos >= this.input.length ? this.finishToken(f.eof) : e3.override ? e3.override(this) : void this.readToken(this.fullCharCodeAtPos());
        }, ce.readToken = function(e3) {
          return isIdentifierStart(e3, this.options.ecmaVersion >= 6) || 92 === e3 ? this.readWord() : this.getTokenFromCode(e3);
        }, ce.fullCharCodeAtPos = function() {
          var e3 = this.input.charCodeAt(this.pos);
          if (e3 <= 55295 || e3 >= 56320) return e3;
          var t3 = this.input.charCodeAt(this.pos + 1);
          return t3 <= 56319 || t3 >= 57344 ? e3 : (e3 << 10) + t3 - 56613888;
        }, ce.skipBlockComment = function() {
          var e3 = this.options.onComment && this.curPosition(), t3 = this.pos, i2 = this.input.indexOf("*/", this.pos += 2);
          if (-1 === i2 && this.raise(this.pos - 2, "Unterminated comment"), this.pos = i2 + 2, this.options.locations) for (var s2 = void 0, r2 = t3; (s2 = nextLineBreak(this.input, r2, this.pos)) > -1; ) ++this.curLine, r2 = this.lineStart = s2;
          this.options.onComment && this.options.onComment(true, this.input.slice(t3 + 2, i2), t3, this.pos, e3, this.curPosition());
        }, ce.skipLineComment = function(e3) {
          for (var t3 = this.pos, i2 = this.options.onComment && this.curPosition(), s2 = this.input.charCodeAt(this.pos += e3); this.pos < this.input.length && !isNewLine(s2); ) s2 = this.input.charCodeAt(++this.pos);
          this.options.onComment && this.options.onComment(false, this.input.slice(t3 + e3, this.pos), t3, this.pos, i2, this.curPosition());
        }, ce.skipSpace = function() {
          e: for (; this.pos < this.input.length; ) {
            var e3 = this.input.charCodeAt(this.pos);
            switch (e3) {
              case 32:
              case 160:
                ++this.pos;
                break;
              case 13:
                10 === this.input.charCodeAt(this.pos + 1) && ++this.pos;
              case 10:
              case 8232:
              case 8233:
                ++this.pos, this.options.locations && (++this.curLine, this.lineStart = this.pos);
                break;
              case 47:
                switch (this.input.charCodeAt(this.pos + 1)) {
                  case 42:
                    this.skipBlockComment();
                    break;
                  case 47:
                    this.skipLineComment(2);
                    break;
                  default:
                    break e;
                }
                break;
              default:
                if (!(e3 > 8 && e3 < 14 || e3 >= 5760 && x.test(String.fromCharCode(e3)))) break e;
                ++this.pos;
            }
          }
        }, ce.finishToken = function(e3, t3) {
          this.end = this.pos, this.options.locations && (this.endLoc = this.curPosition());
          var i2 = this.type;
          this.type = e3, this.value = t3, this.updateContext(i2);
        }, ce.readToken_dot = function() {
          var e3 = this.input.charCodeAt(this.pos + 1);
          if (e3 >= 48 && e3 <= 57) return this.readNumber(true);
          var t3 = this.input.charCodeAt(this.pos + 2);
          return this.options.ecmaVersion >= 6 && 46 === e3 && 46 === t3 ? (this.pos += 3, this.finishToken(f.ellipsis)) : (++this.pos, this.finishToken(f.dot));
        }, ce.readToken_slash = function() {
          var e3 = this.input.charCodeAt(this.pos + 1);
          return this.exprAllowed ? (++this.pos, this.readRegexp()) : 61 === e3 ? this.finishOp(f.assign, 2) : this.finishOp(f.slash, 1);
        }, ce.readToken_mult_modulo_exp = function(e3) {
          var t3 = this.input.charCodeAt(this.pos + 1), i2 = 1, s2 = 42 === e3 ? f.star : f.modulo;
          return this.options.ecmaVersion >= 7 && 42 === e3 && 42 === t3 && (++i2, s2 = f.starstar, t3 = this.input.charCodeAt(this.pos + 2)), 61 === t3 ? this.finishOp(f.assign, i2 + 1) : this.finishOp(s2, i2);
        }, ce.readToken_pipe_amp = function(e3) {
          var t3 = this.input.charCodeAt(this.pos + 1);
          if (t3 === e3) {
            if (this.options.ecmaVersion >= 12) {
              if (61 === this.input.charCodeAt(this.pos + 2)) return this.finishOp(f.assign, 3);
            }
            return this.finishOp(124 === e3 ? f.logicalOR : f.logicalAND, 2);
          }
          return 61 === t3 ? this.finishOp(f.assign, 2) : this.finishOp(124 === e3 ? f.bitwiseOR : f.bitwiseAND, 1);
        }, ce.readToken_caret = function() {
          return 61 === this.input.charCodeAt(this.pos + 1) ? this.finishOp(f.assign, 2) : this.finishOp(f.bitwiseXOR, 1);
        }, ce.readToken_plus_min = function(e3) {
          var t3 = this.input.charCodeAt(this.pos + 1);
          return t3 === e3 ? 45 !== t3 || this.inModule || 62 !== this.input.charCodeAt(this.pos + 2) || 0 !== this.lastTokEnd && !m.test(this.input.slice(this.lastTokEnd, this.pos)) ? this.finishOp(f.incDec, 2) : (this.skipLineComment(3), this.skipSpace(), this.nextToken()) : 61 === t3 ? this.finishOp(f.assign, 2) : this.finishOp(f.plusMin, 1);
        }, ce.readToken_lt_gt = function(e3) {
          var t3 = this.input.charCodeAt(this.pos + 1), i2 = 1;
          return t3 === e3 ? (i2 = 62 === e3 && 62 === this.input.charCodeAt(this.pos + 2) ? 3 : 2, 61 === this.input.charCodeAt(this.pos + i2) ? this.finishOp(f.assign, i2 + 1) : this.finishOp(f.bitShift, i2)) : 33 !== t3 || 60 !== e3 || this.inModule || 45 !== this.input.charCodeAt(this.pos + 2) || 45 !== this.input.charCodeAt(this.pos + 3) ? (61 === t3 && (i2 = 2), this.finishOp(f.relational, i2)) : (this.skipLineComment(4), this.skipSpace(), this.nextToken());
        }, ce.readToken_eq_excl = function(e3) {
          var t3 = this.input.charCodeAt(this.pos + 1);
          return 61 === t3 ? this.finishOp(f.equality, 61 === this.input.charCodeAt(this.pos + 2) ? 3 : 2) : 61 === e3 && 62 === t3 && this.options.ecmaVersion >= 6 ? (this.pos += 2, this.finishToken(f.arrow)) : this.finishOp(61 === e3 ? f.eq : f.prefix, 1);
        }, ce.readToken_question = function() {
          var e3 = this.options.ecmaVersion;
          if (e3 >= 11) {
            var t3 = this.input.charCodeAt(this.pos + 1);
            if (46 === t3) {
              var i2 = this.input.charCodeAt(this.pos + 2);
              if (i2 < 48 || i2 > 57) return this.finishOp(f.questionDot, 2);
            }
            if (63 === t3) {
              if (e3 >= 12) {
                if (61 === this.input.charCodeAt(this.pos + 2)) return this.finishOp(f.assign, 3);
              }
              return this.finishOp(f.coalesce, 2);
            }
          }
          return this.finishOp(f.question, 1);
        }, ce.readToken_numberSign = function() {
          var e3 = 35;
          if (this.options.ecmaVersion >= 13 && (++this.pos, isIdentifierStart(e3 = this.fullCharCodeAtPos(), true) || 92 === e3)) return this.finishToken(f.privateId, this.readWord1());
          this.raise(this.pos, "Unexpected character '" + codePointToString(e3) + "'");
        }, ce.getTokenFromCode = function(e3) {
          switch (e3) {
            case 46:
              return this.readToken_dot();
            case 40:
              return ++this.pos, this.finishToken(f.parenL);
            case 41:
              return ++this.pos, this.finishToken(f.parenR);
            case 59:
              return ++this.pos, this.finishToken(f.semi);
            case 44:
              return ++this.pos, this.finishToken(f.comma);
            case 91:
              return ++this.pos, this.finishToken(f.bracketL);
            case 93:
              return ++this.pos, this.finishToken(f.bracketR);
            case 123:
              return ++this.pos, this.finishToken(f.braceL);
            case 125:
              return ++this.pos, this.finishToken(f.braceR);
            case 58:
              return ++this.pos, this.finishToken(f.colon);
            case 96:
              if (this.options.ecmaVersion < 6) break;
              return ++this.pos, this.finishToken(f.backQuote);
            case 48:
              var t3 = this.input.charCodeAt(this.pos + 1);
              if (120 === t3 || 88 === t3) return this.readRadixNumber(16);
              if (this.options.ecmaVersion >= 6) {
                if (111 === t3 || 79 === t3) return this.readRadixNumber(8);
                if (98 === t3 || 66 === t3) return this.readRadixNumber(2);
              }
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
              return this.readNumber(false);
            case 34:
            case 39:
              return this.readString(e3);
            case 47:
              return this.readToken_slash();
            case 37:
            case 42:
              return this.readToken_mult_modulo_exp(e3);
            case 124:
            case 38:
              return this.readToken_pipe_amp(e3);
            case 94:
              return this.readToken_caret();
            case 43:
            case 45:
              return this.readToken_plus_min(e3);
            case 60:
            case 62:
              return this.readToken_lt_gt(e3);
            case 61:
            case 33:
              return this.readToken_eq_excl(e3);
            case 63:
              return this.readToken_question();
            case 126:
              return this.finishOp(f.prefix, 1);
            case 35:
              return this.readToken_numberSign();
          }
          this.raise(this.pos, "Unexpected character '" + codePointToString(e3) + "'");
        }, ce.finishOp = function(e3, t3) {
          var i2 = this.input.slice(this.pos, this.pos + t3);
          return this.pos += t3, this.finishToken(e3, i2);
        }, ce.readRegexp = function() {
          for (var e3, t3, i2 = this.pos; ; ) {
            this.pos >= this.input.length && this.raise(i2, "Unterminated regular expression");
            var s2 = this.input.charAt(this.pos);
            if (m.test(s2) && this.raise(i2, "Unterminated regular expression"), e3) e3 = false;
            else {
              if ("[" === s2) t3 = true;
              else if ("]" === s2 && t3) t3 = false;
              else if ("/" === s2 && !t3) break;
              e3 = "\\" === s2;
            }
            ++this.pos;
          }
          var r2 = this.input.slice(i2, this.pos);
          ++this.pos;
          var n2 = this.pos, a2 = this.readWord1();
          this.containsEsc && this.unexpected(n2);
          var o2 = this.regexpState || (this.regexpState = new acorn_RegExpValidationState(this));
          o2.reset(i2, r2, a2), this.validateRegExpFlags(o2), this.validateRegExpPattern(o2);
          var h2 = null;
          try {
            h2 = new RegExp(r2, a2);
          } catch (e4) {
          }
          return this.finishToken(f.regexp, { pattern: r2, flags: a2, value: h2 });
        }, ce.readInt = function(e3, t3, i2) {
          for (var s2 = this.options.ecmaVersion >= 12 && void 0 === t3, r2 = i2 && 48 === this.input.charCodeAt(this.pos), n2 = this.pos, a2 = 0, o2 = 0, h2 = 0, c2 = null == t3 ? 1 / 0 : t3; h2 < c2; ++h2, ++this.pos) {
            var p2 = this.input.charCodeAt(this.pos), l2 = void 0;
            if (s2 && 95 === p2) r2 && this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals"), 95 === o2 && this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore"), 0 === h2 && this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits"), o2 = p2;
            else {
              if ((l2 = p2 >= 97 ? p2 - 97 + 10 : p2 >= 65 ? p2 - 65 + 10 : p2 >= 48 && p2 <= 57 ? p2 - 48 : 1 / 0) >= e3) break;
              o2 = p2, a2 = a2 * e3 + l2;
            }
          }
          return s2 && 95 === o2 && this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits"), this.pos === n2 || null != t3 && this.pos - n2 !== t3 ? null : a2;
        }, ce.readRadixNumber = function(e3) {
          var t3 = this.pos;
          this.pos += 2;
          var i2 = this.readInt(e3);
          return null == i2 && this.raise(this.start + 2, "Expected number in radix " + e3), this.options.ecmaVersion >= 11 && 110 === this.input.charCodeAt(this.pos) ? (i2 = stringToBigInt(this.input.slice(t3, this.pos)), ++this.pos) : isIdentifierStart(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(f.num, i2);
        }, ce.readNumber = function(e3) {
          var t3 = this.pos;
          e3 || null !== this.readInt(10, void 0, true) || this.raise(t3, "Invalid number");
          var i2 = this.pos - t3 >= 2 && 48 === this.input.charCodeAt(t3);
          i2 && this.strict && this.raise(t3, "Invalid number");
          var s2 = this.input.charCodeAt(this.pos);
          if (!i2 && !e3 && this.options.ecmaVersion >= 11 && 110 === s2) {
            var r2 = stringToBigInt(this.input.slice(t3, this.pos));
            return ++this.pos, isIdentifierStart(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(f.num, r2);
          }
          i2 && /[89]/.test(this.input.slice(t3, this.pos)) && (i2 = false), 46 !== s2 || i2 || (++this.pos, this.readInt(10), s2 = this.input.charCodeAt(this.pos)), 69 !== s2 && 101 !== s2 || i2 || (43 !== (s2 = this.input.charCodeAt(++this.pos)) && 45 !== s2 || ++this.pos, null === this.readInt(10) && this.raise(t3, "Invalid number")), isIdentifierStart(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number");
          var n2, a2 = (n2 = this.input.slice(t3, this.pos), i2 ? parseInt(n2, 8) : parseFloat(n2.replace(/_/g, "")));
          return this.finishToken(f.num, a2);
        }, ce.readCodePoint = function() {
          var e3;
          if (123 === this.input.charCodeAt(this.pos)) {
            this.options.ecmaVersion < 6 && this.unexpected();
            var t3 = ++this.pos;
            e3 = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos), ++this.pos, e3 > 1114111 && this.invalidStringToken(t3, "Code point out of bounds");
          } else e3 = this.readHexChar(4);
          return e3;
        }, ce.readString = function(e3) {
          for (var t3 = "", i2 = ++this.pos; ; ) {
            this.pos >= this.input.length && this.raise(this.start, "Unterminated string constant");
            var s2 = this.input.charCodeAt(this.pos);
            if (s2 === e3) break;
            92 === s2 ? (t3 += this.input.slice(i2, this.pos), t3 += this.readEscapedChar(false), i2 = this.pos) : 8232 === s2 || 8233 === s2 ? (this.options.ecmaVersion < 10 && this.raise(this.start, "Unterminated string constant"), ++this.pos, this.options.locations && (this.curLine++, this.lineStart = this.pos)) : (isNewLine(s2) && this.raise(this.start, "Unterminated string constant"), ++this.pos);
          }
          return t3 += this.input.slice(i2, this.pos++), this.finishToken(f.string, t3);
        };
        var pe = {};
        ce.tryReadTemplateToken = function() {
          this.inTemplateElement = true;
          try {
            this.readTmplToken();
          } catch (e3) {
            if (e3 !== pe) throw e3;
            this.readInvalidTemplateToken();
          }
          this.inTemplateElement = false;
        }, ce.invalidStringToken = function(e3, t3) {
          if (this.inTemplateElement && this.options.ecmaVersion >= 9) throw pe;
          this.raise(e3, t3);
        }, ce.readTmplToken = function() {
          for (var e3 = "", t3 = this.pos; ; ) {
            this.pos >= this.input.length && this.raise(this.start, "Unterminated template");
            var i2 = this.input.charCodeAt(this.pos);
            if (96 === i2 || 36 === i2 && 123 === this.input.charCodeAt(this.pos + 1)) return this.pos !== this.start || this.type !== f.template && this.type !== f.invalidTemplate ? (e3 += this.input.slice(t3, this.pos), this.finishToken(f.template, e3)) : 36 === i2 ? (this.pos += 2, this.finishToken(f.dollarBraceL)) : (++this.pos, this.finishToken(f.backQuote));
            if (92 === i2) e3 += this.input.slice(t3, this.pos), e3 += this.readEscapedChar(true), t3 = this.pos;
            else if (isNewLine(i2)) {
              switch (e3 += this.input.slice(t3, this.pos), ++this.pos, i2) {
                case 13:
                  10 === this.input.charCodeAt(this.pos) && ++this.pos;
                case 10:
                  e3 += "\n";
                  break;
                default:
                  e3 += String.fromCharCode(i2);
              }
              this.options.locations && (++this.curLine, this.lineStart = this.pos), t3 = this.pos;
            } else ++this.pos;
          }
        }, ce.readInvalidTemplateToken = function() {
          for (; this.pos < this.input.length; this.pos++) switch (this.input[this.pos]) {
            case "\\":
              ++this.pos;
              break;
            case "$":
              if ("{" !== this.input[this.pos + 1]) break;
            case "`":
              return this.finishToken(f.invalidTemplate, this.input.slice(this.start, this.pos));
            case "\r":
              "\n" === this.input[this.pos + 1] && ++this.pos;
            case "\n":
            case "\u2028":
            case "\u2029":
              ++this.curLine, this.lineStart = this.pos + 1;
          }
          this.raise(this.start, "Unterminated template");
        }, ce.readEscapedChar = function(e3) {
          var t3 = this.input.charCodeAt(++this.pos);
          switch (++this.pos, t3) {
            case 110:
              return "\n";
            case 114:
              return "\r";
            case 120:
              return String.fromCharCode(this.readHexChar(2));
            case 117:
              return codePointToString(this.readCodePoint());
            case 116:
              return "	";
            case 98:
              return "\b";
            case 118:
              return "\v";
            case 102:
              return "\f";
            case 13:
              10 === this.input.charCodeAt(this.pos) && ++this.pos;
            case 10:
              return this.options.locations && (this.lineStart = this.pos, ++this.curLine), "";
            case 56:
            case 57:
              if (this.strict && this.invalidStringToken(this.pos - 1, "Invalid escape sequence"), e3) {
                var i2 = this.pos - 1;
                this.invalidStringToken(i2, "Invalid escape sequence in template string");
              }
            default:
              if (t3 >= 48 && t3 <= 55) {
                var s2 = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0], r2 = parseInt(s2, 8);
                return r2 > 255 && (s2 = s2.slice(0, -1), r2 = parseInt(s2, 8)), this.pos += s2.length - 1, t3 = this.input.charCodeAt(this.pos), "0" === s2 && 56 !== t3 && 57 !== t3 || !this.strict && !e3 || this.invalidStringToken(this.pos - 1 - s2.length, e3 ? "Octal literal in template string" : "Octal literal in strict mode"), String.fromCharCode(r2);
              }
              return isNewLine(t3) ? (this.options.locations && (this.lineStart = this.pos, ++this.curLine), "") : String.fromCharCode(t3);
          }
        }, ce.readHexChar = function(e3) {
          var t3 = this.pos, i2 = this.readInt(16, e3);
          return null === i2 && this.invalidStringToken(t3, "Bad character escape sequence"), i2;
        }, ce.readWord1 = function() {
          this.containsEsc = false;
          for (var e3 = "", t3 = true, i2 = this.pos, s2 = this.options.ecmaVersion >= 6; this.pos < this.input.length; ) {
            var r2 = this.fullCharCodeAtPos();
            if (isIdentifierChar(r2, s2)) this.pos += r2 <= 65535 ? 1 : 2;
            else {
              if (92 !== r2) break;
              this.containsEsc = true, e3 += this.input.slice(i2, this.pos);
              var n2 = this.pos;
              117 !== this.input.charCodeAt(++this.pos) && this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"), ++this.pos;
              var a2 = this.readCodePoint();
              (t3 ? isIdentifierStart : isIdentifierChar)(a2, s2) || this.invalidStringToken(n2, "Invalid Unicode escape"), e3 += codePointToString(a2), i2 = this.pos;
            }
            t3 = false;
          }
          return e3 + this.input.slice(i2, this.pos);
        }, ce.readWord = function() {
          var e3 = this.readWord1(), t3 = f.name;
          return this.keywords.test(e3) && (t3 = d[e3]), this.finishToken(t3, e3);
        };
        acorn_Parser.acorn = { Parser: acorn_Parser, version: "8.15.0", defaultOptions: I, Position: acorn_Position, SourceLocation: acorn_SourceLocation, getLineInfo, Node: acorn_Node, TokenType: acorn_TokenType, tokTypes: f, keywordTypes: d, TokContext: acorn_TokContext, tokContexts: F, isIdentifierChar, isIdentifierStart, Token: acorn_Token, isNewLine, lineBreak: m, lineBreakG: g, nonASCIIwhitespace: x };
        const le = require("node:module"), ue = require("node:fs");
        String.fromCharCode;
        const de = /\/$|\/\?|\/#/, fe = /^\.?\//;
        function hasTrailingSlash(e3 = "", t3) {
          return t3 ? de.test(e3) : e3.endsWith("/");
        }
        function withTrailingSlash(e3 = "", t3) {
          if (!t3) return e3.endsWith("/") ? e3 : e3 + "/";
          if (hasTrailingSlash(e3, true)) return e3 || "/";
          let i2 = e3, s2 = "";
          const r2 = e3.indexOf("#");
          if (-1 !== r2 && (i2 = e3.slice(0, r2), s2 = e3.slice(r2), !i2)) return s2;
          const [n2, ...a2] = i2.split("?");
          return n2 + "/" + (a2.length > 0 ? `?${a2.join("?")}` : "") + s2;
        }
        function isNonEmptyURL(e3) {
          return e3 && "/" !== e3;
        }
        function dist_joinURL(e3, ...t3) {
          let i2 = e3 || "";
          for (const e4 of t3.filter((e5) => isNonEmptyURL(e5))) if (i2) {
            const t4 = e4.replace(fe, "");
            i2 = withTrailingSlash(i2) + t4;
          } else i2 = e4;
          return i2;
        }
        /* @__PURE__ */ Symbol.for("ufo:protocolRelative");
        const me = /^[A-Za-z]:\//;
        function pathe_M_eThtNZ_normalizeWindowsPath(e3 = "") {
          return e3 ? e3.replace(/\\/g, "/").replace(me, (e4) => e4.toUpperCase()) : e3;
        }
        const ge = /^[/\\]{2}/, xe = /^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Za-z]:[/\\]/, ve = /^[A-Za-z]:$/, ye = /.(\.[^./]+|\.)$/, pathe_M_eThtNZ_normalize = function(e3) {
          if (0 === e3.length) return ".";
          const t3 = (e3 = pathe_M_eThtNZ_normalizeWindowsPath(e3)).match(ge), i2 = isAbsolute(e3), s2 = "/" === e3[e3.length - 1];
          return 0 === (e3 = normalizeString(e3, !i2)).length ? i2 ? "/" : s2 ? "./" : "." : (s2 && (e3 += "/"), ve.test(e3) && (e3 += "/"), t3 ? i2 ? `//${e3}` : `//./${e3}` : i2 && !isAbsolute(e3) ? `/${e3}` : e3);
        }, pathe_M_eThtNZ_join = function(...e3) {
          let t3 = "";
          for (const i2 of e3) if (i2) if (t3.length > 0) {
            const e4 = "/" === t3[t3.length - 1], s2 = "/" === i2[0];
            t3 += e4 && s2 ? i2.slice(1) : e4 || s2 ? i2 : `/${i2}`;
          } else t3 += i2;
          return pathe_M_eThtNZ_normalize(t3);
        };
        function pathe_M_eThtNZ_cwd() {
          return "undefined" != typeof process && "function" == typeof process.cwd ? process.cwd().replace(/\\/g, "/") : "/";
        }
        const pathe_M_eThtNZ_resolve = function(...e3) {
          let t3 = "", i2 = false;
          for (let s2 = (e3 = e3.map((e4) => pathe_M_eThtNZ_normalizeWindowsPath(e4))).length - 1; s2 >= -1 && !i2; s2--) {
            const r2 = s2 >= 0 ? e3[s2] : pathe_M_eThtNZ_cwd();
            r2 && 0 !== r2.length && (t3 = `${r2}/${t3}`, i2 = isAbsolute(r2));
          }
          return t3 = normalizeString(t3, !i2), i2 && !isAbsolute(t3) ? `/${t3}` : t3.length > 0 ? t3 : ".";
        };
        function normalizeString(e3, t3) {
          let i2 = "", s2 = 0, r2 = -1, n2 = 0, a2 = null;
          for (let o2 = 0; o2 <= e3.length; ++o2) {
            if (o2 < e3.length) a2 = e3[o2];
            else {
              if ("/" === a2) break;
              a2 = "/";
            }
            if ("/" === a2) {
              if (r2 === o2 - 1 || 1 === n2) ;
              else if (2 === n2) {
                if (i2.length < 2 || 2 !== s2 || "." !== i2[i2.length - 1] || "." !== i2[i2.length - 2]) {
                  if (i2.length > 2) {
                    const e4 = i2.lastIndexOf("/");
                    -1 === e4 ? (i2 = "", s2 = 0) : (i2 = i2.slice(0, e4), s2 = i2.length - 1 - i2.lastIndexOf("/")), r2 = o2, n2 = 0;
                    continue;
                  }
                  if (i2.length > 0) {
                    i2 = "", s2 = 0, r2 = o2, n2 = 0;
                    continue;
                  }
                }
                t3 && (i2 += i2.length > 0 ? "/.." : "..", s2 = 2);
              } else i2.length > 0 ? i2 += `/${e3.slice(r2 + 1, o2)}` : i2 = e3.slice(r2 + 1, o2), s2 = o2 - r2 - 1;
              r2 = o2, n2 = 0;
            } else "." === a2 && -1 !== n2 ? ++n2 : n2 = -1;
          }
          return i2;
        }
        const isAbsolute = function(e3) {
          return xe.test(e3);
        }, extname = function(e3) {
          if (".." === e3) return "";
          const t3 = ye.exec(pathe_M_eThtNZ_normalizeWindowsPath(e3));
          return t3 && t3[1] || "";
        }, pathe_M_eThtNZ_dirname = function(e3) {
          const t3 = pathe_M_eThtNZ_normalizeWindowsPath(e3).replace(/\/$/, "").split("/").slice(0, -1);
          return 1 === t3.length && ve.test(t3[0]) && (t3[0] += "/"), t3.join("/") || (isAbsolute(e3) ? "/" : ".");
        }, basename = function(e3, t3) {
          const i2 = pathe_M_eThtNZ_normalizeWindowsPath(e3).split("/");
          let s2 = "";
          for (let e4 = i2.length - 1; e4 >= 0; e4--) {
            const t4 = i2[e4];
            if (t4) {
              s2 = t4;
              break;
            }
          }
          return t3 && s2.endsWith(t3) ? s2.slice(0, -t3.length) : s2;
        }, _e = require("node:url"), Ee = require("node:assert"), be = require("node:process"), Se = require("node:path"), ke = require("node:v8"), we = require("node:util"), Ie = new Set(le.builtinModules);
        function normalizeSlash(e3) {
          return e3.replace(/\\/g, "/");
        }
        const Ce = {}.hasOwnProperty, Re = /^([A-Z][a-z\d]*)+$/, Pe = /* @__PURE__ */ new Set(["string", "function", "number", "object", "Function", "Object", "boolean", "bigint", "symbol"]), Te = {};
        function formatList(e3, t3 = "and") {
          return e3.length < 3 ? e3.join(` ${t3} `) : `${e3.slice(0, -1).join(", ")}, ${t3} ${e3[e3.length - 1]}`;
        }
        const Ae = /* @__PURE__ */ new Map();
        let Ne;
        function createError(e3, t3, i2) {
          return Ae.set(e3, t3), /* @__PURE__ */ (function(e4, t4) {
            return NodeError;
            function NodeError(...i3) {
              const s2 = Error.stackTraceLimit;
              isErrorStackTraceLimitWritable() && (Error.stackTraceLimit = 0);
              const r2 = new e4();
              isErrorStackTraceLimitWritable() && (Error.stackTraceLimit = s2);
              const n2 = (function(e5, t5, i4) {
                const s3 = Ae.get(e5);
                if (Ee(void 0 !== s3, "expected `message` to be found"), "function" == typeof s3) return Ee(s3.length <= t5.length, `Code: ${e5}; The provided arguments length (${t5.length}) does not match the required ones (${s3.length}).`), Reflect.apply(s3, i4, t5);
                const r3 = /%[dfijoOs]/g;
                let n3 = 0;
                for (; null !== r3.exec(s3); ) n3++;
                return Ee(n3 === t5.length, `Code: ${e5}; The provided arguments length (${t5.length}) does not match the required ones (${n3}).`), 0 === t5.length ? s3 : (t5.unshift(s3), Reflect.apply(we.format, null, t5));
              })(t4, i3, r2);
              return Object.defineProperties(r2, { message: { value: n2, enumerable: false, writable: true, configurable: true }, toString: { value() {
                return `${this.name} [${t4}]: ${this.message}`;
              }, enumerable: false, writable: true, configurable: true } }), Le(r2), r2.code = t4, r2;
            }
          })(i2, e3);
        }
        function isErrorStackTraceLimitWritable() {
          try {
            if (ke.startupSnapshot.isBuildingSnapshot()) return false;
          } catch {
          }
          const e3 = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit");
          return void 0 === e3 ? Object.isExtensible(Error) : Ce.call(e3, "writable") && void 0 !== e3.writable ? e3.writable : void 0 !== e3.set;
        }
        Te.ERR_INVALID_ARG_TYPE = createError("ERR_INVALID_ARG_TYPE", (e3, t3, i2) => {
          Ee("string" == typeof e3, "'name' must be a string"), Array.isArray(t3) || (t3 = [t3]);
          let s2 = "The ";
          if (e3.endsWith(" argument")) s2 += `${e3} `;
          else {
            const t4 = e3.includes(".") ? "property" : "argument";
            s2 += `"${e3}" ${t4} `;
          }
          s2 += "must be ";
          const r2 = [], n2 = [], a2 = [];
          for (const e4 of t3) Ee("string" == typeof e4, "All expected entries have to be of type string"), Pe.has(e4) ? r2.push(e4.toLowerCase()) : null === Re.exec(e4) ? (Ee("object" !== e4, 'The value "object" should be written as "Object"'), a2.push(e4)) : n2.push(e4);
          if (n2.length > 0) {
            const e4 = r2.indexOf("object");
            -1 !== e4 && (r2.slice(e4, 1), n2.push("Object"));
          }
          return r2.length > 0 && (s2 += `${r2.length > 1 ? "one of type" : "of type"} ${formatList(r2, "or")}`, (n2.length > 0 || a2.length > 0) && (s2 += " or ")), n2.length > 0 && (s2 += `an instance of ${formatList(n2, "or")}`, a2.length > 0 && (s2 += " or ")), a2.length > 0 && (a2.length > 1 ? s2 += `one of ${formatList(a2, "or")}` : (a2[0].toLowerCase() !== a2[0] && (s2 += "an "), s2 += `${a2[0]}`)), s2 += `. Received ${(function(e4) {
            if (null == e4) return String(e4);
            if ("function" == typeof e4 && e4.name) return `function ${e4.name}`;
            if ("object" == typeof e4) return e4.constructor && e4.constructor.name ? `an instance of ${e4.constructor.name}` : `${(0, we.inspect)(e4, { depth: -1 })}`;
            let t4 = (0, we.inspect)(e4, { colors: false });
            t4.length > 28 && (t4 = `${t4.slice(0, 25)}...`);
            return `type ${typeof e4} (${t4})`;
          })(i2)}`, s2;
        }, TypeError), Te.ERR_INVALID_MODULE_SPECIFIER = createError("ERR_INVALID_MODULE_SPECIFIER", (e3, t3, i2 = void 0) => `Invalid module "${e3}" ${t3}${i2 ? ` imported from ${i2}` : ""}`, TypeError), Te.ERR_INVALID_PACKAGE_CONFIG = createError("ERR_INVALID_PACKAGE_CONFIG", (e3, t3, i2) => `Invalid package config ${e3}${t3 ? ` while importing ${t3}` : ""}${i2 ? `. ${i2}` : ""}`, Error), Te.ERR_INVALID_PACKAGE_TARGET = createError("ERR_INVALID_PACKAGE_TARGET", (e3, t3, i2, s2 = false, r2 = void 0) => {
          const n2 = "string" == typeof i2 && !s2 && i2.length > 0 && !i2.startsWith("./");
          return "." === t3 ? (Ee(false === s2), `Invalid "exports" main target ${JSON.stringify(i2)} defined in the package config ${e3}package.json${r2 ? ` imported from ${r2}` : ""}${n2 ? '; targets must start with "./"' : ""}`) : `Invalid "${s2 ? "imports" : "exports"}" target ${JSON.stringify(i2)} defined for '${t3}' in the package config ${e3}package.json${r2 ? ` imported from ${r2}` : ""}${n2 ? '; targets must start with "./"' : ""}`;
        }, Error), Te.ERR_MODULE_NOT_FOUND = createError("ERR_MODULE_NOT_FOUND", (e3, t3, i2 = false) => `Cannot find ${i2 ? "module" : "package"} '${e3}' imported from ${t3}`, Error), Te.ERR_NETWORK_IMPORT_DISALLOWED = createError("ERR_NETWORK_IMPORT_DISALLOWED", "import of '%s' by %s is not supported: %s", Error), Te.ERR_PACKAGE_IMPORT_NOT_DEFINED = createError("ERR_PACKAGE_IMPORT_NOT_DEFINED", (e3, t3, i2) => `Package import specifier "${e3}" is not defined${t3 ? ` in package ${t3}package.json` : ""} imported from ${i2}`, TypeError), Te.ERR_PACKAGE_PATH_NOT_EXPORTED = createError("ERR_PACKAGE_PATH_NOT_EXPORTED", (e3, t3, i2 = void 0) => "." === t3 ? `No "exports" main defined in ${e3}package.json${i2 ? ` imported from ${i2}` : ""}` : `Package subpath '${t3}' is not defined by "exports" in ${e3}package.json${i2 ? ` imported from ${i2}` : ""}`, Error), Te.ERR_UNSUPPORTED_DIR_IMPORT = createError("ERR_UNSUPPORTED_DIR_IMPORT", "Directory import '%s' is not supported resolving ES modules imported from %s", Error), Te.ERR_UNSUPPORTED_RESOLVE_REQUEST = createError("ERR_UNSUPPORTED_RESOLVE_REQUEST", 'Failed to resolve module specifier "%s" from "%s": Invalid relative URL or base scheme is not hierarchical.', TypeError), Te.ERR_UNKNOWN_FILE_EXTENSION = createError("ERR_UNKNOWN_FILE_EXTENSION", (e3, t3) => `Unknown file extension "${e3}" for ${t3}`, TypeError), Te.ERR_INVALID_ARG_VALUE = createError("ERR_INVALID_ARG_VALUE", (e3, t3, i2 = "is invalid") => {
          let s2 = (0, we.inspect)(t3);
          s2.length > 128 && (s2 = `${s2.slice(0, 128)}...`);
          return `The ${e3.includes(".") ? "property" : "argument"} '${e3}' ${i2}. Received ${s2}`;
        }, TypeError);
        const Le = (function(e3) {
          const t3 = "__node_internal_" + e3.name;
          return Object.defineProperty(e3, "name", { value: t3 }), e3;
        })(function(e3) {
          const t3 = isErrorStackTraceLimitWritable();
          return t3 && (Ne = Error.stackTraceLimit, Error.stackTraceLimit = Number.POSITIVE_INFINITY), Error.captureStackTrace(e3), t3 && (Error.stackTraceLimit = Ne), e3;
        });
        const Oe = {}.hasOwnProperty, { ERR_INVALID_PACKAGE_CONFIG: De } = Te, Ve = /* @__PURE__ */ new Map();
        function read(e3, { base: t3, specifier: i2 }) {
          const s2 = Ve.get(e3);
          if (s2) return s2;
          let r2;
          try {
            r2 = ue.readFileSync(Se.toNamespacedPath(e3), "utf8");
          } catch (e4) {
            const t4 = e4;
            if ("ENOENT" !== t4.code) throw t4;
          }
          const n2 = { exists: false, pjsonPath: e3, main: void 0, name: void 0, type: "none", exports: void 0, imports: void 0 };
          if (void 0 !== r2) {
            let s3;
            try {
              s3 = JSON.parse(r2);
            } catch (s4) {
              const r3 = s4, n3 = new De(e3, (t3 ? `"${i2}" from ` : "") + (0, _e.fileURLToPath)(t3 || i2), r3.message);
              throw n3.cause = r3, n3;
            }
            n2.exists = true, Oe.call(s3, "name") && "string" == typeof s3.name && (n2.name = s3.name), Oe.call(s3, "main") && "string" == typeof s3.main && (n2.main = s3.main), Oe.call(s3, "exports") && (n2.exports = s3.exports), Oe.call(s3, "imports") && (n2.imports = s3.imports), !Oe.call(s3, "type") || "commonjs" !== s3.type && "module" !== s3.type || (n2.type = s3.type);
          }
          return Ve.set(e3, n2), n2;
        }
        function getPackageScopeConfig(e3) {
          let t3 = new URL("package.json", e3);
          for (; ; ) {
            if (t3.pathname.endsWith("node_modules/package.json")) break;
            const i2 = read((0, _e.fileURLToPath)(t3), { specifier: e3 });
            if (i2.exists) return i2;
            const s2 = t3;
            if (t3 = new URL("../package.json", t3), t3.pathname === s2.pathname) break;
          }
          return { pjsonPath: (0, _e.fileURLToPath)(t3), exists: false, type: "none" };
        }
        function getPackageType(e3) {
          return getPackageScopeConfig(e3).type;
        }
        const { ERR_UNKNOWN_FILE_EXTENSION: Ue } = Te, Me = {}.hasOwnProperty, je = { __proto__: null, ".cjs": "commonjs", ".js": "module", ".json": "json", ".mjs": "module" };
        const Fe = { __proto__: null, "data:": function(e3) {
          const { 1: t3 } = /^([^/]+\/[^;,]+)[^,]*?(;base64)?,/.exec(e3.pathname) || [null, null, null];
          return (function(e4) {
            return e4 && /\s*(text|application)\/javascript\s*(;\s*charset=utf-?8\s*)?/i.test(e4) ? "module" : "application/json" === e4 ? "json" : null;
          })(t3);
        }, "file:": function(e3, t3, i2) {
          const s2 = (function(e4) {
            const t4 = e4.pathname;
            let i3 = t4.length;
            for (; i3--; ) {
              const e5 = t4.codePointAt(i3);
              if (47 === e5) return "";
              if (46 === e5) return 47 === t4.codePointAt(i3 - 1) ? "" : t4.slice(i3);
            }
            return "";
          })(e3);
          if (".js" === s2) {
            const t4 = getPackageType(e3);
            return "none" !== t4 ? t4 : "commonjs";
          }
          if ("" === s2) {
            const t4 = getPackageType(e3);
            return "none" === t4 || "commonjs" === t4 ? "commonjs" : "module";
          }
          const r2 = je[s2];
          if (r2) return r2;
          if (i2) return;
          const n2 = (0, _e.fileURLToPath)(e3);
          throw new Ue(s2, n2);
        }, "http:": getHttpProtocolModuleFormat, "https:": getHttpProtocolModuleFormat, "node:": () => "builtin" };
        function getHttpProtocolModuleFormat() {
        }
        const Be = RegExp.prototype[Symbol.replace], { ERR_INVALID_MODULE_SPECIFIER: $e, ERR_INVALID_PACKAGE_CONFIG: qe, ERR_INVALID_PACKAGE_TARGET: We, ERR_MODULE_NOT_FOUND: Ge, ERR_PACKAGE_IMPORT_NOT_DEFINED: He, ERR_PACKAGE_PATH_NOT_EXPORTED: Ke, ERR_UNSUPPORTED_DIR_IMPORT: ze, ERR_UNSUPPORTED_RESOLVE_REQUEST: Je } = Te, Ye = {}.hasOwnProperty, Qe = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))?(\\|\/|$)/i, Ze = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\|\/|$)/i, Xe = /^\.|%|\\/, et = /\*/g, tt = /%2f|%5c/i, it = /* @__PURE__ */ new Set(), st = /[/\\]{2}/;
        function emitInvalidSegmentDeprecation(e3, t3, i2, s2, r2, n2, a2) {
          if (be.noDeprecation) return;
          const o2 = (0, _e.fileURLToPath)(s2), h2 = null !== st.exec(a2 ? e3 : t3);
          be.emitWarning(`Use of deprecated ${h2 ? "double slash" : "leading or trailing slash matching"} resolving "${e3}" for module request "${t3}" ${t3 === i2 ? "" : `matched to "${i2}" `}in the "${r2 ? "imports" : "exports"}" field module resolution of the package at ${o2}${n2 ? ` imported from ${(0, _e.fileURLToPath)(n2)}` : ""}.`, "DeprecationWarning", "DEP0166");
        }
        function emitLegacyIndexDeprecation(e3, t3, i2, s2) {
          if (be.noDeprecation) return;
          const r2 = (function(e4, t4) {
            const i3 = e4.protocol;
            return Me.call(Fe, i3) && Fe[i3](e4, t4, true) || null;
          })(e3, { parentURL: i2.href });
          if ("module" !== r2) return;
          const n2 = (0, _e.fileURLToPath)(e3.href), a2 = (0, _e.fileURLToPath)(new _e.URL(".", t3)), o2 = (0, _e.fileURLToPath)(i2);
          s2 ? Se.resolve(a2, s2) !== n2 && be.emitWarning(`Package ${a2} has a "main" field set to "${s2}", excluding the full filename and extension to the resolved file at "${n2.slice(a2.length)}", imported from ${o2}.
 Automatic extension resolution of the "main" field is deprecated for ES modules.`, "DeprecationWarning", "DEP0151") : be.emitWarning(`No "main" or "exports" field defined in the package.json for ${a2} resolving the main entry point "${n2.slice(a2.length)}", imported from ${o2}.
Default "index" lookups for the main are deprecated for ES modules.`, "DeprecationWarning", "DEP0151");
        }
        function tryStatSync(e3) {
          try {
            return (0, ue.statSync)(e3);
          } catch {
          }
        }
        function fileExists(e3) {
          const t3 = (0, ue.statSync)(e3, { throwIfNoEntry: false }), i2 = t3 ? t3.isFile() : void 0;
          return null != i2 && i2;
        }
        function legacyMainResolve(e3, t3, i2) {
          let s2;
          if (void 0 !== t3.main) {
            if (s2 = new _e.URL(t3.main, e3), fileExists(s2)) return s2;
            const r3 = [`./${t3.main}.js`, `./${t3.main}.json`, `./${t3.main}.node`, `./${t3.main}/index.js`, `./${t3.main}/index.json`, `./${t3.main}/index.node`];
            let n3 = -1;
            for (; ++n3 < r3.length && (s2 = new _e.URL(r3[n3], e3), !fileExists(s2)); ) s2 = void 0;
            if (s2) return emitLegacyIndexDeprecation(s2, e3, i2, t3.main), s2;
          }
          const r2 = ["./index.js", "./index.json", "./index.node"];
          let n2 = -1;
          for (; ++n2 < r2.length && (s2 = new _e.URL(r2[n2], e3), !fileExists(s2)); ) s2 = void 0;
          if (s2) return emitLegacyIndexDeprecation(s2, e3, i2, t3.main), s2;
          throw new Ge((0, _e.fileURLToPath)(new _e.URL(".", e3)), (0, _e.fileURLToPath)(i2));
        }
        function exportsNotFound(e3, t3, i2) {
          return new Ke((0, _e.fileURLToPath)(new _e.URL(".", t3)), e3, i2 && (0, _e.fileURLToPath)(i2));
        }
        function invalidPackageTarget(e3, t3, i2, s2, r2) {
          return t3 = "object" == typeof t3 && null !== t3 ? JSON.stringify(t3, null, "") : `${t3}`, new We((0, _e.fileURLToPath)(new _e.URL(".", i2)), e3, t3, s2, r2 && (0, _e.fileURLToPath)(r2));
        }
        function resolvePackageTargetString(e3, t3, i2, s2, r2, n2, a2, o2, h2) {
          if ("" !== t3 && !n2 && "/" !== e3[e3.length - 1]) throw invalidPackageTarget(i2, e3, s2, a2, r2);
          if (!e3.startsWith("./")) {
            if (a2 && !e3.startsWith("../") && !e3.startsWith("/")) {
              let i3 = false;
              try {
                new _e.URL(e3), i3 = true;
              } catch {
              }
              if (!i3) {
                return packageResolve(n2 ? Be.call(et, e3, () => t3) : e3 + t3, s2, h2);
              }
            }
            throw invalidPackageTarget(i2, e3, s2, a2, r2);
          }
          if (null !== Qe.exec(e3.slice(2))) {
            if (null !== Ze.exec(e3.slice(2))) throw invalidPackageTarget(i2, e3, s2, a2, r2);
            if (!o2) {
              const o3 = n2 ? i2.replace("*", () => t3) : i2 + t3;
              emitInvalidSegmentDeprecation(n2 ? Be.call(et, e3, () => t3) : e3, o3, i2, s2, a2, r2, true);
            }
          }
          const c2 = new _e.URL(e3, s2), p2 = c2.pathname, l2 = new _e.URL(".", s2).pathname;
          if (!p2.startsWith(l2)) throw invalidPackageTarget(i2, e3, s2, a2, r2);
          if ("" === t3) return c2;
          if (null !== Qe.exec(t3)) {
            const h3 = n2 ? i2.replace("*", () => t3) : i2 + t3;
            if (null === Ze.exec(t3)) {
              if (!o2) {
                emitInvalidSegmentDeprecation(n2 ? Be.call(et, e3, () => t3) : e3, h3, i2, s2, a2, r2, false);
              }
            } else !(function(e4, t4, i3, s3, r3) {
              const n3 = `request is not a valid match in pattern "${t4}" for the "${s3 ? "imports" : "exports"}" resolution of ${(0, _e.fileURLToPath)(i3)}`;
              throw new $e(e4, n3, r3 && (0, _e.fileURLToPath)(r3));
            })(h3, i2, s2, a2, r2);
          }
          return n2 ? new _e.URL(Be.call(et, c2.href, () => t3)) : new _e.URL(t3, c2);
        }
        function isArrayIndex(e3) {
          const t3 = Number(e3);
          return `${t3}` === e3 && (t3 >= 0 && t3 < 4294967295);
        }
        function resolvePackageTarget(e3, t3, i2, s2, r2, n2, a2, o2, h2) {
          if ("string" == typeof t3) return resolvePackageTargetString(t3, i2, s2, e3, r2, n2, a2, o2, h2);
          if (Array.isArray(t3)) {
            const c2 = t3;
            if (0 === c2.length) return null;
            let p2, l2 = -1;
            for (; ++l2 < c2.length; ) {
              const t4 = c2[l2];
              let u2;
              try {
                u2 = resolvePackageTarget(e3, t4, i2, s2, r2, n2, a2, o2, h2);
              } catch (e4) {
                if (p2 = e4, "ERR_INVALID_PACKAGE_TARGET" === e4.code) continue;
                throw e4;
              }
              if (void 0 !== u2) {
                if (null !== u2) return u2;
                p2 = null;
              }
            }
            if (null == p2) return null;
            throw p2;
          }
          if ("object" == typeof t3 && null !== t3) {
            const c2 = Object.getOwnPropertyNames(t3);
            let p2 = -1;
            for (; ++p2 < c2.length; ) {
              if (isArrayIndex(c2[p2])) throw new qe((0, _e.fileURLToPath)(e3), r2, '"exports" cannot contain numeric property keys.');
            }
            for (p2 = -1; ++p2 < c2.length; ) {
              const l2 = c2[p2];
              if ("default" === l2 || h2 && h2.has(l2)) {
                const c3 = resolvePackageTarget(e3, t3[l2], i2, s2, r2, n2, a2, o2, h2);
                if (void 0 === c3) continue;
                return c3;
              }
            }
            return null;
          }
          if (null === t3) return null;
          throw invalidPackageTarget(s2, t3, e3, a2, r2);
        }
        function emitTrailingSlashPatternDeprecation(e3, t3, i2) {
          if (be.noDeprecation) return;
          const s2 = (0, _e.fileURLToPath)(t3);
          it.has(s2 + "|" + e3) || (it.add(s2 + "|" + e3), be.emitWarning(`Use of deprecated trailing slash pattern mapping "${e3}" in the "exports" field module resolution of the package at ${s2}${i2 ? ` imported from ${(0, _e.fileURLToPath)(i2)}` : ""}. Mapping specifiers ending in "/" is no longer supported.`, "DeprecationWarning", "DEP0155"));
        }
        function packageExportsResolve(e3, t3, i2, s2, r2) {
          let n2 = i2.exports;
          if ((function(e4, t4, i3) {
            if ("string" == typeof e4 || Array.isArray(e4)) return true;
            if ("object" != typeof e4 || null === e4) return false;
            const s3 = Object.getOwnPropertyNames(e4);
            let r3 = false, n3 = 0, a3 = -1;
            for (; ++a3 < s3.length; ) {
              const e5 = s3[a3], o3 = "" === e5 || "." !== e5[0];
              if (0 === n3++) r3 = o3;
              else if (r3 !== o3) throw new qe((0, _e.fileURLToPath)(t4), i3, `"exports" cannot contain some keys starting with '.' and some not. The exports object must either be an object of package subpath keys or an object of main entry condition name keys only.`);
            }
            return r3;
          })(n2, e3, s2) && (n2 = { ".": n2 }), Ye.call(n2, t3) && !t3.includes("*") && !t3.endsWith("/")) {
            const i3 = resolvePackageTarget(e3, n2[t3], "", t3, s2, false, false, false, r2);
            if (null == i3) throw exportsNotFound(t3, e3, s2);
            return i3;
          }
          let a2 = "", o2 = "";
          const h2 = Object.getOwnPropertyNames(n2);
          let c2 = -1;
          for (; ++c2 < h2.length; ) {
            const i3 = h2[c2], r3 = i3.indexOf("*");
            if (-1 !== r3 && t3.startsWith(i3.slice(0, r3))) {
              t3.endsWith("/") && emitTrailingSlashPatternDeprecation(t3, e3, s2);
              const n3 = i3.slice(r3 + 1);
              t3.length >= i3.length && t3.endsWith(n3) && 1 === patternKeyCompare(a2, i3) && i3.lastIndexOf("*") === r3 && (a2 = i3, o2 = t3.slice(r3, t3.length - n3.length));
            }
          }
          if (a2) {
            const i3 = resolvePackageTarget(e3, n2[a2], o2, a2, s2, true, false, t3.endsWith("/"), r2);
            if (null == i3) throw exportsNotFound(t3, e3, s2);
            return i3;
          }
          throw exportsNotFound(t3, e3, s2);
        }
        function patternKeyCompare(e3, t3) {
          const i2 = e3.indexOf("*"), s2 = t3.indexOf("*"), r2 = -1 === i2 ? e3.length : i2 + 1, n2 = -1 === s2 ? t3.length : s2 + 1;
          return r2 > n2 ? -1 : n2 > r2 || -1 === i2 ? 1 : -1 === s2 || e3.length > t3.length ? -1 : t3.length > e3.length ? 1 : 0;
        }
        function packageImportsResolve(e3, t3, i2) {
          if ("#" === e3 || e3.startsWith("#/") || e3.endsWith("/")) {
            throw new $e(e3, "is not a valid internal imports specifier name", (0, _e.fileURLToPath)(t3));
          }
          let s2;
          const r2 = getPackageScopeConfig(t3);
          if (r2.exists) {
            s2 = (0, _e.pathToFileURL)(r2.pjsonPath);
            const n2 = r2.imports;
            if (n2) if (Ye.call(n2, e3) && !e3.includes("*")) {
              const r3 = resolvePackageTarget(s2, n2[e3], "", e3, t3, false, true, false, i2);
              if (null != r3) return r3;
            } else {
              let r3 = "", a2 = "";
              const o2 = Object.getOwnPropertyNames(n2);
              let h2 = -1;
              for (; ++h2 < o2.length; ) {
                const t4 = o2[h2], i3 = t4.indexOf("*");
                if (-1 !== i3 && e3.startsWith(t4.slice(0, -1))) {
                  const s3 = t4.slice(i3 + 1);
                  e3.length >= t4.length && e3.endsWith(s3) && 1 === patternKeyCompare(r3, t4) && t4.lastIndexOf("*") === i3 && (r3 = t4, a2 = e3.slice(i3, e3.length - s3.length));
                }
              }
              if (r3) {
                const e4 = resolvePackageTarget(s2, n2[r3], a2, r3, t3, true, true, false, i2);
                if (null != e4) return e4;
              }
            }
          }
          throw (function(e4, t4, i3) {
            return new He(e4, t4 && (0, _e.fileURLToPath)(new _e.URL(".", t4)), (0, _e.fileURLToPath)(i3));
          })(e3, s2, t3);
        }
        function packageResolve(e3, t3, i2) {
          if (le.builtinModules.includes(e3)) return new _e.URL("node:" + e3);
          const { packageName: s2, packageSubpath: r2, isScoped: n2 } = (function(e4, t4) {
            let i3 = e4.indexOf("/"), s3 = true, r3 = false;
            "@" === e4[0] && (r3 = true, -1 === i3 || 0 === e4.length ? s3 = false : i3 = e4.indexOf("/", i3 + 1));
            const n3 = -1 === i3 ? e4 : e4.slice(0, i3);
            if (null !== Xe.exec(n3) && (s3 = false), !s3) throw new $e(e4, "is not a valid package name", (0, _e.fileURLToPath)(t4));
            return { packageName: n3, packageSubpath: "." + (-1 === i3 ? "" : e4.slice(i3)), isScoped: r3 };
          })(e3, t3), a2 = getPackageScopeConfig(t3);
          if (a2.exists) {
            const e4 = (0, _e.pathToFileURL)(a2.pjsonPath);
            if (a2.name === s2 && void 0 !== a2.exports && null !== a2.exports) return packageExportsResolve(e4, r2, a2, t3, i2);
          }
          let o2, h2 = new _e.URL("./node_modules/" + s2 + "/package.json", t3), c2 = (0, _e.fileURLToPath)(h2);
          do {
            const a3 = tryStatSync(c2.slice(0, -13));
            if (!a3 || !a3.isDirectory()) {
              o2 = c2, h2 = new _e.URL((n2 ? "../../../../node_modules/" : "../../../node_modules/") + s2 + "/package.json", h2), c2 = (0, _e.fileURLToPath)(h2);
              continue;
            }
            const p2 = read(c2, { base: t3, specifier: e3 });
            return void 0 !== p2.exports && null !== p2.exports ? packageExportsResolve(h2, r2, p2, t3, i2) : "." === r2 ? legacyMainResolve(h2, p2, t3) : new _e.URL(r2, h2);
          } while (c2.length !== o2.length);
          throw new Ge(s2, (0, _e.fileURLToPath)(t3), false);
        }
        function moduleResolve(e3, t3, i2, s2) {
          const r2 = t3.protocol, n2 = "data:" === r2 || "http:" === r2 || "https:" === r2;
          let a2;
          if ((function(e4) {
            return "" !== e4 && ("/" === e4[0] || (function(e5) {
              if ("." === e5[0]) {
                if (1 === e5.length || "/" === e5[1]) return true;
                if ("." === e5[1] && (2 === e5.length || "/" === e5[2])) return true;
              }
              return false;
            })(e4));
          })(e3)) try {
            a2 = new _e.URL(e3, t3);
          } catch (i3) {
            const s3 = new Je(e3, t3);
            throw s3.cause = i3, s3;
          }
          else if ("file:" === r2 && "#" === e3[0]) a2 = packageImportsResolve(e3, t3, i2);
          else try {
            a2 = new _e.URL(e3);
          } catch (s3) {
            if (n2 && !le.builtinModules.includes(e3)) {
              const i3 = new Je(e3, t3);
              throw i3.cause = s3, i3;
            }
            a2 = packageResolve(e3, t3, i2);
          }
          return Ee(void 0 !== a2, "expected to be defined"), "file:" !== a2.protocol ? a2 : (function(e4, t4) {
            if (null !== tt.exec(e4.pathname)) throw new $e(e4.pathname, 'must not include encoded "/" or "\\" characters', (0, _e.fileURLToPath)(t4));
            let i3;
            try {
              i3 = (0, _e.fileURLToPath)(e4);
            } catch (i4) {
              const s4 = i4;
              throw Object.defineProperty(s4, "input", { value: String(e4) }), Object.defineProperty(s4, "module", { value: String(t4) }), s4;
            }
            const s3 = tryStatSync(i3.endsWith("/") ? i3.slice(-1) : i3);
            if (s3 && s3.isDirectory()) {
              const s4 = new ze(i3, (0, _e.fileURLToPath)(t4));
              throw s4.url = String(e4), s4;
            }
            if (!s3 || !s3.isFile()) {
              const s4 = new Ge(i3 || e4.pathname, t4 && (0, _e.fileURLToPath)(t4), true);
              throw s4.url = String(e4), s4;
            }
            {
              const t5 = (0, ue.realpathSync)(i3), { search: s4, hash: r3 } = e4;
              (e4 = (0, _e.pathToFileURL)(t5 + (i3.endsWith(Se.sep) ? "/" : ""))).search = s4, e4.hash = r3;
            }
            return e4;
          })(a2, t3);
        }
        function fileURLToPath(e3) {
          return "string" != typeof e3 || e3.startsWith("file://") ? normalizeSlash((0, _e.fileURLToPath)(e3)) : normalizeSlash(e3);
        }
        function pathToFileURL(e3) {
          return (0, _e.pathToFileURL)(fileURLToPath(e3)).toString();
        }
        const rt = /* @__PURE__ */ new Set(["node", "import"]), nt = [".mjs", ".cjs", ".js", ".json"], at = /* @__PURE__ */ new Set(["ERR_MODULE_NOT_FOUND", "ERR_UNSUPPORTED_DIR_IMPORT", "MODULE_NOT_FOUND", "ERR_PACKAGE_PATH_NOT_EXPORTED"]);
        function _tryModuleResolve(e3, t3, i2) {
          try {
            return moduleResolve(e3, t3, i2);
          } catch (e4) {
            if (!at.has(e4?.code)) throw e4;
          }
        }
        function _resolve(e3, t3 = {}) {
          if ("string" != typeof e3) {
            if (!(e3 instanceof URL)) throw new TypeError("input must be a `string` or `URL`");
            e3 = fileURLToPath(e3);
          }
          if (/(?:node|data|http|https):/.test(e3)) return e3;
          if (Ie.has(e3)) return "node:" + e3;
          if (e3.startsWith("file://") && (e3 = fileURLToPath(e3)), isAbsolute(e3)) try {
            if ((0, ue.statSync)(e3).isFile()) return pathToFileURL(e3);
          } catch (e4) {
            if ("ENOENT" !== e4?.code) throw e4;
          }
          const i2 = t3.conditions ? new Set(t3.conditions) : rt, s2 = (Array.isArray(t3.url) ? t3.url : [t3.url]).filter(Boolean).map((e4) => new URL((function(e5) {
            return "string" != typeof e5 && (e5 = e5.toString()), /(?:node|data|http|https|file):/.test(e5) ? e5 : Ie.has(e5) ? "node:" + e5 : "file://" + encodeURI(normalizeSlash(e5));
          })(e4.toString())));
          0 === s2.length && s2.push(new URL(pathToFileURL(process.cwd())));
          const r2 = [...s2];
          for (const e4 of s2) "file:" === e4.protocol && r2.push(new URL("./", e4), new URL(dist_joinURL(e4.pathname, "_index.js"), e4), new URL("node_modules", e4));
          let n2;
          for (const s3 of r2) {
            if (n2 = _tryModuleResolve(e3, s3, i2), n2) break;
            for (const r3 of ["", "/index"]) {
              for (const a2 of t3.extensions || nt) if (n2 = _tryModuleResolve(dist_joinURL(e3, r3) + a2, s3, i2), n2) break;
              if (n2) break;
            }
            if (n2) break;
          }
          if (!n2) {
            const t4 = new Error(`Cannot find module ${e3} imported from ${r2.join(", ")}`);
            throw t4.code = "ERR_MODULE_NOT_FOUND", t4;
          }
          return pathToFileURL(n2);
        }
        function resolveSync(e3, t3) {
          return _resolve(e3, t3);
        }
        function resolvePathSync(e3, t3) {
          return fileURLToPath(resolveSync(e3, t3));
        }
        const ot = /(?:[\s;]|^)(?:import[\s\w*,{}]*from|import\s*["'*{]|export\b\s*(?:[*{]|default|class|type|function|const|var|let|async function)|import\.meta\b)/m, ht = /\/\*.+?\*\/|\/\/.*(?=[nr])/g;
        function hasESMSyntax(e3, t3 = {}) {
          return t3.stripComments && (e3 = e3.replace(ht, "")), ot.test(e3);
        }
        function escapeStringRegexp(e3) {
          if ("string" != typeof e3) throw new TypeError("Expected a string");
          return e3.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
        }
        const ct = /* @__PURE__ */ new Set(["/", "\\", void 0]), pt = /* @__PURE__ */ Symbol.for("pathe:normalizedAlias"), lt = /[/\\]/;
        function normalizeAliases(e3) {
          if (e3[pt]) return e3;
          const t3 = Object.fromEntries(Object.entries(e3).sort(([e4], [t4]) => (function(e5, t5) {
            return t5.split("/").length - e5.split("/").length;
          })(e4, t4)));
          for (const e4 in t3) for (const i2 in t3) i2 === e4 || e4.startsWith(i2) || t3[e4]?.startsWith(i2) && ct.has(t3[e4][i2.length]) && (t3[e4] = t3[i2] + t3[e4].slice(i2.length));
          return Object.defineProperty(t3, pt, { value: true, enumerable: false }), t3;
        }
        function utils_hasTrailingSlash(e3 = "/") {
          const t3 = e3[e3.length - 1];
          return "/" === t3 || "\\" === t3;
        }
        var ut = { rE: "2.6.1" };
        const dt = require("node:crypto");
        var ft = __webpack_require__.n(dt);
        const mt = /* @__PURE__ */ Object.create(null), dist_i = (e3) => globalThis.process?.env || globalThis.Deno?.env.toObject() || globalThis.__env__ || (e3 ? mt : globalThis), gt = new Proxy(mt, { get: (e3, t3) => dist_i()[t3] ?? mt[t3], has: (e3, t3) => t3 in dist_i() || t3 in mt, set: (e3, t3, i2) => (dist_i(true)[t3] = i2, true), deleteProperty(e3, t3) {
          if (!t3) return false;
          return delete dist_i(true)[t3], true;
        }, ownKeys() {
          const e3 = dist_i(true);
          return Object.keys(e3);
        } }), xt = typeof process < "u" && process.env && process.env.NODE_ENV || "", vt = [["APPVEYOR"], ["AWS_AMPLIFY", "AWS_APP_ID", { ci: true }], ["AZURE_PIPELINES", "SYSTEM_TEAMFOUNDATIONCOLLECTIONURI"], ["AZURE_STATIC", "INPUT_AZURE_STATIC_WEB_APPS_API_TOKEN"], ["APPCIRCLE", "AC_APPCIRCLE"], ["BAMBOO", "bamboo_planKey"], ["BITBUCKET", "BITBUCKET_COMMIT"], ["BITRISE", "BITRISE_IO"], ["BUDDY", "BUDDY_WORKSPACE_ID"], ["BUILDKITE"], ["CIRCLE", "CIRCLECI"], ["CIRRUS", "CIRRUS_CI"], ["CLOUDFLARE_PAGES", "CF_PAGES", { ci: true }], ["CLOUDFLARE_WORKERS", "WORKERS_CI", { ci: true }], ["CODEBUILD", "CODEBUILD_BUILD_ARN"], ["CODEFRESH", "CF_BUILD_ID"], ["DRONE"], ["DRONE", "DRONE_BUILD_EVENT"], ["DSARI"], ["GITHUB_ACTIONS"], ["GITLAB", "GITLAB_CI"], ["GITLAB", "CI_MERGE_REQUEST_ID"], ["GOCD", "GO_PIPELINE_LABEL"], ["LAYERCI"], ["HUDSON", "HUDSON_URL"], ["JENKINS", "JENKINS_URL"], ["MAGNUM"], ["NETLIFY"], ["NETLIFY", "NETLIFY_LOCAL", { ci: false }], ["NEVERCODE"], ["RENDER"], ["SAIL", "SAILCI"], ["SEMAPHORE"], ["SCREWDRIVER"], ["SHIPPABLE"], ["SOLANO", "TDDIUM"], ["STRIDER"], ["TEAMCITY", "TEAMCITY_VERSION"], ["TRAVIS"], ["VERCEL", "NOW_BUILDER"], ["VERCEL", "VERCEL", { ci: false }], ["VERCEL", "VERCEL_ENV", { ci: false }], ["APPCENTER", "APPCENTER_BUILD_ID"], ["CODESANDBOX", "CODESANDBOX_SSE", { ci: false }], ["CODESANDBOX", "CODESANDBOX_HOST", { ci: false }], ["STACKBLITZ"], ["STORMKIT"], ["CLEAVR"], ["ZEABUR"], ["CODESPHERE", "CODESPHERE_APP_ID", { ci: true }], ["RAILWAY", "RAILWAY_PROJECT_ID"], ["RAILWAY", "RAILWAY_SERVICE_ID"], ["DENO-DEPLOY", "DENO_DEPLOYMENT_ID"], ["FIREBASE_APP_HOSTING", "FIREBASE_APP_HOSTING", { ci: true }]];
        const yt = (function() {
          if (globalThis.process?.env) for (const e3 of vt) {
            const t3 = e3[1] || e3[0];
            if (globalThis.process?.env[t3]) return { name: e3[0].toLowerCase(), ...e3[2] };
          }
          return "/bin/jsh" === globalThis.process?.env?.SHELL && globalThis.process?.versions?.webcontainer ? { name: "stackblitz", ci: false } : { name: "", ci: false };
        })();
        yt.name;
        function std_env_dist_n(e3) {
          return !!e3 && "false" !== e3;
        }
        const _t = globalThis.process?.platform || "", Et = std_env_dist_n(gt.CI) || false !== yt.ci, bt = std_env_dist_n(globalThis.process?.stdout && globalThis.process?.stdout.isTTY), St = (std_env_dist_n(gt.DEBUG), "test" === xt || std_env_dist_n(gt.TEST)), kt = (std_env_dist_n(gt.MINIMAL), /^win/i.test(_t)), wt = (/^linux/i.test(_t), /^darwin/i.test(_t), !std_env_dist_n(gt.NO_COLOR) && (std_env_dist_n(gt.FORCE_COLOR) || (bt || kt) && gt.TERM), (globalThis.process?.versions?.node || "").replace(/^v/, "") || null), It = (Number(wt?.split(".")[0]), globalThis.process || /* @__PURE__ */ Object.create(null)), Ct = { versions: {} }, Rt = (new Proxy(It, { get: (e3, t3) => "env" === t3 ? gt : t3 in e3 ? e3[t3] : t3 in Ct ? Ct[t3] : void 0 }), "node" === globalThis.process?.release?.name), Pt = !!globalThis.Bun || !!globalThis.process?.versions?.bun, Tt = !!globalThis.Deno, At = !!globalThis.fastly, Nt = [[!!globalThis.Netlify, "netlify"], [!!globalThis.EdgeRuntime, "edge-light"], ["Cloudflare-Workers" === globalThis.navigator?.userAgent, "workerd"], [At, "fastly"], [Tt, "deno"], [Pt, "bun"], [Rt, "node"]];
        !(function() {
          const e3 = Nt.find((e4) => e4[0]);
          if (e3) e3[1];
        })();
        const Lt = require("node:tty"), Ot = Lt?.WriteStream?.prototype?.hasColors?.() ?? false, base_format = (e3, t3) => {
          if (!Ot) return (e4) => e4;
          const i2 = `\x1B[${e3}m`, s2 = `\x1B[${t3}m`;
          return (e4) => {
            const r2 = e4 + "";
            let n2 = r2.indexOf(s2);
            if (-1 === n2) return i2 + r2 + s2;
            let a2 = i2, o2 = 0;
            const h2 = (22 === t3 ? s2 : "") + i2;
            for (; -1 !== n2; ) a2 += r2.slice(o2, n2) + h2, o2 = n2 + s2.length, n2 = r2.indexOf(s2, o2);
            return a2 += r2.slice(o2) + s2, a2;
          };
        }, Dt = (base_format(0, 0), base_format(1, 22), base_format(2, 22), base_format(3, 23), base_format(4, 24), base_format(53, 55), base_format(7, 27), base_format(8, 28), base_format(9, 29), base_format(30, 39), base_format(31, 39)), Vt = base_format(32, 39), Ut = base_format(33, 39), Mt = base_format(34, 39), jt = (base_format(35, 39), base_format(36, 39)), Ft = (base_format(37, 39), base_format(90, 39));
        base_format(40, 49), base_format(41, 49), base_format(42, 49), base_format(43, 49), base_format(44, 49), base_format(45, 49), base_format(46, 49), base_format(47, 49), base_format(100, 49), base_format(91, 39), base_format(92, 39), base_format(93, 39), base_format(94, 39), base_format(95, 39), base_format(96, 39), base_format(97, 39), base_format(101, 49), base_format(102, 49), base_format(103, 49), base_format(104, 49), base_format(105, 49), base_format(106, 49), base_format(107, 49);
        function isDir(e3) {
          if ("string" != typeof e3 || e3.startsWith("file://")) return false;
          try {
            return (0, ue.lstatSync)(e3).isDirectory();
          } catch {
            return false;
          }
        }
        function utils_hash(e3, t3 = 8) {
          return ((function() {
            if (void 0 !== $t) return $t;
            try {
              return $t = !!ft().getFips?.(), $t;
            } catch {
              return $t = false, $t;
            }
          })() ? ft().createHash("sha256") : ft().createHash("md5")).update(e3).digest("hex").slice(0, t3);
        }
        const Bt = { true: Vt("true"), false: Ut("false"), "[rebuild]": Ut("[rebuild]"), "[esm]": Mt("[esm]"), "[cjs]": Vt("[cjs]"), "[import]": Mt("[import]"), "[require]": Vt("[require]"), "[native]": jt("[native]"), "[transpile]": Ut("[transpile]"), "[fallback]": Dt("[fallback]"), "[unknown]": Dt("[unknown]"), "[hit]": Vt("[hit]"), "[miss]": Ut("[miss]"), "[json]": Vt("[json]"), "[data]": Vt("[data]") };
        function debug(e3, ...t3) {
          if (!e3.opts.debug) return;
          const i2 = process.cwd();
          console.log(Ft(["[jiti]", ...t3.map((e4) => e4 in Bt ? Bt[e4] : "string" != typeof e4 ? JSON.stringify(e4) : e4.replace(i2, "."))].join(" ")));
        }
        function jitiInteropDefault(e3, t3) {
          return e3.opts.interopDefault ? (function(e4) {
            const t4 = typeof e4;
            if (null === e4 || "object" !== t4 && "function" !== t4) return e4;
            const i2 = e4.default, s2 = typeof i2, r2 = null == i2, n2 = "object" === s2 || "function" === s2;
            if (r2 && e4 instanceof Promise) return e4;
            return new Proxy(e4, { get(t5, s3, a2) {
              if ("__esModule" === s3) return true;
              if ("default" === s3) return r2 ? e4 : "function" == typeof i2?.default && e4.__esModule ? i2.default : i2;
              if (Reflect.has(t5, s3)) return Reflect.get(t5, s3, a2);
              if (n2 && !(i2 instanceof Promise)) {
                let e5 = Reflect.get(i2, s3, a2);
                return "function" == typeof e5 && (e5 = e5.bind(i2)), e5;
              }
            }, apply: (e5, t5, r3) => "function" == typeof e5 ? Reflect.apply(e5, t5, r3) : "function" === s2 ? Reflect.apply(i2, t5, r3) : void 0 });
          })(t3) : t3;
        }
        let $t;
        function _booleanEnv(e3, t3) {
          const i2 = _jsonEnv(e3, t3);
          return Boolean(i2);
        }
        function _jsonEnv(e3, t3) {
          const i2 = process.env[e3];
          if (!(e3 in process.env)) return t3;
          try {
            return JSON.parse(i2);
          } catch {
            return t3;
          }
        }
        const qt = /\.(c|m)?j(sx?)$/, Wt = /\.(c|m)?t(sx?)$/;
        function jitiResolve(e3, t3, i2) {
          let s2, r2;
          if (e3.isNativeRe.test(t3)) return t3;
          e3.alias && (t3 = (function(e4, t4) {
            const i3 = pathe_M_eThtNZ_normalizeWindowsPath(e4);
            t4 = normalizeAliases(t4);
            for (const [e5, s3] of Object.entries(t4)) {
              if (!i3.startsWith(e5)) continue;
              const t5 = utils_hasTrailingSlash(e5) ? e5.slice(0, -1) : e5;
              if (utils_hasTrailingSlash(i3[t5.length])) return pathe_M_eThtNZ_join(s3, i3.slice(e5.length));
            }
            return i3;
          })(t3, e3.alias));
          let n2 = i2?.parentURL || e3.url;
          isDir(n2) && (n2 = pathe_M_eThtNZ_join(n2, "_index.js"));
          const a2 = (i2?.async ? [i2?.conditions, ["node", "import"], ["node", "require"]] : [i2?.conditions, ["node", "require"], ["node", "import"]]).filter(Boolean);
          for (const i3 of a2) {
            try {
              s2 = resolvePathSync(t3, { url: n2, conditions: i3, extensions: e3.opts.extensions });
            } catch (e4) {
              r2 = e4;
            }
            if (s2) return s2;
          }
          try {
            return e3.nativeRequire.resolve(t3, { paths: i2.paths });
          } catch (e4) {
            r2 = e4;
          }
          for (const r3 of e3.additionalExts) {
            if (s2 = tryNativeRequireResolve(e3, t3 + r3, n2, i2) || tryNativeRequireResolve(e3, t3 + "/index" + r3, n2, i2), s2) return s2;
            if ((Wt.test(e3.filename) || Wt.test(e3.parentModule?.filename || "") || qt.test(t3)) && (s2 = tryNativeRequireResolve(e3, t3.replace(qt, ".$1t$2"), n2, i2), s2)) return s2;
          }
          if (!i2?.try) throw r2;
        }
        function tryNativeRequireResolve(e3, t3, i2, s2) {
          try {
            return e3.nativeRequire.resolve(t3, { ...s2, paths: [pathe_M_eThtNZ_dirname(fileURLToPath(i2)), ...s2?.paths || []] });
          } catch {
          }
        }
        const Gt = require("node:perf_hooks"), Ht = require("node:vm");
        var Kt = __webpack_require__.n(Ht);
        function jitiRequire(e3, t3, i2) {
          const s2 = e3.parentCache || {};
          if (t3.startsWith("node:")) return nativeImportOrRequire(e3, t3, i2.async);
          if (t3.startsWith("file:")) t3 = (0, _e.fileURLToPath)(t3);
          else if (t3.startsWith("data:")) {
            if (!i2.async) throw new Error("`data:` URLs are only supported in ESM context. Use `import` or `jiti.import` instead.");
            return debug(e3, "[native]", "[data]", "[import]", t3), nativeImportOrRequire(e3, t3, true);
          }
          if (le.builtinModules.includes(t3) || ".pnp.js" === t3) return nativeImportOrRequire(e3, t3, i2.async);
          if (e3.opts.tryNative && !e3.opts.transformOptions) try {
            if (!(t3 = jitiResolve(e3, t3, i2)) && i2.try) return;
            if (debug(e3, "[try-native]", i2.async && e3.nativeImport ? "[import]" : "[require]", t3), i2.async && e3.nativeImport) return e3.nativeImport(t3).then((i3) => (false === e3.opts.moduleCache && delete e3.nativeRequire.cache[t3], jitiInteropDefault(e3, i3)));
            {
              const i3 = e3.nativeRequire(t3);
              return false === e3.opts.moduleCache && delete e3.nativeRequire.cache[t3], jitiInteropDefault(e3, i3);
            }
          } catch (i3) {
            debug(e3, `[try-native] Using fallback for ${t3} because of an error:`, i3);
          }
          const r2 = jitiResolve(e3, t3, i2);
          if (!r2 && i2.try) return;
          const n2 = extname(r2);
          if (".json" === n2) {
            debug(e3, "[json]", r2);
            const t4 = e3.nativeRequire(r2);
            return t4 && !("default" in t4) && Object.defineProperty(t4, "default", { value: t4, enumerable: false }), t4;
          }
          if (n2 && !e3.opts.extensions.includes(n2)) return debug(e3, "[native]", "[unknown]", i2.async ? "[import]" : "[require]", r2), nativeImportOrRequire(e3, r2, i2.async);
          if (e3.isNativeRe.test(r2)) return debug(e3, "[native]", i2.async ? "[import]" : "[require]", r2), nativeImportOrRequire(e3, r2, i2.async);
          if (s2[r2]) return jitiInteropDefault(e3, s2[r2]?.exports);
          if (e3.opts.moduleCache) {
            const t4 = e3.nativeRequire.cache[r2];
            if (t4?.loaded) return jitiInteropDefault(e3, t4.exports);
          }
          const a2 = (0, ue.readFileSync)(r2, "utf8");
          return eval_evalModule(e3, a2, { id: t3, filename: r2, ext: n2, cache: s2, async: i2.async });
        }
        function nativeImportOrRequire(e3, t3, i2) {
          return i2 && e3.nativeImport ? e3.nativeImport((function(e4) {
            return kt && isAbsolute(e4) ? pathToFileURL(e4) : e4;
          })(t3)).then((t4) => jitiInteropDefault(e3, t4)) : jitiInteropDefault(e3, e3.nativeRequire(t3));
        }
        const zt = "9";
        function getCache(e3, t3, i2) {
          if (!e3.opts.fsCache || !t3.filename) return i2();
          const s2 = ` /* v${zt}-${utils_hash(t3.source, 16)} */
`;
          let r2 = `${basename(pathe_M_eThtNZ_dirname(t3.filename))}-${(function(e4) {
            const t4 = e4.split(lt).pop();
            if (!t4) return;
            const i3 = t4.lastIndexOf(".");
            return i3 <= 0 ? t4 : t4.slice(0, i3);
          })(t3.filename)}` + (e3.opts.sourceMaps ? "+map" : "") + (t3.interopDefault ? ".i" : "") + `.${utils_hash(t3.filename)}` + (t3.async ? ".mjs" : ".cjs");
          t3.jsx && t3.filename.endsWith("x") && (r2 += "x");
          const n2 = e3.opts.fsCache, a2 = pathe_M_eThtNZ_join(n2, r2);
          if (!e3.opts.rebuildFsCache && (0, ue.existsSync)(a2)) {
            const i3 = (0, ue.readFileSync)(a2, "utf8");
            if (i3.endsWith(s2)) return debug(e3, "[cache]", "[hit]", t3.filename, "~>", a2), i3;
          }
          debug(e3, "[cache]", "[miss]", t3.filename);
          const o2 = i2();
          return o2.includes("__JITI_ERROR__") || ((0, ue.writeFileSync)(a2, o2 + s2, "utf8"), debug(e3, "[cache]", "[store]", t3.filename, "~>", a2)), o2;
        }
        function prepareCacheDir(t3) {
          if (true === t3.opts.fsCache && (t3.opts.fsCache = (function(t4) {
            const i2 = t4.filename && pathe_M_eThtNZ_resolve(t4.filename, "../node_modules");
            if (i2 && (0, ue.existsSync)(i2)) return pathe_M_eThtNZ_join(i2, ".cache/jiti");
            let s2 = (0, e2.tmpdir)();
            if (process.env.TMPDIR && s2 === process.cwd() && !process.env.JITI_RESPECT_TMPDIR_ENV) {
              const t5 = process.env.TMPDIR;
              delete process.env.TMPDIR, s2 = (0, e2.tmpdir)(), process.env.TMPDIR = t5;
            }
            return pathe_M_eThtNZ_join(s2, "jiti");
          })(t3)), t3.opts.fsCache) try {
            if ((0, ue.mkdirSync)(t3.opts.fsCache, { recursive: true }), !(function(e3) {
              try {
                return (0, ue.accessSync)(e3, ue.constants.W_OK), true;
              } catch {
                return false;
              }
            })(t3.opts.fsCache)) throw new Error("directory is not writable!");
          } catch (e3) {
            debug(t3, "Error creating cache directory at ", t3.opts.fsCache, e3), t3.opts.fsCache = false;
          }
        }
        function transform(e3, t3) {
          let i2 = getCache(e3, t3, () => {
            const i3 = e3.opts.transform({ ...e3.opts.transformOptions, babel: { ...e3.opts.sourceMaps ? { sourceFileName: t3.filename, sourceMaps: "inline" } : {}, ...e3.opts.transformOptions?.babel }, interopDefault: e3.opts.interopDefault, ...t3 });
            return i3.error && e3.opts.debug && debug(e3, i3.error), i3.code;
          });
          return i2.startsWith("#!") && (i2 = "// " + i2), i2;
        }
        function eval_evalModule(e3, t3, i2 = {}) {
          const s2 = i2.id || (i2.filename ? basename(i2.filename) : `_jitiEval.${i2.ext || (i2.async ? "mjs" : "js")}`), r2 = i2.filename || jitiResolve(e3, s2, { async: i2.async }), n2 = i2.ext || extname(r2), a2 = i2.cache || e3.parentCache || {}, o2 = /\.[cm]?tsx?$/.test(n2), h2 = ".mjs" === n2 || ".js" === n2 && "module" === (function(e4) {
            for (; e4 && "." !== e4 && "/" !== e4; ) {
              e4 = pathe_M_eThtNZ_join(e4, "..");
              try {
                const t4 = (0, ue.readFileSync)(pathe_M_eThtNZ_join(e4, "package.json"), "utf8");
                try {
                  return JSON.parse(t4);
                } catch {
                }
                break;
              } catch {
              }
            }
          })(r2)?.type, c2 = ".cjs" === n2, p2 = i2.forceTranspile ?? (!c2 && !(h2 && i2.async) && (o2 || h2 || e3.isTransformRe.test(r2) || hasESMSyntax(t3))), l2 = Gt.performance.now();
          if (p2) {
            t3 = transform(e3, { filename: r2, source: t3, ts: o2, async: i2.async ?? false, jsx: e3.opts.jsx });
            const s3 = Math.round(1e3 * (Gt.performance.now() - l2)) / 1e3;
            debug(e3, "[transpile]", i2.async ? "[esm]" : "[cjs]", r2, `(${s3}ms)`);
          } else {
            if (debug(e3, "[native]", i2.async ? "[import]" : "[require]", r2), i2.async) return Promise.resolve(nativeImportOrRequire(e3, r2, i2.async)).catch((s3) => (debug(e3, "Native import error:", s3), debug(e3, "[fallback]", r2), eval_evalModule(e3, t3, { ...i2, forceTranspile: true })));
            try {
              return nativeImportOrRequire(e3, r2, i2.async);
            } catch (s3) {
              debug(e3, "Native require error:", s3), debug(e3, "[fallback]", r2), t3 = transform(e3, { filename: r2, source: t3, ts: o2, async: i2.async ?? false, jsx: e3.opts.jsx });
            }
          }
          const u2 = new le.Module(r2);
          u2.filename = r2, e3.parentModule && (u2.parent = e3.parentModule, Array.isArray(e3.parentModule.children) && !e3.parentModule.children.includes(u2) && e3.parentModule.children.push(u2));
          const d2 = createJiti2(r2, e3.opts, { parentModule: u2, parentCache: a2, nativeImport: e3.nativeImport, onError: e3.onError, createRequire: e3.createRequire }, true);
          let f2;
          u2.require = d2, u2.path = pathe_M_eThtNZ_dirname(r2), u2.paths = le.Module._nodeModulePaths(u2.path), a2[r2] = u2, e3.opts.moduleCache && (e3.nativeRequire.cache[r2] = u2);
          const m2 = (function(e4, t4) {
            return `(${t4?.async ? "async " : ""}function (exports, require, module, __filename, __dirname, jitiImport, jitiESMResolve) { ${e4}
});`;
          })(t3, { async: i2.async });
          try {
            f2 = Kt().runInThisContext(m2, { filename: r2, lineOffset: 0, displayErrors: false });
          } catch (t4) {
            "SyntaxError" === t4.name && i2.async && e3.nativeImport ? (debug(e3, "[esm]", "[import]", "[fallback]", r2), f2 = (function(e4, t5) {
              const i3 = `data:text/javascript;base64,${Buffer.from(`export default ${e4}`).toString("base64")}`;
              return (...e5) => t5(i3).then((t6) => t6.default(...e5));
            })(m2, e3.nativeImport)) : (e3.opts.moduleCache && delete e3.nativeRequire.cache[r2], e3.onError(t4));
          }
          let g2;
          try {
            g2 = f2(u2.exports, u2.require, u2, u2.filename, pathe_M_eThtNZ_dirname(u2.filename), d2.import, d2.esmResolve);
          } catch (t4) {
            e3.opts.moduleCache && delete e3.nativeRequire.cache[r2], e3.onError(t4);
          }
          function next() {
            if (u2.exports && u2.exports.__JITI_ERROR__) {
              const { filename: t4, line: i3, column: s3, code: r3, message: n3 } = u2.exports.__JITI_ERROR__, a3 = new Error(`${r3}: ${n3} 
 ${`${t4}:${i3}:${s3}`}`);
              Error.captureStackTrace(a3, jitiRequire), e3.onError(a3);
            }
            u2.loaded = true;
            return jitiInteropDefault(e3, u2.exports);
          }
          return i2.async ? Promise.resolve(g2).then(next) : next();
        }
        const Jt = "win32" === (0, e2.platform)();
        function createJiti2(e3, t3 = {}, i2, s2 = false) {
          const r2 = s2 ? t3 : (function(e4) {
            const t4 = { fsCache: _booleanEnv("JITI_FS_CACHE", _booleanEnv("JITI_CACHE", true)), rebuildFsCache: _booleanEnv("JITI_REBUILD_FS_CACHE", false), moduleCache: _booleanEnv("JITI_MODULE_CACHE", _booleanEnv("JITI_REQUIRE_CACHE", true)), debug: _booleanEnv("JITI_DEBUG", false), sourceMaps: _booleanEnv("JITI_SOURCE_MAPS", false), interopDefault: _booleanEnv("JITI_INTEROP_DEFAULT", true), extensions: _jsonEnv("JITI_EXTENSIONS", [".js", ".mjs", ".cjs", ".ts", ".tsx", ".mts", ".cts", ".mtsx", ".ctsx"]), alias: _jsonEnv("JITI_ALIAS", {}), nativeModules: _jsonEnv("JITI_NATIVE_MODULES", []), transformModules: _jsonEnv("JITI_TRANSFORM_MODULES", []), tryNative: _jsonEnv("JITI_TRY_NATIVE", "Bun" in globalThis), jsx: _booleanEnv("JITI_JSX", false) };
            t4.jsx && t4.extensions.push(".jsx", ".tsx");
            const i3 = {};
            return void 0 !== e4.cache && (i3.fsCache = e4.cache), void 0 !== e4.requireCache && (i3.moduleCache = e4.requireCache), { ...t4, ...i3, ...e4 };
          })(t3), n2 = r2.alias && Object.keys(r2.alias).length > 0 ? normalizeAliases(r2.alias || {}) : void 0, a2 = ["typescript", "jiti", ...r2.nativeModules || []], o2 = new RegExp(`node_modules/(${a2.map((e4) => escapeStringRegexp(e4)).join("|")})/`), h2 = [...r2.transformModules || []], c2 = new RegExp(`node_modules/(${h2.map((e4) => escapeStringRegexp(e4)).join("|")})/`);
          e3 || (e3 = process.cwd()), !s2 && isDir(e3) && (e3 = pathe_M_eThtNZ_join(e3, "_index.js"));
          const p2 = pathToFileURL(e3), l2 = [...r2.extensions].filter((e4) => ".js" !== e4), u2 = i2.createRequire(Jt ? e3.replace(/\//g, "\\") : e3), d2 = { filename: e3, url: p2, opts: r2, alias: n2, nativeModules: a2, transformModules: h2, isNativeRe: o2, isTransformRe: c2, additionalExts: l2, nativeRequire: u2, onError: i2.onError, parentModule: i2.parentModule, parentCache: i2.parentCache, nativeImport: i2.nativeImport, createRequire: i2.createRequire };
          s2 || debug(d2, "[init]", ...[["version:", ut.rE], ["module-cache:", r2.moduleCache], ["fs-cache:", r2.fsCache], ["rebuild-fs-cache:", r2.rebuildFsCache], ["interop-defaults:", r2.interopDefault]].flat()), s2 || prepareCacheDir(d2);
          const f2 = Object.assign(function(e4) {
            return jitiRequire(d2, e4, { async: false });
          }, { cache: r2.moduleCache ? u2.cache : /* @__PURE__ */ Object.create(null), extensions: u2.extensions, main: u2.main, options: r2, resolve: Object.assign(function(e4) {
            return jitiResolve(d2, e4, { async: false });
          }, { paths: u2.resolve.paths }), transform: (e4) => transform(d2, e4), evalModule: (e4, t4) => eval_evalModule(d2, e4, t4), async import(e4, t4) {
            const i3 = await jitiRequire(d2, e4, { ...t4, async: true });
            return t4?.default ? i3?.default ?? i3 : i3;
          }, esmResolve(e4, t4) {
            "string" == typeof t4 && (t4 = { parentURL: t4 });
            const i3 = jitiResolve(d2, e4, { parentURL: p2, ...t4, async: true });
            return !i3 || "string" != typeof i3 || i3.startsWith("file://") ? i3 : pathToFileURL(i3);
          } });
          return f2;
        }
      })(), module2.exports = i.default;
    })();
  }
});

// node_modules/jiti/dist/babel.cjs
var require_babel = __commonJS({
  "node_modules/jiti/dist/babel.cjs"(exports2, module2) {
    (() => {
      var e = { "./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/files lazy recursive": function(e2) {
        function webpackEmptyAsyncContext(e3) {
          return Promise.resolve().then(function() {
            var t2 = new Error("Cannot find module '" + e3 + "'");
            throw t2.code = "MODULE_NOT_FOUND", t2;
          });
        }
        webpackEmptyAsyncContext.keys = () => [], webpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext, webpackEmptyAsyncContext.id = "./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/files lazy recursive", e2.exports = webpackEmptyAsyncContext;
      }, "./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/files sync recursive": function(e2) {
        function webpackEmptyContext(e3) {
          var t2 = new Error("Cannot find module '" + e3 + "'");
          throw t2.code = "MODULE_NOT_FOUND", t2;
        }
        webpackEmptyContext.keys = () => [], webpackEmptyContext.resolve = webpackEmptyContext, webpackEmptyContext.id = "./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/files sync recursive", e2.exports = webpackEmptyContext;
      }, "./node_modules/.pnpm/@babel+plugin-syntax-class-properties@7.12.13_@babel+core@7.28.4/node_modules/@babel/plugin-syntax-class-properties/lib/index.js": function(e2, t2, r2) {
        "use strict";
        t2.default = void 0;
        var n = (0, r2("./node_modules/.pnpm/@babel+helper-plugin-utils@7.27.1/node_modules/@babel/helper-plugin-utils/lib/index.js").declare)((e3) => (e3.assertVersion(7), { name: "syntax-class-properties", manipulateOptions(e4, t3) {
          t3.plugins.push("classProperties", "classPrivateProperties", "classPrivateMethods");
        } }));
        t2.default = n;
      }, "./node_modules/.pnpm/@jridgewell+gen-mapping@0.3.13/node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js": function(e2, t2, r2) {
        var n;
        !(function(e3, t3, r3) {
          "use strict";
          var n2 = Object.create, s = Object.defineProperty, i = Object.getOwnPropertyDescriptor, o = Object.getOwnPropertyNames, a = Object.getPrototypeOf, l = Object.prototype.hasOwnProperty, __commonJS2 = (e4, t4) => function() {
            return t4 || (0, e4[o(e4)[0]])((t4 = { exports: {} }).exports, t4), t4.exports;
          }, __export = (e4, t4) => {
            for (var r4 in t4) s(e4, r4, { get: t4[r4], enumerable: true });
          }, __copyProps = (e4, t4, r4, n3) => {
            if (t4 && "object" == typeof t4 || "function" == typeof t4) for (let a2 of o(t4)) l.call(e4, a2) || a2 === r4 || s(e4, a2, { get: () => t4[a2], enumerable: !(n3 = i(t4, a2)) || n3.enumerable });
            return e4;
          }, __toESM = (e4, t4, r4) => (r4 = null != e4 ? n2(a(e4)) : {}, __copyProps(!t4 && e4 && e4.__esModule ? r4 : s(r4, "default", { value: e4, enumerable: true }), e4)), __toCommonJS = (e4) => __copyProps(s({}, "__esModule", { value: true }), e4), p = __commonJS2({ "umd:@jridgewell/sourcemap-codec"(e4, r4) {
            r4.exports = t3;
          } }), c = __commonJS2({ "umd:@jridgewell/trace-mapping"(e4, t4) {
            t4.exports = r3;
          } }), u = {};
          __export(u, { GenMapping: () => E, addMapping: () => addMapping, addSegment: () => addSegment, allMappings: () => allMappings, fromMap: () => fromMap, maybeAddMapping: () => maybeAddMapping, maybeAddSegment: () => maybeAddSegment, setIgnore: () => setIgnore, setSourceContent: () => setSourceContent, toDecodedMap: () => toDecodedMap, toEncodedMap: () => toEncodedMap }), e3.exports = __toCommonJS(u);
          var d = class {
            constructor() {
              this._indexes = { __proto__: null }, this.array = [];
            }
          };
          function cast(e4) {
            return e4;
          }
          function get(e4, t4) {
            return cast(e4)._indexes[t4];
          }
          function put(e4, t4) {
            const r4 = get(e4, t4);
            if (void 0 !== r4) return r4;
            const { array: n3, _indexes: s2 } = cast(e4), i2 = n3.push(t4);
            return s2[t4] = i2 - 1;
          }
          function remove(e4, t4) {
            const r4 = get(e4, t4);
            if (void 0 === r4) return;
            const { array: n3, _indexes: s2 } = cast(e4);
            for (let e5 = r4 + 1; e5 < n3.length; e5++) {
              const t5 = n3[e5];
              n3[e5 - 1] = t5, s2[t5]--;
            }
            s2[t4] = void 0, n3.pop();
          }
          var h = __toESM(p()), m = __toESM(c()), f = 0, y = 1, b = 2, g = 3, x = 4, v = -1, E = class {
            constructor({ file: e4, sourceRoot: t4 } = {}) {
              this._names = new d(), this._sources = new d(), this._sourcesContent = [], this._mappings = [], this.file = e4, this.sourceRoot = t4, this._ignoreList = new d();
            }
          };
          function cast2(e4) {
            return e4;
          }
          function addSegment(e4, t4, r4, n3, s2, i2, o2, a2) {
            return addSegmentInternal(false, e4, t4, r4, n3, s2, i2, o2, a2);
          }
          function addMapping(e4, t4) {
            return addMappingInternal(false, e4, t4);
          }
          var maybeAddSegment = (e4, t4, r4, n3, s2, i2, o2, a2) => addSegmentInternal(true, e4, t4, r4, n3, s2, i2, o2, a2), maybeAddMapping = (e4, t4) => addMappingInternal(true, e4, t4);
          function setSourceContent(e4, t4, r4) {
            const { _sources: n3, _sourcesContent: s2 } = cast2(e4);
            s2[put(n3, t4)] = r4;
          }
          function setIgnore(e4, t4, r4 = true) {
            const { _sources: n3, _sourcesContent: s2, _ignoreList: i2 } = cast2(e4), o2 = put(n3, t4);
            o2 === s2.length && (s2[o2] = null), r4 ? put(i2, o2) : remove(i2, o2);
          }
          function toDecodedMap(e4) {
            const { _mappings: t4, _sources: r4, _sourcesContent: n3, _names: s2, _ignoreList: i2 } = cast2(e4);
            return removeEmptyFinalLines(t4), { version: 3, file: e4.file || void 0, names: s2.array, sourceRoot: e4.sourceRoot || void 0, sources: r4.array, sourcesContent: n3, mappings: t4, ignoreList: i2.array };
          }
          function toEncodedMap(e4) {
            const t4 = toDecodedMap(e4);
            return Object.assign({}, t4, { mappings: (0, h.encode)(t4.mappings) });
          }
          function fromMap(e4) {
            const t4 = new m.TraceMap(e4), r4 = new E({ file: t4.file, sourceRoot: t4.sourceRoot });
            return putAll(cast2(r4)._names, t4.names), putAll(cast2(r4)._sources, t4.sources), cast2(r4)._sourcesContent = t4.sourcesContent || t4.sources.map(() => null), cast2(r4)._mappings = (0, m.decodedMappings)(t4), t4.ignoreList && putAll(cast2(r4)._ignoreList, t4.ignoreList), r4;
          }
          function allMappings(e4) {
            const t4 = [], { _mappings: r4, _sources: n3, _names: s2 } = cast2(e4);
            for (let e5 = 0; e5 < r4.length; e5++) {
              const i2 = r4[e5];
              for (let r5 = 0; r5 < i2.length; r5++) {
                const o2 = i2[r5], a2 = { line: e5 + 1, column: o2[f] };
                let l2, p2, c2;
                1 !== o2.length && (l2 = n3.array[o2[y]], p2 = { line: o2[b] + 1, column: o2[g] }, 5 === o2.length && (c2 = s2.array[o2[x]])), t4.push({ generated: a2, source: l2, original: p2, name: c2 });
              }
            }
            return t4;
          }
          function addSegmentInternal(e4, t4, r4, n3, s2, i2, o2, a2, l2) {
            const { _mappings: p2, _sources: c2, _sourcesContent: u2, _names: d2 } = cast2(t4), h2 = getIndex(p2, r4), m2 = getColumnIndex(h2, n3);
            if (!s2) {
              if (e4 && skipSourceless(h2, m2)) return;
              return insert(h2, m2, [n3]);
            }
            assert(i2), assert(o2);
            const f2 = put(c2, s2), y2 = a2 ? put(d2, a2) : v;
            if (f2 === u2.length && (u2[f2] = null != l2 ? l2 : null), !e4 || !skipSource(h2, m2, f2, i2, o2, y2)) return insert(h2, m2, a2 ? [n3, f2, i2, o2, y2] : [n3, f2, i2, o2]);
          }
          function assert(e4) {
          }
          function getIndex(e4, t4) {
            for (let r4 = e4.length; r4 <= t4; r4++) e4[r4] = [];
            return e4[t4];
          }
          function getColumnIndex(e4, t4) {
            let r4 = e4.length;
            for (let n3 = r4 - 1; n3 >= 0 && !(t4 >= e4[n3][f]); r4 = n3--) ;
            return r4;
          }
          function insert(e4, t4, r4) {
            for (let r5 = e4.length; r5 > t4; r5--) e4[r5] = e4[r5 - 1];
            e4[t4] = r4;
          }
          function removeEmptyFinalLines(e4) {
            const { length: t4 } = e4;
            let r4 = t4;
            for (let t5 = r4 - 1; t5 >= 0 && !(e4[t5].length > 0); r4 = t5, t5--) ;
            r4 < t4 && (e4.length = r4);
          }
          function putAll(e4, t4) {
            for (let r4 = 0; r4 < t4.length; r4++) put(e4, t4[r4]);
          }
          function skipSourceless(e4, t4) {
            return 0 === t4 || 1 === e4[t4 - 1].length;
          }
          function skipSource(e4, t4, r4, n3, s2, i2) {
            if (0 === t4) return false;
            const o2 = e4[t4 - 1];
            return 1 !== o2.length && r4 === o2[y] && n3 === o2[b] && s2 === o2[g] && i2 === (5 === o2.length ? o2[x] : v);
          }
          function addMappingInternal(e4, t4, r4) {
            const { generated: n3, source: s2, original: i2, name: o2, content: a2 } = r4;
            return s2 ? (assert(i2), addSegmentInternal(e4, t4, n3.line - 1, n3.column, s2, i2.line - 1, i2.column, o2, a2)) : addSegmentInternal(e4, t4, n3.line - 1, n3.column, null, null, null, null, null);
          }
        })(e2 = r2.nmd(e2), r2("./node_modules/.pnpm/@jridgewell+sourcemap-codec@1.5.5/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js"), r2("./node_modules/.pnpm/@jridgewell+trace-mapping@0.3.31/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js")), e2.exports = "default" in (n = e2).exports ? n.exports.default : n.exports;
      }, "./node_modules/.pnpm/@jridgewell+remapping@2.3.5/node_modules/@jridgewell/remapping/dist/remapping.umd.js": function(e2, t2, r2) {
        var n;
        !(function(e3, t3, r3) {
          "use strict";
          var n2 = Object.create, s = Object.defineProperty, i = Object.getOwnPropertyDescriptor, o = Object.getOwnPropertyNames, a = Object.getPrototypeOf, l = Object.prototype.hasOwnProperty, __commonJS2 = (e4, t4) => function() {
            return t4 || (0, e4[o(e4)[0]])((t4 = { exports: {} }).exports, t4), t4.exports;
          }, __export = (e4, t4) => {
            for (var r4 in t4) s(e4, r4, { get: t4[r4], enumerable: true });
          }, __copyProps = (e4, t4, r4, n3) => {
            if (t4 && "object" == typeof t4 || "function" == typeof t4) for (let a2 of o(t4)) l.call(e4, a2) || a2 === r4 || s(e4, a2, { get: () => t4[a2], enumerable: !(n3 = i(t4, a2)) || n3.enumerable });
            return e4;
          }, __toESM = (e4, t4, r4) => (r4 = null != e4 ? n2(a(e4)) : {}, __copyProps(!t4 && e4 && e4.__esModule ? r4 : s(r4, "default", { value: e4, enumerable: true }), e4)), __toCommonJS = (e4) => __copyProps(s({}, "__esModule", { value: true }), e4), p = __commonJS2({ "umd:@jridgewell/trace-mapping"(e4, t4) {
            t4.exports = r3;
          } }), c = __commonJS2({ "umd:@jridgewell/gen-mapping"(e4, r4) {
            r4.exports = t3;
          } }), u = {};
          __export(u, { default: () => remapping }), e3.exports = __toCommonJS(u);
          var d = __toESM(p()), h = __toESM(c()), m = __toESM(p()), f = SegmentObject("", -1, -1, "", null, false), y = [];
          function SegmentObject(e4, t4, r4, n3, s2, i2) {
            return { source: e4, line: t4, column: r4, name: n3, content: s2, ignore: i2 };
          }
          function Source(e4, t4, r4, n3, s2) {
            return { map: e4, sources: t4, source: r4, content: n3, ignore: s2 };
          }
          function MapSource(e4, t4) {
            return Source(e4, t4, "", null, false);
          }
          function OriginalSource(e4, t4, r4) {
            return Source(null, y, e4, t4, r4);
          }
          function traceMappings(e4) {
            const t4 = new h.GenMapping({ file: e4.map.file }), { sources: r4, map: n3 } = e4, s2 = n3.names, i2 = (0, m.decodedMappings)(n3);
            for (let e5 = 0; e5 < i2.length; e5++) {
              const n4 = i2[e5];
              for (let i3 = 0; i3 < n4.length; i3++) {
                const o2 = n4[i3], a2 = o2[0];
                let l2 = f;
                if (1 !== o2.length && (l2 = originalPositionFor(r4[o2[1]], o2[2], o2[3], 5 === o2.length ? s2[o2[4]] : ""), null == l2)) continue;
                const { column: p2, line: c2, name: u2, content: d2, source: m2, ignore: y2 } = l2;
                (0, h.maybeAddSegment)(t4, e5, a2, m2, c2, p2, u2), m2 && null != d2 && (0, h.setSourceContent)(t4, m2, d2), y2 && (0, h.setIgnore)(t4, m2, true);
              }
            }
            return t4;
          }
          function originalPositionFor(e4, t4, r4, n3) {
            if (!e4.map) return SegmentObject(e4.source, t4, r4, n3, e4.content, e4.ignore);
            const s2 = (0, m.traceSegment)(e4.map, t4, r4);
            return null == s2 ? null : 1 === s2.length ? f : originalPositionFor(e4.sources[s2[1]], s2[2], s2[3], 5 === s2.length ? e4.map.names[s2[4]] : n3);
          }
          function asArray(e4) {
            return Array.isArray(e4) ? e4 : [e4];
          }
          function buildSourceMapTree(e4, t4) {
            const r4 = asArray(e4).map((e5) => new d.TraceMap(e5, "")), n3 = r4.pop();
            for (let e5 = 0; e5 < r4.length; e5++) if (r4[e5].sources.length > 1) throw new Error(`Transformation map ${e5} must have exactly one source file.
Did you specify these with the most recent transformation maps first?`);
            let s2 = build(n3, t4, "", 0);
            for (let e5 = r4.length - 1; e5 >= 0; e5--) s2 = MapSource(r4[e5], [s2]);
            return s2;
          }
          function build(e4, t4, r4, n3) {
            const { resolvedSources: s2, sourcesContent: i2, ignoreList: o2 } = e4, a2 = n3 + 1;
            return MapSource(e4, s2.map((e5, n4) => {
              const s3 = { importer: r4, depth: a2, source: e5 || "", content: void 0, ignore: void 0 }, l2 = t4(s3.source, s3), { source: p2, content: c2, ignore: u2 } = s3;
              return l2 ? build(new d.TraceMap(l2, p2), t4, p2, a2) : OriginalSource(p2, void 0 !== c2 ? c2 : i2 ? i2[n4] : null, void 0 !== u2 ? u2 : !!o2 && o2.includes(n4));
            }));
          }
          var b = __toESM(c()), g = class {
            constructor(e4, t4) {
              const r4 = t4.decodedMappings ? (0, b.toDecodedMap)(e4) : (0, b.toEncodedMap)(e4);
              this.version = r4.version, this.file = r4.file, this.mappings = r4.mappings, this.names = r4.names, this.ignoreList = r4.ignoreList, this.sourceRoot = r4.sourceRoot, this.sources = r4.sources, t4.excludeContent || (this.sourcesContent = r4.sourcesContent);
            }
            toString() {
              return JSON.stringify(this);
            }
          };
          function remapping(e4, t4, r4) {
            const n3 = "object" == typeof r4 ? r4 : { excludeContent: !!r4, decodedMappings: false }, s2 = buildSourceMapTree(e4, t4);
            return new g(traceMappings(s2), n3);
          }
        })(e2 = r2.nmd(e2), r2("./node_modules/.pnpm/@jridgewell+gen-mapping@0.3.13/node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js"), r2("./node_modules/.pnpm/@jridgewell+trace-mapping@0.3.31/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js")), e2.exports = "default" in (n = e2).exports ? n.exports.default : n.exports;
      }, "./node_modules/.pnpm/@jridgewell+resolve-uri@3.1.2/node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js": function(e2) {
        e2.exports = (function() {
          "use strict";
          const e3 = /^[\w+.-]+:\/\//, t2 = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/, r2 = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
          function isAbsoluteUrl(t3) {
            return e3.test(t3);
          }
          function isSchemeRelativeUrl(e4) {
            return e4.startsWith("//");
          }
          function isAbsolutePath(e4) {
            return e4.startsWith("/");
          }
          function isFileUrl(e4) {
            return e4.startsWith("file:");
          }
          function isRelative(e4) {
            return /^[.?#]/.test(e4);
          }
          function parseAbsoluteUrl(e4) {
            const r3 = t2.exec(e4);
            return makeUrl(r3[1], r3[2] || "", r3[3], r3[4] || "", r3[5] || "/", r3[6] || "", r3[7] || "");
          }
          function parseFileUrl(e4) {
            const t3 = r2.exec(e4), n = t3[2];
            return makeUrl("file:", "", t3[1] || "", "", isAbsolutePath(n) ? n : "/" + n, t3[3] || "", t3[4] || "");
          }
          function makeUrl(e4, t3, r3, n, s, i, o) {
            return { scheme: e4, user: t3, host: r3, port: n, path: s, query: i, hash: o, type: 7 };
          }
          function parseUrl(e4) {
            if (isSchemeRelativeUrl(e4)) {
              const t4 = parseAbsoluteUrl("http:" + e4);
              return t4.scheme = "", t4.type = 6, t4;
            }
            if (isAbsolutePath(e4)) {
              const t4 = parseAbsoluteUrl("http://foo.com" + e4);
              return t4.scheme = "", t4.host = "", t4.type = 5, t4;
            }
            if (isFileUrl(e4)) return parseFileUrl(e4);
            if (isAbsoluteUrl(e4)) return parseAbsoluteUrl(e4);
            const t3 = parseAbsoluteUrl("http://foo.com/" + e4);
            return t3.scheme = "", t3.host = "", t3.type = e4 ? e4.startsWith("?") ? 3 : e4.startsWith("#") ? 2 : 4 : 1, t3;
          }
          function stripPathFilename(e4) {
            if (e4.endsWith("/..")) return e4;
            const t3 = e4.lastIndexOf("/");
            return e4.slice(0, t3 + 1);
          }
          function mergePaths(e4, t3) {
            normalizePath(t3, t3.type), "/" === e4.path ? e4.path = t3.path : e4.path = stripPathFilename(t3.path) + e4.path;
          }
          function normalizePath(e4, t3) {
            const r3 = t3 <= 4, n = e4.path.split("/");
            let s = 1, i = 0, o = false;
            for (let e5 = 1; e5 < n.length; e5++) {
              const t4 = n[e5];
              t4 ? (o = false, "." !== t4 && (".." !== t4 ? (n[s++] = t4, i++) : i ? (o = true, i--, s--) : r3 && (n[s++] = t4))) : o = true;
            }
            let a = "";
            for (let e5 = 1; e5 < s; e5++) a += "/" + n[e5];
            (!a || o && !a.endsWith("/..")) && (a += "/"), e4.path = a;
          }
          function resolve(e4, t3) {
            if (!e4 && !t3) return "";
            const r3 = parseUrl(e4);
            let n = r3.type;
            if (t3 && 7 !== n) {
              const e5 = parseUrl(t3), s2 = e5.type;
              switch (n) {
                case 1:
                  r3.hash = e5.hash;
                case 2:
                  r3.query = e5.query;
                case 3:
                case 4:
                  mergePaths(r3, e5);
                case 5:
                  r3.user = e5.user, r3.host = e5.host, r3.port = e5.port;
                case 6:
                  r3.scheme = e5.scheme;
              }
              s2 > n && (n = s2);
            }
            normalizePath(r3, n);
            const s = r3.query + r3.hash;
            switch (n) {
              case 2:
              case 3:
                return s;
              case 4: {
                const n2 = r3.path.slice(1);
                return n2 ? isRelative(t3 || e4) && !isRelative(n2) ? "./" + n2 + s : n2 + s : s || ".";
              }
              case 5:
                return r3.path + s;
              default:
                return r3.scheme + "//" + r3.user + r3.host + r3.port + r3.path + s;
            }
          }
          return resolve;
        })();
      }, "./node_modules/.pnpm/@jridgewell+sourcemap-codec@1.5.5/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js": function(e2, t2, r2) {
        var n;
        !(function(e3) {
          "use strict";
          var t3 = Object.defineProperty, r3 = Object.getOwnPropertyDescriptor, n2 = Object.getOwnPropertyNames, s = Object.prototype.hasOwnProperty, __copyProps = (e4, i2, o2, a2) => {
            if (i2 && "object" == typeof i2 || "function" == typeof i2) for (let l2 of n2(i2)) s.call(e4, l2) || l2 === o2 || t3(e4, l2, { get: () => i2[l2], enumerable: !(a2 = r3(i2, l2)) || a2.enumerable });
            return e4;
          }, __toCommonJS = (e4) => __copyProps(t3({}, "__esModule", { value: true }), e4), i = {};
          ((e4, r4) => {
            for (var n3 in r4) t3(e4, n3, { get: r4[n3], enumerable: true });
          })(i, { decode: () => decode, decodeGeneratedRanges: () => decodeGeneratedRanges, decodeOriginalScopes: () => decodeOriginalScopes, encode: () => encode, encodeGeneratedRanges: () => encodeGeneratedRanges, encodeOriginalScopes: () => encodeOriginalScopes }), e3.exports = __toCommonJS(i);
          var o = ",".charCodeAt(0), a = ";".charCodeAt(0), l = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", p = new Uint8Array(64), c = new Uint8Array(128);
          for (let e4 = 0; e4 < l.length; e4++) {
            const t4 = l.charCodeAt(e4);
            p[e4] = t4, c[t4] = e4;
          }
          function decodeInteger(e4, t4) {
            let r4 = 0, n3 = 0, s2 = 0;
            do {
              const t5 = e4.next();
              s2 = c[t5], r4 |= (31 & s2) << n3, n3 += 5;
            } while (32 & s2);
            const i2 = 1 & r4;
            return r4 >>>= 1, i2 && (r4 = -2147483648 | -r4), t4 + r4;
          }
          function encodeInteger(e4, t4, r4) {
            let n3 = t4 - r4;
            n3 = n3 < 0 ? -n3 << 1 | 1 : n3 << 1;
            do {
              let t5 = 31 & n3;
              n3 >>>= 5, n3 > 0 && (t5 |= 32), e4.write(p[t5]);
            } while (n3 > 0);
            return t4;
          }
          function hasMoreVlq(e4, t4) {
            return !(e4.pos >= t4) && e4.peek() !== o;
          }
          var u = 16384, d = "undefined" != typeof TextDecoder ? new TextDecoder() : "undefined" != typeof Buffer ? { decode: (e4) => Buffer.from(e4.buffer, e4.byteOffset, e4.byteLength).toString() } : { decode(e4) {
            let t4 = "";
            for (let r4 = 0; r4 < e4.length; r4++) t4 += String.fromCharCode(e4[r4]);
            return t4;
          } }, h = class {
            constructor() {
              this.pos = 0, this.out = "", this.buffer = new Uint8Array(u);
            }
            write(e4) {
              const { buffer: t4 } = this;
              t4[this.pos++] = e4, this.pos === u && (this.out += d.decode(t4), this.pos = 0);
            }
            flush() {
              const { buffer: e4, out: t4, pos: r4 } = this;
              return r4 > 0 ? t4 + d.decode(e4.subarray(0, r4)) : t4;
            }
          }, m = class {
            constructor(e4) {
              this.pos = 0, this.buffer = e4;
            }
            next() {
              return this.buffer.charCodeAt(this.pos++);
            }
            peek() {
              return this.buffer.charCodeAt(this.pos);
            }
            indexOf(e4) {
              const { buffer: t4, pos: r4 } = this, n3 = t4.indexOf(e4, r4);
              return -1 === n3 ? t4.length : n3;
            }
          }, f = [];
          function decodeOriginalScopes(e4) {
            const { length: t4 } = e4, r4 = new m(e4), n3 = [], s2 = [];
            let i2 = 0;
            for (; r4.pos < t4; r4.pos++) {
              i2 = decodeInteger(r4, i2);
              const e5 = decodeInteger(r4, 0);
              if (!hasMoreVlq(r4, t4)) {
                const t5 = s2.pop();
                t5[2] = i2, t5[3] = e5;
                continue;
              }
              const o2 = decodeInteger(r4, 0), a2 = 1 & decodeInteger(r4, 0) ? [i2, e5, 0, 0, o2, decodeInteger(r4, 0)] : [i2, e5, 0, 0, o2];
              let l2 = f;
              if (hasMoreVlq(r4, t4)) {
                l2 = [];
                do {
                  const e6 = decodeInteger(r4, 0);
                  l2.push(e6);
                } while (hasMoreVlq(r4, t4));
              }
              a2.vars = l2, n3.push(a2), s2.push(a2);
            }
            return n3;
          }
          function encodeOriginalScopes(e4) {
            const t4 = new h();
            for (let r4 = 0; r4 < e4.length; ) r4 = _encodeOriginalScopes(e4, r4, t4, [0]);
            return t4.flush();
          }
          function _encodeOriginalScopes(e4, t4, r4, n3) {
            const s2 = e4[t4], { 0: i2, 1: a2, 2: l2, 3: p2, 4: c2, vars: u2 } = s2;
            t4 > 0 && r4.write(o), n3[0] = encodeInteger(r4, i2, n3[0]), encodeInteger(r4, a2, 0), encodeInteger(r4, c2, 0), encodeInteger(r4, 6 === s2.length ? 1 : 0, 0), 6 === s2.length && encodeInteger(r4, s2[5], 0);
            for (const e5 of u2) encodeInteger(r4, e5, 0);
            for (t4++; t4 < e4.length; ) {
              const s3 = e4[t4], { 0: i3, 1: o2 } = s3;
              if (i3 > l2 || i3 === l2 && o2 >= p2) break;
              t4 = _encodeOriginalScopes(e4, t4, r4, n3);
            }
            return r4.write(o), n3[0] = encodeInteger(r4, l2, n3[0]), encodeInteger(r4, p2, 0), t4;
          }
          function decodeGeneratedRanges(e4) {
            const { length: t4 } = e4, r4 = new m(e4), n3 = [], s2 = [];
            let i2 = 0, o2 = 0, a2 = 0, l2 = 0, p2 = 0, c2 = 0, u2 = 0, d2 = 0;
            do {
              const e5 = r4.indexOf(";");
              let t5 = 0;
              for (; r4.pos < e5; r4.pos++) {
                if (t5 = decodeInteger(r4, t5), !hasMoreVlq(r4, e5)) {
                  const e6 = s2.pop();
                  e6[2] = i2, e6[3] = t5;
                  continue;
                }
                const h2 = decodeInteger(r4, 0), m2 = 2 & h2, y = 4 & h2;
                let b, g = null, x = f;
                if (1 & h2) {
                  const e6 = decodeInteger(r4, o2);
                  a2 = decodeInteger(r4, o2 === e6 ? a2 : 0), o2 = e6, b = [i2, t5, 0, 0, e6, a2];
                } else b = [i2, t5, 0, 0];
                if (b.isScope = !!y, m2) {
                  const e6 = l2, t6 = p2;
                  l2 = decodeInteger(r4, l2);
                  const n4 = e6 === l2;
                  p2 = decodeInteger(r4, n4 ? p2 : 0), c2 = decodeInteger(r4, n4 && t6 === p2 ? c2 : 0), g = [l2, p2, c2];
                }
                if (b.callsite = g, hasMoreVlq(r4, e5)) {
                  x = [];
                  do {
                    u2 = i2, d2 = t5;
                    const e6 = decodeInteger(r4, 0);
                    let n4;
                    if (e6 < -1) {
                      n4 = [[decodeInteger(r4, 0)]];
                      for (let t6 = -1; t6 > e6; t6--) {
                        const e7 = u2;
                        u2 = decodeInteger(r4, u2), d2 = decodeInteger(r4, u2 === e7 ? d2 : 0);
                        const t7 = decodeInteger(r4, 0);
                        n4.push([t7, u2, d2]);
                      }
                    } else n4 = [[e6]];
                    x.push(n4);
                  } while (hasMoreVlq(r4, e5));
                }
                b.bindings = x, n3.push(b), s2.push(b);
              }
              i2++, r4.pos = e5 + 1;
            } while (r4.pos < t4);
            return n3;
          }
          function encodeGeneratedRanges(e4) {
            if (0 === e4.length) return "";
            const t4 = new h();
            for (let r4 = 0; r4 < e4.length; ) r4 = _encodeGeneratedRanges(e4, r4, t4, [0, 0, 0, 0, 0, 0, 0]);
            return t4.flush();
          }
          function _encodeGeneratedRanges(e4, t4, r4, n3) {
            const s2 = e4[t4], { 0: i2, 1: a2, 2: l2, 3: p2, isScope: c2, callsite: u2, bindings: d2 } = s2;
            if (n3[0] < i2 ? (catchupLine(r4, n3[0], i2), n3[0] = i2, n3[1] = 0) : t4 > 0 && r4.write(o), n3[1] = encodeInteger(r4, s2[1], n3[1]), encodeInteger(r4, (6 === s2.length ? 1 : 0) | (u2 ? 2 : 0) | (c2 ? 4 : 0), 0), 6 === s2.length) {
              const { 4: e5, 5: t5 } = s2;
              e5 !== n3[2] && (n3[3] = 0), n3[2] = encodeInteger(r4, e5, n3[2]), n3[3] = encodeInteger(r4, t5, n3[3]);
            }
            if (u2) {
              const { 0: e5, 1: t5, 2: i3 } = s2.callsite;
              e5 !== n3[4] ? (n3[5] = 0, n3[6] = 0) : t5 !== n3[5] && (n3[6] = 0), n3[4] = encodeInteger(r4, e5, n3[4]), n3[5] = encodeInteger(r4, t5, n3[5]), n3[6] = encodeInteger(r4, i3, n3[6]);
            }
            if (d2) for (const e5 of d2) {
              e5.length > 1 && encodeInteger(r4, -e5.length, 0), encodeInteger(r4, e5[0][0], 0);
              let t5 = i2, n4 = a2;
              for (let s3 = 1; s3 < e5.length; s3++) {
                const i3 = e5[s3];
                t5 = encodeInteger(r4, i3[1], t5), n4 = encodeInteger(r4, i3[2], n4), encodeInteger(r4, i3[0], 0);
              }
            }
            for (t4++; t4 < e4.length; ) {
              const s3 = e4[t4], { 0: i3, 1: o2 } = s3;
              if (i3 > l2 || i3 === l2 && o2 >= p2) break;
              t4 = _encodeGeneratedRanges(e4, t4, r4, n3);
            }
            return n3[0] < l2 ? (catchupLine(r4, n3[0], l2), n3[0] = l2, n3[1] = 0) : r4.write(o), n3[1] = encodeInteger(r4, p2, n3[1]), t4;
          }
          function catchupLine(e4, t4, r4) {
            do {
              e4.write(a);
            } while (++t4 < r4);
          }
          function decode(e4) {
            const { length: t4 } = e4, r4 = new m(e4), n3 = [];
            let s2 = 0, i2 = 0, o2 = 0, a2 = 0, l2 = 0;
            do {
              const e5 = r4.indexOf(";"), t5 = [];
              let p2 = true, c2 = 0;
              for (s2 = 0; r4.pos < e5; ) {
                let n4;
                s2 = decodeInteger(r4, s2), s2 < c2 && (p2 = false), c2 = s2, hasMoreVlq(r4, e5) ? (i2 = decodeInteger(r4, i2), o2 = decodeInteger(r4, o2), a2 = decodeInteger(r4, a2), hasMoreVlq(r4, e5) ? (l2 = decodeInteger(r4, l2), n4 = [s2, i2, o2, a2, l2]) : n4 = [s2, i2, o2, a2]) : n4 = [s2], t5.push(n4), r4.pos++;
              }
              p2 || sort(t5), n3.push(t5), r4.pos = e5 + 1;
            } while (r4.pos <= t4);
            return n3;
          }
          function sort(e4) {
            e4.sort(sortComparator);
          }
          function sortComparator(e4, t4) {
            return e4[0] - t4[0];
          }
          function encode(e4) {
            const t4 = new h();
            let r4 = 0, n3 = 0, s2 = 0, i2 = 0;
            for (let l2 = 0; l2 < e4.length; l2++) {
              const p2 = e4[l2];
              if (l2 > 0 && t4.write(a), 0 === p2.length) continue;
              let c2 = 0;
              for (let e5 = 0; e5 < p2.length; e5++) {
                const a2 = p2[e5];
                e5 > 0 && t4.write(o), c2 = encodeInteger(t4, a2[0], c2), 1 !== a2.length && (r4 = encodeInteger(t4, a2[1], r4), n3 = encodeInteger(t4, a2[2], n3), s2 = encodeInteger(t4, a2[3], s2), 4 !== a2.length && (i2 = encodeInteger(t4, a2[4], i2)));
              }
            }
            return t4.flush();
          }
        })(e2 = r2.nmd(e2)), e2.exports = "default" in (n = e2).exports ? n.exports.default : n.exports;
      }, "./node_modules/.pnpm/@jridgewell+trace-mapping@0.3.31/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js": function(e2, t2, r2) {
        var n;
        !(function(e3, t3, r3) {
          "use strict";
          var n2 = Object.create, s = Object.defineProperty, i = Object.getOwnPropertyDescriptor, o = Object.getOwnPropertyNames, a = Object.getPrototypeOf, l = Object.prototype.hasOwnProperty, __commonJS2 = (e4, t4) => function() {
            return t4 || (0, e4[o(e4)[0]])((t4 = { exports: {} }).exports, t4), t4.exports;
          }, __export = (e4, t4) => {
            for (var r4 in t4) s(e4, r4, { get: t4[r4], enumerable: true });
          }, __copyProps = (e4, t4, r4, n3) => {
            if (t4 && "object" == typeof t4 || "function" == typeof t4) for (let a2 of o(t4)) l.call(e4, a2) || a2 === r4 || s(e4, a2, { get: () => t4[a2], enumerable: !(n3 = i(t4, a2)) || n3.enumerable });
            return e4;
          }, __toESM = (e4, t4, r4) => (r4 = null != e4 ? n2(a(e4)) : {}, __copyProps(!t4 && e4 && e4.__esModule ? r4 : s(r4, "default", { value: e4, enumerable: true }), e4)), __toCommonJS = (e4) => __copyProps(s({}, "__esModule", { value: true }), e4), p = __commonJS2({ "umd:@jridgewell/sourcemap-codec"(e4, t4) {
            t4.exports = r3;
          } }), c = __commonJS2({ "umd:@jridgewell/resolve-uri"(e4, r4) {
            r4.exports = t3;
          } }), u = {};
          __export(u, { AnyMap: () => FlattenMap, FlattenMap: () => FlattenMap, GREATEST_LOWER_BOUND: () => _, LEAST_UPPER_BOUND: () => P, TraceMap: () => A, allGeneratedPositionsFor: () => allGeneratedPositionsFor, decodedMap: () => decodedMap, decodedMappings: () => decodedMappings, eachMapping: () => eachMapping, encodedMap: () => encodedMap, encodedMappings: () => encodedMappings, generatedPositionFor: () => generatedPositionFor, isIgnored: () => isIgnored, originalPositionFor: () => originalPositionFor, presortedDecodedMap: () => presortedDecodedMap, sourceContentFor: () => sourceContentFor, traceSegment: () => traceSegment }), e3.exports = __toCommonJS(u);
          var d = __toESM(p()), h = __toESM(c());
          function stripFilename(e4) {
            if (!e4) return "";
            const t4 = e4.lastIndexOf("/");
            return e4.slice(0, t4 + 1);
          }
          function resolver(e4, t4) {
            const r4 = stripFilename(e4), n3 = t4 ? t4 + "/" : "";
            return (e5) => (0, h.default)(n3 + (e5 || ""), r4);
          }
          var m = 0, f = 1, y = 2, b = 3, g = 4, x = 1, v = 2;
          function maybeSort(e4, t4) {
            const r4 = nextUnsortedSegmentLine(e4, 0);
            if (r4 === e4.length) return e4;
            t4 || (e4 = e4.slice());
            for (let n3 = r4; n3 < e4.length; n3 = nextUnsortedSegmentLine(e4, n3 + 1)) e4[n3] = sortSegments(e4[n3], t4);
            return e4;
          }
          function nextUnsortedSegmentLine(e4, t4) {
            for (let r4 = t4; r4 < e4.length; r4++) if (!isSorted(e4[r4])) return r4;
            return e4.length;
          }
          function isSorted(e4) {
            for (let t4 = 1; t4 < e4.length; t4++) if (e4[t4][m] < e4[t4 - 1][m]) return false;
            return true;
          }
          function sortSegments(e4, t4) {
            return t4 || (e4 = e4.slice()), e4.sort(sortComparator);
          }
          function sortComparator(e4, t4) {
            return e4[m] - t4[m];
          }
          function buildBySources(e4, t4) {
            const r4 = t4.map(() => []);
            for (let t5 = 0; t5 < e4.length; t5++) {
              const n3 = e4[t5];
              for (let e5 = 0; e5 < n3.length; e5++) {
                const s2 = n3[e5];
                if (1 === s2.length) continue;
                const i2 = s2[f], o2 = s2[y], a2 = s2[b], l2 = r4[i2];
                (l2[o2] || (l2[o2] = [])).push([a2, t5, s2[m]]);
              }
            }
            for (let e5 = 0; e5 < r4.length; e5++) {
              const t5 = r4[e5];
              for (let e6 = 0; e6 < t5.length; e6++) {
                const r5 = t5[e6];
                r5 && r5.sort(sortComparator);
              }
            }
            return r4;
          }
          var E = false;
          function binarySearch(e4, t4, r4, n3) {
            for (; r4 <= n3; ) {
              const s2 = r4 + (n3 - r4 >> 1), i2 = e4[s2][m] - t4;
              if (0 === i2) return E = true, s2;
              i2 < 0 ? r4 = s2 + 1 : n3 = s2 - 1;
            }
            return E = false, r4 - 1;
          }
          function upperBound(e4, t4, r4) {
            for (let n3 = r4 + 1; n3 < e4.length && e4[n3][m] === t4; r4 = n3++) ;
            return r4;
          }
          function lowerBound(e4, t4, r4) {
            for (let n3 = r4 - 1; n3 >= 0 && e4[n3][m] === t4; r4 = n3--) ;
            return r4;
          }
          function memoizedState() {
            return { lastKey: -1, lastNeedle: -1, lastIndex: -1 };
          }
          function memoizedBinarySearch(e4, t4, r4, n3) {
            const { lastKey: s2, lastNeedle: i2, lastIndex: o2 } = r4;
            let a2 = 0, l2 = e4.length - 1;
            if (n3 === s2) {
              if (t4 === i2) return E = -1 !== o2 && e4[o2][m] === t4, o2;
              t4 >= i2 ? a2 = -1 === o2 ? 0 : o2 : l2 = o2;
            }
            return r4.lastKey = n3, r4.lastNeedle = t4, r4.lastIndex = binarySearch(e4, t4, a2, l2);
          }
          function parse(e4) {
            return "string" == typeof e4 ? JSON.parse(e4) : e4;
          }
          var FlattenMap = function(e4, t4) {
            const r4 = parse(e4);
            if (!("sections" in r4)) return new A(r4, t4);
            const n3 = [], s2 = [], i2 = [], o2 = [], a2 = [];
            return recurse(r4, t4, n3, s2, i2, o2, a2, 0, 0, 1 / 0, 1 / 0), presortedDecodedMap({ version: 3, file: r4.file, names: o2, sources: s2, sourcesContent: i2, mappings: n3, ignoreList: a2 });
          };
          function recurse(e4, t4, r4, n3, s2, i2, o2, a2, l2, p2, c2) {
            const { sections: u2 } = e4;
            for (let e5 = 0; e5 < u2.length; e5++) {
              const { map: d2, offset: h2 } = u2[e5];
              let m2 = p2, f2 = c2;
              if (e5 + 1 < u2.length) {
                const t5 = u2[e5 + 1].offset;
                m2 = Math.min(p2, a2 + t5.line), m2 === p2 ? f2 = Math.min(c2, l2 + t5.column) : m2 < p2 && (f2 = l2 + t5.column);
              }
              addSection(d2, t4, r4, n3, s2, i2, o2, a2 + h2.line, l2 + h2.column, m2, f2);
            }
          }
          function addSection(e4, t4, r4, n3, s2, i2, o2, a2, l2, p2, c2) {
            const u2 = parse(e4);
            if ("sections" in u2) return recurse(...arguments);
            const d2 = new A(u2, t4), h2 = n3.length, x2 = i2.length, v2 = decodedMappings(d2), { resolvedSources: E2, sourcesContent: T2, ignoreList: S2 } = d2;
            if (append(n3, E2), append(i2, d2.names), T2) append(s2, T2);
            else for (let e5 = 0; e5 < E2.length; e5++) s2.push(null);
            if (S2) for (let e5 = 0; e5 < S2.length; e5++) o2.push(S2[e5] + h2);
            for (let e5 = 0; e5 < v2.length; e5++) {
              const t5 = a2 + e5;
              if (t5 > p2) return;
              const n4 = getLine(r4, t5), s3 = 0 === e5 ? l2 : 0, i3 = v2[e5];
              for (let e6 = 0; e6 < i3.length; e6++) {
                const r5 = i3[e6], o3 = s3 + r5[m];
                if (t5 === p2 && o3 >= c2) return;
                if (1 === r5.length) {
                  n4.push([o3]);
                  continue;
                }
                const a3 = h2 + r5[f], l3 = r5[y], u3 = r5[b];
                n4.push(4 === r5.length ? [o3, a3, l3, u3] : [o3, a3, l3, u3, x2 + r5[g]]);
              }
            }
          }
          function append(e4, t4) {
            for (let r4 = 0; r4 < t4.length; r4++) e4.push(t4[r4]);
          }
          function getLine(e4, t4) {
            for (let r4 = e4.length; r4 <= t4; r4++) e4[r4] = [];
            return e4[t4];
          }
          var T = "`line` must be greater than 0 (lines start at line 1)", S = "`column` must be greater than or equal to 0 (columns start at column 0)", P = -1, _ = 1, A = class {
            constructor(e4, t4) {
              const r4 = "string" == typeof e4;
              if (!r4 && e4._decodedMemo) return e4;
              const n3 = parse(e4), { version: s2, file: i2, names: o2, sourceRoot: a2, sources: l2, sourcesContent: p2 } = n3;
              this.version = s2, this.file = i2, this.names = o2 || [], this.sourceRoot = a2, this.sources = l2, this.sourcesContent = p2, this.ignoreList = n3.ignoreList || n3.x_google_ignoreList || void 0;
              const c2 = resolver(t4, a2);
              this.resolvedSources = l2.map(c2);
              const { mappings: u2 } = n3;
              if ("string" == typeof u2) this._encoded = u2, this._decoded = void 0;
              else {
                if (!Array.isArray(u2)) throw n3.sections ? new Error("TraceMap passed sectioned source map, please use FlattenMap export instead") : new Error(`invalid source map: ${JSON.stringify(n3)}`);
                this._encoded = void 0, this._decoded = maybeSort(u2, r4);
              }
              this._decodedMemo = memoizedState(), this._bySources = void 0, this._bySourceMemos = void 0;
            }
          };
          function cast(e4) {
            return e4;
          }
          function encodedMappings(e4) {
            var t4, r4;
            return null != (r4 = (t4 = cast(e4))._encoded) ? r4 : t4._encoded = (0, d.encode)(cast(e4)._decoded);
          }
          function decodedMappings(e4) {
            var t4;
            return (t4 = cast(e4))._decoded || (t4._decoded = (0, d.decode)(cast(e4)._encoded));
          }
          function traceSegment(e4, t4, r4) {
            const n3 = decodedMappings(e4);
            if (t4 >= n3.length) return null;
            const s2 = n3[t4], i2 = traceSegmentInternal(s2, cast(e4)._decodedMemo, t4, r4, _);
            return -1 === i2 ? null : s2[i2];
          }
          function originalPositionFor(e4, t4) {
            let { line: r4, column: n3, bias: s2 } = t4;
            if (r4--, r4 < 0) throw new Error(T);
            if (n3 < 0) throw new Error(S);
            const i2 = decodedMappings(e4);
            if (r4 >= i2.length) return OMapping(null, null, null, null);
            const o2 = i2[r4], a2 = traceSegmentInternal(o2, cast(e4)._decodedMemo, r4, n3, s2 || _);
            if (-1 === a2) return OMapping(null, null, null, null);
            const l2 = o2[a2];
            if (1 === l2.length) return OMapping(null, null, null, null);
            const { names: p2, resolvedSources: c2 } = e4;
            return OMapping(c2[l2[f]], l2[y] + 1, l2[b], 5 === l2.length ? p2[l2[g]] : null);
          }
          function generatedPositionFor(e4, t4) {
            const { source: r4, line: n3, column: s2, bias: i2 } = t4;
            return generatedPosition(e4, r4, n3, s2, i2 || _, false);
          }
          function allGeneratedPositionsFor(e4, t4) {
            const { source: r4, line: n3, column: s2, bias: i2 } = t4;
            return generatedPosition(e4, r4, n3, s2, i2 || P, true);
          }
          function eachMapping(e4, t4) {
            const r4 = decodedMappings(e4), { names: n3, resolvedSources: s2 } = e4;
            for (let e5 = 0; e5 < r4.length; e5++) {
              const i2 = r4[e5];
              for (let r5 = 0; r5 < i2.length; r5++) {
                const o2 = i2[r5], a2 = e5 + 1, l2 = o2[0];
                let p2 = null, c2 = null, u2 = null, d2 = null;
                1 !== o2.length && (p2 = s2[o2[1]], c2 = o2[2] + 1, u2 = o2[3]), 5 === o2.length && (d2 = n3[o2[4]]), t4({ generatedLine: a2, generatedColumn: l2, source: p2, originalLine: c2, originalColumn: u2, name: d2 });
              }
            }
          }
          function sourceIndex(e4, t4) {
            const { sources: r4, resolvedSources: n3 } = e4;
            let s2 = r4.indexOf(t4);
            return -1 === s2 && (s2 = n3.indexOf(t4)), s2;
          }
          function sourceContentFor(e4, t4) {
            const { sourcesContent: r4 } = e4;
            if (null == r4) return null;
            const n3 = sourceIndex(e4, t4);
            return -1 === n3 ? null : r4[n3];
          }
          function isIgnored(e4, t4) {
            const { ignoreList: r4 } = e4;
            if (null == r4) return false;
            const n3 = sourceIndex(e4, t4);
            return -1 !== n3 && r4.includes(n3);
          }
          function presortedDecodedMap(e4, t4) {
            const r4 = new A(clone(e4, []), t4);
            return cast(r4)._decoded = e4.mappings, r4;
          }
          function decodedMap(e4) {
            return clone(e4, decodedMappings(e4));
          }
          function encodedMap(e4) {
            return clone(e4, encodedMappings(e4));
          }
          function clone(e4, t4) {
            return { version: e4.version, file: e4.file, names: e4.names, sourceRoot: e4.sourceRoot, sources: e4.sources, sourcesContent: e4.sourcesContent, mappings: t4, ignoreList: e4.ignoreList || e4.x_google_ignoreList };
          }
          function OMapping(e4, t4, r4, n3) {
            return { source: e4, line: t4, column: r4, name: n3 };
          }
          function GMapping(e4, t4) {
            return { line: e4, column: t4 };
          }
          function traceSegmentInternal(e4, t4, r4, n3, s2) {
            let i2 = memoizedBinarySearch(e4, n3, t4, r4);
            return E ? i2 = (s2 === P ? upperBound : lowerBound)(e4, n3, i2) : s2 === P && i2++, -1 === i2 || i2 === e4.length ? -1 : i2;
          }
          function sliceGeneratedPositions(e4, t4, r4, n3, s2) {
            let i2 = traceSegmentInternal(e4, t4, r4, n3, _);
            if (E || s2 !== P || i2++, -1 === i2 || i2 === e4.length) return [];
            const o2 = E ? n3 : e4[i2][m];
            E || (i2 = lowerBound(e4, o2, i2));
            const a2 = upperBound(e4, o2, i2), l2 = [];
            for (; i2 <= a2; i2++) {
              const t5 = e4[i2];
              l2.push(GMapping(t5[x] + 1, t5[v]));
            }
            return l2;
          }
          function generatedPosition(e4, t4, r4, n3, s2, i2) {
            var o2, a2;
            if (--r4 < 0) throw new Error(T);
            if (n3 < 0) throw new Error(S);
            const { sources: l2, resolvedSources: p2 } = e4;
            let c2 = l2.indexOf(t4);
            if (-1 === c2 && (c2 = p2.indexOf(t4)), -1 === c2) return i2 ? [] : GMapping(null, null);
            const u2 = (o2 = cast(e4))._bySourceMemos || (o2._bySourceMemos = l2.map(memoizedState)), d2 = ((a2 = cast(e4))._bySources || (a2._bySources = buildBySources(decodedMappings(e4), u2)))[c2][r4];
            if (null == d2) return i2 ? [] : GMapping(null, null);
            const h2 = u2[c2];
            if (i2) return sliceGeneratedPositions(d2, h2, r4, n3, s2);
            const m2 = traceSegmentInternal(d2, h2, r4, n3, s2);
            if (-1 === m2) return GMapping(null, null);
            const f2 = d2[m2];
            return GMapping(f2[x] + 1, f2[v]);
          }
        })(e2 = r2.nmd(e2), r2("./node_modules/.pnpm/@jridgewell+resolve-uri@3.1.2/node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js"), r2("./node_modules/.pnpm/@jridgewell+sourcemap-codec@1.5.5/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js")), e2.exports = "default" in (n = e2).exports ? n.exports.default : n.exports;
      }, "./node_modules/.pnpm/babel-plugin-parameter-decorator@1.0.16/node_modules/babel-plugin-parameter-decorator/lib/index.js": function(e2, t2, r2) {
        "use strict";
        var n = r2("path");
        function isInType(e3) {
          switch (e3.parent.type) {
            case "TSTypeReference":
            case "TSQualifiedName":
            case "TSExpressionWithTypeArguments":
            case "TSTypeQuery":
              return true;
            default:
              return false;
          }
        }
        e2.exports = function(e3) {
          var t3 = e3.types, decoratorExpressionForConstructor = function(e4, r3) {
            return function(n2) {
              var s = t3.callExpression(e4.expression, [t3.Identifier(n2), t3.Identifier("undefined"), t3.NumericLiteral(r3.key)]), i = t3.logicalExpression("||", s, t3.Identifier(n2)), o = t3.assignmentExpression("=", t3.Identifier(n2), i);
              return t3.expressionStatement(o);
            };
          }, decoratorExpressionForMethod = function(e4, r3) {
            return function(n2, s) {
              var i = t3.callExpression(e4.expression, [t3.Identifier("".concat(n2, ".prototype")), t3.StringLiteral(s), t3.NumericLiteral(r3.key)]);
              return t3.expressionStatement(i);
            };
          };
          return { visitor: { Program: function(e4, t4) {
            var r3 = (0, n.extname)(t4.file.opts.filename);
            ".ts" !== r3 && ".tsx" !== r3 || (function() {
              var t5 = /* @__PURE__ */ Object.create(null);
              e4.node.body.filter(function(e5) {
                var t6 = e5.type, r5 = e5.declaration;
                switch (t6) {
                  case "ClassDeclaration":
                    return true;
                  case "ExportNamedDeclaration":
                  case "ExportDefaultDeclaration":
                    return r5 && "ClassDeclaration" === r5.type;
                  default:
                    return false;
                }
              }).map(function(e5) {
                return "ClassDeclaration" === e5.type ? e5 : e5.declaration;
              }).forEach(function(e5) {
                e5.body.body.forEach(function(e6) {
                  (e6.params || []).forEach(function(e7) {
                    (e7.decorators || []).forEach(function(e8) {
                      e8.expression.callee ? t5[e8.expression.callee.name] = e8 : t5[e8.expression.name] = e8;
                    });
                  });
                });
              });
              var r4 = true, n2 = false, s = void 0;
              try {
                for (var i, o = e4.get("body")[Symbol.iterator](); !(r4 = (i = o.next()).done); r4 = true) {
                  var a = i.value;
                  if ("ImportDeclaration" === a.node.type) {
                    if (0 === a.node.specifiers.length) continue;
                    var l = true, p = false, c = void 0;
                    try {
                      for (var u, _loop = function() {
                        var e5 = u.value, r5 = a.scope.getBinding(e5.local.name);
                        r5.referencePaths.length ? r5.referencePaths.reduce(function(e6, t6) {
                          return e6 || isInType(t6);
                        }, false) && Object.keys(t5).forEach(function(n3) {
                          var s2 = t5[n3];
                          (s2.expression.arguments || []).forEach(function(t6) {
                            t6.name === e5.local.name && r5.referencePaths.push({ parent: s2.expression });
                          });
                        }) : t5[e5.local.name] && r5.referencePaths.push({ parent: t5[e5.local.name] });
                      }, d = a.node.specifiers[Symbol.iterator](); !(l = (u = d.next()).done); l = true) _loop();
                    } catch (e5) {
                      p = true, c = e5;
                    } finally {
                      try {
                        l || null == d.return || d.return();
                      } finally {
                        if (p) throw c;
                      }
                    }
                  }
                }
              } catch (e5) {
                n2 = true, s = e5;
              } finally {
                try {
                  r4 || null == o.return || o.return();
                } finally {
                  if (n2) throw s;
                }
              }
            })();
          }, Function: function(e4) {
            var r3 = "";
            e4.node.id ? r3 = e4.node.id.name : e4.node.key && (r3 = e4.node.key.name), (e4.get("params") || []).slice().forEach(function(n2) {
              var s = n2.node.decorators || [], i = s.length;
              if (s.slice().forEach(function(t4) {
                if ("ClassMethod" === e4.type) {
                  var s2, i2 = e4.parentPath.parentPath, o2 = e4.findParent(function(e5) {
                    return "ClassDeclaration" === e5.type;
                  });
                  if (o2 ? s2 = o2.node.id.name : (i2.insertAfter(null), s2 = (function(e5) {
                    var t5 = e5.findParent(function(e6) {
                      return "AssignmentExpression" === e6.node.type;
                    });
                    return "SequenceExpression" === t5.node.right.type ? t5.node.right.expressions[1].name : "ClassExpression" === t5.node.right.type ? t5.node.left.name : null;
                  })(e4)), "constructor" === r3) {
                    var a = decoratorExpressionForConstructor(t4, n2)(s2);
                    i2.insertAfter(a);
                  } else {
                    var l = decoratorExpressionForMethod(t4, n2)(s2, r3);
                    i2.insertAfter(l);
                  }
                } else {
                  var p = e4.findParent(function(e5) {
                    return "VariableDeclarator" === e5.node.type;
                  }).node.id.name;
                  if (r3 === p) {
                    var c = decoratorExpressionForConstructor(t4, n2)(p);
                    if ("body" === e4.parentKey) e4.insertAfter(c);
                    else e4.findParent(function(e5) {
                      return "body" === e5.parentKey;
                    }).insertAfter(c);
                  } else {
                    var u = e4.findParent(function(e5) {
                      return "CallExpression" === e5.node.type;
                    }), d = decoratorExpressionForMethod(t4, n2)(p, r3);
                    u.insertAfter(d);
                  }
                }
              }), i) {
                var o = (function(e5) {
                  switch (e5.node.type) {
                    case "ObjectPattern":
                      return t3.ObjectPattern(e5.node.properties);
                    case "AssignmentPattern":
                      return t3.AssignmentPattern(e5.node.left, e5.node.right);
                    case "TSParameterProperty":
                      return t3.Identifier(e5.node.parameter.name);
                    default:
                      return t3.Identifier(e5.node.name);
                  }
                })(n2);
                n2.replaceWith(o);
              }
            });
          } } };
        };
      }, "./node_modules/.pnpm/convert-source-map@2.0.0/node_modules/convert-source-map/index.js": function(e2, t2) {
        "use strict";
        var r2;
        function Converter(e3, t3) {
          (t3 = t3 || {}).hasComment && (e3 = (function(e4) {
            return e4.split(",").pop();
          })(e3)), "base64" === t3.encoding ? e3 = r2(e3) : "uri" === t3.encoding && (e3 = decodeURIComponent(e3)), (t3.isJSON || t3.encoding) && (e3 = JSON.parse(e3)), this.sourcemap = e3;
        }
        function makeConverter(e3) {
          return new Converter(e3, { isJSON: true });
        }
        Object.defineProperty(t2, "commentRegex", { get: function() {
          return /^\s*?\/[\/\*][@#]\s+?sourceMappingURL=data:(((?:application|text)\/json)(?:;charset=([^;,]+?)?)?)?(?:;(base64))?,(.*?)$/gm;
        } }), Object.defineProperty(t2, "mapFileCommentRegex", { get: function() {
          return /(?:\/\/[@#][ \t]+?sourceMappingURL=([^\s'"`]+?)[ \t]*?$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^*]+?)[ \t]*?(?:\*\/){1}[ \t]*?$)/gm;
        } }), r2 = "undefined" != typeof Buffer ? "function" == typeof Buffer.from ? function(e3) {
          return Buffer.from(e3, "base64").toString();
        } : function(e3) {
          if ("number" == typeof value) throw new TypeError("The value to decode must not be of type number.");
          return new Buffer(e3, "base64").toString();
        } : function(e3) {
          return decodeURIComponent(escape(atob(e3)));
        }, Converter.prototype.toJSON = function(e3) {
          return JSON.stringify(this.sourcemap, null, e3);
        }, "undefined" != typeof Buffer ? "function" == typeof Buffer.from ? Converter.prototype.toBase64 = function() {
          var e3 = this.toJSON();
          return Buffer.from(e3, "utf8").toString("base64");
        } : Converter.prototype.toBase64 = function() {
          var e3 = this.toJSON();
          if ("number" == typeof e3) throw new TypeError("The json to encode must not be of type number.");
          return new Buffer(e3, "utf8").toString("base64");
        } : Converter.prototype.toBase64 = function() {
          var e3 = this.toJSON();
          return btoa(unescape(encodeURIComponent(e3)));
        }, Converter.prototype.toURI = function() {
          var e3 = this.toJSON();
          return encodeURIComponent(e3);
        }, Converter.prototype.toComment = function(e3) {
          var t3, r3, n;
          return null != e3 && "uri" === e3.encoding ? (t3 = "", r3 = this.toURI()) : (t3 = ";base64", r3 = this.toBase64()), n = "sourceMappingURL=data:application/json;charset=utf-8" + t3 + "," + r3, null != e3 && e3.multiline ? "/*# " + n + " */" : "//# " + n;
        }, Converter.prototype.toObject = function() {
          return JSON.parse(this.toJSON());
        }, Converter.prototype.addProperty = function(e3, t3) {
          if (this.sourcemap.hasOwnProperty(e3)) throw new Error('property "' + e3 + '" already exists on the sourcemap, use set property instead');
          return this.setProperty(e3, t3);
        }, Converter.prototype.setProperty = function(e3, t3) {
          return this.sourcemap[e3] = t3, this;
        }, Converter.prototype.getProperty = function(e3) {
          return this.sourcemap[e3];
        }, t2.fromObject = function(e3) {
          return new Converter(e3);
        }, t2.fromJSON = function(e3) {
          return new Converter(e3, { isJSON: true });
        }, t2.fromURI = function(e3) {
          return new Converter(e3, { encoding: "uri" });
        }, t2.fromBase64 = function(e3) {
          return new Converter(e3, { encoding: "base64" });
        }, t2.fromComment = function(e3) {
          var r3;
          return new Converter(e3 = e3.replace(/^\/\*/g, "//").replace(/\*\/$/g, ""), { encoding: (r3 = t2.commentRegex.exec(e3)) && r3[4] || "uri", hasComment: true });
        }, t2.fromMapFileComment = function(e3, r3) {
          if ("string" == typeof r3) throw new Error("String directory paths are no longer supported with `fromMapFileComment`\nPlease review the Upgrading documentation at https://github.com/thlorenz/convert-source-map#upgrading");
          var n = (function(e4, r4) {
            var n2 = t2.mapFileCommentRegex.exec(e4), s = n2[1] || n2[2];
            try {
              return null != (e4 = r4(s)) && "function" == typeof e4.catch ? e4.catch(throwError) : e4;
            } catch (e5) {
              throwError(e5);
            }
            function throwError(e5) {
              throw new Error("An error occurred while trying to read the map file at " + s + "\n" + e5.stack);
            }
          })(e3, r3);
          return null != n && "function" == typeof n.then ? n.then(makeConverter) : makeConverter(n);
        }, t2.fromSource = function(e3) {
          var r3 = e3.match(t2.commentRegex);
          return r3 ? t2.fromComment(r3.pop()) : null;
        }, t2.fromMapFileSource = function(e3, r3) {
          if ("string" == typeof r3) throw new Error("String directory paths are no longer supported with `fromMapFileSource`\nPlease review the Upgrading documentation at https://github.com/thlorenz/convert-source-map#upgrading");
          var n = e3.match(t2.mapFileCommentRegex);
          return n ? t2.fromMapFileComment(n.pop(), r3) : null;
        }, t2.removeComments = function(e3) {
          return e3.replace(t2.commentRegex, "");
        }, t2.removeMapFileComments = function(e3) {
          return e3.replace(t2.mapFileCommentRegex, "");
        }, t2.generateMapFileComment = function(e3, t3) {
          var r3 = "sourceMappingURL=" + e3;
          return t3 && t3.multiline ? "/*# " + r3 + " */" : "//# " + r3;
        };
      }, "./node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/browser.js": function(e2, t2, r2) {
        t2.formatArgs = function(t3) {
          if (t3[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + t3[0] + (this.useColors ? "%c " : " ") + "+" + e2.exports.humanize(this.diff), !this.useColors) return;
          const r3 = "color: " + this.color;
          t3.splice(1, 0, r3, "color: inherit");
          let n2 = 0, s = 0;
          t3[0].replace(/%[a-zA-Z%]/g, (e3) => {
            "%%" !== e3 && (n2++, "%c" === e3 && (s = n2));
          }), t3.splice(s, 0, r3);
        }, t2.save = function(e3) {
          try {
            e3 ? t2.storage.setItem("debug", e3) : t2.storage.removeItem("debug");
          } catch (e4) {
          }
        }, t2.load = function() {
          let e3;
          try {
            e3 = t2.storage.getItem("debug") || t2.storage.getItem("DEBUG");
          } catch (e4) {
          }
          !e3 && "undefined" != typeof process && "env" in process && (e3 = process.env.DEBUG);
          return e3;
        }, t2.useColors = function() {
          if ("undefined" != typeof window && window.process && ("renderer" === window.process.type || window.process.__nwjs)) return true;
          if ("undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) return false;
          let e3;
          return "undefined" != typeof document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || "undefined" != typeof window && window.console && (window.console.firebug || window.console.exception && window.console.table) || "undefined" != typeof navigator && navigator.userAgent && (e3 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(e3[1], 10) >= 31 || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
        }, t2.storage = (function() {
          try {
            return localStorage;
          } catch (e3) {
          }
        })(), t2.destroy = /* @__PURE__ */ (() => {
          let e3 = false;
          return () => {
            e3 || (e3 = true, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
          };
        })(), t2.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"], t2.log = console.debug || console.log || (() => {
        }), e2.exports = r2("./node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/common.js")(t2);
        const { formatters: n } = e2.exports;
        n.j = function(e3) {
          try {
            return JSON.stringify(e3);
          } catch (e4) {
            return "[UnexpectedJSONParseError]: " + e4.message;
          }
        };
      }, "./node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/common.js": function(e2, t2, r2) {
        e2.exports = function(e3) {
          function createDebug(e4) {
            let t3, r3, n, s = null;
            function debug(...e5) {
              if (!debug.enabled) return;
              const r4 = debug, n2 = Number(/* @__PURE__ */ new Date()), s2 = n2 - (t3 || n2);
              r4.diff = s2, r4.prev = t3, r4.curr = n2, t3 = n2, e5[0] = createDebug.coerce(e5[0]), "string" != typeof e5[0] && e5.unshift("%O");
              let i = 0;
              e5[0] = e5[0].replace(/%([a-zA-Z%])/g, (t4, n3) => {
                if ("%%" === t4) return "%";
                i++;
                const s3 = createDebug.formatters[n3];
                if ("function" == typeof s3) {
                  const n4 = e5[i];
                  t4 = s3.call(r4, n4), e5.splice(i, 1), i--;
                }
                return t4;
              }), createDebug.formatArgs.call(r4, e5);
              (r4.log || createDebug.log).apply(r4, e5);
            }
            return debug.namespace = e4, debug.useColors = createDebug.useColors(), debug.color = createDebug.selectColor(e4), debug.extend = extend, debug.destroy = createDebug.destroy, Object.defineProperty(debug, "enabled", { enumerable: true, configurable: false, get: () => null !== s ? s : (r3 !== createDebug.namespaces && (r3 = createDebug.namespaces, n = createDebug.enabled(e4)), n), set: (e5) => {
              s = e5;
            } }), "function" == typeof createDebug.init && createDebug.init(debug), debug;
          }
          function extend(e4, t3) {
            const r3 = createDebug(this.namespace + (void 0 === t3 ? ":" : t3) + e4);
            return r3.log = this.log, r3;
          }
          function matchesTemplate(e4, t3) {
            let r3 = 0, n = 0, s = -1, i = 0;
            for (; r3 < e4.length; ) if (n < t3.length && (t3[n] === e4[r3] || "*" === t3[n])) "*" === t3[n] ? (s = n, i = r3, n++) : (r3++, n++);
            else {
              if (-1 === s) return false;
              n = s + 1, i++, r3 = i;
            }
            for (; n < t3.length && "*" === t3[n]; ) n++;
            return n === t3.length;
          }
          return createDebug.debug = createDebug, createDebug.default = createDebug, createDebug.coerce = function(e4) {
            if (e4 instanceof Error) return e4.stack || e4.message;
            return e4;
          }, createDebug.disable = function() {
            const e4 = [...createDebug.names, ...createDebug.skips.map((e5) => "-" + e5)].join(",");
            return createDebug.enable(""), e4;
          }, createDebug.enable = function(e4) {
            createDebug.save(e4), createDebug.namespaces = e4, createDebug.names = [], createDebug.skips = [];
            const t3 = ("string" == typeof e4 ? e4 : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
            for (const e5 of t3) "-" === e5[0] ? createDebug.skips.push(e5.slice(1)) : createDebug.names.push(e5);
          }, createDebug.enabled = function(e4) {
            for (const t3 of createDebug.skips) if (matchesTemplate(e4, t3)) return false;
            for (const t3 of createDebug.names) if (matchesTemplate(e4, t3)) return true;
            return false;
          }, createDebug.humanize = r2("./node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js"), createDebug.destroy = function() {
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
          }, Object.keys(e3).forEach((t3) => {
            createDebug[t3] = e3[t3];
          }), createDebug.names = [], createDebug.skips = [], createDebug.formatters = {}, createDebug.selectColor = function(e4) {
            let t3 = 0;
            for (let r3 = 0; r3 < e4.length; r3++) t3 = (t3 << 5) - t3 + e4.charCodeAt(r3), t3 |= 0;
            return createDebug.colors[Math.abs(t3) % createDebug.colors.length];
          }, createDebug.enable(createDebug.load()), createDebug;
        };
      }, "./node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/index.js": function(e2, t2, r2) {
        "undefined" == typeof process || "renderer" === process.type || true === process.browser || process.__nwjs ? e2.exports = r2("./node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/browser.js") : e2.exports = r2("./node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/node.js");
      }, "./node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/node.js": function(e2, t2, r2) {
        const n = r2("tty"), s = r2("util");
        t2.init = function(e3) {
          e3.inspectOpts = {};
          const r3 = Object.keys(t2.inspectOpts);
          for (let n2 = 0; n2 < r3.length; n2++) e3.inspectOpts[r3[n2]] = t2.inspectOpts[r3[n2]];
        }, t2.log = function(...e3) {
          return process.stderr.write(s.formatWithOptions(t2.inspectOpts, ...e3) + "\n");
        }, t2.formatArgs = function(r3) {
          const { namespace: n2, useColors: s2 } = this;
          if (s2) {
            const t3 = this.color, s3 = "\x1B[3" + (t3 < 8 ? t3 : "8;5;" + t3), i2 = `  ${s3};1m${n2} \x1B[0m`;
            r3[0] = i2 + r3[0].split("\n").join("\n" + i2), r3.push(s3 + "m+" + e2.exports.humanize(this.diff) + "\x1B[0m");
          } else r3[0] = (function() {
            if (t2.inspectOpts.hideDate) return "";
            return (/* @__PURE__ */ new Date()).toISOString() + " ";
          })() + n2 + " " + r3[0];
        }, t2.save = function(e3) {
          e3 ? process.env.DEBUG = e3 : delete process.env.DEBUG;
        }, t2.load = function() {
          return process.env.DEBUG;
        }, t2.useColors = function() {
          return "colors" in t2.inspectOpts ? Boolean(t2.inspectOpts.colors) : n.isatty(process.stderr.fd);
        }, t2.destroy = s.deprecate(() => {
        }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."), t2.colors = [6, 2, 3, 4, 5, 1];
        try {
          const e3 = r2("./node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js");
          e3 && (e3.stderr || e3).level >= 2 && (t2.colors = [20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221]);
        } catch (e3) {
        }
        t2.inspectOpts = Object.keys(process.env).filter((e3) => /^debug_/i.test(e3)).reduce((e3, t3) => {
          const r3 = t3.substring(6).toLowerCase().replace(/_([a-z])/g, (e4, t4) => t4.toUpperCase());
          let n2 = process.env[t3];
          return n2 = !!/^(yes|on|true|enabled)$/i.test(n2) || !/^(no|off|false|disabled)$/i.test(n2) && ("null" === n2 ? null : Number(n2)), e3[r3] = n2, e3;
        }, {}), e2.exports = r2("./node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/common.js")(t2);
        const { formatters: i } = e2.exports;
        i.o = function(e3) {
          return this.inspectOpts.colors = this.useColors, s.inspect(e3, this.inspectOpts).split("\n").map((e4) => e4.trim()).join(" ");
        }, i.O = function(e3) {
          return this.inspectOpts.colors = this.useColors, s.inspect(e3, this.inspectOpts);
        };
      }, "./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js": function(e2) {
        "use strict";
        const t2 = /* @__PURE__ */ Symbol.for("gensync:v1:start"), r2 = /* @__PURE__ */ Symbol.for("gensync:v1:suspend"), n = "GENSYNC_OPTIONS_ERROR", s = "GENSYNC_RACE_NONEMPTY", i = "GENSYNC_ERRBACK_NO_CALLBACK";
        function assertTypeof(e3, t3, r3, s2) {
          if (typeof r3 === e3 || s2 && void 0 === r3) return;
          let i2;
          throw i2 = s2 ? `Expected opts.${t3} to be either a ${e3}, or undefined.` : `Expected opts.${t3} to be a ${e3}.`, makeError(i2, n);
        }
        function makeError(e3, t3) {
          return Object.assign(new Error(e3), { code: t3 });
        }
        function buildOperation({ name: e3, arity: n2, sync: s2, async: i2 }) {
          return setFunctionMetadata(e3, n2, function* (...e4) {
            const n3 = yield t2;
            if (!n3) {
              return s2.call(this, e4);
            }
            let o;
            try {
              i2.call(this, e4, (e5) => {
                o || (o = { value: e5 }, n3());
              }, (e5) => {
                o || (o = { err: e5 }, n3());
              });
            } catch (e5) {
              o = { err: e5 }, n3();
            }
            if (yield r2, o.hasOwnProperty("err")) throw o.err;
            return o.value;
          });
        }
        function evaluateSync(e3) {
          let t3;
          for (; !({ value: t3 } = e3.next()).done; ) assertStart(t3, e3);
          return t3;
        }
        function evaluateAsync(e3, t3, r3) {
          !(function step() {
            try {
              let r4;
              for (; !({ value: r4 } = e3.next()).done; ) {
                assertStart(r4, e3);
                let t4 = true, n2 = false;
                const s2 = e3.next(() => {
                  t4 ? n2 = true : step();
                });
                if (t4 = false, assertSuspend(s2, e3), !n2) return;
              }
              return t3(r4);
            } catch (e4) {
              return r3(e4);
            }
          })();
        }
        function assertStart(e3, r3) {
          e3 !== t2 && throwError(r3, makeError(`Got unexpected yielded value in gensync generator: ${JSON.stringify(e3)}. Did you perhaps mean to use 'yield*' instead of 'yield'?`, "GENSYNC_EXPECTED_START"));
        }
        function assertSuspend({ value: e3, done: t3 }, n2) {
          (t3 || e3 !== r2) && throwError(n2, makeError(t3 ? "Unexpected generator completion. If you get this, it is probably a gensync bug." : `Expected GENSYNC_SUSPEND, got ${JSON.stringify(e3)}. If you get this, it is probably a gensync bug.`, "GENSYNC_EXPECTED_SUSPEND"));
        }
        function throwError(e3, t3) {
          throw e3.throw && e3.throw(t3), t3;
        }
        function setFunctionMetadata(e3, t3, r3) {
          if ("string" == typeof e3) {
            const t4 = Object.getOwnPropertyDescriptor(r3, "name");
            t4 && !t4.configurable || Object.defineProperty(r3, "name", Object.assign(t4 || {}, { configurable: true, value: e3 }));
          }
          if ("number" == typeof t3) {
            const e4 = Object.getOwnPropertyDescriptor(r3, "length");
            e4 && !e4.configurable || Object.defineProperty(r3, "length", Object.assign(e4 || {}, { configurable: true, value: t3 }));
          }
          return r3;
        }
        e2.exports = Object.assign(function(e3) {
          let t3 = e3;
          return t3 = "function" != typeof e3 ? (function({ name: e4, arity: t4, sync: r3, async: s2, errback: i2 }) {
            if (assertTypeof("string", "name", e4, true), assertTypeof("number", "arity", t4, true), assertTypeof("function", "sync", r3), assertTypeof("function", "async", s2, true), assertTypeof("function", "errback", i2, true), s2 && i2) throw makeError("Expected one of either opts.async or opts.errback, but got _both_.", n);
            if ("string" != typeof e4) {
              let t5;
              i2 && i2.name && "errback" !== i2.name && (t5 = i2.name), s2 && s2.name && "async" !== s2.name && (t5 = s2.name.replace(/Async$/, "")), r3 && r3.name && "sync" !== r3.name && (t5 = r3.name.replace(/Sync$/, "")), "string" == typeof t5 && (e4 = t5);
            }
            "number" != typeof t4 && (t4 = r3.length);
            return buildOperation({ name: e4, arity: t4, sync: function(e5) {
              return r3.apply(this, e5);
            }, async: function(e5, t5, n2) {
              s2 ? s2.apply(this, e5).then(t5, n2) : i2 ? i2.call(this, ...e5, (e6, r4) => {
                null == e6 ? t5(r4) : n2(e6);
              }) : t5(r3.apply(this, e5));
            } });
          })(e3) : (function(e4) {
            return setFunctionMetadata(e4.name, e4.length, function(...t4) {
              return e4.apply(this, t4);
            });
          })(e3), Object.assign(t3, /* @__PURE__ */ (function(e4) {
            const t4 = { sync: function(...t5) {
              return evaluateSync(e4.apply(this, t5));
            }, async: function(...t5) {
              return new Promise((r3, n2) => {
                evaluateAsync(e4.apply(this, t5), r3, n2);
              });
            }, errback: function(...t5) {
              const r3 = t5.pop();
              if ("function" != typeof r3) throw makeError("Asynchronous function called without callback", i);
              let n2;
              try {
                n2 = e4.apply(this, t5);
              } catch (e5) {
                return void r3(e5);
              }
              evaluateAsync(n2, (e5) => r3(void 0, e5), (e5) => r3(e5));
            } };
            return t4;
          })(t3));
        }, { all: buildOperation({ name: "all", arity: 1, sync: function(e3) {
          return Array.from(e3[0]).map((e4) => evaluateSync(e4));
        }, async: function(e3, t3, r3) {
          const n2 = Array.from(e3[0]);
          if (0 === n2.length) return void Promise.resolve().then(() => t3([]));
          let s2 = 0;
          const i2 = n2.map(() => {
          });
          n2.forEach((e4, n3) => {
            evaluateAsync(e4, (e5) => {
              i2[n3] = e5, s2 += 1, s2 === i2.length && t3(i2);
            }, r3);
          });
        } }), race: buildOperation({ name: "race", arity: 1, sync: function(e3) {
          const t3 = Array.from(e3[0]);
          if (0 === t3.length) throw makeError("Must race at least 1 item", s);
          return evaluateSync(t3[0]);
        }, async: function(e3, t3, r3) {
          const n2 = Array.from(e3[0]);
          if (0 === n2.length) throw makeError("Must race at least 1 item", s);
          for (const e4 of n2) evaluateAsync(e4, t3, r3);
        } }) });
      }, "./node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js": function(e2) {
        "use strict";
        e2.exports = (e3, t2 = process.argv) => {
          const r2 = e3.startsWith("-") ? "" : 1 === e3.length ? "-" : "--", n = t2.indexOf(r2 + e3), s = t2.indexOf("--");
          return -1 !== n && (-1 === s || n < s);
        };
      }, "./node_modules/.pnpm/jsesc@3.1.0/node_modules/jsesc/jsesc.js": function(e2) {
        "use strict";
        const t2 = {}, r2 = t2.hasOwnProperty, forOwn = (e3, t3) => {
          for (const n2 in e3) r2.call(e3, n2) && t3(n2, e3[n2]);
        }, fourHexEscape = (e3) => "\\u" + ("0000" + e3).slice(-4), hexadecimal = (e3, t3) => {
          let r3 = e3.toString(16);
          return t3 ? r3 : r3.toUpperCase();
        }, n = t2.toString, s = Array.isArray, isBigInt = (e3) => "bigint" == typeof e3, i = { "\\": "\\\\", "\b": "\\b", "\f": "\\f", "\n": "\\n", "\r": "\\r", "	": "\\t" }, o = /[\\\b\f\n\r\t]/, a = /[0-9]/, l = /[\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/, p = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^]/g, c = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^ !#-&\(-\[\]-_a-~]/g, jsesc = (e3, t3) => {
          const increaseIndentation = () => {
            g = b, ++t3.indentLevel, b = t3.indent.repeat(t3.indentLevel);
          }, r3 = { escapeEverything: false, minimal: false, isScriptContext: false, quotes: "single", wrap: false, es6: false, json: false, compact: true, lowercaseHex: false, numbers: "decimal", indent: "	", indentLevel: 0, __inline1__: false, __inline2__: false }, u = t3 && t3.json;
          var d, h;
          u && (r3.quotes = "double", r3.wrap = true), d = r3, "single" != (t3 = (h = t3) ? (forOwn(h, (e4, t4) => {
            d[e4] = t4;
          }), d) : d).quotes && "double" != t3.quotes && "backtick" != t3.quotes && (t3.quotes = "single");
          const m = "double" == t3.quotes ? '"' : "backtick" == t3.quotes ? "`" : "'", f = t3.compact, y = t3.lowercaseHex;
          let b = t3.indent.repeat(t3.indentLevel), g = "";
          const x = t3.__inline1__, v = t3.__inline2__, E = f ? "" : "\n";
          let T, S = true;
          const P = "binary" == t3.numbers, _ = "octal" == t3.numbers, A = "decimal" == t3.numbers, C = "hexadecimal" == t3.numbers;
          if (u && e3 && /* @__PURE__ */ ((e4) => "function" == typeof e4)(e3.toJSON) && (e3 = e3.toJSON()), !((e4) => "string" == typeof e4 || "[object String]" == n.call(e4))(e3)) {
            if (((e4) => "[object Map]" == n.call(e4))(e3)) return 0 == e3.size ? "new Map()" : (f || (t3.__inline1__ = true, t3.__inline2__ = false), "new Map(" + jsesc(Array.from(e3), t3) + ")");
            if (((e4) => "[object Set]" == n.call(e4))(e3)) return 0 == e3.size ? "new Set()" : "new Set(" + jsesc(Array.from(e3), t3) + ")";
            if (((e4) => "function" == typeof Buffer && Buffer.isBuffer(e4))(e3)) return 0 == e3.length ? "Buffer.from([])" : "Buffer.from(" + jsesc(Array.from(e3), t3) + ")";
            if (s(e3)) return T = [], t3.wrap = true, x && (t3.__inline1__ = false, t3.__inline2__ = true), v || increaseIndentation(), ((e4, t4) => {
              const r4 = e4.length;
              let n2 = -1;
              for (; ++n2 < r4; ) t4(e4[n2]);
            })(e3, (e4) => {
              S = false, v && (t3.__inline2__ = false), T.push((f || v ? "" : b) + jsesc(e4, t3));
            }), S ? "[]" : v ? "[" + T.join(", ") + "]" : "[" + E + T.join("," + E) + E + (f ? "" : g) + "]";
            if (((e4) => "number" == typeof e4 || "[object Number]" == n.call(e4))(e3) || isBigInt(e3)) {
              if (u) return JSON.stringify(Number(e3));
              let t4;
              if (A) t4 = String(e3);
              else if (C) {
                let r4 = e3.toString(16);
                y || (r4 = r4.toUpperCase()), t4 = "0x" + r4;
              } else P ? t4 = "0b" + e3.toString(2) : _ && (t4 = "0o" + e3.toString(8));
              return isBigInt(e3) ? t4 + "n" : t4;
            }
            return isBigInt(e3) ? u ? JSON.stringify(Number(e3)) : e3 + "n" : ((e4) => "[object Object]" == n.call(e4))(e3) ? (T = [], t3.wrap = true, increaseIndentation(), forOwn(e3, (e4, r4) => {
              S = false, T.push((f ? "" : b) + jsesc(e4, t3) + ":" + (f ? "" : " ") + jsesc(r4, t3));
            }), S ? "{}" : "{" + E + T.join("," + E) + E + (f ? "" : g) + "}") : u ? JSON.stringify(e3) || "null" : String(e3);
          }
          const w = t3.escapeEverything ? p : c;
          return T = e3.replace(w, (e4, r4, n2, s2, p2, c2) => {
            if (r4) {
              if (t3.minimal) return r4;
              const e5 = r4.charCodeAt(0), n3 = r4.charCodeAt(1);
              if (t3.es6) {
                return "\\u{" + hexadecimal(1024 * (e5 - 55296) + n3 - 56320 + 65536, y) + "}";
              }
              return fourHexEscape(hexadecimal(e5, y)) + fourHexEscape(hexadecimal(n3, y));
            }
            if (n2) return fourHexEscape(hexadecimal(n2.charCodeAt(0), y));
            if ("\0" == e4 && !u && !a.test(c2.charAt(p2 + 1))) return "\\0";
            if (s2) return s2 == m || t3.escapeEverything ? "\\" + s2 : s2;
            if (o.test(e4)) return i[e4];
            if (t3.minimal && !l.test(e4)) return e4;
            const d2 = hexadecimal(e4.charCodeAt(0), y);
            return u || d2.length > 2 ? fourHexEscape(d2) : "\\x" + ("00" + d2).slice(-2);
          }), "`" == m && (T = T.replace(/\$\{/g, "\\${")), t3.isScriptContext && (T = T.replace(/<\/(script|style)/gi, "<\\/$1").replace(/<!--/g, u ? "\\u003C!--" : "\\x3C!--")), t3.wrap && (T = m + T + m), T;
        };
        jsesc.version = "3.0.2", e2.exports = jsesc;
      }, "./node_modules/.pnpm/mlly@1.8.0/node_modules/mlly/dist lazy recursive": function(e2) {
        function webpackEmptyAsyncContext(e3) {
          return Promise.resolve().then(function() {
            var t2 = new Error("Cannot find module '" + e3 + "'");
            throw t2.code = "MODULE_NOT_FOUND", t2;
          });
        }
        webpackEmptyAsyncContext.keys = () => [], webpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext, webpackEmptyAsyncContext.id = "./node_modules/.pnpm/mlly@1.8.0/node_modules/mlly/dist lazy recursive", e2.exports = webpackEmptyAsyncContext;
      }, "./node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js": function(e2) {
        var t2 = 1e3, r2 = 60 * t2, n = 60 * r2, s = 24 * n, i = 7 * s, o = 365.25 * s;
        function plural(e3, t3, r3, n2) {
          var s2 = t3 >= 1.5 * r3;
          return Math.round(e3 / r3) + " " + n2 + (s2 ? "s" : "");
        }
        e2.exports = function(e3, a) {
          a = a || {};
          var l = typeof e3;
          if ("string" === l && e3.length > 0) return (function(e4) {
            if ((e4 = String(e4)).length > 100) return;
            var a2 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e4);
            if (!a2) return;
            var l2 = parseFloat(a2[1]);
            switch ((a2[2] || "ms").toLowerCase()) {
              case "years":
              case "year":
              case "yrs":
              case "yr":
              case "y":
                return l2 * o;
              case "weeks":
              case "week":
              case "w":
                return l2 * i;
              case "days":
              case "day":
              case "d":
                return l2 * s;
              case "hours":
              case "hour":
              case "hrs":
              case "hr":
              case "h":
                return l2 * n;
              case "minutes":
              case "minute":
              case "mins":
              case "min":
              case "m":
                return l2 * r2;
              case "seconds":
              case "second":
              case "secs":
              case "sec":
              case "s":
                return l2 * t2;
              case "milliseconds":
              case "millisecond":
              case "msecs":
              case "msec":
              case "ms":
                return l2;
              default:
                return;
            }
          })(e3);
          if ("number" === l && isFinite(e3)) return a.long ? (function(e4) {
            var i2 = Math.abs(e4);
            if (i2 >= s) return plural(e4, i2, s, "day");
            if (i2 >= n) return plural(e4, i2, n, "hour");
            if (i2 >= r2) return plural(e4, i2, r2, "minute");
            if (i2 >= t2) return plural(e4, i2, t2, "second");
            return e4 + " ms";
          })(e3) : (function(e4) {
            var i2 = Math.abs(e4);
            if (i2 >= s) return Math.round(e4 / s) + "d";
            if (i2 >= n) return Math.round(e4 / n) + "h";
            if (i2 >= r2) return Math.round(e4 / r2) + "m";
            if (i2 >= t2) return Math.round(e4 / t2) + "s";
            return e4 + "ms";
          })(e3);
          throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(e3));
        };
      }, "./node_modules/.pnpm/semver@6.3.1/node_modules/semver/semver.js": function(e2, t2) {
        var r2;
        t2 = e2.exports = SemVer, r2 = "object" == typeof process && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? function() {
          var e3 = Array.prototype.slice.call(arguments, 0);
          e3.unshift("SEMVER"), console.log.apply(console, e3);
        } : function() {
        }, t2.SEMVER_SPEC_VERSION = "2.0.0";
        var n = 256, s = Number.MAX_SAFE_INTEGER || 9007199254740991, i = n - 6, o = t2.re = [], a = t2.safeRe = [], l = t2.src = [], p = t2.tokens = {}, c = 0;
        function tok(e3) {
          p[e3] = c++;
        }
        var u = "[a-zA-Z0-9-]", d = [["\\s", 1], ["\\d", n], [u, i]];
        function makeSafeRe(e3) {
          for (var t3 = 0; t3 < d.length; t3++) {
            var r3 = d[t3][0], n2 = d[t3][1];
            e3 = e3.split(r3 + "*").join(r3 + "{0," + n2 + "}").split(r3 + "+").join(r3 + "{1," + n2 + "}");
          }
          return e3;
        }
        tok("NUMERICIDENTIFIER"), l[p.NUMERICIDENTIFIER] = "0|[1-9]\\d*", tok("NUMERICIDENTIFIERLOOSE"), l[p.NUMERICIDENTIFIERLOOSE] = "\\d+", tok("NONNUMERICIDENTIFIER"), l[p.NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-]" + u + "*", tok("MAINVERSION"), l[p.MAINVERSION] = "(" + l[p.NUMERICIDENTIFIER] + ")\\.(" + l[p.NUMERICIDENTIFIER] + ")\\.(" + l[p.NUMERICIDENTIFIER] + ")", tok("MAINVERSIONLOOSE"), l[p.MAINVERSIONLOOSE] = "(" + l[p.NUMERICIDENTIFIERLOOSE] + ")\\.(" + l[p.NUMERICIDENTIFIERLOOSE] + ")\\.(" + l[p.NUMERICIDENTIFIERLOOSE] + ")", tok("PRERELEASEIDENTIFIER"), l[p.PRERELEASEIDENTIFIER] = "(?:" + l[p.NUMERICIDENTIFIER] + "|" + l[p.NONNUMERICIDENTIFIER] + ")", tok("PRERELEASEIDENTIFIERLOOSE"), l[p.PRERELEASEIDENTIFIERLOOSE] = "(?:" + l[p.NUMERICIDENTIFIERLOOSE] + "|" + l[p.NONNUMERICIDENTIFIER] + ")", tok("PRERELEASE"), l[p.PRERELEASE] = "(?:-(" + l[p.PRERELEASEIDENTIFIER] + "(?:\\." + l[p.PRERELEASEIDENTIFIER] + ")*))", tok("PRERELEASELOOSE"), l[p.PRERELEASELOOSE] = "(?:-?(" + l[p.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + l[p.PRERELEASEIDENTIFIERLOOSE] + ")*))", tok("BUILDIDENTIFIER"), l[p.BUILDIDENTIFIER] = u + "+", tok("BUILD"), l[p.BUILD] = "(?:\\+(" + l[p.BUILDIDENTIFIER] + "(?:\\." + l[p.BUILDIDENTIFIER] + ")*))", tok("FULL"), tok("FULLPLAIN"), l[p.FULLPLAIN] = "v?" + l[p.MAINVERSION] + l[p.PRERELEASE] + "?" + l[p.BUILD] + "?", l[p.FULL] = "^" + l[p.FULLPLAIN] + "$", tok("LOOSEPLAIN"), l[p.LOOSEPLAIN] = "[v=\\s]*" + l[p.MAINVERSIONLOOSE] + l[p.PRERELEASELOOSE] + "?" + l[p.BUILD] + "?", tok("LOOSE"), l[p.LOOSE] = "^" + l[p.LOOSEPLAIN] + "$", tok("GTLT"), l[p.GTLT] = "((?:<|>)?=?)", tok("XRANGEIDENTIFIERLOOSE"), l[p.XRANGEIDENTIFIERLOOSE] = l[p.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*", tok("XRANGEIDENTIFIER"), l[p.XRANGEIDENTIFIER] = l[p.NUMERICIDENTIFIER] + "|x|X|\\*", tok("XRANGEPLAIN"), l[p.XRANGEPLAIN] = "[v=\\s]*(" + l[p.XRANGEIDENTIFIER] + ")(?:\\.(" + l[p.XRANGEIDENTIFIER] + ")(?:\\.(" + l[p.XRANGEIDENTIFIER] + ")(?:" + l[p.PRERELEASE] + ")?" + l[p.BUILD] + "?)?)?", tok("XRANGEPLAINLOOSE"), l[p.XRANGEPLAINLOOSE] = "[v=\\s]*(" + l[p.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + l[p.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + l[p.XRANGEIDENTIFIERLOOSE] + ")(?:" + l[p.PRERELEASELOOSE] + ")?" + l[p.BUILD] + "?)?)?", tok("XRANGE"), l[p.XRANGE] = "^" + l[p.GTLT] + "\\s*" + l[p.XRANGEPLAIN] + "$", tok("XRANGELOOSE"), l[p.XRANGELOOSE] = "^" + l[p.GTLT] + "\\s*" + l[p.XRANGEPLAINLOOSE] + "$", tok("COERCE"), l[p.COERCE] = "(^|[^\\d])(\\d{1,16})(?:\\.(\\d{1,16}))?(?:\\.(\\d{1,16}))?(?:$|[^\\d])", tok("COERCERTL"), o[p.COERCERTL] = new RegExp(l[p.COERCE], "g"), a[p.COERCERTL] = new RegExp(makeSafeRe(l[p.COERCE]), "g"), tok("LONETILDE"), l[p.LONETILDE] = "(?:~>?)", tok("TILDETRIM"), l[p.TILDETRIM] = "(\\s*)" + l[p.LONETILDE] + "\\s+", o[p.TILDETRIM] = new RegExp(l[p.TILDETRIM], "g"), a[p.TILDETRIM] = new RegExp(makeSafeRe(l[p.TILDETRIM]), "g");
        tok("TILDE"), l[p.TILDE] = "^" + l[p.LONETILDE] + l[p.XRANGEPLAIN] + "$", tok("TILDELOOSE"), l[p.TILDELOOSE] = "^" + l[p.LONETILDE] + l[p.XRANGEPLAINLOOSE] + "$", tok("LONECARET"), l[p.LONECARET] = "(?:\\^)", tok("CARETTRIM"), l[p.CARETTRIM] = "(\\s*)" + l[p.LONECARET] + "\\s+", o[p.CARETTRIM] = new RegExp(l[p.CARETTRIM], "g"), a[p.CARETTRIM] = new RegExp(makeSafeRe(l[p.CARETTRIM]), "g");
        tok("CARET"), l[p.CARET] = "^" + l[p.LONECARET] + l[p.XRANGEPLAIN] + "$", tok("CARETLOOSE"), l[p.CARETLOOSE] = "^" + l[p.LONECARET] + l[p.XRANGEPLAINLOOSE] + "$", tok("COMPARATORLOOSE"), l[p.COMPARATORLOOSE] = "^" + l[p.GTLT] + "\\s*(" + l[p.LOOSEPLAIN] + ")$|^$", tok("COMPARATOR"), l[p.COMPARATOR] = "^" + l[p.GTLT] + "\\s*(" + l[p.FULLPLAIN] + ")$|^$", tok("COMPARATORTRIM"), l[p.COMPARATORTRIM] = "(\\s*)" + l[p.GTLT] + "\\s*(" + l[p.LOOSEPLAIN] + "|" + l[p.XRANGEPLAIN] + ")", o[p.COMPARATORTRIM] = new RegExp(l[p.COMPARATORTRIM], "g"), a[p.COMPARATORTRIM] = new RegExp(makeSafeRe(l[p.COMPARATORTRIM]), "g");
        tok("HYPHENRANGE"), l[p.HYPHENRANGE] = "^\\s*(" + l[p.XRANGEPLAIN] + ")\\s+-\\s+(" + l[p.XRANGEPLAIN] + ")\\s*$", tok("HYPHENRANGELOOSE"), l[p.HYPHENRANGELOOSE] = "^\\s*(" + l[p.XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + l[p.XRANGEPLAINLOOSE] + ")\\s*$", tok("STAR"), l[p.STAR] = "(<|>)?=?\\s*\\*";
        for (var h = 0; h < c; h++) r2(h, l[h]), o[h] || (o[h] = new RegExp(l[h]), a[h] = new RegExp(makeSafeRe(l[h])));
        function parse(e3, t3) {
          if (t3 && "object" == typeof t3 || (t3 = { loose: !!t3, includePrerelease: false }), e3 instanceof SemVer) return e3;
          if ("string" != typeof e3) return null;
          if (e3.length > n) return null;
          if (!(t3.loose ? a[p.LOOSE] : a[p.FULL]).test(e3)) return null;
          try {
            return new SemVer(e3, t3);
          } catch (e4) {
            return null;
          }
        }
        function SemVer(e3, t3) {
          if (t3 && "object" == typeof t3 || (t3 = { loose: !!t3, includePrerelease: false }), e3 instanceof SemVer) {
            if (e3.loose === t3.loose) return e3;
            e3 = e3.version;
          } else if ("string" != typeof e3) throw new TypeError("Invalid Version: " + e3);
          if (e3.length > n) throw new TypeError("version is longer than " + n + " characters");
          if (!(this instanceof SemVer)) return new SemVer(e3, t3);
          r2("SemVer", e3, t3), this.options = t3, this.loose = !!t3.loose;
          var i2 = e3.trim().match(t3.loose ? a[p.LOOSE] : a[p.FULL]);
          if (!i2) throw new TypeError("Invalid Version: " + e3);
          if (this.raw = e3, this.major = +i2[1], this.minor = +i2[2], this.patch = +i2[3], this.major > s || this.major < 0) throw new TypeError("Invalid major version");
          if (this.minor > s || this.minor < 0) throw new TypeError("Invalid minor version");
          if (this.patch > s || this.patch < 0) throw new TypeError("Invalid patch version");
          i2[4] ? this.prerelease = i2[4].split(".").map(function(e4) {
            if (/^[0-9]+$/.test(e4)) {
              var t4 = +e4;
              if (t4 >= 0 && t4 < s) return t4;
            }
            return e4;
          }) : this.prerelease = [], this.build = i2[5] ? i2[5].split(".") : [], this.format();
        }
        t2.parse = parse, t2.valid = function(e3, t3) {
          var r3 = parse(e3, t3);
          return r3 ? r3.version : null;
        }, t2.clean = function(e3, t3) {
          var r3 = parse(e3.trim().replace(/^[=v]+/, ""), t3);
          return r3 ? r3.version : null;
        }, t2.SemVer = SemVer, SemVer.prototype.format = function() {
          return this.version = this.major + "." + this.minor + "." + this.patch, this.prerelease.length && (this.version += "-" + this.prerelease.join(".")), this.version;
        }, SemVer.prototype.toString = function() {
          return this.version;
        }, SemVer.prototype.compare = function(e3) {
          return r2("SemVer.compare", this.version, this.options, e3), e3 instanceof SemVer || (e3 = new SemVer(e3, this.options)), this.compareMain(e3) || this.comparePre(e3);
        }, SemVer.prototype.compareMain = function(e3) {
          return e3 instanceof SemVer || (e3 = new SemVer(e3, this.options)), compareIdentifiers(this.major, e3.major) || compareIdentifiers(this.minor, e3.minor) || compareIdentifiers(this.patch, e3.patch);
        }, SemVer.prototype.comparePre = function(e3) {
          if (e3 instanceof SemVer || (e3 = new SemVer(e3, this.options)), this.prerelease.length && !e3.prerelease.length) return -1;
          if (!this.prerelease.length && e3.prerelease.length) return 1;
          if (!this.prerelease.length && !e3.prerelease.length) return 0;
          var t3 = 0;
          do {
            var n2 = this.prerelease[t3], s2 = e3.prerelease[t3];
            if (r2("prerelease compare", t3, n2, s2), void 0 === n2 && void 0 === s2) return 0;
            if (void 0 === s2) return 1;
            if (void 0 === n2) return -1;
            if (n2 !== s2) return compareIdentifiers(n2, s2);
          } while (++t3);
        }, SemVer.prototype.compareBuild = function(e3) {
          e3 instanceof SemVer || (e3 = new SemVer(e3, this.options));
          var t3 = 0;
          do {
            var n2 = this.build[t3], s2 = e3.build[t3];
            if (r2("prerelease compare", t3, n2, s2), void 0 === n2 && void 0 === s2) return 0;
            if (void 0 === s2) return 1;
            if (void 0 === n2) return -1;
            if (n2 !== s2) return compareIdentifiers(n2, s2);
          } while (++t3);
        }, SemVer.prototype.inc = function(e3, t3) {
          switch (e3) {
            case "premajor":
              this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t3);
              break;
            case "preminor":
              this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t3);
              break;
            case "prepatch":
              this.prerelease.length = 0, this.inc("patch", t3), this.inc("pre", t3);
              break;
            case "prerelease":
              0 === this.prerelease.length && this.inc("patch", t3), this.inc("pre", t3);
              break;
            case "major":
              0 === this.minor && 0 === this.patch && 0 !== this.prerelease.length || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
              break;
            case "minor":
              0 === this.patch && 0 !== this.prerelease.length || this.minor++, this.patch = 0, this.prerelease = [];
              break;
            case "patch":
              0 === this.prerelease.length && this.patch++, this.prerelease = [];
              break;
            case "pre":
              if (0 === this.prerelease.length) this.prerelease = [0];
              else {
                for (var r3 = this.prerelease.length; --r3 >= 0; ) "number" == typeof this.prerelease[r3] && (this.prerelease[r3]++, r3 = -2);
                -1 === r3 && this.prerelease.push(0);
              }
              t3 && (this.prerelease[0] === t3 ? isNaN(this.prerelease[1]) && (this.prerelease = [t3, 0]) : this.prerelease = [t3, 0]);
              break;
            default:
              throw new Error("invalid increment argument: " + e3);
          }
          return this.format(), this.raw = this.version, this;
        }, t2.inc = function(e3, t3, r3, n2) {
          "string" == typeof r3 && (n2 = r3, r3 = void 0);
          try {
            return new SemVer(e3, r3).inc(t3, n2).version;
          } catch (e4) {
            return null;
          }
        }, t2.diff = function(e3, t3) {
          if (eq(e3, t3)) return null;
          var r3 = parse(e3), n2 = parse(t3), s2 = "";
          if (r3.prerelease.length || n2.prerelease.length) {
            s2 = "pre";
            var i2 = "prerelease";
          }
          for (var o2 in r3) if (("major" === o2 || "minor" === o2 || "patch" === o2) && r3[o2] !== n2[o2]) return s2 + o2;
          return i2;
        }, t2.compareIdentifiers = compareIdentifiers;
        var m = /^[0-9]+$/;
        function compareIdentifiers(e3, t3) {
          var r3 = m.test(e3), n2 = m.test(t3);
          return r3 && n2 && (e3 = +e3, t3 = +t3), e3 === t3 ? 0 : r3 && !n2 ? -1 : n2 && !r3 ? 1 : e3 < t3 ? -1 : 1;
        }
        function compare(e3, t3, r3) {
          return new SemVer(e3, r3).compare(new SemVer(t3, r3));
        }
        function gt(e3, t3, r3) {
          return compare(e3, t3, r3) > 0;
        }
        function lt(e3, t3, r3) {
          return compare(e3, t3, r3) < 0;
        }
        function eq(e3, t3, r3) {
          return 0 === compare(e3, t3, r3);
        }
        function neq(e3, t3, r3) {
          return 0 !== compare(e3, t3, r3);
        }
        function gte(e3, t3, r3) {
          return compare(e3, t3, r3) >= 0;
        }
        function lte(e3, t3, r3) {
          return compare(e3, t3, r3) <= 0;
        }
        function cmp(e3, t3, r3, n2) {
          switch (t3) {
            case "===":
              return "object" == typeof e3 && (e3 = e3.version), "object" == typeof r3 && (r3 = r3.version), e3 === r3;
            case "!==":
              return "object" == typeof e3 && (e3 = e3.version), "object" == typeof r3 && (r3 = r3.version), e3 !== r3;
            case "":
            case "=":
            case "==":
              return eq(e3, r3, n2);
            case "!=":
              return neq(e3, r3, n2);
            case ">":
              return gt(e3, r3, n2);
            case ">=":
              return gte(e3, r3, n2);
            case "<":
              return lt(e3, r3, n2);
            case "<=":
              return lte(e3, r3, n2);
            default:
              throw new TypeError("Invalid operator: " + t3);
          }
        }
        function Comparator(e3, t3) {
          if (t3 && "object" == typeof t3 || (t3 = { loose: !!t3, includePrerelease: false }), e3 instanceof Comparator) {
            if (e3.loose === !!t3.loose) return e3;
            e3 = e3.value;
          }
          if (!(this instanceof Comparator)) return new Comparator(e3, t3);
          e3 = e3.trim().split(/\s+/).join(" "), r2("comparator", e3, t3), this.options = t3, this.loose = !!t3.loose, this.parse(e3), this.semver === f ? this.value = "" : this.value = this.operator + this.semver.version, r2("comp", this);
        }
        t2.rcompareIdentifiers = function(e3, t3) {
          return compareIdentifiers(t3, e3);
        }, t2.major = function(e3, t3) {
          return new SemVer(e3, t3).major;
        }, t2.minor = function(e3, t3) {
          return new SemVer(e3, t3).minor;
        }, t2.patch = function(e3, t3) {
          return new SemVer(e3, t3).patch;
        }, t2.compare = compare, t2.compareLoose = function(e3, t3) {
          return compare(e3, t3, true);
        }, t2.compareBuild = function(e3, t3, r3) {
          var n2 = new SemVer(e3, r3), s2 = new SemVer(t3, r3);
          return n2.compare(s2) || n2.compareBuild(s2);
        }, t2.rcompare = function(e3, t3, r3) {
          return compare(t3, e3, r3);
        }, t2.sort = function(e3, r3) {
          return e3.sort(function(e4, n2) {
            return t2.compareBuild(e4, n2, r3);
          });
        }, t2.rsort = function(e3, r3) {
          return e3.sort(function(e4, n2) {
            return t2.compareBuild(n2, e4, r3);
          });
        }, t2.gt = gt, t2.lt = lt, t2.eq = eq, t2.neq = neq, t2.gte = gte, t2.lte = lte, t2.cmp = cmp, t2.Comparator = Comparator;
        var f = {};
        function Range(e3, t3) {
          if (t3 && "object" == typeof t3 || (t3 = { loose: !!t3, includePrerelease: false }), e3 instanceof Range) return e3.loose === !!t3.loose && e3.includePrerelease === !!t3.includePrerelease ? e3 : new Range(e3.raw, t3);
          if (e3 instanceof Comparator) return new Range(e3.value, t3);
          if (!(this instanceof Range)) return new Range(e3, t3);
          if (this.options = t3, this.loose = !!t3.loose, this.includePrerelease = !!t3.includePrerelease, this.raw = e3.trim().split(/\s+/).join(" "), this.set = this.raw.split("||").map(function(e4) {
            return this.parseRange(e4.trim());
          }, this).filter(function(e4) {
            return e4.length;
          }), !this.set.length) throw new TypeError("Invalid SemVer Range: " + this.raw);
          this.format();
        }
        function isSatisfiable(e3, t3) {
          for (var r3 = true, n2 = e3.slice(), s2 = n2.pop(); r3 && n2.length; ) r3 = n2.every(function(e4) {
            return s2.intersects(e4, t3);
          }), s2 = n2.pop();
          return r3;
        }
        function isX(e3) {
          return !e3 || "x" === e3.toLowerCase() || "*" === e3;
        }
        function hyphenReplace(e3, t3, r3, n2, s2, i2, o2, a2, l2, p2, c2, u2, d2) {
          return ((t3 = isX(r3) ? "" : isX(n2) ? ">=" + r3 + ".0.0" : isX(s2) ? ">=" + r3 + "." + n2 + ".0" : ">=" + t3) + " " + (a2 = isX(l2) ? "" : isX(p2) ? "<" + (+l2 + 1) + ".0.0" : isX(c2) ? "<" + l2 + "." + (+p2 + 1) + ".0" : u2 ? "<=" + l2 + "." + p2 + "." + c2 + "-" + u2 : "<=" + a2)).trim();
        }
        function testSet(e3, t3, n2) {
          for (var s2 = 0; s2 < e3.length; s2++) if (!e3[s2].test(t3)) return false;
          if (t3.prerelease.length && !n2.includePrerelease) {
            for (s2 = 0; s2 < e3.length; s2++) if (r2(e3[s2].semver), e3[s2].semver !== f && e3[s2].semver.prerelease.length > 0) {
              var i2 = e3[s2].semver;
              if (i2.major === t3.major && i2.minor === t3.minor && i2.patch === t3.patch) return true;
            }
            return false;
          }
          return true;
        }
        function satisfies(e3, t3, r3) {
          try {
            t3 = new Range(t3, r3);
          } catch (e4) {
            return false;
          }
          return t3.test(e3);
        }
        function outside(e3, t3, r3, n2) {
          var s2, i2, o2, a2, l2;
          switch (e3 = new SemVer(e3, n2), t3 = new Range(t3, n2), r3) {
            case ">":
              s2 = gt, i2 = lte, o2 = lt, a2 = ">", l2 = ">=";
              break;
            case "<":
              s2 = lt, i2 = gte, o2 = gt, a2 = "<", l2 = "<=";
              break;
            default:
              throw new TypeError('Must provide a hilo val of "<" or ">"');
          }
          if (satisfies(e3, t3, n2)) return false;
          for (var p2 = 0; p2 < t3.set.length; ++p2) {
            var c2 = t3.set[p2], u2 = null, d2 = null;
            if (c2.forEach(function(e4) {
              e4.semver === f && (e4 = new Comparator(">=0.0.0")), u2 = u2 || e4, d2 = d2 || e4, s2(e4.semver, u2.semver, n2) ? u2 = e4 : o2(e4.semver, d2.semver, n2) && (d2 = e4);
            }), u2.operator === a2 || u2.operator === l2) return false;
            if ((!d2.operator || d2.operator === a2) && i2(e3, d2.semver)) return false;
            if (d2.operator === l2 && o2(e3, d2.semver)) return false;
          }
          return true;
        }
        Comparator.prototype.parse = function(e3) {
          var t3 = this.options.loose ? a[p.COMPARATORLOOSE] : a[p.COMPARATOR], r3 = e3.match(t3);
          if (!r3) throw new TypeError("Invalid comparator: " + e3);
          this.operator = void 0 !== r3[1] ? r3[1] : "", "=" === this.operator && (this.operator = ""), r3[2] ? this.semver = new SemVer(r3[2], this.options.loose) : this.semver = f;
        }, Comparator.prototype.toString = function() {
          return this.value;
        }, Comparator.prototype.test = function(e3) {
          if (r2("Comparator.test", e3, this.options.loose), this.semver === f || e3 === f) return true;
          if ("string" == typeof e3) try {
            e3 = new SemVer(e3, this.options);
          } catch (e4) {
            return false;
          }
          return cmp(e3, this.operator, this.semver, this.options);
        }, Comparator.prototype.intersects = function(e3, t3) {
          if (!(e3 instanceof Comparator)) throw new TypeError("a Comparator is required");
          var r3;
          if (t3 && "object" == typeof t3 || (t3 = { loose: !!t3, includePrerelease: false }), "" === this.operator) return "" === this.value || (r3 = new Range(e3.value, t3), satisfies(this.value, r3, t3));
          if ("" === e3.operator) return "" === e3.value || (r3 = new Range(this.value, t3), satisfies(e3.semver, r3, t3));
          var n2 = !(">=" !== this.operator && ">" !== this.operator || ">=" !== e3.operator && ">" !== e3.operator), s2 = !("<=" !== this.operator && "<" !== this.operator || "<=" !== e3.operator && "<" !== e3.operator), i2 = this.semver.version === e3.semver.version, o2 = !(">=" !== this.operator && "<=" !== this.operator || ">=" !== e3.operator && "<=" !== e3.operator), a2 = cmp(this.semver, "<", e3.semver, t3) && (">=" === this.operator || ">" === this.operator) && ("<=" === e3.operator || "<" === e3.operator), l2 = cmp(this.semver, ">", e3.semver, t3) && ("<=" === this.operator || "<" === this.operator) && (">=" === e3.operator || ">" === e3.operator);
          return n2 || s2 || i2 && o2 || a2 || l2;
        }, t2.Range = Range, Range.prototype.format = function() {
          return this.range = this.set.map(function(e3) {
            return e3.join(" ").trim();
          }).join("||").trim(), this.range;
        }, Range.prototype.toString = function() {
          return this.range;
        }, Range.prototype.parseRange = function(e3) {
          var t3 = this.options.loose, n2 = t3 ? a[p.HYPHENRANGELOOSE] : a[p.HYPHENRANGE];
          e3 = e3.replace(n2, hyphenReplace), r2("hyphen replace", e3), e3 = e3.replace(a[p.COMPARATORTRIM], "$1$2$3"), r2("comparator trim", e3, a[p.COMPARATORTRIM]), e3 = (e3 = (e3 = e3.replace(a[p.TILDETRIM], "$1~")).replace(a[p.CARETTRIM], "$1^")).split(/\s+/).join(" ");
          var s2 = t3 ? a[p.COMPARATORLOOSE] : a[p.COMPARATOR], i2 = e3.split(" ").map(function(e4) {
            return (function(e5, t4) {
              return r2("comp", e5, t4), e5 = (function(e6, t5) {
                return e6.trim().split(/\s+/).map(function(e7) {
                  return (function(e8, t6) {
                    r2("caret", e8, t6);
                    var n3 = t6.loose ? a[p.CARETLOOSE] : a[p.CARET];
                    return e8.replace(n3, function(t7, n4, s3, i3, o2) {
                      var a2;
                      return r2("caret", e8, t7, n4, s3, i3, o2), isX(n4) ? a2 = "" : isX(s3) ? a2 = ">=" + n4 + ".0.0 <" + (+n4 + 1) + ".0.0" : isX(i3) ? a2 = "0" === n4 ? ">=" + n4 + "." + s3 + ".0 <" + n4 + "." + (+s3 + 1) + ".0" : ">=" + n4 + "." + s3 + ".0 <" + (+n4 + 1) + ".0.0" : o2 ? (r2("replaceCaret pr", o2), a2 = "0" === n4 ? "0" === s3 ? ">=" + n4 + "." + s3 + "." + i3 + "-" + o2 + " <" + n4 + "." + s3 + "." + (+i3 + 1) : ">=" + n4 + "." + s3 + "." + i3 + "-" + o2 + " <" + n4 + "." + (+s3 + 1) + ".0" : ">=" + n4 + "." + s3 + "." + i3 + "-" + o2 + " <" + (+n4 + 1) + ".0.0") : (r2("no pr"), a2 = "0" === n4 ? "0" === s3 ? ">=" + n4 + "." + s3 + "." + i3 + " <" + n4 + "." + s3 + "." + (+i3 + 1) : ">=" + n4 + "." + s3 + "." + i3 + " <" + n4 + "." + (+s3 + 1) + ".0" : ">=" + n4 + "." + s3 + "." + i3 + " <" + (+n4 + 1) + ".0.0"), r2("caret return", a2), a2;
                    });
                  })(e7, t5);
                }).join(" ");
              })(e5, t4), r2("caret", e5), e5 = (function(e6, t5) {
                return e6.trim().split(/\s+/).map(function(e7) {
                  return (function(e8, t6) {
                    var n3 = t6.loose ? a[p.TILDELOOSE] : a[p.TILDE];
                    return e8.replace(n3, function(t7, n4, s3, i3, o2) {
                      var a2;
                      return r2("tilde", e8, t7, n4, s3, i3, o2), isX(n4) ? a2 = "" : isX(s3) ? a2 = ">=" + n4 + ".0.0 <" + (+n4 + 1) + ".0.0" : isX(i3) ? a2 = ">=" + n4 + "." + s3 + ".0 <" + n4 + "." + (+s3 + 1) + ".0" : o2 ? (r2("replaceTilde pr", o2), a2 = ">=" + n4 + "." + s3 + "." + i3 + "-" + o2 + " <" + n4 + "." + (+s3 + 1) + ".0") : a2 = ">=" + n4 + "." + s3 + "." + i3 + " <" + n4 + "." + (+s3 + 1) + ".0", r2("tilde return", a2), a2;
                    });
                  })(e7, t5);
                }).join(" ");
              })(e5, t4), r2("tildes", e5), e5 = (function(e6, t5) {
                return r2("replaceXRanges", e6, t5), e6.split(/\s+/).map(function(e7) {
                  return (function(e8, t6) {
                    e8 = e8.trim();
                    var n3 = t6.loose ? a[p.XRANGELOOSE] : a[p.XRANGE];
                    return e8.replace(n3, function(n4, s3, i3, o2, a2, l2) {
                      r2("xRange", e8, n4, s3, i3, o2, a2, l2);
                      var p2 = isX(i3), c2 = p2 || isX(o2), u2 = c2 || isX(a2), d2 = u2;
                      return "=" === s3 && d2 && (s3 = ""), l2 = t6.includePrerelease ? "-0" : "", p2 ? n4 = ">" === s3 || "<" === s3 ? "<0.0.0-0" : "*" : s3 && d2 ? (c2 && (o2 = 0), a2 = 0, ">" === s3 ? (s3 = ">=", c2 ? (i3 = +i3 + 1, o2 = 0, a2 = 0) : (o2 = +o2 + 1, a2 = 0)) : "<=" === s3 && (s3 = "<", c2 ? i3 = +i3 + 1 : o2 = +o2 + 1), n4 = s3 + i3 + "." + o2 + "." + a2 + l2) : c2 ? n4 = ">=" + i3 + ".0.0" + l2 + " <" + (+i3 + 1) + ".0.0" + l2 : u2 && (n4 = ">=" + i3 + "." + o2 + ".0" + l2 + " <" + i3 + "." + (+o2 + 1) + ".0" + l2), r2("xRange return", n4), n4;
                    });
                  })(e7, t5);
                }).join(" ");
              })(e5, t4), r2("xrange", e5), e5 = (function(e6, t5) {
                return r2("replaceStars", e6, t5), e6.trim().replace(a[p.STAR], "");
              })(e5, t4), r2("stars", e5), e5;
            })(e4, this.options);
          }, this).join(" ").split(/\s+/);
          return this.options.loose && (i2 = i2.filter(function(e4) {
            return !!e4.match(s2);
          })), i2 = i2.map(function(e4) {
            return new Comparator(e4, this.options);
          }, this);
        }, Range.prototype.intersects = function(e3, t3) {
          if (!(e3 instanceof Range)) throw new TypeError("a Range is required");
          return this.set.some(function(r3) {
            return isSatisfiable(r3, t3) && e3.set.some(function(e4) {
              return isSatisfiable(e4, t3) && r3.every(function(r4) {
                return e4.every(function(e5) {
                  return r4.intersects(e5, t3);
                });
              });
            });
          });
        }, t2.toComparators = function(e3, t3) {
          return new Range(e3, t3).set.map(function(e4) {
            return e4.map(function(e5) {
              return e5.value;
            }).join(" ").trim().split(" ");
          });
        }, Range.prototype.test = function(e3) {
          if (!e3) return false;
          if ("string" == typeof e3) try {
            e3 = new SemVer(e3, this.options);
          } catch (e4) {
            return false;
          }
          for (var t3 = 0; t3 < this.set.length; t3++) if (testSet(this.set[t3], e3, this.options)) return true;
          return false;
        }, t2.satisfies = satisfies, t2.maxSatisfying = function(e3, t3, r3) {
          var n2 = null, s2 = null;
          try {
            var i2 = new Range(t3, r3);
          } catch (e4) {
            return null;
          }
          return e3.forEach(function(e4) {
            i2.test(e4) && (n2 && -1 !== s2.compare(e4) || (s2 = new SemVer(n2 = e4, r3)));
          }), n2;
        }, t2.minSatisfying = function(e3, t3, r3) {
          var n2 = null, s2 = null;
          try {
            var i2 = new Range(t3, r3);
          } catch (e4) {
            return null;
          }
          return e3.forEach(function(e4) {
            i2.test(e4) && (n2 && 1 !== s2.compare(e4) || (s2 = new SemVer(n2 = e4, r3)));
          }), n2;
        }, t2.minVersion = function(e3, t3) {
          e3 = new Range(e3, t3);
          var r3 = new SemVer("0.0.0");
          if (e3.test(r3)) return r3;
          if (r3 = new SemVer("0.0.0-0"), e3.test(r3)) return r3;
          r3 = null;
          for (var n2 = 0; n2 < e3.set.length; ++n2) {
            e3.set[n2].forEach(function(e4) {
              var t4 = new SemVer(e4.semver.version);
              switch (e4.operator) {
                case ">":
                  0 === t4.prerelease.length ? t4.patch++ : t4.prerelease.push(0), t4.raw = t4.format();
                case "":
                case ">=":
                  r3 && !gt(r3, t4) || (r3 = t4);
                  break;
                case "<":
                case "<=":
                  break;
                default:
                  throw new Error("Unexpected operation: " + e4.operator);
              }
            });
          }
          if (r3 && e3.test(r3)) return r3;
          return null;
        }, t2.validRange = function(e3, t3) {
          try {
            return new Range(e3, t3).range || "*";
          } catch (e4) {
            return null;
          }
        }, t2.ltr = function(e3, t3, r3) {
          return outside(e3, t3, "<", r3);
        }, t2.gtr = function(e3, t3, r3) {
          return outside(e3, t3, ">", r3);
        }, t2.outside = outside, t2.prerelease = function(e3, t3) {
          var r3 = parse(e3, t3);
          return r3 && r3.prerelease.length ? r3.prerelease : null;
        }, t2.intersects = function(e3, t3, r3) {
          return e3 = new Range(e3, r3), t3 = new Range(t3, r3), e3.intersects(t3);
        }, t2.coerce = function(e3, t3) {
          if (e3 instanceof SemVer) return e3;
          "number" == typeof e3 && (e3 = String(e3));
          if ("string" != typeof e3) return null;
          var r3 = null;
          if ((t3 = t3 || {}).rtl) {
            for (var n2; (n2 = a[p.COERCERTL].exec(e3)) && (!r3 || r3.index + r3[0].length !== e3.length); ) r3 && n2.index + n2[0].length === r3.index + r3[0].length || (r3 = n2), a[p.COERCERTL].lastIndex = n2.index + n2[1].length + n2[2].length;
            a[p.COERCERTL].lastIndex = -1;
          } else r3 = e3.match(a[p.COERCE]);
          if (null === r3) return null;
          return parse(r3[2] + "." + (r3[3] || "0") + "." + (r3[4] || "0"), t3);
        };
      }, "./node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js": function(e2, t2, r2) {
        "use strict";
        const n = r2("os"), s = r2("tty"), i = r2("./node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js"), { env: o } = process;
        let a;
        function translateLevel(e3) {
          return 0 !== e3 && { level: e3, hasBasic: true, has256: e3 >= 2, has16m: e3 >= 3 };
        }
        function supportsColor(e3, t3) {
          if (0 === a) return 0;
          if (i("color=16m") || i("color=full") || i("color=truecolor")) return 3;
          if (i("color=256")) return 2;
          if (e3 && !t3 && void 0 === a) return 0;
          const r3 = a || 0;
          if ("dumb" === o.TERM) return r3;
          if ("win32" === process.platform) {
            const e4 = n.release().split(".");
            return Number(e4[0]) >= 10 && Number(e4[2]) >= 10586 ? Number(e4[2]) >= 14931 ? 3 : 2 : 1;
          }
          if ("CI" in o) return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((e4) => e4 in o) || "codeship" === o.CI_NAME ? 1 : r3;
          if ("TEAMCITY_VERSION" in o) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(o.TEAMCITY_VERSION) ? 1 : 0;
          if ("truecolor" === o.COLORTERM) return 3;
          if ("TERM_PROGRAM" in o) {
            const e4 = parseInt((o.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
            switch (o.TERM_PROGRAM) {
              case "iTerm.app":
                return e4 >= 3 ? 3 : 2;
              case "Apple_Terminal":
                return 2;
            }
          }
          return /-256(color)?$/i.test(o.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(o.TERM) || "COLORTERM" in o ? 1 : r3;
        }
        i("no-color") || i("no-colors") || i("color=false") || i("color=never") ? a = 0 : (i("color") || i("colors") || i("color=true") || i("color=always")) && (a = 1), "FORCE_COLOR" in o && (a = "true" === o.FORCE_COLOR ? 1 : "false" === o.FORCE_COLOR ? 0 : 0 === o.FORCE_COLOR.length ? 1 : Math.min(parseInt(o.FORCE_COLOR, 10), 3)), e2.exports = { supportsColor: function(e3) {
          return translateLevel(supportsColor(e3, e3 && e3.isTTY));
        }, stdout: translateLevel(supportsColor(true, s.isatty(1))), stderr: translateLevel(supportsColor(true, s.isatty(2))) };
      }, assert: function(e2) {
        "use strict";
        e2.exports = require("assert");
      }, fs: function(e2) {
        "use strict";
        e2.exports = require("fs");
      }, module: function(e2) {
        "use strict";
        e2.exports = require("module");
      }, os: function(e2) {
        "use strict";
        e2.exports = require("os");
      }, path: function(e2) {
        "use strict";
        e2.exports = require("path");
      }, process: function(e2) {
        "use strict";
        e2.exports = require("process");
      }, tty: function(e2) {
        "use strict";
        e2.exports = require("tty");
      }, url: function(e2) {
        "use strict";
        e2.exports = require("url");
      }, util: function(e2) {
        "use strict";
        e2.exports = require("util");
      }, v8: function(e2) {
        "use strict";
        e2.exports = require("v8");
      }, "./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/caching.js": function(e2, t2, r2) {
        "use strict";
        function _gensync() {
          const e3 = r2("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return _gensync = function() {
            return e3;
          }, e3;
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.assertSimpleType = assertSimpleType, t2.makeStrongCache = makeStrongCache, t2.makeStrongCacheSync = function(e3) {
          return synchronize(makeStrongCache(e3));
        }, t2.makeWeakCache = makeWeakCache, t2.makeWeakCacheSync = function(e3) {
          return synchronize(makeWeakCache(e3));
        };
        var n = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/gensync-utils/async.js"), s = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/util.js");
        const synchronize = (e3) => _gensync()(e3).sync;
        function* genTrue() {
          return true;
        }
        function makeWeakCache(e3) {
          return makeCachedFunction(WeakMap, e3);
        }
        function makeStrongCache(e3) {
          return makeCachedFunction(Map, e3);
        }
        function makeCachedFunction(e3, t3) {
          const r3 = new e3(), i = new e3(), o = new e3();
          return function* (e4, a) {
            const l = yield* (0, n.isAsync)(), p = l ? i : r3, c = yield* (function* (e5, t4, r4, s2, i2) {
              const o2 = yield* getCachedValue(t4, s2, i2);
              if (o2.valid) return o2;
              if (e5) {
                const e6 = yield* getCachedValue(r4, s2, i2);
                if (e6.valid) {
                  return { valid: true, value: yield* (0, n.waitFor)(e6.value.promise) };
                }
              }
              return { valid: false, value: null };
            })(l, p, o, e4, a);
            if (c.valid) return c.value;
            const u = new CacheConfigurator(a), d = t3(e4, u);
            let h, m;
            return m = (0, s.isIterableIterator)(d) ? yield* (0, n.onFirstPause)(d, () => {
              h = (function(e5, t4, r4) {
                const n2 = new Lock();
                return updateFunctionCache(t4, e5, r4, n2), n2;
              })(u, o, e4);
            }) : d, updateFunctionCache(p, u, e4, m), h && (o.delete(e4), h.release(m)), m;
          };
        }
        function* getCachedValue(e3, t3, r3) {
          const n2 = e3.get(t3);
          if (n2) {
            for (const { value: e4, valid: t4 } of n2) if (yield* t4(r3)) return { valid: true, value: e4 };
          }
          return { valid: false, value: null };
        }
        function updateFunctionCache(e3, t3, r3, n2) {
          t3.configured() || t3.forever();
          let s2 = e3.get(r3);
          switch (t3.deactivate(), t3.mode()) {
            case "forever":
              s2 = [{ value: n2, valid: genTrue }], e3.set(r3, s2);
              break;
            case "invalidate":
              s2 = [{ value: n2, valid: t3.validator() }], e3.set(r3, s2);
              break;
            case "valid":
              s2 ? s2.push({ value: n2, valid: t3.validator() }) : (s2 = [{ value: n2, valid: t3.validator() }], e3.set(r3, s2));
          }
        }
        class CacheConfigurator {
          constructor(e3) {
            this._active = true, this._never = false, this._forever = false, this._invalidate = false, this._configured = false, this._pairs = [], this._data = void 0, this._data = e3;
          }
          simple() {
            return (function(e3) {
              function cacheFn(t3) {
                if ("boolean" != typeof t3) return e3.using(() => assertSimpleType(t3()));
                t3 ? e3.forever() : e3.never();
              }
              return cacheFn.forever = () => e3.forever(), cacheFn.never = () => e3.never(), cacheFn.using = (t3) => e3.using(() => assertSimpleType(t3())), cacheFn.invalidate = (t3) => e3.invalidate(() => assertSimpleType(t3())), cacheFn;
            })(this);
          }
          mode() {
            return this._never ? "never" : this._forever ? "forever" : this._invalidate ? "invalidate" : "valid";
          }
          forever() {
            if (!this._active) throw new Error("Cannot change caching after evaluation has completed.");
            if (this._never) throw new Error("Caching has already been configured with .never()");
            this._forever = true, this._configured = true;
          }
          never() {
            if (!this._active) throw new Error("Cannot change caching after evaluation has completed.");
            if (this._forever) throw new Error("Caching has already been configured with .forever()");
            this._never = true, this._configured = true;
          }
          using(e3) {
            if (!this._active) throw new Error("Cannot change caching after evaluation has completed.");
            if (this._never || this._forever) throw new Error("Caching has already been configured with .never or .forever()");
            this._configured = true;
            const t3 = e3(this._data), r3 = (0, n.maybeAsync)(e3, "You appear to be using an async cache handler, but Babel has been called synchronously");
            return (0, n.isThenable)(t3) ? t3.then((e4) => (this._pairs.push([e4, r3]), e4)) : (this._pairs.push([t3, r3]), t3);
          }
          invalidate(e3) {
            return this._invalidate = true, this.using(e3);
          }
          validator() {
            const e3 = this._pairs;
            return function* (t3) {
              for (const [r3, n2] of e3) if (r3 !== (yield* n2(t3))) return false;
              return true;
            };
          }
          deactivate() {
            this._active = false;
          }
          configured() {
            return this._configured;
          }
        }
        function assertSimpleType(e3) {
          if ((0, n.isThenable)(e3)) throw new Error("You appear to be using an async cache handler, which your current version of Babel does not support. We may add support for this in the future, but if you're on the most recent version of @babel/core and still seeing this error, then you'll need to synchronously handle your caching logic.");
          if (null != e3 && "string" != typeof e3 && "boolean" != typeof e3 && "number" != typeof e3) throw new Error("Cache keys must be either string, boolean, number, null, or undefined.");
          return e3;
        }
        class Lock {
          constructor() {
            this.released = false, this.promise = void 0, this._resolve = void 0, this.promise = new Promise((e3) => {
              this._resolve = e3;
            });
          }
          release(e3) {
            this.released = true, this._resolve(e3);
          }
        }
      }, "./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/config-chain.js": function(e2, t2, r2) {
        "use strict";
        function _path() {
          const e3 = r2("path");
          return _path = function() {
            return e3;
          }, e3;
        }
        function _debug() {
          const e3 = r2("./node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/index.js");
          return _debug = function() {
            return e3;
          }, e3;
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.buildPresetChain = function* (e3, t3) {
          const r3 = yield* d(e3, t3);
          return r3 ? { plugins: dedupDescriptors(r3.plugins), presets: dedupDescriptors(r3.presets), options: r3.options.map((e4) => normalizeOptions(e4)), files: /* @__PURE__ */ new Set() } : null;
        }, t2.buildPresetChainWalker = void 0, t2.buildRootChain = function* (e3, t3) {
          let r3, n2;
          const o2 = new i.ConfigPrinter(), a2 = yield* v({ options: e3, dirname: t3.cwd }, t3, void 0, o2);
          if (!a2) return null;
          const p2 = yield* o2.output();
          let c2;
          "string" == typeof e3.configFile ? c2 = yield* (0, l.loadConfig)(e3.configFile, t3.cwd, t3.envName, t3.caller) : false !== e3.configFile && (c2 = yield* (0, l.findRootConfig)(t3.root, t3.envName, t3.caller));
          let { babelrc: u2, babelrcRoots: d2 } = e3, h2 = t3.cwd;
          const m2 = emptyChain(), f2 = new i.ConfigPrinter();
          if (c2) {
            const e4 = b(c2), n3 = yield* loadFileChain(e4, t3, void 0, f2);
            if (!n3) return null;
            r3 = yield* f2.output(), void 0 === u2 && (u2 = e4.options.babelrc), void 0 === d2 && (h2 = e4.dirname, d2 = e4.options.babelrcRoots), mergeChain(m2, n3);
          }
          let y2, x2, E2 = false;
          const T2 = emptyChain();
          if ((true === u2 || void 0 === u2) && "string" == typeof t3.filename) {
            const e4 = yield* (0, l.findPackageData)(t3.filename);
            if (e4 && (function(e5, t4, r4, n3) {
              if ("boolean" == typeof r4) return r4;
              const i2 = e5.root;
              if (void 0 === r4) return t4.directories.includes(i2);
              let o3 = r4;
              Array.isArray(o3) || (o3 = [o3]);
              if (o3 = o3.map((e6) => "string" == typeof e6 ? _path().resolve(n3, e6) : e6), 1 === o3.length && o3[0] === i2) return t4.directories.includes(i2);
              return o3.some((r5) => ("string" == typeof r5 && (r5 = (0, s.default)(r5, n3)), t4.directories.some((t5) => matchPattern(r5, n3, t5, e5))));
            })(t3, e4, d2, h2)) {
              if ({ ignore: y2, config: x2 } = yield* (0, l.findRelativeConfig)(e4, t3.envName, t3.caller), y2 && T2.files.add(y2.filepath), y2 && shouldIgnore(t3, y2.ignore, null, y2.dirname) && (E2 = true), x2 && !E2) {
                const e5 = g(x2), r4 = new i.ConfigPrinter(), s2 = yield* loadFileChain(e5, t3, void 0, r4);
                s2 ? (n2 = yield* r4.output(), mergeChain(T2, s2)) : E2 = true;
              }
              x2 && E2 && T2.files.add(x2.filepath);
            }
          }
          t3.showConfig && console.log(`Babel configs on "${t3.filename}" (ascending priority):
` + [r3, n2, p2].filter((e4) => !!e4).join("\n\n") + "\n-----End Babel configs-----");
          const S2 = mergeChain(mergeChain(mergeChain(emptyChain(), m2), T2), a2);
          return { plugins: E2 ? [] : dedupDescriptors(S2.plugins), presets: E2 ? [] : dedupDescriptors(S2.presets), options: E2 ? [] : S2.options.map((e4) => normalizeOptions(e4)), fileHandling: E2 ? "ignored" : "transpile", ignore: y2 || void 0, babelrc: x2 || void 0, config: c2 || void 0, files: S2.files };
        };
        var n = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/validation/options.js"), s = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/pattern-to-regex.js"), i = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/printer.js"), o = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/errors/rewrite-stack-trace.js"), a = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/errors/config-error.js"), l = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/files/index.js"), p = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/caching.js"), c = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/config-descriptors.js");
        const u = _debug()("babel:config:config-chain");
        const d = t2.buildPresetChainWalker = makeChainWalker({ root: (e3) => h(e3), env: (e3, t3) => m(e3)(t3), overrides: (e3, t3) => f(e3)(t3), overridesEnv: (e3, t3, r3) => y(e3)(t3)(r3), createLogger: () => () => {
        } }), h = (0, p.makeWeakCacheSync)((e3) => buildRootDescriptors(e3, e3.alias, c.createUncachedDescriptors)), m = (0, p.makeWeakCacheSync)((e3) => (0, p.makeStrongCacheSync)((t3) => buildEnvDescriptors(e3, e3.alias, c.createUncachedDescriptors, t3))), f = (0, p.makeWeakCacheSync)((e3) => (0, p.makeStrongCacheSync)((t3) => buildOverrideDescriptors(e3, e3.alias, c.createUncachedDescriptors, t3))), y = (0, p.makeWeakCacheSync)((e3) => (0, p.makeStrongCacheSync)((t3) => (0, p.makeStrongCacheSync)((r3) => buildOverrideEnvDescriptors(e3, e3.alias, c.createUncachedDescriptors, t3, r3))));
        const b = (0, p.makeWeakCacheSync)((e3) => ({ filepath: e3.filepath, dirname: e3.dirname, options: (0, n.validate)("configfile", e3.options, e3.filepath) })), g = (0, p.makeWeakCacheSync)((e3) => ({ filepath: e3.filepath, dirname: e3.dirname, options: (0, n.validate)("babelrcfile", e3.options, e3.filepath) })), x = (0, p.makeWeakCacheSync)((e3) => ({ filepath: e3.filepath, dirname: e3.dirname, options: (0, n.validate)("extendsfile", e3.options, e3.filepath) })), v = makeChainWalker({ root: (e3) => buildRootDescriptors(e3, "base", c.createCachedDescriptors), env: (e3, t3) => buildEnvDescriptors(e3, "base", c.createCachedDescriptors, t3), overrides: (e3, t3) => buildOverrideDescriptors(e3, "base", c.createCachedDescriptors, t3), overridesEnv: (e3, t3, r3) => buildOverrideEnvDescriptors(e3, "base", c.createCachedDescriptors, t3, r3), createLogger: (e3, t3, r3) => (function(e4, t4, r4) {
          var n2;
          if (!r4) return () => {
          };
          return r4.configure(t4.showConfig, i.ChainFormatter.Programmatic, { callerName: null == (n2 = t4.caller) ? void 0 : n2.name });
        })(0, t3, r3) }), E = makeChainWalker({ root: (e3) => T(e3), env: (e3, t3) => S(e3)(t3), overrides: (e3, t3) => P(e3)(t3), overridesEnv: (e3, t3, r3) => _(e3)(t3)(r3), createLogger: (e3, t3, r3) => (function(e4, t4, r4) {
          if (!r4) return () => {
          };
          return r4.configure(t4.showConfig, i.ChainFormatter.Config, { filepath: e4 });
        })(e3.filepath, t3, r3) });
        function* loadFileChain(e3, t3, r3, n2) {
          const s2 = yield* E(e3, t3, r3, n2);
          return null == s2 || s2.files.add(e3.filepath), s2;
        }
        const T = (0, p.makeWeakCacheSync)((e3) => buildRootDescriptors(e3, e3.filepath, c.createUncachedDescriptors)), S = (0, p.makeWeakCacheSync)((e3) => (0, p.makeStrongCacheSync)((t3) => buildEnvDescriptors(e3, e3.filepath, c.createUncachedDescriptors, t3))), P = (0, p.makeWeakCacheSync)((e3) => (0, p.makeStrongCacheSync)((t3) => buildOverrideDescriptors(e3, e3.filepath, c.createUncachedDescriptors, t3))), _ = (0, p.makeWeakCacheSync)((e3) => (0, p.makeStrongCacheSync)((t3) => (0, p.makeStrongCacheSync)((r3) => buildOverrideEnvDescriptors(e3, e3.filepath, c.createUncachedDescriptors, t3, r3))));
        function buildRootDescriptors({ dirname: e3, options: t3 }, r3, n2) {
          return n2(e3, t3, r3);
        }
        function buildEnvDescriptors({ dirname: e3, options: t3 }, r3, n2, s2) {
          var i2;
          const o2 = null == (i2 = t3.env) ? void 0 : i2[s2];
          return o2 ? n2(e3, o2, `${r3}.env["${s2}"]`) : null;
        }
        function buildOverrideDescriptors({ dirname: e3, options: t3 }, r3, n2, s2) {
          var i2;
          const o2 = null == (i2 = t3.overrides) ? void 0 : i2[s2];
          if (!o2) throw new Error("Assertion failure - missing override");
          return n2(e3, o2, `${r3}.overrides[${s2}]`);
        }
        function buildOverrideEnvDescriptors({ dirname: e3, options: t3 }, r3, n2, s2, i2) {
          var o2, a2;
          const l2 = null == (o2 = t3.overrides) ? void 0 : o2[s2];
          if (!l2) throw new Error("Assertion failure - missing override");
          const p2 = null == (a2 = l2.env) ? void 0 : a2[i2];
          return p2 ? n2(e3, p2, `${r3}.overrides[${s2}].env["${i2}"]`) : null;
        }
        function makeChainWalker({ root: e3, env: t3, overrides: r3, overridesEnv: n2, createLogger: s2 }) {
          return function* (i2, o2, a2 = /* @__PURE__ */ new Set(), l2) {
            const { dirname: p2 } = i2, c2 = [], u2 = e3(i2);
            if (configIsApplicable(u2, p2, o2, i2.filepath)) {
              c2.push({ config: u2, envName: void 0, index: void 0 });
              const e4 = t3(i2, o2.envName);
              e4 && configIsApplicable(e4, p2, o2, i2.filepath) && c2.push({ config: e4, envName: o2.envName, index: void 0 }), (u2.options.overrides || []).forEach((e5, t4) => {
                const s3 = r3(i2, t4);
                if (configIsApplicable(s3, p2, o2, i2.filepath)) {
                  c2.push({ config: s3, index: t4, envName: void 0 });
                  const e6 = n2(i2, t4, o2.envName);
                  e6 && configIsApplicable(e6, p2, o2, i2.filepath) && c2.push({ config: e6, index: t4, envName: o2.envName });
                }
              });
            }
            if (c2.some(({ config: { options: { ignore: e4, only: t4 } } }) => shouldIgnore(o2, e4, t4, p2))) return null;
            const d2 = emptyChain(), h2 = s2(i2, o2, l2);
            for (const { config: e4, index: t4, envName: r4 } of c2) {
              if (!(yield* mergeExtendsChain(d2, e4.options, p2, o2, a2, l2))) return null;
              h2(e4, t4, r4), yield* mergeChainOpts(d2, e4);
            }
            return d2;
          };
        }
        function* mergeExtendsChain(e3, t3, r3, n2, s2, i2) {
          if (void 0 === t3.extends) return true;
          const o2 = yield* (0, l.loadConfig)(t3.extends, r3, n2.envName, n2.caller);
          if (s2.has(o2)) throw new Error(`Configuration cycle detected loading ${o2.filepath}.
File already loaded following the config chain:
` + Array.from(s2, (e4) => ` - ${e4.filepath}`).join("\n"));
          s2.add(o2);
          const a2 = yield* loadFileChain(x(o2), n2, s2, i2);
          return s2.delete(o2), !!a2 && (mergeChain(e3, a2), true);
        }
        function mergeChain(e3, t3) {
          e3.options.push(...t3.options), e3.plugins.push(...t3.plugins), e3.presets.push(...t3.presets);
          for (const r3 of t3.files) e3.files.add(r3);
          return e3;
        }
        function* mergeChainOpts(e3, { options: t3, plugins: r3, presets: n2 }) {
          return e3.options.push(t3), e3.plugins.push(...yield* r3()), e3.presets.push(...yield* n2()), e3;
        }
        function emptyChain() {
          return { options: [], presets: [], plugins: [], files: /* @__PURE__ */ new Set() };
        }
        function normalizeOptions(e3) {
          const t3 = Object.assign({}, e3);
          return delete t3.extends, delete t3.env, delete t3.overrides, delete t3.plugins, delete t3.presets, delete t3.passPerPreset, delete t3.ignore, delete t3.only, delete t3.test, delete t3.include, delete t3.exclude, hasOwnProperty.call(t3, "sourceMap") && (t3.sourceMaps = t3.sourceMap, delete t3.sourceMap), t3;
        }
        function dedupDescriptors(e3) {
          const t3 = /* @__PURE__ */ new Map(), r3 = [];
          for (const n2 of e3) if ("function" == typeof n2.value) {
            const e4 = n2.value;
            let s2 = t3.get(e4);
            s2 || (s2 = /* @__PURE__ */ new Map(), t3.set(e4, s2));
            let i2 = s2.get(n2.name);
            i2 ? i2.value = n2 : (i2 = { value: n2 }, r3.push(i2), n2.ownPass || s2.set(n2.name, i2));
          } else r3.push({ value: n2 });
          return r3.reduce((e4, t4) => (e4.push(t4.value), e4), []);
        }
        function configIsApplicable({ options: e3 }, t3, r3, n2) {
          return (void 0 === e3.test || configFieldIsApplicable(r3, e3.test, t3, n2)) && (void 0 === e3.include || configFieldIsApplicable(r3, e3.include, t3, n2)) && (void 0 === e3.exclude || !configFieldIsApplicable(r3, e3.exclude, t3, n2));
        }
        function configFieldIsApplicable(e3, t3, r3, n2) {
          return matchesPatterns(e3, Array.isArray(t3) ? t3 : [t3], r3, n2);
        }
        function ignoreListReplacer(e3, t3) {
          return t3 instanceof RegExp ? String(t3) : t3;
        }
        function shouldIgnore(e3, t3, r3, n2) {
          if (t3 && matchesPatterns(e3, t3, n2)) {
            var s2;
            const r4 = `No config is applied to "${null != (s2 = e3.filename) ? s2 : "(unknown)"}" because it matches one of \`ignore: ${JSON.stringify(t3, ignoreListReplacer)}\` from "${n2}"`;
            return u(r4), e3.showConfig && console.log(r4), true;
          }
          if (r3 && !matchesPatterns(e3, r3, n2)) {
            var i2;
            const t4 = `No config is applied to "${null != (i2 = e3.filename) ? i2 : "(unknown)"}" because it fails to match one of \`only: ${JSON.stringify(r3, ignoreListReplacer)}\` from "${n2}"`;
            return u(t4), e3.showConfig && console.log(t4), true;
          }
          return false;
        }
        function matchesPatterns(e3, t3, r3, n2) {
          return t3.some((t4) => matchPattern(t4, r3, e3.filename, e3, n2));
        }
        function matchPattern(e3, t3, r3, n2, i2) {
          if ("function" == typeof e3) return !!(0, o.endHiddenCallStack)(e3)(r3, { dirname: t3, envName: n2.envName, caller: n2.caller });
          if ("string" != typeof r3) throw new a.default("Configuration contains string/RegExp pattern, but no filename was passed to Babel", i2);
          return "string" == typeof e3 && (e3 = (0, s.default)(e3, t3)), e3.test(r3);
        }
      }, "./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/config-descriptors.js": function(e2, t2, r2) {
        "use strict";
        function _gensync() {
          const e3 = r2("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return _gensync = function() {
            return e3;
          }, e3;
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.createCachedDescriptors = function(e3, t3, r3) {
          const { plugins: n2, presets: s2, passPerPreset: i2 } = t3;
          return { options: optionsWithResolvedBrowserslistConfigFile(t3, e3), plugins: n2 ? () => u(n2, e3)(r3) : () => handlerOf([]), presets: s2 ? () => p(s2, e3)(r3)(!!i2) : () => handlerOf([]) };
        }, t2.createDescriptor = createDescriptor, t2.createUncachedDescriptors = function(e3, t3, r3) {
          return { options: optionsWithResolvedBrowserslistConfigFile(t3, e3), plugins: (0, n.once)(() => createPluginDescriptors(t3.plugins || [], e3, r3)), presets: (0, n.once)(() => createPresetDescriptors(t3.presets || [], e3, r3, !!t3.passPerPreset)) };
        };
        var n = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/gensync-utils/functional.js"), s = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/files/index.js"), i = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/item.js"), o = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/caching.js"), a = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/resolve-targets.js");
        function* handlerOf(e3) {
          return e3;
        }
        function optionsWithResolvedBrowserslistConfigFile(e3, t3) {
          return "string" == typeof e3.browserslistConfigFile && (e3.browserslistConfigFile = (0, a.resolveBrowserslistConfigFile)(e3.browserslistConfigFile, t3)), e3;
        }
        const l = /* @__PURE__ */ new WeakMap(), p = (0, o.makeWeakCacheSync)((e3, t3) => {
          const r3 = t3.using((e4) => e4);
          return (0, o.makeStrongCacheSync)((t4) => (0, o.makeStrongCache)(function* (n2) {
            return (yield* createPresetDescriptors(e3, r3, t4, n2)).map((e4) => loadCachedDescriptor(l, e4));
          }));
        }), c = /* @__PURE__ */ new WeakMap(), u = (0, o.makeWeakCacheSync)((e3, t3) => {
          const r3 = t3.using((e4) => e4);
          return (0, o.makeStrongCache)(function* (t4) {
            return (yield* createPluginDescriptors(e3, r3, t4)).map((e4) => loadCachedDescriptor(c, e4));
          });
        }), d = {};
        function loadCachedDescriptor(e3, t3) {
          const { value: r3, options: n2 = d } = t3;
          if (false === n2) return t3;
          let s2 = e3.get(r3);
          s2 || (s2 = /* @__PURE__ */ new WeakMap(), e3.set(r3, s2));
          let i2 = s2.get(n2);
          if (i2 || (i2 = [], s2.set(n2, i2)), !i2.includes(t3)) {
            const e4 = i2.filter((e5) => {
              return n3 = t3, (r4 = e5).name === n3.name && r4.value === n3.value && r4.options === n3.options && r4.dirname === n3.dirname && r4.alias === n3.alias && r4.ownPass === n3.ownPass && (null == (s3 = r4.file) ? void 0 : s3.request) === (null == (i3 = n3.file) ? void 0 : i3.request) && (null == (o2 = r4.file) ? void 0 : o2.resolved) === (null == (a2 = n3.file) ? void 0 : a2.resolved);
              var r4, n3, s3, i3, o2, a2;
            });
            if (e4.length > 0) return e4[0];
            i2.push(t3);
          }
          return t3;
        }
        function* createPresetDescriptors(e3, t3, r3, n2) {
          return yield* createDescriptors("preset", e3, t3, r3, n2);
        }
        function* createPluginDescriptors(e3, t3, r3) {
          return yield* createDescriptors("plugin", e3, t3, r3);
        }
        function* createDescriptors(e3, t3, r3, n2, s2) {
          const i2 = yield* _gensync().all(t3.map((t4, i3) => createDescriptor(t4, r3, { type: e3, alias: `${n2}$${i3}`, ownPass: !!s2 })));
          return (function(e4) {
            const t4 = /* @__PURE__ */ new Map();
            for (const r4 of e4) {
              if ("function" != typeof r4.value) continue;
              let n3 = t4.get(r4.value);
              if (n3 || (n3 = /* @__PURE__ */ new Set(), t4.set(r4.value, n3)), n3.has(r4.name)) {
                const t5 = e4.filter((e5) => e5.value === r4.value);
                throw new Error(["Duplicate plugin/preset detected.", "If you'd like to use two separate instances of a plugin,", "they need separate names, e.g.", "", "  plugins: [", "    ['some-plugin', {}],", "    ['some-plugin', {}, 'some unique name'],", "  ]", "", "Duplicates detected are:", `${JSON.stringify(t5, null, 2)}`].join("\n"));
              }
              n3.add(r4.name);
            }
          })(i2), i2;
        }
        function* createDescriptor(e3, t3, { type: r3, alias: n2, ownPass: o2 }) {
          const a2 = (0, i.getItemDescriptor)(e3);
          if (a2) return a2;
          let l2, p2, c2, u2 = e3;
          Array.isArray(u2) && (3 === u2.length ? [u2, p2, l2] = u2 : [u2, p2] = u2);
          let d2 = null;
          if ("string" == typeof u2) {
            if ("string" != typeof r3) throw new Error("To resolve a string-based item, the type of item must be given");
            const e4 = "plugin" === r3 ? s.loadPlugin : s.loadPreset, n3 = u2;
            ({ filepath: d2, value: u2 } = yield* e4(u2, t3)), c2 = { request: n3, resolved: d2 };
          }
          if (!u2) throw new Error(`Unexpected falsy value: ${String(u2)}`);
          if ("object" == typeof u2 && u2.__esModule) {
            if (!u2.default) throw new Error("Must export a default export when using ES6 modules.");
            u2 = u2.default;
          }
          if ("object" != typeof u2 && "function" != typeof u2) throw new Error(`Unsupported format: ${typeof u2}. Expected an object or a function.`);
          if (null !== d2 && "object" == typeof u2 && u2) throw new Error(`Plugin/Preset files are not allowed to export objects, only functions. In ${d2}`);
          return { name: l2, alias: d2 || n2, value: u2, options: p2, dirname: t3, ownPass: o2, file: c2 };
        }
      }, "./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/files/configuration.js": function(e2, t2, r2) {
        "use strict";
        function _debug() {
          const e3 = r2("./node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/index.js");
          return _debug = function() {
            return e3;
          }, e3;
        }
        function _fs() {
          const e3 = r2("fs");
          return _fs = function() {
            return e3;
          }, e3;
        }
        function _path() {
          const e3 = r2("path");
          return _path = function() {
            return e3;
          }, e3;
        }
        function _json() {
          const e3 = r2("./node_modules/.pnpm/json5@2.2.3/node_modules/json5/dist/index.mjs");
          return _json = function() {
            return e3;
          }, e3;
        }
        function _gensync() {
          const e3 = r2("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return _gensync = function() {
            return e3;
          }, e3;
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.ROOT_CONFIG_FILENAMES = void 0, t2.findConfigUpwards = function(e3) {
          let t3 = e3;
          for (; ; ) {
            for (const e5 of h) if (_fs().existsSync(_path().join(t3, e5))) return t3;
            const e4 = _path().dirname(t3);
            if (t3 === e4) break;
            t3 = e4;
          }
          return null;
        }, t2.findRelativeConfig = function* (e3, t3, r3) {
          let n2 = null, s2 = null;
          const i2 = _path().dirname(e3.filepath);
          for (const a2 of e3.directories) {
            var o2;
            if (!n2) n2 = yield* loadOneConfig(m, a2, t3, r3, (null == (o2 = e3.pkg) ? void 0 : o2.dirname) === a2 ? g(e3.pkg) : null);
            if (!s2) {
              const e4 = _path().join(a2, f);
              s2 = yield* v(e4), s2 && d("Found ignore %o from %o.", s2.filepath, i2);
            }
          }
          return { config: n2, ignore: s2 };
        }, t2.findRootConfig = function(e3, t3, r3) {
          return loadOneConfig(h, e3, t3, r3);
        }, t2.loadConfig = function* (e3, t3, n2, s2) {
          const i2 = (a2 = process.versions.node, p2 = "8.9", a2 = a2.split("."), p2 = p2.split("."), +a2[0] > +p2[0] || a2[0] == p2[0] && +a2[1] >= +p2[1] ? r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/files sync recursive").resolve : (e4, { paths: [t4] }, n3 = r2("module")) => {
            let s3 = n3._findPath(e4, n3._nodeModulePaths(t4).concat(t4));
            if (s3) return s3;
            throw s3 = new Error(`Cannot resolve module '${e4}'`), s3.code = "MODULE_NOT_FOUND", s3;
          })(e3, { paths: [t3] }), o2 = yield* readConfig(i2, n2, s2);
          var a2, p2;
          if (!o2) throw new l.default("Config file contains no configuration data", i2);
          return d("Loaded config %o from %o.", e3, t3), o2;
        }, t2.resolveShowConfigPath = function* (e3) {
          const t3 = process.env.BABEL_SHOW_CONFIG_FOR;
          if (null != t3) {
            const r3 = _path().resolve(e3, t3);
            if (!(yield* p.stat(r3)).isFile()) throw new Error(`${r3}: BABEL_SHOW_CONFIG_FOR must refer to a regular file, directories are not supported.`);
            return r3;
          }
          return null;
        };
        var n = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/caching.js"), s = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/helpers/config-api.js"), i = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/files/utils.js"), o = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/files/module-types.js"), a = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/pattern-to-regex.js"), l = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/errors/config-error.js"), p = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/gensync-utils/fs.js");
        r2("module");
        var c = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/errors/rewrite-stack-trace.js"), u = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/gensync-utils/async.js");
        const d = _debug()("babel:config:loading:files:configuration"), h = t2.ROOT_CONFIG_FILENAMES = ["babel.config.js", "babel.config.cjs", "babel.config.mjs", "babel.config.json", "babel.config.cts", "babel.config.ts", "babel.config.mts"], m = [".babelrc", ".babelrc.js", ".babelrc.cjs", ".babelrc.mjs", ".babelrc.json", ".babelrc.cts"], f = ".babelignore", y = (0, n.makeWeakCache)(function* (e3, t3) {
          return yield* [], { options: (0, c.endHiddenCallStack)(e3)((0, s.makeConfigAPI)(t3)), cacheNeedsConfiguration: !t3.configured() };
        });
        function* readConfigCode(e3, t3) {
          if (!_fs().existsSync(e3)) return null;
          let r3 = yield* (0, o.default)(e3, (yield* (0, u.isAsync)()) ? "auto" : "require", "You appear to be using a native ECMAScript module configuration file, which is only supported when running Babel asynchronously or when using the Node.js `--experimental-require-module` flag.", "You appear to be using a configuration file that contains top-level await, which is only supported when running Babel asynchronously."), n2 = false;
          if ("function" == typeof r3 && ({ options: r3, cacheNeedsConfiguration: n2 } = yield* y(r3, t3)), !r3 || "object" != typeof r3 || Array.isArray(r3)) throw new l.default("Configuration should be an exported JavaScript object.", e3);
          if ("function" == typeof r3.then) throw null == r3.catch || r3.catch(() => {
          }), new l.default("You appear to be using an async configuration, which your current version of Babel does not support. We may add support for this in the future, but if you're on the most recent version of @babel/core and still seeing this error, then you'll need to synchronously return your config.", e3);
          return n2 && (function(e4) {
            throw new l.default(`Caching was left unconfigured. Babel's plugins, presets, and .babelrc.js files can be configured
for various types of caching, using the first param of their handler functions:

module.exports = function(api) {
  // The API exposes the following:

  // Cache the returned value forever and don't call this function again.
  api.cache(true);

  // Don't cache at all. Not recommended because it will be very slow.
  api.cache(false);

  // Cached based on the value of some function. If this function returns a value different from
  // a previously-encountered value, the plugins will re-evaluate.
  var env = api.cache(() => process.env.NODE_ENV);

  // If testing for a specific env, we recommend specifics to avoid instantiating a plugin for
  // any possible NODE_ENV value that might come up during plugin execution.
  var isProd = api.cache(() => process.env.NODE_ENV === "production");

  // .cache(fn) will perform a linear search though instances to find the matching plugin based
  // based on previous instantiated plugins. If you want to recreate the plugin and discard the
  // previous instance whenever something changes, you may use:
  var isProd = api.cache.invalidate(() => process.env.NODE_ENV === "production");

  // Note, we also expose the following more-verbose versions of the above examples:
  api.cache.forever(); // api.cache(true)
  api.cache.never();   // api.cache(false)
  api.cache.using(fn); // api.cache(fn)

  // Return the value that will be cached.
  return { };
};`, e4);
          })(e3), (function(e4, t4) {
            let r4 = b.get(e4);
            r4 || b.set(e4, r4 = /* @__PURE__ */ new Map());
            let n3 = r4.get(t4);
            n3 || (n3 = { filepath: t4, dirname: _path().dirname(t4), options: e4 }, r4.set(t4, n3));
            return n3;
          })(r3, e3);
        }
        const b = /* @__PURE__ */ new WeakMap();
        const g = (0, n.makeWeakCacheSync)((e3) => {
          const t3 = e3.options.babel;
          if (void 0 === t3) return null;
          if ("object" != typeof t3 || Array.isArray(t3) || null === t3) throw new l.default(".babel property must be an object", e3.filepath);
          return { filepath: e3.filepath, dirname: e3.dirname, options: t3 };
        }), x = (0, i.makeStaticFileCache)((e3, t3) => {
          let r3;
          try {
            r3 = _json().parse(t3);
          } catch (t4) {
            throw new l.default(`Error while parsing config - ${t4.message}`, e3);
          }
          if (!r3) throw new l.default("No config detected", e3);
          if ("object" != typeof r3) throw new l.default("Config returned typeof " + typeof r3, e3);
          if (Array.isArray(r3)) throw new l.default("Expected config object but found array", e3);
          return delete r3.$schema, { filepath: e3, dirname: _path().dirname(e3), options: r3 };
        }), v = (0, i.makeStaticFileCache)((e3, t3) => {
          const r3 = _path().dirname(e3), n2 = t3.split("\n").map((e4) => e4.replace(/#.*$/, "").trim()).filter(Boolean);
          for (const t4 of n2) if ("!" === t4[0]) throw new l.default("Negation of file paths is not supported.", e3);
          return { filepath: e3, dirname: _path().dirname(e3), ignore: n2.map((e4) => (0, a.default)(e4, r3)) };
        });
        function* loadOneConfig(e3, t3, r3, n2, s2 = null) {
          const i2 = (yield* _gensync().all(e3.map((e4) => readConfig(_path().join(t3, e4), r3, n2)))).reduce((e4, r4) => {
            if (r4 && e4) throw new l.default(`Multiple configuration files found. Please remove one:
 - ${_path().basename(e4.filepath)}
 - ${r4.filepath}
from ${t3}`);
            return r4 || e4;
          }, s2);
          return i2 && d("Found configuration %o from %o.", i2.filepath, t3), i2;
        }
        function readConfig(e3, t3, r3) {
          switch (_path().extname(e3)) {
            case ".js":
            case ".cjs":
            case ".mjs":
            case ".ts":
            case ".cts":
            case ".mts":
              return readConfigCode(e3, { envName: t3, caller: r3 });
            default:
              return x(e3);
          }
        }
      }, "./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/files/import.cjs": function(e2, t2, r2) {
        e2.exports = function(e3) {
          return r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/files lazy recursive")(e3);
        };
      }, "./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/files/index.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), Object.defineProperty(t2, "ROOT_CONFIG_FILENAMES", { enumerable: true, get: function() {
          return s.ROOT_CONFIG_FILENAMES;
        } }), Object.defineProperty(t2, "findConfigUpwards", { enumerable: true, get: function() {
          return s.findConfigUpwards;
        } }), Object.defineProperty(t2, "findPackageData", { enumerable: true, get: function() {
          return n.findPackageData;
        } }), Object.defineProperty(t2, "findRelativeConfig", { enumerable: true, get: function() {
          return s.findRelativeConfig;
        } }), Object.defineProperty(t2, "findRootConfig", { enumerable: true, get: function() {
          return s.findRootConfig;
        } }), Object.defineProperty(t2, "loadConfig", { enumerable: true, get: function() {
          return s.loadConfig;
        } }), Object.defineProperty(t2, "loadPlugin", { enumerable: true, get: function() {
          return i.loadPlugin;
        } }), Object.defineProperty(t2, "loadPreset", { enumerable: true, get: function() {
          return i.loadPreset;
        } }), Object.defineProperty(t2, "resolvePlugin", { enumerable: true, get: function() {
          return i.resolvePlugin;
        } }), Object.defineProperty(t2, "resolvePreset", { enumerable: true, get: function() {
          return i.resolvePreset;
        } }), Object.defineProperty(t2, "resolveShowConfigPath", { enumerable: true, get: function() {
          return s.resolveShowConfigPath;
        } });
        var n = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/files/package.js"), s = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/files/configuration.js"), i = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/files/plugins.js");
      }, "./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/files/module-types.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function* (e3, t3, r3, s2) {
          let o2;
          const a2 = _path().extname(e3), l2 = ".ts" === a2 || ".cts" === a2 || ".mts" === a2, p2 = h[hasOwnProperty.call(h, a2) ? a2 : ".js"];
          switch (`${t3} ${p2}`) {
            case "require cjs":
            case "auto cjs":
              return l2 ? ensureTsSupport(e3, a2, () => loadCjsDefault(e3)) : loadCjsDefault(e3, arguments[2]);
            case "auto unknown":
            case "require unknown":
            case "require esm":
              try {
                return l2 ? ensureTsSupport(e3, a2, () => loadCjsDefault(e3)) : loadCjsDefault(e3, arguments[2]);
              } catch (t4) {
                if ("ERR_REQUIRE_ASYNC_MODULE" === t4.code || "ERR_REQUIRE_CYCLE_MODULE" === t4.code && m.has(e3)) {
                  if (m.add(e3), !(null != o2 ? o2 : o2 = yield* (0, n.isAsync)())) throw new i.default(s2, e3);
                } else if ("ERR_REQUIRE_ESM" !== t4.code && "esm" !== p2) throw t4;
              }
            case "auto esm":
              if (null != o2 ? o2 : o2 = yield* (0, n.isAsync)()) {
                const t4 = l2 ? ensureTsSupport(e3, a2, () => c(e3)) : c(e3);
                return (yield* (0, n.waitFor)(t4)).default;
              }
              throw l2 ? new i.default(tsNotSupportedError(a2), e3) : new i.default(r3, e3);
            default:
              throw new Error("Internal Babel error: unreachable code.");
          }
        }, t2.supportsESM = void 0;
        var n = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/gensync-utils/async.js");
        function _path() {
          const e3 = r2("path");
          return _path = function() {
            return e3;
          }, e3;
        }
        function _url() {
          const e3 = r2("url");
          return _url = function() {
            return e3;
          }, e3;
        }
        function _semver() {
          const e3 = r2("./node_modules/.pnpm/semver@6.3.1/node_modules/semver/semver.js");
          return _semver = function() {
            return e3;
          }, e3;
        }
        function _debug() {
          const e3 = r2("./node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/index.js");
          return _debug = function() {
            return e3;
          }, e3;
        }
        r2("module");
        var s = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/errors/rewrite-stack-trace.js"), i = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/errors/config-error.js"), o = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/transform-file.js");
        function asyncGeneratorStep(e3, t3, r3, n2, s2, i2, o2) {
          try {
            var a2 = e3[i2](o2), l2 = a2.value;
          } catch (e4) {
            return void r3(e4);
          }
          a2.done ? t3(l2) : Promise.resolve(l2).then(n2, s2);
        }
        const a = _debug()("babel:config:loading:files:module-types");
        try {
          var l = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/files/import.cjs");
        } catch (e3) {
        }
        t2.supportsESM = _semver().satisfies(process.versions.node, "^12.17 || >=13.2");
        const p = /* @__PURE__ */ new Set();
        function loadCjsDefault(e3) {
          if (p.has(e3)) return a("Auto-ignoring usage of config %o.", e3), {};
          let t3;
          try {
            p.add(e3), t3 = (0, s.endHiddenCallStack)(r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/files sync recursive"))(e3);
          } finally {
            p.delete(e3);
          }
          return null == t3 || !t3.__esModule && "Module" !== t3[Symbol.toStringTag] ? t3 : t3.default || (arguments[1] ? t3 : void 0);
        }
        const c = (0, s.endHiddenCallStack)((u = function* (e3) {
          const t3 = (0, _url().pathToFileURL)(e3).toString() + "?import";
          if (!l) throw new i.default("Internal error: Native ECMAScript modules aren't supported by this platform.\n", e3);
          return yield l(t3);
        }, d = function() {
          var e3 = this, t3 = arguments;
          return new Promise(function(r3, n2) {
            var s2 = u.apply(e3, t3);
            function _next(e4) {
              asyncGeneratorStep(s2, r3, n2, _next, _throw, "next", e4);
            }
            function _throw(e4) {
              asyncGeneratorStep(s2, r3, n2, _next, _throw, "throw", e4);
            }
            _next(void 0);
          });
        }, function(e3) {
          return d.apply(this, arguments);
        }));
        var u, d;
        const tsNotSupportedError = (e3) => `You are using a ${e3} config file, but Babel only supports transpiling .cts configs. Either:
- Use a .cts config file
- Update to Node.js 23.6.0, which has native TypeScript support
- Install tsx to transpile ${e3} files on the fly`, h = { ".js": "unknown", ".mjs": "esm", ".cjs": "cjs", ".ts": "unknown", ".mts": "esm", ".cts": "cjs" }, m = /* @__PURE__ */ new Set();
        function ensureTsSupport(e3, t3, n2) {
          if (process.features.typescript || (void 0)[".ts"] || (void 0)[".cts"] || (void 0)[".mts"]) return n2();
          if (".cts" !== t3) throw new i.default(tsNotSupportedError(t3), e3);
          const s2 = { babelrc: false, configFile: false, sourceType: "unambiguous", sourceMaps: "inline", sourceFileName: _path().basename(e3), presets: [[getTSPreset(e3), Object.assign({ onlyRemoveTypeImports: true, optimizeConstEnums: true }, { allowDeclareFields: true })]] };
          let handler = function(e4, t4) {
            if (handler && t4.endsWith(".cts")) try {
              return e4._compile((0, o.transformFileSync)(t4, Object.assign({}, s2, { filename: t4 })).code, t4);
            } catch (e5) {
              const t5 = r2("./node_modules/.pnpm/@babel+preset-typescript@7.27.1_@babel+core@7.28.4/node_modules/@babel/preset-typescript/package.json");
              throw _semver().lt(t5.version, "7.21.4") && console.error("`.cts` configuration file failed to load, please try to update `@babel/preset-typescript`."), e5;
            }
            return (void 0)[".js"](e4, t4);
          };
          (void 0)[t3] = handler;
          try {
            return n2();
          } finally {
            (void 0)[t3] === handler && delete (void 0)[t3], handler = void 0;
          }
        }
        function getTSPreset(e3) {
          try {
            return r2("./node_modules/.pnpm/@babel+preset-typescript@7.27.1_@babel+core@7.28.4/node_modules/@babel/preset-typescript/lib/index.js");
          } catch (t3) {
            if ("MODULE_NOT_FOUND" !== t3.code) throw t3;
            let r3 = "You appear to be using a .cts file as Babel configuration, but the `@babel/preset-typescript` package was not found: please install it!";
            throw process.versions.pnp && (r3 += `
If you are using Yarn Plug'n'Play, you may also need to add the following configuration to your .yarnrc.yml file:

packageExtensions:
	"@babel/core@*":
		peerDependencies:
			"@babel/preset-typescript": "*"
`), new i.default(r3, e3);
          }
        }
      }, "./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/files/package.js": function(e2, t2, r2) {
        "use strict";
        function _path() {
          const e3 = r2("path");
          return _path = function() {
            return e3;
          }, e3;
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.findPackageData = function* (e3) {
          let t3 = null;
          const r3 = [];
          let n2 = true, s2 = _path().dirname(e3);
          for (; !t3 && "node_modules" !== _path().basename(s2); ) {
            r3.push(s2), t3 = yield* o(_path().join(s2, i));
            const e4 = _path().dirname(s2);
            if (s2 === e4) {
              n2 = false;
              break;
            }
            s2 = e4;
          }
          return { filepath: e3, directories: r3, pkg: t3, isPackage: n2 };
        };
        var n = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/files/utils.js"), s = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/errors/config-error.js");
        const i = "package.json", o = (0, n.makeStaticFileCache)((e3, t3) => {
          let r3;
          try {
            r3 = JSON.parse(t3);
          } catch (t4) {
            throw new s.default(`Error while parsing JSON - ${t4.message}`, e3);
          }
          if (!r3) throw new Error(`${e3}: No config detected`);
          if ("object" != typeof r3) throw new s.default("Config returned typeof " + typeof r3, e3);
          if (Array.isArray(r3)) throw new s.default("Expected config object but found array", e3);
          return { filepath: e3, dirname: _path().dirname(e3), options: r3 };
        });
      }, "./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/files/plugins.js": function(e2, t2, r2) {
        "use strict";
        function _debug() {
          const e3 = r2("./node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/index.js");
          return _debug = function() {
            return e3;
          }, e3;
        }
        function _path() {
          const e3 = r2("path");
          return _path = function() {
            return e3;
          }, e3;
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.loadPlugin = function* (e3, t3) {
          const { filepath: r3, loader: s2 } = f(e3, t3, yield* (0, n.isAsync)()), i2 = yield* requireModule("plugin", s2, r3);
          return o("Loaded plugin %o from %o.", e3, t3), { filepath: r3, value: i2 };
        }, t2.loadPreset = function* (e3, t3) {
          const { filepath: r3, loader: s2 } = y(e3, t3, yield* (0, n.isAsync)()), i2 = yield* requireModule("preset", s2, r3);
          return o("Loaded preset %o from %o.", e3, t3), { filepath: r3, value: i2 };
        }, t2.resolvePreset = t2.resolvePlugin = void 0;
        var n = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/gensync-utils/async.js"), s = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/files/module-types.js");
        function _url() {
          const e3 = r2("url");
          return _url = function() {
            return e3;
          }, e3;
        }
        var i = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/vendor/import-meta-resolve.js");
        function _fs() {
          const e3 = r2("fs");
          return _fs = function() {
            return e3;
          }, e3;
        }
        r2("module");
        const o = _debug()("babel:config:loading:files:plugins"), a = /^module:/, l = /^(?!@|module:|[^/]+\/|babel-plugin-)/, p = /^(?!@|module:|[^/]+\/|babel-preset-)/, c = /^(@babel\/)(?!plugin-|[^/]+\/)/, u = /^(@babel\/)(?!preset-|[^/]+\/)/, d = /^(@(?!babel\/)[^/]+\/)(?![^/]*babel-plugin(?:-|\/|$)|[^/]+\/)/, h = /^(@(?!babel\/)[^/]+\/)(?![^/]*babel-preset(?:-|\/|$)|[^/]+\/)/, m = /^(@(?!babel$)[^/]+)$/, f = t2.resolvePlugin = resolveStandardizedName.bind(null, "plugin"), y = t2.resolvePreset = resolveStandardizedName.bind(null, "preset");
        function standardizeName(e3, t3) {
          if (_path().isAbsolute(t3)) return t3;
          const r3 = "preset" === e3;
          return t3.replace(r3 ? p : l, `babel-${e3}-`).replace(r3 ? u : c, `$1${e3}-`).replace(r3 ? h : d, `$1babel-${e3}-`).replace(m, `$1/babel-${e3}`).replace(a, "");
        }
        function* resolveAlternativesHelper(e3, t3) {
          const r3 = standardizeName(e3, t3), { error: n2, value: s2 } = yield r3;
          if (!n2) return s2;
          if ("MODULE_NOT_FOUND" !== n2.code) throw n2;
          r3 === t3 || (yield t3).error || (n2.message += `
- If you want to resolve "${t3}", use "module:${t3}"`), (yield standardizeName(e3, "@babel/" + t3)).error || (n2.message += `
- Did you mean "@babel/${t3}"?`);
          const i2 = "preset" === e3 ? "plugin" : "preset";
          if ((yield standardizeName(i2, t3)).error || (n2.message += `
- Did you accidentally pass a ${i2} as a ${e3}?`), "plugin" === e3) {
            const e4 = r3.replace("-proposal-", "-transform-");
            e4 === r3 || (yield e4).error || (n2.message += `
- Did you mean "${e4}"?`);
          }
          throw n2.message += "\n\nMake sure that all the Babel plugins and presets you are using\nare defined as dependencies or devDependencies in your package.json\nfile. It's possible that the missing plugin is loaded by a preset\nyou are using that forgot to add the plugin to its dependencies: you\ncan workaround this problem by explicitly adding the missing package\nto your top-level package.json.\n", n2;
        }
        function tryRequireResolve(e3, t3) {
          try {
            return t3 ? { error: null, value: (n2 = process.versions.node, s2 = "8.9", n2 = n2.split("."), s2 = s2.split("."), +n2[0] > +s2[0] || n2[0] == s2[0] && +n2[1] >= +s2[1] ? r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/files sync recursive").resolve : (e4, { paths: [t4] }, n3 = r2("module")) => {
              let s3 = n3._findPath(e4, n3._nodeModulePaths(t4).concat(t4));
              if (s3) return s3;
              throw s3 = new Error(`Cannot resolve module '${e4}'`), s3.code = "MODULE_NOT_FOUND", s3;
            })(e3, { paths: [t3] }) } : { error: null, value: r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/files sync recursive").resolve(e3) };
          } catch (e4) {
            return { error: e4, value: null };
          }
          var n2, s2;
        }
        function tryImportMetaResolve(e3, t3) {
          try {
            return { error: null, value: (0, i.resolve)(e3, t3) };
          } catch (e4) {
            return { error: e4, value: null };
          }
        }
        function resolveStandardizedNameForRequire(e3, t3, r3) {
          const n2 = resolveAlternativesHelper(e3, t3);
          let s2 = n2.next();
          for (; !s2.done; ) s2 = n2.next(tryRequireResolve(s2.value, r3));
          return { loader: "require", filepath: s2.value };
        }
        function resolveStandardizedName(e3, t3, r3, n2) {
          if (!s.supportsESM || !n2) return resolveStandardizedNameForRequire(e3, t3, r3);
          try {
            const n3 = (function(e4, t4, r4) {
              const n4 = (0, _url().pathToFileURL)(_path().join(r4, "./babel-virtual-resolve-base.js")).href, s2 = resolveAlternativesHelper(e4, t4);
              let i2 = s2.next();
              for (; !i2.done; ) i2 = s2.next(tryImportMetaResolve(i2.value, n4));
              return { loader: "auto", filepath: (0, _url().fileURLToPath)(i2.value) };
            })(e3, t3, r3);
            if (!(0, _fs().existsSync)(n3.filepath)) throw Object.assign(new Error(`Could not resolve "${t3}" in file ${r3}.`), { type: "MODULE_NOT_FOUND" });
            return n3;
          } catch (n3) {
            try {
              return resolveStandardizedNameForRequire(e3, t3, r3);
            } catch (e4) {
              if ("MODULE_NOT_FOUND" === n3.type) throw n3;
              if ("MODULE_NOT_FOUND" === e4.type) throw e4;
              throw n3;
            }
          }
        }
        var b = /* @__PURE__ */ new Set();
        function* requireModule(e3, t3, r3) {
          if (!(yield* (0, n.isAsync)()) && b.has(r3)) throw new Error(`Reentrant ${e3} detected trying to load "${r3}". This module is not ignored and is trying to load itself while compiling itself, leading to a dependency cycle. We recommend adding it to your "ignore" list in your babelrc, or to a .babelignore.`);
          try {
            return b.add(r3), yield* (0, s.default)(r3, t3, `You appear to be using a native ECMAScript module ${e3}, which is only supported when running Babel asynchronously or when using the Node.js \`--experimental-require-module\` flag.`, `You appear to be using a ${e3} that contains top-level await, which is only supported when running Babel asynchronously.`, true);
          } catch (e4) {
            throw e4.message = `[BABEL]: ${e4.message} (While processing: ${r3})`, e4;
          } finally {
            b.delete(r3);
          }
        }
      }, "./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/files/utils.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.makeStaticFileCache = function(e3) {
          return (0, n.makeStrongCache)(function* (t3, r3) {
            const n2 = r3.invalidate(() => (function(e4) {
              if (!_fs2().existsSync(e4)) return null;
              try {
                return +_fs2().statSync(e4).mtime;
              } catch (e5) {
                if ("ENOENT" !== e5.code && "ENOTDIR" !== e5.code) throw e5;
              }
              return null;
            })(t3));
            return null === n2 ? null : e3(t3, yield* s.readFile(t3, "utf8"));
          });
        };
        var n = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/caching.js"), s = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/gensync-utils/fs.js");
        function _fs2() {
          const e3 = r2("fs");
          return _fs2 = function() {
            return e3;
          }, e3;
        }
      }, "./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/full.js": function(e2, t2, r2) {
        "use strict";
        function _gensync() {
          const e3 = r2("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return _gensync = function() {
            return e3;
          }, e3;
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var n = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/gensync-utils/async.js"), s = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/util.js"), i = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/index.js"), o = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/plugin.js"), a = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/item.js"), l = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/config-chain.js"), p = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/helpers/deep-array.js");
        function _traverse() {
          const e3 = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/index.js");
          return _traverse = function() {
            return e3;
          }, e3;
        }
        var c = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/caching.js"), u = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/validation/options.js"), d = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/validation/plugins.js"), h = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/helpers/config-api.js"), m = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/partial.js"), f = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/errors/config-error.js");
        t2.default = _gensync()(function* (e3) {
          var t3;
          const r3 = yield* (0, m.default)(e3);
          if (!r3) return null;
          const { options: n2, context: i2, fileHandling: o2 } = r3;
          if ("ignored" === o2) return null;
          const l2 = {}, { plugins: c2, presets: d2 } = n2;
          if (!c2 || !d2) throw new Error("Assertion failure - plugins and presets exist");
          const h2 = Object.assign({}, i2, { targets: n2.targets }), toDescriptor = (e4) => {
            const t4 = (0, a.getItemDescriptor)(e4);
            if (!t4) throw new Error("Assertion failure - must be config item");
            return t4;
          }, f2 = d2.map(toDescriptor), y2 = c2.map(toDescriptor), b2 = [[]], g2 = [], x2 = [], v = yield* enhanceError(i2, function* recursePresetDescriptors(e4, t4) {
            const r4 = [];
            for (let s2 = 0; s2 < e4.length; s2++) {
              const i3 = e4[s2];
              if (false !== i3.options) {
                try {
                  var n3 = yield* loadPresetDescriptor(i3, h2);
                } catch (t5) {
                  throw "BABEL_UNKNOWN_OPTION" === t5.code && (0, u.checkNoUnwrappedItemOptionPairs)(e4, s2, "preset", t5), t5;
                }
                x2.push(n3.externalDependencies), i3.ownPass ? r4.push({ preset: n3.chain, pass: [] }) : r4.unshift({ preset: n3.chain, pass: t4 });
              }
            }
            if (r4.length > 0) {
              b2.splice(1, 0, ...r4.map((e5) => e5.pass).filter((e5) => e5 !== t4));
              for (const { preset: e5, pass: t5 } of r4) {
                if (!e5) return true;
                t5.push(...e5.plugins);
                if (yield* recursePresetDescriptors(e5.presets, t5)) return true;
                e5.options.forEach((e6) => {
                  (0, s.mergeOptions)(l2, e6);
                });
              }
            }
          })(f2, b2[0]);
          if (v) return null;
          const E = l2;
          (0, s.mergeOptions)(E, n2);
          const T = Object.assign({}, h2, { assumptions: null != (t3 = E.assumptions) ? t3 : {} });
          return yield* enhanceError(i2, function* () {
            b2[0].unshift(...y2);
            for (const t4 of b2) {
              const r4 = [];
              g2.push(r4);
              for (let n3 = 0; n3 < t4.length; n3++) {
                const s2 = t4[n3];
                if (false !== s2.options) {
                  try {
                    var e4 = yield* loadPluginDescriptor(s2, T);
                  } catch (e5) {
                    throw "BABEL_UNKNOWN_PLUGIN_PROPERTY" === e5.code && (0, u.checkNoUnwrappedItemOptionPairs)(t4, n3, "plugin", e5), e5;
                  }
                  r4.push(e4), x2.push(e4.externalDependencies);
                }
              }
            }
          })(), E.plugins = g2[0], E.presets = g2.slice(1).filter((e4) => e4.length > 0).map((e4) => ({ plugins: e4 })), E.passPerPreset = E.presets.length > 0, { options: E, passes: g2, externalDependencies: (0, p.finalize)(x2) };
        });
        function enhanceError(e3, t3) {
          return function* (r3, n2) {
            try {
              return yield* t3(r3, n2);
            } catch (t4) {
              var s2;
              if (!/^\[BABEL\]/.test(t4.message)) t4.message = `[BABEL] ${null != (s2 = e3.filename) ? s2 : "unknown file"}: ${t4.message}`;
              throw t4;
            }
          };
        }
        const makeDescriptorLoader = (e3) => (0, c.makeWeakCache)(function* ({ value: t3, options: r3, dirname: s2, alias: o2 }, a2) {
          if (false === r3) throw new Error("Assertion failure");
          r3 = r3 || {};
          const l2 = [];
          let c2 = t3;
          if ("function" == typeof t3) {
            const p2 = (0, n.maybeAsync)(t3, "You appear to be using an async plugin/preset, but Babel has been called synchronously"), u2 = Object.assign({}, i, e3(a2, l2));
            try {
              c2 = yield* p2(u2, r3, s2);
            } catch (e4) {
              throw o2 && (e4.message += ` (While processing: ${JSON.stringify(o2)})`), e4;
            }
          }
          if (!c2 || "object" != typeof c2) throw new Error("Plugin/Preset did not return an object.");
          if ((0, n.isThenable)(c2)) throw yield* [], new Error(`You appear to be using a promise as a plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version. As an alternative, you can prefix the promise with "await". (While processing: ${JSON.stringify(o2)})`);
          if (l2.length > 0 && (!a2.configured() || "forever" === a2.mode())) {
            let e4 = `A plugin/preset has external untracked dependencies (${l2[0]}), but the cache `;
            throw a2.configured() ? e4 += " has been configured to never be invalidated. " : e4 += "has not been configured to be invalidated when the external dependencies change. ", e4 += `Plugins/presets should configure their cache to be invalidated when the external dependencies change, for example using \`api.cache.invalidate(() => statSync(filepath).mtimeMs)\` or \`api.cache.never()\`
(While processing: ${JSON.stringify(o2)})`, new Error(e4);
          }
          return { value: c2, options: r3, dirname: s2, alias: o2, externalDependencies: (0, p.finalize)(l2) };
        }), y = makeDescriptorLoader(h.makePluginAPI), b = makeDescriptorLoader(h.makePresetAPI), g = (0, c.makeWeakCache)(function* ({ value: e3, options: t3, dirname: r3, alias: s2, externalDependencies: i2 }, a2) {
          const l2 = (0, d.validatePluginObject)(e3), c2 = Object.assign({}, l2);
          if (c2.visitor && (c2.visitor = _traverse().default.explode(Object.assign({}, c2.visitor))), c2.inherits) {
            const e4 = { name: void 0, alias: `${s2}$inherits`, value: c2.inherits, options: t3, dirname: r3 }, o2 = yield* (0, n.forwardAsync)(loadPluginDescriptor, (t4) => a2.invalidate((r4) => t4(e4, r4)));
            c2.pre = chainMaybeAsync(o2.pre, c2.pre), c2.post = chainMaybeAsync(o2.post, c2.post), c2.manipulateOptions = chainMaybeAsync(o2.manipulateOptions, c2.manipulateOptions), c2.visitor = _traverse().default.visitors.merge([o2.visitor || {}, c2.visitor || {}]), o2.externalDependencies.length > 0 && (i2 = 0 === i2.length ? o2.externalDependencies : (0, p.finalize)([i2, o2.externalDependencies]));
          }
          return new o.default(c2, t3, s2, i2);
        });
        function* loadPluginDescriptor(e3, t3) {
          if (e3.value instanceof o.default) {
            if (e3.options) throw new Error("Passed options to an existing Plugin instance will not work.");
            return e3.value;
          }
          return yield* g(yield* y(e3, t3), t3);
        }
        const needsFilename = (e3) => e3 && "function" != typeof e3, validateIfOptionNeedsFilename = (e3, t3) => {
          if (needsFilename(e3.test) || needsFilename(e3.include) || needsFilename(e3.exclude)) {
            const e4 = t3.name ? `"${t3.name}"` : "/* your preset */";
            throw new f.default([`Preset ${e4} requires a filename to be set when babel is called directly,`, "```", `babel.transformSync(code, { filename: 'file.ts', presets: [${e4}] });`, "```", "See https://babeljs.io/docs/en/options#filename for more information."].join("\n"));
          }
        }, validatePreset = (e3, t3, r3) => {
          if (!t3.filename) {
            var n2;
            const { options: t4 } = e3;
            validateIfOptionNeedsFilename(t4, r3), null == (n2 = t4.overrides) || n2.forEach((e4) => validateIfOptionNeedsFilename(e4, r3));
          }
        }, x = (0, c.makeWeakCacheSync)(({ value: e3, dirname: t3, alias: r3, externalDependencies: n2 }) => ({ options: (0, u.validate)("preset", e3), alias: r3, dirname: t3, externalDependencies: n2 }));
        function* loadPresetDescriptor(e3, t3) {
          const r3 = x(yield* b(e3, t3));
          return validatePreset(r3, t3, e3), { chain: yield* (0, l.buildPresetChain)(r3, t3), externalDependencies: r3.externalDependencies };
        }
        function chainMaybeAsync(e3, t3) {
          return e3 ? t3 ? function(...r3) {
            const n2 = e3.apply(this, r3);
            return n2 && "function" == typeof n2.then ? n2.then(() => t3.apply(this, r3)) : t3.apply(this, r3);
          } : e3 : t3;
        }
      }, "./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/helpers/config-api.js": function(e2, t2, r2) {
        "use strict";
        function _semver() {
          const e3 = r2("./node_modules/.pnpm/semver@6.3.1/node_modules/semver/semver.js");
          return _semver = function() {
            return e3;
          }, e3;
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.makeConfigAPI = makeConfigAPI, t2.makePluginAPI = function(e3, t3) {
          return Object.assign({}, makePresetAPI(e3, t3), { assumption: (t4) => e3.using((e4) => e4.assumptions[t4]) });
        }, t2.makePresetAPI = makePresetAPI;
        var n = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/index.js"), s = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/caching.js");
        function makeConfigAPI(e3) {
          return { version: n.version, cache: e3.simple(), env: (t3) => e3.using((e4) => void 0 === t3 ? e4.envName : "function" == typeof t3 ? (0, s.assertSimpleType)(t3(e4.envName)) : (Array.isArray(t3) ? t3 : [t3]).some((t4) => {
            if ("string" != typeof t4) throw new Error("Unexpected non-string value");
            return t4 === e4.envName;
          })), async: () => false, caller: (t3) => e3.using((e4) => (0, s.assertSimpleType)(t3(e4.caller))), assertVersion };
        }
        function makePresetAPI(e3, t3) {
          return Object.assign({}, makeConfigAPI(e3), { targets: () => JSON.parse(e3.using((e4) => JSON.stringify(e4.targets))), addExternalDependency: (e4) => {
            t3.push(e4);
          } });
        }
        function assertVersion(e3) {
          if ("number" == typeof e3) {
            if (!Number.isInteger(e3)) throw new Error("Expected string or integer value.");
            e3 = `^${e3}.0.0-0`;
          }
          if ("string" != typeof e3) throw new Error("Expected string or integer value.");
          if ("*" === e3 || _semver().satisfies(n.version, e3)) return;
          const t3 = Error.stackTraceLimit;
          "number" == typeof t3 && t3 < 25 && (Error.stackTraceLimit = 25);
          const r3 = new Error(`Requires Babel "${e3}", but was loaded with "${n.version}". If you are sure you have a compatible version of @babel/core, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for the first entry that doesn't mention "@babel/core" or "babel-core" to see what is calling Babel.`);
          throw "number" == typeof t3 && (Error.stackTraceLimit = t3), Object.assign(r3, { code: "BABEL_VERSION_UNSUPPORTED", version: n.version, range: e3 });
        }
      }, "./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/helpers/deep-array.js": function(e2, t2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.finalize = function(e3) {
          return Object.freeze(e3);
        }, t2.flattenToSet = function(e3) {
          const t3 = /* @__PURE__ */ new Set(), r2 = [e3];
          for (; r2.length > 0; ) for (const e4 of r2.pop()) Array.isArray(e4) ? r2.push(e4) : t3.add(e4);
          return t3;
        };
      }, "./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/helpers/environment.js": function(e2, t2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.getEnv = function(e3 = "development") {
          return process.env.BABEL_ENV || process.env.NODE_ENV || e3;
        };
      }, "./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/index.js": function(e2, t2, r2) {
        "use strict";
        function _gensync() {
          const e3 = r2("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return _gensync = function() {
            return e3;
          }, e3;
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.createConfigItem = function(e3, t3, r3) {
          if (void 0 !== r3) (0, o.beginHiddenCallStack)(p.errback)(e3, t3, r3);
          else {
            if ("function" != typeof t3) return createConfigItemSync(e3, t3);
            (0, o.beginHiddenCallStack)(p.errback)(e3, void 0, r3);
          }
        }, t2.createConfigItemAsync = function(...e3) {
          return (0, o.beginHiddenCallStack)(p.async)(...e3);
        }, t2.createConfigItemSync = createConfigItemSync, Object.defineProperty(t2, "default", { enumerable: true, get: function() {
          return n.default;
        } }), t2.loadOptions = function(e3, t3) {
          if (void 0 !== t3) (0, o.beginHiddenCallStack)(l.errback)(e3, t3);
          else {
            if ("function" != typeof e3) return loadOptionsSync(e3);
            (0, o.beginHiddenCallStack)(l.errback)(void 0, e3);
          }
        }, t2.loadOptionsAsync = function(...e3) {
          return (0, o.beginHiddenCallStack)(l.async)(...e3);
        }, t2.loadOptionsSync = loadOptionsSync, t2.loadPartialConfig = function(e3, t3) {
          if (void 0 !== t3) (0, o.beginHiddenCallStack)(a.errback)(e3, t3);
          else {
            if ("function" != typeof e3) return loadPartialConfigSync(e3);
            (0, o.beginHiddenCallStack)(a.errback)(void 0, e3);
          }
        }, t2.loadPartialConfigAsync = function(...e3) {
          return (0, o.beginHiddenCallStack)(a.async)(...e3);
        }, t2.loadPartialConfigSync = loadPartialConfigSync;
        var n = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/full.js"), s = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/partial.js"), i = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/item.js"), o = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/errors/rewrite-stack-trace.js");
        const a = _gensync()(s.loadPartialConfig);
        function loadPartialConfigSync(...e3) {
          return (0, o.beginHiddenCallStack)(a.sync)(...e3);
        }
        const l = _gensync()(function* (e3) {
          var t3;
          const r3 = yield* (0, n.default)(e3);
          return null != (t3 = null == r3 ? void 0 : r3.options) ? t3 : null;
        });
        function loadOptionsSync(...e3) {
          return (0, o.beginHiddenCallStack)(l.sync)(...e3);
        }
        const p = _gensync()(i.createConfigItem);
        function createConfigItemSync(...e3) {
          return (0, o.beginHiddenCallStack)(p.sync)(...e3);
        }
      }, "./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/item.js": function(e2, t2, r2) {
        "use strict";
        function _path() {
          const e3 = r2("path");
          return _path = function() {
            return e3;
          }, e3;
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.createConfigItem = function* (e3, { dirname: t3 = ".", type: r3 } = {}) {
          return createItemFromDescriptor(yield* (0, n.createDescriptor)(e3, _path().resolve(t3), { type: r3, alias: "programmatic item" }));
        }, t2.createItemFromDescriptor = createItemFromDescriptor, t2.getItemDescriptor = function(e3) {
          if (null != e3 && e3[s]) return e3._descriptor;
          return;
        };
        var n = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/config-descriptors.js");
        function createItemFromDescriptor(e3) {
          return new ConfigItem(e3);
        }
        const s = /* @__PURE__ */ Symbol.for("@babel/core@7 - ConfigItem");
        class ConfigItem {
          constructor(e3) {
            this._descriptor = void 0, this[s] = true, this.value = void 0, this.options = void 0, this.dirname = void 0, this.name = void 0, this.file = void 0, this._descriptor = e3, Object.defineProperty(this, "_descriptor", { enumerable: false }), Object.defineProperty(this, s, { enumerable: false }), this.value = this._descriptor.value, this.options = this._descriptor.options, this.dirname = this._descriptor.dirname, this.name = this._descriptor.name, this.file = this._descriptor.file ? { request: this._descriptor.file.request, resolved: this._descriptor.file.resolved } : void 0, Object.freeze(this);
          }
        }
        Object.freeze(ConfigItem.prototype);
      }, "./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/partial.js": function(e2, t2, r2) {
        "use strict";
        function _path() {
          const e3 = r2("path");
          return _path = function() {
            return e3;
          }, e3;
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = loadPrivatePartialConfig, t2.loadPartialConfig = function* (e3) {
          let t3 = false;
          if ("object" == typeof e3 && null !== e3 && !Array.isArray(e3)) {
            var r3 = e3;
            ({ showIgnoredFiles: t3 } = r3), e3 = (function(e4, t4) {
              if (null == e4) return {};
              var r4 = {};
              for (var n2 in e4) if ({}.hasOwnProperty.call(e4, n2)) {
                if (-1 !== t4.indexOf(n2)) continue;
                r4[n2] = e4[n2];
              }
              return r4;
            })(r3, u);
          }
          const s2 = yield* loadPrivatePartialConfig(e3);
          if (!s2) return null;
          const { options: i2, babelrc: o2, ignore: a2, config: l2, fileHandling: p2, files: c2 } = s2;
          if ("ignored" === p2 && !t3) return null;
          return (i2.plugins || []).forEach((e4) => {
            if (e4.value instanceof n.default) throw new Error("Passing cached plugin instances is not supported in babel.loadPartialConfig()");
          }), new PartialConfig(i2, o2 ? o2.filepath : void 0, a2 ? a2.filepath : void 0, l2 ? l2.filepath : void 0, p2, c2);
        };
        var n = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/plugin.js"), s = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/util.js"), i = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/item.js"), o = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/config-chain.js"), a = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/helpers/environment.js"), l = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/validation/options.js"), p = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/files/index.js"), c = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/resolve-targets.js");
        const u = ["showIgnoredFiles"];
        function* loadPrivatePartialConfig(e3) {
          if (null != e3 && ("object" != typeof e3 || Array.isArray(e3))) throw new Error("Babel options must be an object, null, or undefined");
          const t3 = e3 ? (0, l.validate)("arguments", e3) : {}, { envName: r3 = (0, a.getEnv)(), cwd: n2 = ".", root: u2 = ".", rootMode: d = "root", caller: h, cloneInputAst: m = true } = t3, f = _path().resolve(n2), y = (function(e4, t4) {
            switch (t4) {
              case "root":
                return e4;
              case "upward-optional": {
                const t5 = (0, p.findConfigUpwards)(e4);
                return null === t5 ? e4 : t5;
              }
              case "upward": {
                const t5 = (0, p.findConfigUpwards)(e4);
                if (null !== t5) return t5;
                throw Object.assign(new Error(`Babel was run with rootMode:"upward" but a root could not be found when searching upward from "${e4}".
One of the following config files must be in the directory tree: "${p.ROOT_CONFIG_FILENAMES.join(", ")}".`), { code: "BABEL_ROOT_NOT_FOUND", dirname: e4 });
              }
              default:
                throw new Error("Assertion failure - unknown rootMode value.");
            }
          })(_path().resolve(f, u2), d), b = "string" == typeof t3.filename ? _path().resolve(n2, t3.filename) : void 0, g = { filename: b, cwd: f, root: y, envName: r3, caller: h, showConfig: (yield* (0, p.resolveShowConfigPath)(f)) === b }, x = yield* (0, o.buildRootChain)(t3, g);
          if (!x) return null;
          const v = { assumptions: {} };
          x.options.forEach((e4) => {
            (0, s.mergeOptions)(v, e4);
          });
          return { options: Object.assign({}, v, { targets: (0, c.resolveTargets)(v, y), cloneInputAst: m, babelrc: false, configFile: false, browserslistConfigFile: false, passPerPreset: false, envName: g.envName, cwd: g.cwd, root: g.root, rootMode: "root", filename: "string" == typeof g.filename ? g.filename : void 0, plugins: x.plugins.map((e4) => (0, i.createItemFromDescriptor)(e4)), presets: x.presets.map((e4) => (0, i.createItemFromDescriptor)(e4)) }), context: g, fileHandling: x.fileHandling, ignore: x.ignore, babelrc: x.babelrc, config: x.config, files: x.files };
        }
        class PartialConfig {
          constructor(e3, t3, r3, n2, s2, i2) {
            this.options = void 0, this.babelrc = void 0, this.babelignore = void 0, this.config = void 0, this.fileHandling = void 0, this.files = void 0, this.options = e3, this.babelignore = r3, this.babelrc = t3, this.config = n2, this.fileHandling = s2, this.files = i2, Object.freeze(this);
          }
          hasFilesystemConfig() {
            return void 0 !== this.babelrc || void 0 !== this.config;
          }
        }
        Object.freeze(PartialConfig.prototype);
      }, "./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/pattern-to-regex.js": function(e2, t2, r2) {
        "use strict";
        function _path() {
          const e3 = r2("path");
          return _path = function() {
            return e3;
          }, e3;
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
          const r3 = _path().resolve(t3, e3).split(_path().sep);
          return new RegExp(["^", ...r3.map((e4, t4) => {
            const c = t4 === r3.length - 1;
            return "**" === e4 ? c ? p : l : "*" === e4 ? c ? a : o : 0 === e4.indexOf("*.") ? i + escapeRegExp(e4.slice(1)) + (c ? s : n) : escapeRegExp(e4) + (c ? s : n);
          })].join(""));
        };
        const n = `\\${_path().sep}`, s = `(?:${n}|$)`, i = `[^${n}]+`, o = `(?:${i}${n})`, a = `(?:${i}${s})`, l = `${o}*?`, p = `${o}*?${a}?`;
        function escapeRegExp(e3) {
          return e3.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&");
        }
      }, "./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/plugin.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var n = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/helpers/deep-array.js");
        t2.default = class {
          constructor(e3, t3, r3, s = (0, n.finalize)([])) {
            this.key = void 0, this.manipulateOptions = void 0, this.post = void 0, this.pre = void 0, this.visitor = void 0, this.parserOverride = void 0, this.generatorOverride = void 0, this.options = void 0, this.externalDependencies = void 0, this.key = e3.name || r3, this.manipulateOptions = e3.manipulateOptions, this.post = e3.post, this.pre = e3.pre, this.visitor = e3.visitor || {}, this.parserOverride = e3.parserOverride, this.generatorOverride = e3.generatorOverride, this.options = t3, this.externalDependencies = s;
          }
        };
      }, "./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/printer.js": function(e2, t2, r2) {
        "use strict";
        function _gensync() {
          const e3 = r2("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return _gensync = function() {
            return e3;
          }, e3;
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.ConfigPrinter = t2.ChainFormatter = void 0;
        const n = t2.ChainFormatter = { Programmatic: 0, Config: 1 }, s = { title(e3, t3, r3) {
          let s2 = "";
          return e3 === n.Programmatic ? (s2 = "programmatic options", t3 && (s2 += " from " + t3)) : s2 = "config " + r3, s2;
        }, loc(e3, t3) {
          let r3 = "";
          return null != e3 && (r3 += `.overrides[${e3}]`), null != t3 && (r3 += `.env["${t3}"]`), r3;
        }, *optionsAndDescriptors(e3) {
          const t3 = Object.assign({}, e3.options);
          delete t3.overrides, delete t3.env;
          const r3 = [...yield* e3.plugins()];
          r3.length && (t3.plugins = r3.map((e4) => descriptorToConfig(e4)));
          const n2 = [...yield* e3.presets()];
          return n2.length && (t3.presets = [...n2].map((e4) => descriptorToConfig(e4))), JSON.stringify(t3, void 0, 2);
        } };
        function descriptorToConfig(e3) {
          var t3;
          let r3 = null == (t3 = e3.file) ? void 0 : t3.request;
          return null == r3 && ("object" == typeof e3.value ? r3 = e3.value : "function" == typeof e3.value && (r3 = `[Function: ${e3.value.toString().slice(0, 50)} ... ]`)), null == r3 && (r3 = "[Unknown]"), void 0 === e3.options ? r3 : null == e3.name ? [r3, e3.options] : [r3, e3.options, e3.name];
        }
        class ConfigPrinter {
          constructor() {
            this._stack = [];
          }
          configure(e3, t3, { callerName: r3, filepath: n2 }) {
            return e3 ? (e4, s2, i) => {
              this._stack.push({ type: t3, callerName: r3, filepath: n2, content: e4, index: s2, envName: i });
            } : () => {
            };
          }
          static *format(e3) {
            let t3 = s.title(e3.type, e3.callerName, e3.filepath);
            const r3 = s.loc(e3.index, e3.envName);
            r3 && (t3 += ` ${r3}`);
            return `${t3}
${yield* s.optionsAndDescriptors(e3.content)}`;
          }
          *output() {
            if (0 === this._stack.length) return "";
            return (yield* _gensync().all(this._stack.map((e3) => ConfigPrinter.format(e3)))).join("\n\n");
          }
        }
        t2.ConfigPrinter = ConfigPrinter;
      }, "./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/resolve-targets.js": function(e2, t2, r2) {
        "use strict";
        function _path() {
          const e3 = r2("path");
          return _path = function() {
            return e3;
          }, e3;
        }
        function _helperCompilationTargets() {
          const e3 = r2("./stubs/helper-compilation-targets.mjs");
          return _helperCompilationTargets = function() {
            return e3;
          }, e3;
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.resolveBrowserslistConfigFile = function(e3, t3) {
          return _path().resolve(t3, e3);
        }, t2.resolveTargets = function(e3, t3) {
          const r3 = e3.targets;
          let n;
          "string" == typeof r3 || Array.isArray(r3) ? n = { browsers: r3 } : r3 && (n = "esmodules" in r3 ? Object.assign({}, r3, { esmodules: "intersect" }) : r3);
          const { browserslistConfigFile: s } = e3;
          let i, o = false;
          "string" == typeof s ? i = s : o = false === s;
          return (0, _helperCompilationTargets().default)(n, { ignoreBrowserslistConfig: o, configFile: i, configPath: t3, browserslistEnv: e3.browserslistEnv });
        };
      }, "./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/util.js": function(e2, t2) {
        "use strict";
        function mergeDefaultFields(e3, t3) {
          for (const r2 of Object.keys(t3)) {
            const n = t3[r2];
            void 0 !== n && (e3[r2] = n);
          }
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.isIterableIterator = function(e3) {
          return !!e3 && "function" == typeof e3.next && "function" == typeof e3[Symbol.iterator];
        }, t2.mergeOptions = function(e3, t3) {
          for (const r2 of Object.keys(t3)) if ("parserOpts" !== r2 && "generatorOpts" !== r2 && "assumptions" !== r2 || !t3[r2]) {
            const n = t3[r2];
            void 0 !== n && (e3[r2] = n);
          } else {
            const n = t3[r2];
            mergeDefaultFields(e3[r2] || (e3[r2] = {}), n);
          }
        };
      }, "./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/validation/option-assertions.js": function(e2, t2, r2) {
        "use strict";
        function _helperCompilationTargets() {
          const e3 = r2("./stubs/helper-compilation-targets.mjs");
          return _helperCompilationTargets = function() {
            return e3;
          }, e3;
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.access = access, t2.assertArray = assertArray, t2.assertAssumptions = function(e3, t3) {
          if (void 0 === t3) return;
          if ("object" != typeof t3 || null === t3) throw new Error(`${msg(e3)} must be an object or undefined.`);
          let r3 = e3;
          do {
            r3 = r3.parent;
          } while ("root" !== r3.type);
          const s = "preset" === r3.source;
          for (const r4 of Object.keys(t3)) {
            const i = access(e3, r4);
            if (!n.assumptionsNames.has(r4)) throw new Error(`${msg(i)} is not a supported assumption.`);
            if ("boolean" != typeof t3[r4]) throw new Error(`${msg(i)} must be a boolean.`);
            if (s && false === t3[r4]) throw new Error(`${msg(i)} cannot be set to 'false' inside presets.`);
          }
          return t3;
        }, t2.assertBabelrcSearch = function(e3, t3) {
          if (void 0 === t3 || "boolean" == typeof t3) return t3;
          if (Array.isArray(t3)) t3.forEach((t4, r3) => {
            if (!checkValidTest(t4)) throw new Error(`${msg(access(e3, r3))} must be a string/Function/RegExp.`);
          });
          else if (!checkValidTest(t3)) throw new Error(`${msg(e3)} must be a undefined, a boolean, a string/Function/RegExp or an array of those, got ${JSON.stringify(t3)}`);
          return t3;
        }, t2.assertBoolean = assertBoolean, t2.assertCallerMetadata = function(e3, t3) {
          const r3 = assertObject(e3, t3);
          if (r3) {
            if ("string" != typeof r3.name) throw new Error(`${msg(e3)} set but does not contain "name" property string`);
            for (const t4 of Object.keys(r3)) {
              const n2 = access(e3, t4), s = r3[t4];
              if (null != s && "boolean" != typeof s && "string" != typeof s && "number" != typeof s) throw new Error(`${msg(n2)} must be null, undefined, a boolean, a string, or a number.`);
            }
          }
          return t3;
        }, t2.assertCompact = function(e3, t3) {
          if (void 0 !== t3 && "boolean" != typeof t3 && "auto" !== t3) throw new Error(`${msg(e3)} must be a boolean, "auto", or undefined`);
          return t3;
        }, t2.assertConfigApplicableTest = function(e3, t3) {
          if (void 0 === t3) return t3;
          if (Array.isArray(t3)) t3.forEach((t4, r3) => {
            if (!checkValidTest(t4)) throw new Error(`${msg(access(e3, r3))} must be a string/Function/RegExp.`);
          });
          else if (!checkValidTest(t3)) throw new Error(`${msg(e3)} must be a string/Function/RegExp, or an array of those`);
          return t3;
        }, t2.assertConfigFileSearch = function(e3, t3) {
          if (void 0 !== t3 && "boolean" != typeof t3 && "string" != typeof t3) throw new Error(`${msg(e3)} must be a undefined, a boolean, a string, got ${JSON.stringify(t3)}`);
          return t3;
        }, t2.assertFunction = function(e3, t3) {
          if (void 0 !== t3 && "function" != typeof t3) throw new Error(`${msg(e3)} must be a function, or undefined`);
          return t3;
        }, t2.assertIgnoreList = function(e3, t3) {
          const r3 = assertArray(e3, t3);
          return null == r3 || r3.forEach((t4, r4) => (function(e4, t5) {
            if ("string" != typeof t5 && "function" != typeof t5 && !(t5 instanceof RegExp)) throw new Error(`${msg(e4)} must be an array of string/Function/RegExp values, or undefined`);
            return t5;
          })(access(e3, r4), t4)), r3;
        }, t2.assertInputSourceMap = function(e3, t3) {
          if (void 0 !== t3 && "boolean" != typeof t3 && ("object" != typeof t3 || !t3)) throw new Error(`${msg(e3)} must be a boolean, object, or undefined`);
          return t3;
        }, t2.assertObject = assertObject, t2.assertPluginList = function(e3, t3) {
          const r3 = assertArray(e3, t3);
          r3 && r3.forEach((t4, r4) => (function(e4, t5) {
            if (Array.isArray(t5)) {
              if (0 === t5.length) throw new Error(`${msg(e4)} must include an object`);
              if (t5.length > 3) throw new Error(`${msg(e4)} may only be a two-tuple or three-tuple`);
              if (assertPluginTarget(access(e4, 0), t5[0]), t5.length > 1) {
                const r5 = t5[1];
                if (void 0 !== r5 && false !== r5 && ("object" != typeof r5 || Array.isArray(r5) || null === r5)) throw new Error(`${msg(access(e4, 1))} must be an object, false, or undefined`);
              }
              if (3 === t5.length) {
                const r5 = t5[2];
                if (void 0 !== r5 && "string" != typeof r5) throw new Error(`${msg(access(e4, 2))} must be a string, or undefined`);
              }
            } else assertPluginTarget(e4, t5);
            return t5;
          })(access(e3, r4), t4));
          return r3;
        }, t2.assertRootMode = function(e3, t3) {
          if (void 0 !== t3 && "root" !== t3 && "upward" !== t3 && "upward-optional" !== t3) throw new Error(`${msg(e3)} must be a "root", "upward", "upward-optional" or undefined`);
          return t3;
        }, t2.assertSourceMaps = function(e3, t3) {
          if (void 0 !== t3 && "boolean" != typeof t3 && "inline" !== t3 && "both" !== t3) throw new Error(`${msg(e3)} must be a boolean, "inline", "both", or undefined`);
          return t3;
        }, t2.assertSourceType = function(e3, t3) {
          if (void 0 !== t3 && "module" !== t3 && "commonjs" !== t3 && "script" !== t3 && "unambiguous" !== t3) throw new Error(`${msg(e3)} must be "module", "commonjs", "script", "unambiguous", or undefined`);
          return t3;
        }, t2.assertString = function(e3, t3) {
          if (void 0 !== t3 && "string" != typeof t3) throw new Error(`${msg(e3)} must be a string, or undefined`);
          return t3;
        }, t2.assertTargets = function(e3, t3) {
          if ((0, _helperCompilationTargets().isBrowsersQueryValid)(t3)) return t3;
          if ("object" != typeof t3 || !t3 || Array.isArray(t3)) throw new Error(`${msg(e3)} must be a string, an array of strings or an object`);
          const r3 = access(e3, "browsers"), n2 = access(e3, "esmodules");
          assertBrowsersList(r3, t3.browsers), assertBoolean(n2, t3.esmodules);
          for (const r4 of Object.keys(t3)) {
            const n3 = t3[r4], s = access(e3, r4);
            if ("esmodules" === r4) assertBoolean(s, n3);
            else if ("browsers" === r4) assertBrowsersList(s, n3);
            else {
              if (!hasOwnProperty.call(_helperCompilationTargets().TargetNames, r4)) {
                const e4 = Object.keys(_helperCompilationTargets().TargetNames).join(", ");
                throw new Error(`${msg(s)} is not a valid target. Supported targets are ${e4}`);
              }
              assertBrowserVersion(s, n3);
            }
          }
          return t3;
        }, t2.msg = msg;
        var n = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/validation/options.js");
        function msg(e3) {
          switch (e3.type) {
            case "root":
              return "";
            case "env":
              return `${msg(e3.parent)}.env["${e3.name}"]`;
            case "overrides":
              return `${msg(e3.parent)}.overrides[${e3.index}]`;
            case "option":
              return `${msg(e3.parent)}.${e3.name}`;
            case "access":
              return `${msg(e3.parent)}[${JSON.stringify(e3.name)}]`;
            default:
              throw new Error(`Assertion failure: Unknown type ${e3.type}`);
          }
        }
        function access(e3, t3) {
          return { type: "access", name: t3, parent: e3 };
        }
        function assertBoolean(e3, t3) {
          if (void 0 !== t3 && "boolean" != typeof t3) throw new Error(`${msg(e3)} must be a boolean, or undefined`);
          return t3;
        }
        function assertObject(e3, t3) {
          if (void 0 !== t3 && ("object" != typeof t3 || Array.isArray(t3) || !t3)) throw new Error(`${msg(e3)} must be an object, or undefined`);
          return t3;
        }
        function assertArray(e3, t3) {
          if (null != t3 && !Array.isArray(t3)) throw new Error(`${msg(e3)} must be an array, or undefined`);
          return t3;
        }
        function checkValidTest(e3) {
          return "string" == typeof e3 || "function" == typeof e3 || e3 instanceof RegExp;
        }
        function assertPluginTarget(e3, t3) {
          if (("object" != typeof t3 || !t3) && "string" != typeof t3 && "function" != typeof t3) throw new Error(`${msg(e3)} must be a string, object, function`);
          return t3;
        }
        function assertBrowsersList(e3, t3) {
          if (void 0 !== t3 && !(0, _helperCompilationTargets().isBrowsersQueryValid)(t3)) throw new Error(`${msg(e3)} must be undefined, a string or an array of strings`);
        }
        function assertBrowserVersion(e3, t3) {
          if (("number" != typeof t3 || Math.round(t3) !== t3) && "string" != typeof t3) throw new Error(`${msg(e3)} must be a string or an integer number`);
        }
      }, "./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/validation/options.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.assumptionsNames = void 0, t2.checkNoUnwrappedItemOptionPairs = function(e3, t3, r3, n2) {
          if (0 === t3) return;
          const s2 = e3[t3 - 1], i2 = e3[t3];
          s2.file && void 0 === s2.options && "object" == typeof i2.value && (n2.message += `
- Maybe you meant to use
"${r3}s": [
  ["${s2.file.request}", ${JSON.stringify(i2.value, void 0, 2)}]
]
To be a valid ${r3}, its name and options should be wrapped in a pair of brackets`);
        }, t2.validate = function(e3, t3, r3) {
          try {
            return validateNested({ type: "root", source: e3 }, t3);
          } catch (e4) {
            const t4 = new i.default(e4.message, r3);
            throw e4.code && (t4.code = e4.code), t4;
          }
        };
        var n = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/validation/removed.js"), s = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/validation/option-assertions.js"), i = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/errors/config-error.js");
        const o = { cwd: s.assertString, root: s.assertString, rootMode: s.assertRootMode, configFile: s.assertConfigFileSearch, caller: s.assertCallerMetadata, filename: s.assertString, filenameRelative: s.assertString, code: s.assertBoolean, ast: s.assertBoolean, cloneInputAst: s.assertBoolean, envName: s.assertString }, a = { babelrc: s.assertBoolean, babelrcRoots: s.assertBabelrcSearch }, l = { extends: s.assertString, ignore: s.assertIgnoreList, only: s.assertIgnoreList, targets: s.assertTargets, browserslistConfigFile: s.assertConfigFileSearch, browserslistEnv: s.assertString }, p = { inputSourceMap: s.assertInputSourceMap, presets: s.assertPluginList, plugins: s.assertPluginList, passPerPreset: s.assertBoolean, assumptions: s.assertAssumptions, env: function(e3, t3) {
          if ("env" === e3.parent.type) throw new Error(`${(0, s.msg)(e3)} is not allowed inside of another .env block`);
          const r3 = e3.parent, n2 = (0, s.assertObject)(e3, t3);
          if (n2) for (const t4 of Object.keys(n2)) {
            const i2 = (0, s.assertObject)((0, s.access)(e3, t4), n2[t4]);
            if (!i2) continue;
            validateNested({ type: "env", name: t4, parent: r3 }, i2);
          }
          return n2;
        }, overrides: function(e3, t3) {
          if ("env" === e3.parent.type) throw new Error(`${(0, s.msg)(e3)} is not allowed inside an .env block`);
          if ("overrides" === e3.parent.type) throw new Error(`${(0, s.msg)(e3)} is not allowed inside an .overrides block`);
          const r3 = e3.parent, n2 = (0, s.assertArray)(e3, t3);
          if (n2) for (const [t4, i2] of n2.entries()) {
            const n3 = (0, s.access)(e3, t4), o2 = (0, s.assertObject)(n3, i2);
            if (!o2) throw new Error(`${(0, s.msg)(n3)} must be an object`);
            validateNested({ type: "overrides", index: t4, parent: r3 }, o2);
          }
          return n2;
        }, test: s.assertConfigApplicableTest, include: s.assertConfigApplicableTest, exclude: s.assertConfigApplicableTest, retainLines: s.assertBoolean, comments: s.assertBoolean, shouldPrintComment: s.assertFunction, compact: s.assertCompact, minified: s.assertBoolean, auxiliaryCommentBefore: s.assertString, auxiliaryCommentAfter: s.assertString, sourceType: s.assertSourceType, wrapPluginVisitorMethod: s.assertFunction, highlightCode: s.assertBoolean, sourceMaps: s.assertSourceMaps, sourceMap: s.assertSourceMaps, sourceFileName: s.assertString, sourceRoot: s.assertString, parserOpts: s.assertObject, generatorOpts: s.assertObject };
        Object.assign(p, { getModuleId: s.assertFunction, moduleRoot: s.assertString, moduleIds: s.assertBoolean, moduleId: s.assertString });
        t2.assumptionsNames = /* @__PURE__ */ new Set(["arrayLikeIsIterable", "constantReexports", "constantSuper", "enumerableModuleMeta", "ignoreFunctionLength", "ignoreToPrimitiveHint", "iterableIsArray", "mutableTemplateObject", "noClassCalls", "noDocumentAll", "noIncompleteNsImportDetection", "noNewArrows", "noUninitializedPrivateFieldAccess", "objectRestNoSymbols", "privateFieldsAsSymbols", "privateFieldsAsProperties", "pureGetters", "setClassMethods", "setComputedProperties", "setPublicClassFields", "setSpreadProperties", "skipForOfIteratorClosing", "superIsCallableConstructor"]);
        function getSource(e3) {
          return "root" === e3.type ? e3.source : getSource(e3.parent);
        }
        function validateNested(e3, t3) {
          const r3 = getSource(e3);
          return (function(e4) {
            if (hasOwnProperty.call(e4, "sourceMap") && hasOwnProperty.call(e4, "sourceMaps")) throw new Error(".sourceMap is an alias for .sourceMaps, cannot use both");
          })(t3), Object.keys(t3).forEach((n2) => {
            const i2 = { type: "option", name: n2, parent: e3 };
            if ("preset" === r3 && l[n2]) throw new Error(`${(0, s.msg)(i2)} is not allowed in preset options`);
            if ("arguments" !== r3 && o[n2]) throw new Error(`${(0, s.msg)(i2)} is only allowed in root programmatic options`);
            if ("arguments" !== r3 && "configfile" !== r3 && a[n2]) {
              if ("babelrcfile" === r3 || "extendsfile" === r3) throw new Error(`${(0, s.msg)(i2)} is not allowed in .babelrc or "extends"ed files, only in root programmatic options, or babel.config.js/config file options`);
              throw new Error(`${(0, s.msg)(i2)} is only allowed in root programmatic options, or babel.config.js/config file options`);
            }
            (p[n2] || l[n2] || a[n2] || o[n2] || throwUnknownError)(i2, t3[n2]);
          }), t3;
        }
        function throwUnknownError(e3) {
          const t3 = e3.name;
          if (n.default[t3]) {
            const { message: r3, version: i2 = 5 } = n.default[t3];
            throw new Error(`Using removed Babel ${i2} option: ${(0, s.msg)(e3)} - ${r3}`);
          }
          {
            const t4 = new Error(`Unknown option: ${(0, s.msg)(e3)}. Check out https://babeljs.io/docs/en/babel-core/#options for more information about options.`);
            throw t4.code = "BABEL_UNKNOWN_OPTION", t4;
          }
        }
      }, "./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/validation/plugins.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.validatePluginObject = function(e3) {
          const t3 = { type: "root", source: "plugin" };
          return Object.keys(e3).forEach((r3) => {
            const n2 = s[r3];
            if (!n2) {
              const e4 = new Error(`.${r3} is not a valid Plugin property`);
              throw e4.code = "BABEL_UNKNOWN_PLUGIN_PROPERTY", e4;
            }
            n2({ type: "option", name: r3, parent: t3 }, e3[r3]);
          }), e3;
        };
        var n = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/validation/option-assertions.js");
        const s = { name: n.assertString, manipulateOptions: n.assertFunction, pre: n.assertFunction, post: n.assertFunction, inherits: n.assertFunction, visitor: function(e3, t3) {
          const r3 = (0, n.assertObject)(e3, t3);
          if (r3 && (Object.keys(r3).forEach((e4) => {
            "_exploded" !== e4 && "_verified" !== e4 && (function(e5, t4) {
              if (t4 && "object" == typeof t4) Object.keys(t4).forEach((t5) => {
                if ("enter" !== t5 && "exit" !== t5) throw new Error(`.visitor["${e5}"] may only have .enter and/or .exit handlers.`);
              });
              else if ("function" != typeof t4) throw new Error(`.visitor["${e5}"] must be a function`);
            })(e4, r3[e4]);
          }), r3.enter || r3.exit)) throw new Error(`${(0, n.msg)(e3)} cannot contain catch-all "enter" or "exit" handlers. Please target individual nodes.`);
          return r3;
        }, parserOverride: n.assertFunction, generatorOverride: n.assertFunction };
      }, "./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/validation/removed.js": function(e2, t2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        t2.default = { auxiliaryComment: { message: "Use `auxiliaryCommentBefore` or `auxiliaryCommentAfter`" }, blacklist: { message: "Put the specific transforms you want in the `plugins` option" }, breakConfig: { message: "This is not a necessary option in Babel 6" }, experimental: { message: "Put the specific transforms you want in the `plugins` option" }, externalHelpers: { message: "Use the `external-helpers` plugin instead. Check out http://babeljs.io/docs/plugins/external-helpers/" }, extra: { message: "" }, jsxPragma: { message: "use the `pragma` option in the `react-jsx` plugin. Check out http://babeljs.io/docs/plugins/transform-react-jsx/" }, loose: { message: "Specify the `loose` option for the relevant plugin you are using or use a preset that sets the option." }, metadataUsedHelpers: { message: "Not required anymore as this is enabled by default" }, modules: { message: "Use the corresponding module transform plugin in the `plugins` option. Check out http://babeljs.io/docs/plugins/#modules" }, nonStandard: { message: "Use the `react-jsx` and `flow-strip-types` plugins to support JSX and Flow. Also check out the react preset http://babeljs.io/docs/plugins/preset-react/" }, optional: { message: "Put the specific transforms you want in the `plugins` option" }, sourceMapName: { message: "The `sourceMapName` option has been removed because it makes more sense for the tooling that calls Babel to assign `map.file` themselves." }, stage: { message: "Check out the corresponding stage-x presets http://babeljs.io/docs/plugins/#presets" }, whitelist: { message: "Put the specific transforms you want in the `plugins` option" }, resolveModuleSource: { version: 6, message: "Use `babel-plugin-module-resolver@3`'s 'resolvePath' options" }, metadata: { version: 6, message: "Generated plugin metadata is always included in the output result" }, sourceMapTarget: { version: 6, message: "The `sourceMapTarget` option has been removed because it makes more sense for the tooling that calls Babel to assign `map.file` themselves." } };
      }, "./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/errors/config-error.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var n = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/errors/rewrite-stack-trace.js");
        class ConfigError extends Error {
          constructor(e3, t3) {
            super(e3), (0, n.expectedError)(this), t3 && (0, n.injectVirtualStackFrame)(this, t3);
          }
        }
        t2.default = ConfigError;
      }, "./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/errors/rewrite-stack-trace.js": function(e2, t2) {
        "use strict";
        var r2;
        Object.defineProperty(t2, "__esModule", { value: true }), t2.beginHiddenCallStack = function(e3) {
          return s ? Object.defineProperty(function(...t3) {
            return setupPrepareStackTrace(), e3(...t3);
          }, "name", { value: o }) : e3;
        }, t2.endHiddenCallStack = function(e3) {
          return s ? Object.defineProperty(function(...t3) {
            return e3(...t3);
          }, "name", { value: i }) : e3;
        }, t2.expectedError = function(e3) {
          if (!s) return;
          return a.add(e3), e3;
        }, t2.injectVirtualStackFrame = function(e3, t3) {
          if (!s) return;
          let r3 = l.get(e3);
          r3 || l.set(e3, r3 = []);
          return r3.push(/* @__PURE__ */ (function(e4) {
            return /* @__PURE__ */ Object.create({ isNative: () => false, isConstructor: () => false, isToplevel: () => true, getFileName: () => e4, getLineNumber: () => {
            }, getColumnNumber: () => {
            }, getFunctionName: () => {
            }, getMethodName: () => {
            }, getTypeName: () => {
            }, toString: () => e4 });
          })(t3)), e3;
        };
        const n = Function.call.bind(Error.prototype.toString), s = !!Error.captureStackTrace && true === (null == (r2 = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit")) ? void 0 : r2.writable), i = "startHiding - secret - don't use this - v1", o = "stopHiding - secret - don't use this - v1", a = /* @__PURE__ */ new WeakSet(), l = /* @__PURE__ */ new WeakMap();
        function setupPrepareStackTrace() {
          setupPrepareStackTrace = () => {
          };
          const { prepareStackTrace: e3 = defaultPrepareStackTrace } = Error;
          Error.stackTraceLimit && (Error.stackTraceLimit = Math.max(Error.stackTraceLimit, 50)), Error.prepareStackTrace = function(t3, r3) {
            let n2 = [];
            let s2 = a.has(t3) ? "hiding" : "unknown";
            for (let e4 = 0; e4 < r3.length; e4++) {
              const a2 = r3[e4].getFunctionName();
              if (a2 === i) s2 = "hiding";
              else if (a2 === o) {
                if ("hiding" === s2) s2 = "showing", l.has(t3) && n2.unshift(...l.get(t3));
                else if ("unknown" === s2) {
                  n2 = r3;
                  break;
                }
              } else "hiding" !== s2 && n2.push(r3[e4]);
            }
            return e3(t3, n2);
          };
        }
        function defaultPrepareStackTrace(e3, t3) {
          return 0 === t3.length ? n(e3) : `${n(e3)}
    at ${t3.join("\n    at ")}`;
        }
      }, "./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/gensync-utils/async.js": function(e2, t2, r2) {
        "use strict";
        function _gensync() {
          const e3 = r2("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return _gensync = function() {
            return e3;
          }, e3;
        }
        function asyncGeneratorStep(e3, t3, r3, n2, s2, i2, o2) {
          try {
            var a = e3[i2](o2), l = a.value;
          } catch (e4) {
            return void r3(e4);
          }
          a.done ? t3(l) : Promise.resolve(l).then(n2, s2);
        }
        function _asyncToGenerator(e3) {
          return function() {
            var t3 = this, r3 = arguments;
            return new Promise(function(n2, s2) {
              var i2 = e3.apply(t3, r3);
              function _next(e4) {
                asyncGeneratorStep(i2, n2, s2, _next, _throw, "next", e4);
              }
              function _throw(e4) {
                asyncGeneratorStep(i2, n2, s2, _next, _throw, "throw", e4);
              }
              _next(void 0);
            });
          };
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.forwardAsync = function(e3, t3) {
          const r3 = _gensync()(e3);
          return s((e4) => {
            const n2 = r3[e4];
            return t3(n2);
          });
        }, t2.isAsync = void 0, t2.isThenable = isThenable, t2.maybeAsync = function(e3, t3) {
          return _gensync()({ sync(...r3) {
            const n2 = e3.apply(this, r3);
            if (isThenable(n2)) throw new Error(t3);
            return n2;
          }, async(...t4) {
            return Promise.resolve(e3.apply(this, t4));
          } });
        }, t2.waitFor = t2.onFirstPause = void 0;
        const n = _gensync()(function* (e3) {
          return yield* e3;
        });
        t2.isAsync = _gensync()({ sync: () => false, errback: (e3) => e3(null, true) });
        const s = _gensync()({ sync: (e3) => e3("sync"), async: (i = _asyncToGenerator(function* (e3) {
          return e3("async");
        }), function(e3) {
          return i.apply(this, arguments);
        }) });
        var i;
        t2.onFirstPause = _gensync()({ name: "onFirstPause", arity: 2, sync: function(e3) {
          return n.sync(e3);
        }, errback: function(e3, t3, r3) {
          let s2 = false;
          n.errback(e3, (e4, t4) => {
            s2 = true, r3(e4, t4);
          }), s2 || t3();
        } }), t2.waitFor = _gensync()({ sync: (e3) => e3, async: (o = _asyncToGenerator(function* (e3) {
          return e3;
        }), function(e3) {
          return o.apply(this, arguments);
        }) });
        var o;
        function isThenable(e3) {
          return !(!e3 || "object" != typeof e3 && "function" != typeof e3 || !e3.then || "function" != typeof e3.then);
        }
      }, "./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/gensync-utils/fs.js": function(e2, t2, r2) {
        "use strict";
        function _fs() {
          const e3 = r2("fs");
          return _fs = function() {
            return e3;
          }, e3;
        }
        function _gensync() {
          const e3 = r2("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return _gensync = function() {
            return e3;
          }, e3;
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.stat = t2.readFile = void 0;
        t2.readFile = _gensync()({ sync: _fs().readFileSync, errback: _fs().readFile }), t2.stat = _gensync()({ sync: _fs().statSync, errback: _fs().stat });
      }, "./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/gensync-utils/functional.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.once = function(e3) {
          let t3, r3, s = false;
          return function* () {
            if (!t3) {
              if (r3) return s = true, yield* (0, n.waitFor)(r3);
              if (yield* (0, n.isAsync)()) {
                let n2, i;
                r3 = new Promise((e4, t4) => {
                  n2 = e4, i = t4;
                });
                try {
                  t3 = { ok: true, value: yield* e3() }, r3 = null, s && n2(t3.value);
                } catch (e4) {
                  t3 = { ok: false, value: e4 }, r3 = null, s && i(e4);
                }
              } else try {
                t3 = { ok: true, value: yield* e3() };
              } catch (e4) {
                t3 = { ok: false, value: e4 };
              }
            }
            if (t3.ok) return t3.value;
            throw t3.value;
          };
        };
        var n = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/gensync-utils/async.js");
      }, "./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/index.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.DEFAULT_EXTENSIONS = void 0, Object.defineProperty(t2, "File", { enumerable: true, get: function() {
          return n.default;
        } }), Object.defineProperty(t2, "buildExternalHelpers", { enumerable: true, get: function() {
          return s.default;
        } }), Object.defineProperty(t2, "createConfigItem", { enumerable: true, get: function() {
          return a.createConfigItem;
        } }), Object.defineProperty(t2, "createConfigItemAsync", { enumerable: true, get: function() {
          return a.createConfigItemAsync;
        } }), Object.defineProperty(t2, "createConfigItemSync", { enumerable: true, get: function() {
          return a.createConfigItemSync;
        } }), Object.defineProperty(t2, "getEnv", { enumerable: true, get: function() {
          return o.getEnv;
        } }), Object.defineProperty(t2, "loadOptions", { enumerable: true, get: function() {
          return a.loadOptions;
        } }), Object.defineProperty(t2, "loadOptionsAsync", { enumerable: true, get: function() {
          return a.loadOptionsAsync;
        } }), Object.defineProperty(t2, "loadOptionsSync", { enumerable: true, get: function() {
          return a.loadOptionsSync;
        } }), Object.defineProperty(t2, "loadPartialConfig", { enumerable: true, get: function() {
          return a.loadPartialConfig;
        } }), Object.defineProperty(t2, "loadPartialConfigAsync", { enumerable: true, get: function() {
          return a.loadPartialConfigAsync;
        } }), Object.defineProperty(t2, "loadPartialConfigSync", { enumerable: true, get: function() {
          return a.loadPartialConfigSync;
        } }), Object.defineProperty(t2, "parse", { enumerable: true, get: function() {
          return u.parse;
        } }), Object.defineProperty(t2, "parseAsync", { enumerable: true, get: function() {
          return u.parseAsync;
        } }), Object.defineProperty(t2, "parseSync", { enumerable: true, get: function() {
          return u.parseSync;
        } }), t2.resolvePreset = t2.resolvePlugin = void 0, Object.defineProperty(t2, "template", { enumerable: true, get: function() {
          return _template().default;
        } }), Object.defineProperty(t2, "tokTypes", { enumerable: true, get: function() {
          return _parser().tokTypes;
        } }), Object.defineProperty(t2, "transform", { enumerable: true, get: function() {
          return l.transform;
        } }), Object.defineProperty(t2, "transformAsync", { enumerable: true, get: function() {
          return l.transformAsync;
        } }), Object.defineProperty(t2, "transformFile", { enumerable: true, get: function() {
          return p.transformFile;
        } }), Object.defineProperty(t2, "transformFileAsync", { enumerable: true, get: function() {
          return p.transformFileAsync;
        } }), Object.defineProperty(t2, "transformFileSync", { enumerable: true, get: function() {
          return p.transformFileSync;
        } }), Object.defineProperty(t2, "transformFromAst", { enumerable: true, get: function() {
          return c.transformFromAst;
        } }), Object.defineProperty(t2, "transformFromAstAsync", { enumerable: true, get: function() {
          return c.transformFromAstAsync;
        } }), Object.defineProperty(t2, "transformFromAstSync", { enumerable: true, get: function() {
          return c.transformFromAstSync;
        } }), Object.defineProperty(t2, "transformSync", { enumerable: true, get: function() {
          return l.transformSync;
        } }), Object.defineProperty(t2, "traverse", { enumerable: true, get: function() {
          return _traverse().default;
        } }), t2.version = t2.types = void 0;
        var n = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/transformation/file/file.js"), s = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/tools/build-external-helpers.js"), i = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/files/index.js"), o = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/helpers/environment.js");
        function _types() {
          const e3 = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/index.js");
          return _types = function() {
            return e3;
          }, e3;
        }
        function _parser() {
          const e3 = r2("./node_modules/.pnpm/@babel+parser@7.28.4/node_modules/@babel/parser/lib/index.js");
          return _parser = function() {
            return e3;
          }, e3;
        }
        function _traverse() {
          const e3 = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/index.js");
          return _traverse = function() {
            return e3;
          }, e3;
        }
        function _template() {
          const e3 = r2("./node_modules/.pnpm/@babel+template@7.27.2/node_modules/@babel/template/lib/index.js");
          return _template = function() {
            return e3;
          }, e3;
        }
        Object.defineProperty(t2, "types", { enumerable: true, get: function() {
          return _types();
        } });
        var a = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/index.js"), l = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/transform.js"), p = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/transform-file.js"), c = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/transform-ast.js"), u = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/parse.js");
        t2.version = "7.28.4";
        t2.resolvePlugin = (e3, t3) => i.resolvePlugin(e3, t3, false).filepath;
        t2.resolvePreset = (e3, t3) => i.resolvePreset(e3, t3, false).filepath;
        t2.DEFAULT_EXTENSIONS = Object.freeze([".js", ".jsx", ".es6", ".es", ".mjs", ".cjs"]);
        t2.OptionManager = class {
          init(e3) {
            return (0, a.loadOptionsSync)(e3);
          }
        }, t2.Plugin = function(e3) {
          throw new Error(`The (${e3}) Babel 5 plugin is being run with an unsupported Babel version.`);
        };
      }, "./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/parse.js": function(e2, t2, r2) {
        "use strict";
        function _gensync() {
          const e3 = r2("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return _gensync = function() {
            return e3;
          }, e3;
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.parse = void 0, t2.parseAsync = function(...e3) {
          return (0, o.beginHiddenCallStack)(a.async)(...e3);
        }, t2.parseSync = function(...e3) {
          return (0, o.beginHiddenCallStack)(a.sync)(...e3);
        };
        var n = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/index.js"), s = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/parser/index.js"), i = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/transformation/normalize-opts.js"), o = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/errors/rewrite-stack-trace.js");
        const a = _gensync()(function* (e3, t3) {
          const r3 = yield* (0, n.default)(t3);
          return null === r3 ? null : yield* (0, s.default)(r3.passes, (0, i.default)(r3), e3);
        });
        t2.parse = function(e3, t3, r3) {
          if ("function" == typeof t3 && (r3 = t3, t3 = void 0), void 0 === r3) return (0, o.beginHiddenCallStack)(a.sync)(e3, t3);
          (0, o.beginHiddenCallStack)(a.errback)(e3, t3, r3);
        };
      }, "./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/parser/index.js": function(e2, t2, r2) {
        "use strict";
        function _parser() {
          const e3 = r2("./node_modules/.pnpm/@babel+parser@7.28.4/node_modules/@babel/parser/lib/index.js");
          return _parser = function() {
            return e3;
          }, e3;
        }
        function _codeFrame() {
          const e3 = r2("./stubs/babel-codeframe.mjs");
          return _codeFrame = function() {
            return e3;
          }, e3;
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function* (e3, { parserOpts: t3, highlightCode: r3 = true, filename: s = "unknown" }, i) {
          try {
            const r4 = [];
            for (const n2 of e3) for (const e4 of n2) {
              const { parserOverride: n3 } = e4;
              if (n3) {
                const e5 = n3(i, t3, _parser().parse);
                void 0 !== e5 && r4.push(e5);
              }
            }
            if (0 === r4.length) return (0, _parser().parse)(i, t3);
            if (1 === r4.length) {
              if (yield* [], "function" == typeof r4[0].then) throw new Error("You appear to be using an async parser plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
              return r4[0];
            }
            throw new Error("More than one plugin attempted to override parsing.");
          } catch (e4) {
            "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED" === e4.code && (e4.message += "\nConsider renaming the file to '.mjs', or setting sourceType:module or sourceType:unambiguous in your Babel config for this file.");
            const { loc: t4, missingPlugin: o } = e4;
            if (t4) {
              const a = (0, _codeFrame().codeFrameColumns)(i, { start: { line: t4.line, column: t4.column + 1 } }, { highlightCode: r3 });
              e4.message = o ? `${s}: ` + (0, n.default)(o[0], t4, a, s) : `${s}: ${e4.message}

` + a, e4.code = "BABEL_PARSE_ERROR";
            }
            throw e4;
          }
        };
        var n = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/parser/util/missing-plugin-helper.js");
      }, "./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/parser/util/missing-plugin-helper.js": function(e2, t2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, n, s) {
          let i = `Support for the experimental syntax '${e3}' isn't currently enabled (${t3.line}:${t3.column + 1}):

` + n;
          const o = r2[e3];
          if (o) {
            const { syntax: e4, transform: t4 } = o;
            if (e4) {
              const r3 = getNameURLCombination(e4);
              if (t4) {
                i += `

Add ${getNameURLCombination(t4)} to the '${t4.name.startsWith("@babel/plugin") ? "plugins" : "presets"}' section of your Babel config to enable transformation.
If you want to leave it as-is, add ${r3} to the 'plugins' section to enable parsing.`;
              } else i += `

Add ${r3} to the 'plugins' section of your Babel config to enable parsing.`;
            }
          }
          return i += `

If you already added the plugin for this syntax to your config, it's possible that your config isn't being loaded.
You can re-run Babel with the BABEL_SHOW_CONFIG_FOR environment variable to show the loaded configuration:
	npx cross-env BABEL_SHOW_CONFIG_FOR=${s === "unknown" ? "<name of the input file>" : s} <your build command>
See https://babeljs.io/docs/configuration#print-effective-configs for more info.
`, i;
        };
        const r2 = { asyncDoExpressions: { syntax: { name: "@babel/plugin-syntax-async-do-expressions", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-async-do-expressions" } }, decimal: { syntax: { name: "@babel/plugin-syntax-decimal", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-decimal" } }, decorators: { syntax: { name: "@babel/plugin-syntax-decorators", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-decorators" }, transform: { name: "@babel/plugin-proposal-decorators", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-decorators" } }, doExpressions: { syntax: { name: "@babel/plugin-syntax-do-expressions", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-do-expressions" }, transform: { name: "@babel/plugin-proposal-do-expressions", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-do-expressions" } }, exportDefaultFrom: { syntax: { name: "@babel/plugin-syntax-export-default-from", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-export-default-from" }, transform: { name: "@babel/plugin-proposal-export-default-from", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-export-default-from" } }, flow: { syntax: { name: "@babel/plugin-syntax-flow", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-flow" }, transform: { name: "@babel/preset-flow", url: "https://github.com/babel/babel/tree/main/packages/babel-preset-flow" } }, functionBind: { syntax: { name: "@babel/plugin-syntax-function-bind", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-function-bind" }, transform: { name: "@babel/plugin-proposal-function-bind", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-function-bind" } }, functionSent: { syntax: { name: "@babel/plugin-syntax-function-sent", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-function-sent" }, transform: { name: "@babel/plugin-proposal-function-sent", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-function-sent" } }, jsx: { syntax: { name: "@babel/plugin-syntax-jsx", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-jsx" }, transform: { name: "@babel/preset-react", url: "https://github.com/babel/babel/tree/main/packages/babel-preset-react" } }, pipelineOperator: { syntax: { name: "@babel/plugin-syntax-pipeline-operator", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-pipeline-operator" }, transform: { name: "@babel/plugin-proposal-pipeline-operator", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-pipeline-operator" } }, recordAndTuple: { syntax: { name: "@babel/plugin-syntax-record-and-tuple", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-record-and-tuple" } }, throwExpressions: { syntax: { name: "@babel/plugin-syntax-throw-expressions", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-throw-expressions" }, transform: { name: "@babel/plugin-proposal-throw-expressions", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-throw-expressions" } }, typescript: { syntax: { name: "@babel/plugin-syntax-typescript", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-typescript" }, transform: { name: "@babel/preset-typescript", url: "https://github.com/babel/babel/tree/main/packages/babel-preset-typescript" } } };
        Object.assign(r2, { asyncGenerators: { syntax: { name: "@babel/plugin-syntax-async-generators", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-async-generators" }, transform: { name: "@babel/plugin-transform-async-generator-functions", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-async-generator-functions" } }, classProperties: { syntax: { name: "@babel/plugin-syntax-class-properties", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties" }, transform: { name: "@babel/plugin-transform-class-properties", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-class-properties" } }, classPrivateProperties: { syntax: { name: "@babel/plugin-syntax-class-properties", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties" }, transform: { name: "@babel/plugin-transform-class-properties", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-class-properties" } }, classPrivateMethods: { syntax: { name: "@babel/plugin-syntax-class-properties", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties" }, transform: { name: "@babel/plugin-transform-private-methods", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-private-methods" } }, classStaticBlock: { syntax: { name: "@babel/plugin-syntax-class-static-block", url: "https://github.com/babel/babel/tree/HEAD/packages/babel-plugin-syntax-class-static-block" }, transform: { name: "@babel/plugin-transform-class-static-block", url: "https://github.com/babel/babel/tree/HEAD/packages/babel-plugin-transform-class-static-block" } }, dynamicImport: { syntax: { name: "@babel/plugin-syntax-dynamic-import", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-dynamic-import" } }, exportNamespaceFrom: { syntax: { name: "@babel/plugin-syntax-export-namespace-from", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-export-namespace-from" }, transform: { name: "@babel/plugin-transform-export-namespace-from", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-export-namespace-from" } }, importAssertions: { syntax: { name: "@babel/plugin-syntax-import-assertions", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-assertions" } }, importAttributes: { syntax: { name: "@babel/plugin-syntax-import-attributes", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-attributes" } }, importMeta: { syntax: { name: "@babel/plugin-syntax-import-meta", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-meta" } }, logicalAssignment: { syntax: { name: "@babel/plugin-syntax-logical-assignment-operators", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-logical-assignment-operators" }, transform: { name: "@babel/plugin-transform-logical-assignment-operators", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-logical-assignment-operators" } }, moduleStringNames: { syntax: { name: "@babel/plugin-syntax-module-string-names", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-module-string-names" } }, numericSeparator: { syntax: { name: "@babel/plugin-syntax-numeric-separator", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-numeric-separator" }, transform: { name: "@babel/plugin-transform-numeric-separator", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-numeric-separator" } }, nullishCoalescingOperator: { syntax: { name: "@babel/plugin-syntax-nullish-coalescing-operator", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-nullish-coalescing-operator" }, transform: { name: "@babel/plugin-transform-nullish-coalescing-operator", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-nullish-coalescing-opearator" } }, objectRestSpread: { syntax: { name: "@babel/plugin-syntax-object-rest-spread", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-object-rest-spread" }, transform: { name: "@babel/plugin-transform-object-rest-spread", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-object-rest-spread" } }, optionalCatchBinding: { syntax: { name: "@babel/plugin-syntax-optional-catch-binding", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-optional-catch-binding" }, transform: { name: "@babel/plugin-transform-optional-catch-binding", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-optional-catch-binding" } }, optionalChaining: { syntax: { name: "@babel/plugin-syntax-optional-chaining", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-optional-chaining" }, transform: { name: "@babel/plugin-transform-optional-chaining", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-optional-chaining" } }, privateIn: { syntax: { name: "@babel/plugin-syntax-private-property-in-object", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-private-property-in-object" }, transform: { name: "@babel/plugin-transform-private-property-in-object", url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-private-property-in-object" } }, regexpUnicodeSets: { syntax: { name: "@babel/plugin-syntax-unicode-sets-regex", url: "https://github.com/babel/babel/blob/main/packages/babel-plugin-syntax-unicode-sets-regex/README.md" }, transform: { name: "@babel/plugin-transform-unicode-sets-regex", url: "https://github.com/babel/babel/blob/main/packages/babel-plugin-proposalunicode-sets-regex/README.md" } } });
        const getNameURLCombination = ({ name: e3, url: t3 }) => `${e3} (${t3})`;
      }, "./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/tools/build-external-helpers.js": function(e2, t2, r2) {
        "use strict";
        function helpers() {
          const e3 = r2("./node_modules/.pnpm/@babel+helpers@7.28.4/node_modules/@babel/helpers/lib/index.js");
          return helpers = function() {
            return e3;
          }, e3;
        }
        function _generator() {
          const e3 = r2("./node_modules/.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/lib/index.js");
          return _generator = function() {
            return e3;
          }, e3;
        }
        function _template() {
          const e3 = r2("./node_modules/.pnpm/@babel+template@7.27.2/node_modules/@babel/template/lib/index.js");
          return _template = function() {
            return e3;
          }, e3;
        }
        function _t() {
          const e3 = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/index.js");
          return _t = function() {
            return e3;
          }, e3;
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3 = "global") {
          let r3;
          const n2 = { global: buildGlobal, module: buildModule, umd: buildUmd, var: buildVar }[t3];
          if (!n2) throw new Error(`Unsupported output type ${t3}`);
          r3 = n2(e3);
          return (0, _generator().default)(r3).code;
        };
        const { arrayExpression: n, assignmentExpression: s, binaryExpression: i, blockStatement: o, callExpression: a, cloneNode: l, conditionalExpression: p, exportNamedDeclaration: c, exportSpecifier: u, expressionStatement: d, functionExpression: h, identifier: m, memberExpression: f, objectExpression: y, program: b, stringLiteral: g, unaryExpression: x, variableDeclaration: v, variableDeclarator: E } = _t(), buildUmdWrapper = (e3) => _template().default.statement`
    (function (root, factory) {
      if (typeof define === "function" && define.amd) {
        define(AMD_ARGUMENTS, factory);
      } else if (typeof exports === "object") {
        factory(COMMON_ARGUMENTS);
      } else {
        factory(BROWSER_ARGUMENTS);
      }
    })(UMD_ROOT, function (FACTORY_PARAMETERS) {
      FACTORY_BODY
    });
  `(e3);
        function buildGlobal(e3) {
          const t3 = m("babelHelpers"), r3 = [], n2 = h(null, [m("global")], o(r3)), l2 = b([d(a(n2, [p(i("===", x("typeof", m("global")), g("undefined")), m("self"), m("global"))]))]);
          return r3.push(v("var", [E(t3, s("=", f(m("global"), t3), y([])))])), buildHelpers(r3, t3, e3), l2;
        }
        function buildModule(e3) {
          const t3 = [], r3 = buildHelpers(t3, null, e3);
          return t3.unshift(c(null, Object.keys(r3).map((e4) => u(l(r3[e4]), m(e4))))), b(t3, [], "module");
        }
        function buildUmd(e3) {
          const t3 = m("babelHelpers"), r3 = [];
          return r3.push(v("var", [E(t3, m("global"))])), buildHelpers(r3, t3, e3), b([buildUmdWrapper({ FACTORY_PARAMETERS: m("global"), BROWSER_ARGUMENTS: s("=", f(m("root"), t3), y([])), COMMON_ARGUMENTS: m("exports"), AMD_ARGUMENTS: n([g("exports")]), FACTORY_BODY: r3, UMD_ROOT: m("this") })]);
        }
        function buildVar(e3) {
          const t3 = m("babelHelpers"), r3 = [];
          r3.push(v("var", [E(t3, y([]))]));
          const n2 = b(r3);
          return buildHelpers(r3, t3, e3), r3.push(d(t3)), n2;
        }
        function buildHelpers(e3, t3, r3) {
          const getHelperReference = (e4) => t3 ? f(t3, m(e4)) : m(`_${e4}`), n2 = {};
          return helpers().list.forEach(function(i2) {
            if (r3 && !r3.includes(i2)) return;
            const o2 = n2[i2] = getHelperReference(i2), { nodes: a2 } = helpers().get(i2, getHelperReference, t3 ? null : `_${i2}`, [], t3 ? (e4, t4, r4) => {
              r4((e5) => s("=", o2, e5)), e4.body.push(d(s("=", o2, m(t4))));
            } : null);
            e3.push(...a2);
          }), n2;
        }
      }, "./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/transform-ast.js": function(e2, t2, r2) {
        "use strict";
        function _gensync() {
          const e3 = r2("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return _gensync = function() {
            return e3;
          }, e3;
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.transformFromAst = void 0, t2.transformFromAstAsync = function(...e3) {
          return (0, i.beginHiddenCallStack)(o.async)(...e3);
        }, t2.transformFromAstSync = function(...e3) {
          return (0, i.beginHiddenCallStack)(o.sync)(...e3);
        };
        var n = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/index.js"), s = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/transformation/index.js"), i = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/errors/rewrite-stack-trace.js");
        const o = _gensync()(function* (e3, t3, r3) {
          const i2 = yield* (0, n.default)(r3);
          if (null === i2) return null;
          if (!e3) throw new Error("No AST given");
          return yield* (0, s.run)(i2, t3, e3);
        });
        t2.transformFromAst = function(e3, t3, r3, n2) {
          let s2, a;
          if ("function" == typeof r3 ? (a = r3, s2 = void 0) : (s2 = r3, a = n2), void 0 === a) return (0, i.beginHiddenCallStack)(o.sync)(e3, t3, s2);
          (0, i.beginHiddenCallStack)(o.errback)(e3, t3, s2, a);
        };
      }, "./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/transform-file.js": function(e2, t2, r2) {
        "use strict";
        function _gensync() {
          const e3 = r2("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return _gensync = function() {
            return e3;
          }, e3;
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.transformFile = function(...e3) {
          o.errback(...e3);
        }, t2.transformFileAsync = function(...e3) {
          return o.async(...e3);
        }, t2.transformFileSync = function(...e3) {
          return o.sync(...e3);
        };
        var n = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/index.js"), s = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/transformation/index.js"), i = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/gensync-utils/fs.js");
        const o = _gensync()(function* (e3, t3) {
          const r3 = Object.assign({}, t3, { filename: e3 }), o2 = yield* (0, n.default)(r3);
          if (null === o2) return null;
          const a = yield* i.readFile(e3, "utf8");
          return yield* (0, s.run)(o2, a);
        });
      }, "./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/transform.js": function(e2, t2, r2) {
        "use strict";
        function _gensync() {
          const e3 = r2("./node_modules/.pnpm/gensync@1.0.0-beta.2/node_modules/gensync/index.js");
          return _gensync = function() {
            return e3;
          }, e3;
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.transform = void 0, t2.transformAsync = function(...e3) {
          return (0, i.beginHiddenCallStack)(o.async)(...e3);
        }, t2.transformSync = function(...e3) {
          return (0, i.beginHiddenCallStack)(o.sync)(...e3);
        };
        var n = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/index.js"), s = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/transformation/index.js"), i = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/errors/rewrite-stack-trace.js");
        const o = _gensync()(function* (e3, t3) {
          const r3 = yield* (0, n.default)(t3);
          return null === r3 ? null : yield* (0, s.run)(r3, e3);
        });
        t2.transform = function(e3, t3, r3) {
          let n2, s2;
          if ("function" == typeof t3 ? (s2 = t3, n2 = void 0) : (n2 = t3, s2 = r3), void 0 === s2) return (0, i.beginHiddenCallStack)(o.sync)(e3, n2);
          (0, i.beginHiddenCallStack)(o.errback)(e3, n2, s2);
        };
      }, "./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/transformation/block-hoist-plugin.js": function(e2, t2, r2) {
        "use strict";
        function _traverse() {
          const e3 = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/index.js");
          return _traverse = function() {
            return e3;
          }, e3;
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function() {
          s || (s = new n.default(Object.assign({}, i, { visitor: _traverse().default.explode(i.visitor) }), {}));
          return s;
        };
        var n = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/plugin.js");
        let s;
        const i = { name: "internal.blockHoist", visitor: { Block: { exit({ node: e3 }) {
          e3.body = performHoisting(e3.body);
        } }, SwitchCase: { exit({ node: e3 }) {
          e3.consequent = performHoisting(e3.consequent);
        } } } };
        function performHoisting(e3) {
          let t3 = Math.pow(2, 30) - 1, r3 = false;
          for (let n2 = 0; n2 < e3.length; n2++) {
            const s2 = priority(e3[n2]);
            if (s2 > t3) {
              r3 = true;
              break;
            }
            t3 = s2;
          }
          return r3 ? (function(e4) {
            const t4 = /* @__PURE__ */ Object.create(null);
            for (let r5 = 0; r5 < e4.length; r5++) {
              const n3 = e4[r5], s2 = priority(n3);
              (t4[s2] || (t4[s2] = [])).push(n3);
            }
            const r4 = Object.keys(t4).map((e5) => +e5).sort((e5, t5) => t5 - e5);
            let n2 = 0;
            for (const s2 of r4) {
              const r5 = t4[s2];
              for (const t5 of r5) e4[n2++] = t5;
            }
            return e4;
          })(e3.slice()) : e3;
        }
        function priority(e3) {
          const t3 = null == e3 ? void 0 : e3._blockHoist;
          return null == t3 ? 1 : true === t3 ? 2 : t3;
        }
      }, "./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/transformation/file/babel-7-helpers.cjs": function(e2, t2, r2) {
        t2.getModuleName = () => r2("./node_modules/.pnpm/@babel+helper-module-transforms@7.28.3_@babel+core@7.28.4/node_modules/@babel/helper-module-transforms/lib/index.js").getModuleName;
      }, "./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/transformation/file/file.js": function(e2, t2, r2) {
        "use strict";
        function helpers() {
          const e3 = r2("./node_modules/.pnpm/@babel+helpers@7.28.4/node_modules/@babel/helpers/lib/index.js");
          return helpers = function() {
            return e3;
          }, e3;
        }
        function _traverse() {
          const e3 = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/index.js");
          return _traverse = function() {
            return e3;
          }, e3;
        }
        function _codeFrame() {
          const e3 = r2("./stubs/babel-codeframe.mjs");
          return _codeFrame = function() {
            return e3;
          }, e3;
        }
        function _t() {
          const e3 = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/index.js");
          return _t = function() {
            return e3;
          }, e3;
        }
        function _semver() {
          const e3 = r2("./node_modules/.pnpm/semver@6.3.1/node_modules/semver/semver.js");
          return _semver = function() {
            return e3;
          }, e3;
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var n = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/transformation/file/babel-7-helpers.cjs");
        const { cloneNode: s, interpreterDirective: i } = _t(), o = { enter(e3, t3) {
          const r3 = e3.node.loc;
          r3 && (t3.loc = r3, e3.stop());
        } };
        class File {
          constructor(e3, { code: t3, ast: r3, inputMap: n2 }) {
            this._map = /* @__PURE__ */ new Map(), this.opts = void 0, this.declarations = {}, this.path = void 0, this.ast = void 0, this.scope = void 0, this.metadata = {}, this.code = "", this.inputMap = void 0, this.hub = { file: this, getCode: () => this.code, getScope: () => this.scope, addHelper: this.addHelper.bind(this), buildError: this.buildCodeFrameError.bind(this) }, this.opts = e3, this.code = t3, this.ast = r3, this.inputMap = n2, this.path = _traverse().NodePath.get({ hub: this.hub, parentPath: null, parent: this.ast, container: this.ast, key: "program" }).setContext(), this.scope = this.path.scope;
          }
          get shebang() {
            const { interpreter: e3 } = this.path.node;
            return e3 ? e3.value : "";
          }
          set shebang(e3) {
            e3 ? this.path.get("interpreter").replaceWith(i(e3)) : this.path.get("interpreter").remove();
          }
          set(e3, t3) {
            if ("helpersNamespace" === e3) throw new Error("Babel 7.0.0-beta.56 has dropped support for the 'helpersNamespace' utility.If you are using @babel/plugin-external-helpers you will need to use a newer version than the one you currently have installed. If you have your own implementation, you'll want to explore using 'helperGenerator' alongside 'file.availableHelper()'.");
            this._map.set(e3, t3);
          }
          get(e3) {
            return this._map.get(e3);
          }
          has(e3) {
            return this._map.has(e3);
          }
          availableHelper(e3, t3) {
            if (helpers().isInternal(e3)) return false;
            let r3;
            try {
              r3 = helpers().minVersion(e3);
            } catch (e4) {
              if ("BABEL_HELPER_UNKNOWN" !== e4.code) throw e4;
              return false;
            }
            return "string" != typeof t3 || (_semver().valid(t3) && (t3 = `^${t3}`), !_semver().intersects(`<${r3}`, t3) && !_semver().intersects(">=8.0.0", t3));
          }
          addHelper(e3) {
            if (helpers().isInternal(e3)) throw new Error("Cannot use internal helper " + e3);
            return this._addHelper(e3);
          }
          _addHelper(e3) {
            const t3 = this.declarations[e3];
            if (t3) return s(t3);
            const r3 = this.get("helperGenerator");
            if (r3) {
              const t4 = r3(e3);
              if (t4) return t4;
            }
            helpers().minVersion(e3);
            const n2 = this.declarations[e3] = this.scope.generateUidIdentifier(e3), i2 = {};
            for (const t4 of helpers().getDependencies(e3)) i2[t4] = this._addHelper(t4);
            const { nodes: o2, globals: a } = helpers().get(e3, (e4) => i2[e4], n2.name, Object.keys(this.scope.getAllBindings()));
            a.forEach((e4) => {
              this.path.scope.hasBinding(e4, true) && this.path.scope.rename(e4);
            }), o2.forEach((e4) => {
              e4._compact = true;
            });
            const l = this.path.unshiftContainer("body", o2);
            for (const e4 of l) e4.isVariableDeclaration() && this.scope.registerDeclaration(e4);
            return n2;
          }
          buildCodeFrameError(e3, t3, r3 = SyntaxError) {
            let n2 = null == e3 ? void 0 : e3.loc;
            if (!n2 && e3) {
              const r4 = { loc: null };
              (0, _traverse().default)(e3, o, this.scope, r4), n2 = r4.loc;
              let s2 = "This is an error on an internal node. Probably an internal error.";
              n2 && (s2 += " Location has been estimated."), t3 += ` (${s2})`;
            }
            if (n2) {
              const { highlightCode: e4 = true } = this.opts;
              t3 += "\n" + (0, _codeFrame().codeFrameColumns)(this.code, { start: { line: n2.start.line, column: n2.start.column + 1 }, end: n2.end && n2.start.line === n2.end.line ? { line: n2.end.line, column: n2.end.column + 1 } : void 0 }, { highlightCode: e4 });
            }
            return new r3(t3);
          }
        }
        t2.default = File, File.prototype.addImport = function() {
          throw new Error("This API has been removed. If you're looking for this functionality in Babel 7, you should import the '@babel/helper-module-imports' module and use the functions exposed  from that module, such as 'addNamed' or 'addDefault'.");
        }, File.prototype.addTemplateObject = function() {
          throw new Error("This function has been moved into the template literal transform itself.");
        }, File.prototype.getModuleName = function() {
          return n.getModuleName()(this.opts, this.opts);
        };
      }, "./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/transformation/file/generate.js": function(e2, t2, r2) {
        "use strict";
        function _convertSourceMap() {
          const e3 = r2("./node_modules/.pnpm/convert-source-map@2.0.0/node_modules/convert-source-map/index.js");
          return _convertSourceMap = function() {
            return e3;
          }, e3;
        }
        function _generator() {
          const e3 = r2("./node_modules/.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/lib/index.js");
          return _generator = function() {
            return e3;
          }, e3;
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
          const { opts: r3, ast: s, code: i, inputMap: o } = t3, { generatorOpts: a } = r3;
          a.inputSourceMap = null == o ? void 0 : o.toObject();
          const l = [];
          for (const t4 of e3) for (const e4 of t4) {
            const { generatorOverride: t5 } = e4;
            if (t5) {
              const e5 = t5(s, a, i, _generator().default);
              void 0 !== e5 && l.push(e5);
            }
          }
          let p;
          if (0 === l.length) p = (0, _generator().default)(s, a, i);
          else {
            if (1 !== l.length) throw new Error("More than one plugin attempted to override codegen.");
            if (p = l[0], "function" == typeof p.then) throw new Error("You appear to be using an async codegen plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
          }
          let { code: c, decodedMap: u = p.map } = p;
          p.__mergedMap ? u = Object.assign({}, p.map) : u && (u = o ? (0, n.default)(o.toObject(), u, a.sourceFileName) : p.map);
          "inline" !== r3.sourceMaps && "both" !== r3.sourceMaps || (c += "\n" + _convertSourceMap().fromObject(u).toComment());
          "inline" === r3.sourceMaps && (u = null);
          return { outputCode: c, outputMap: u };
        };
        var n = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/transformation/file/merge-map.js");
      }, "./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/transformation/file/merge-map.js": function(e2, t2, r2) {
        "use strict";
        function _remapping() {
          const e3 = r2("./node_modules/.pnpm/@jridgewell+remapping@2.3.5/node_modules/@jridgewell/remapping/dist/remapping.umd.js");
          return _remapping = function() {
            return e3;
          }, e3;
        }
        function rootless(e3) {
          return Object.assign({}, e3, { sourceRoot: null });
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3) {
          const n = r3.replace(/\\/g, "/");
          let s = false;
          const i = _remapping()(rootless(t3), (t4, r4) => t4 !== n || s ? null : (s = true, r4.source = "", rootless(e3)));
          "string" == typeof e3.sourceRoot && (i.sourceRoot = e3.sourceRoot);
          return Object.assign({}, i);
        };
      }, "./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/transformation/index.js": function(e2, t2, r2) {
        "use strict";
        function _traverse() {
          const e3 = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/index.js");
          return _traverse = function() {
            return e3;
          }, e3;
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.run = function* (e3, t3, r3) {
          const c = yield* (0, o.default)(e3.passes, (0, i.default)(e3), t3, r3), u = c.opts;
          try {
            yield* (function* (e4, t4) {
              const r4 = yield* (0, p.isAsync)();
              for (const i2 of t4) {
                const t5 = [], o2 = [], a2 = [];
                for (const l3 of i2.concat([(0, s.default)()])) {
                  const s2 = new n.default(e4, l3.key, l3.options, r4);
                  t5.push([l3, s2]), o2.push(s2), a2.push(l3.visitor);
                }
                for (const [r5, n2] of t5) if (r5.pre) {
                  const t6 = (0, p.maybeAsync)(r5.pre, "You appear to be using an async plugin/preset, but Babel has been called synchronously");
                  yield* t6.call(n2, e4);
                }
                const l2 = _traverse().default.visitors.merge(a2, o2, e4.opts.wrapPluginVisitorMethod);
                (0, _traverse().default)(e4.ast, l2, e4.scope);
                for (const [r5, n2] of t5) if (r5.post) {
                  const t6 = (0, p.maybeAsync)(r5.post, "You appear to be using an async plugin/preset, but Babel has been called synchronously");
                  yield* t6.call(n2, e4);
                }
              }
            })(c, e3.passes);
          } catch (e4) {
            var d;
            throw e4.message = `${null != (d = u.filename) ? d : "unknown file"}: ${e4.message}`, e4.code || (e4.code = "BABEL_TRANSFORM_ERROR"), e4;
          }
          let h, m;
          try {
            false !== u.code && ({ outputCode: h, outputMap: m } = (0, a.default)(e3.passes, c));
          } catch (e4) {
            var f;
            throw e4.message = `${null != (f = u.filename) ? f : "unknown file"}: ${e4.message}`, e4.code || (e4.code = "BABEL_GENERATE_ERROR"), e4;
          }
          return { metadata: c.metadata, options: u, ast: true === u.ast ? c.ast : null, code: void 0 === h ? null : h, map: void 0 === m ? null : m, sourceType: c.ast.program.sourceType, externalDependencies: (0, l.flattenToSet)(e3.externalDependencies) };
        };
        var n = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/transformation/plugin-pass.js"), s = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/transformation/block-hoist-plugin.js"), i = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/transformation/normalize-opts.js"), o = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/transformation/normalize-file.js"), a = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/transformation/file/generate.js"), l = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/config/helpers/deep-array.js"), p = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/gensync-utils/async.js");
      }, "./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/transformation/normalize-file.js": function(e2, t2, r2) {
        "use strict";
        function _fs() {
          const e3 = r2("fs");
          return _fs = function() {
            return e3;
          }, e3;
        }
        function _path() {
          const e3 = r2("path");
          return _path = function() {
            return e3;
          }, e3;
        }
        function _debug() {
          const e3 = r2("./node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/index.js");
          return _debug = function() {
            return e3;
          }, e3;
        }
        function _t() {
          const e3 = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/index.js");
          return _t = function() {
            return e3;
          }, e3;
        }
        function _convertSourceMap() {
          const e3 = r2("./node_modules/.pnpm/convert-source-map@2.0.0/node_modules/convert-source-map/index.js");
          return _convertSourceMap = function() {
            return e3;
          }, e3;
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function* (e3, t3, r3, a2) {
          if (r3 = `${r3 || ""}`, a2) {
            if ("Program" === a2.type) a2 = o(a2, [], []);
            else if ("File" !== a2.type) throw new Error("AST root must be a Program or File node");
            t3.cloneInputAst && (a2 = (0, i.default)(a2));
          } else a2 = yield* (0, s.default)(e3, t3, r3);
          let u = null;
          if (false !== t3.inputSourceMap) {
            if ("object" == typeof t3.inputSourceMap && (u = _convertSourceMap().fromObject(t3.inputSourceMap)), !u) {
              const e4 = extractComments(p, a2);
              if (e4) try {
                u = _convertSourceMap().fromComment("//" + e4);
              } catch (e5) {
                l("discarding unknown inline input sourcemap");
              }
            }
            if (!u) {
              const e4 = extractComments(c, a2);
              if ("string" == typeof t3.filename && e4) try {
                const r4 = c.exec(e4), n2 = _fs().readFileSync(_path().resolve(_path().dirname(t3.filename), r4[1]), "utf8");
                u = _convertSourceMap().fromJSON(n2);
              } catch (e5) {
                l("discarding unknown file input sourcemap", e5);
              }
              else e4 && l("discarding un-loadable file input sourcemap");
            }
          }
          return new n.default(t3, { code: r3, ast: a2, inputMap: u });
        };
        var n = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/transformation/file/file.js"), s = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/parser/index.js"), i = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/transformation/util/clone-deep.js");
        const { file: o, traverseFast: a } = _t(), l = _debug()("babel:transform:file"), p = /^[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,.*$/, c = /^[@#][ \t]+sourceMappingURL=([^\s'"`]+)[ \t]*$/;
        function extractCommentsFromList(e3, t3, r3) {
          return t3 && (t3 = t3.filter(({ value: t4 }) => !e3.test(t4) || (r3 = t4, false))), [t3, r3];
        }
        function extractComments(e3, t3) {
          let r3 = null;
          return a(t3, (t4) => {
            [t4.leadingComments, r3] = extractCommentsFromList(e3, t4.leadingComments, r3), [t4.innerComments, r3] = extractCommentsFromList(e3, t4.innerComments, r3), [t4.trailingComments, r3] = extractCommentsFromList(e3, t4.trailingComments, r3);
          }), r3;
        }
      }, "./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/transformation/normalize-opts.js": function(e2, t2, r2) {
        "use strict";
        function _path() {
          const e3 = r2("path");
          return _path = function() {
            return e3;
          }, e3;
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
          const { filename: t3, cwd: r3, filenameRelative: n = "string" == typeof t3 ? _path().relative(r3, t3) : "unknown", sourceType: s = "module", inputSourceMap: i, sourceMaps: o = !!i, sourceRoot: a = e3.options.moduleRoot, sourceFileName: l = _path().basename(n), comments: p = true, compact: c = "auto" } = e3.options, u = e3.options, d = Object.assign({}, u, { parserOpts: Object.assign({ sourceType: ".mjs" === _path().extname(n) ? "module" : s, sourceFileName: t3, plugins: [] }, u.parserOpts), generatorOpts: Object.assign({ filename: t3, auxiliaryCommentBefore: u.auxiliaryCommentBefore, auxiliaryCommentAfter: u.auxiliaryCommentAfter, retainLines: u.retainLines, comments: p, shouldPrintComment: u.shouldPrintComment, compact: c, minified: u.minified, sourceMaps: !!o, sourceRoot: a, sourceFileName: l }, u.generatorOpts) });
          for (const t4 of e3.passes) for (const e4 of t4) e4.manipulateOptions && e4.manipulateOptions(d, d.parserOpts);
          return d;
        };
      }, "./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/transformation/plugin-pass.js": function(e2, t2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        class PluginPass {
          constructor(e3, t3, r2, n) {
            this._map = /* @__PURE__ */ new Map(), this.key = void 0, this.file = void 0, this.opts = void 0, this.cwd = void 0, this.filename = void 0, this.isAsync = void 0, this.key = t3, this.file = e3, this.opts = r2 || {}, this.cwd = e3.opts.cwd, this.filename = e3.opts.filename, this.isAsync = n;
          }
          set(e3, t3) {
            this._map.set(e3, t3);
          }
          get(e3) {
            return this._map.get(e3);
          }
          availableHelper(e3, t3) {
            return this.file.availableHelper(e3, t3);
          }
          addHelper(e3) {
            return this.file.addHelper(e3);
          }
          buildCodeFrameError(e3, t3, r2) {
            return this.file.buildCodeFrameError(e3, t3, r2);
          }
        }
        t2.default = PluginPass, PluginPass.prototype.getModuleName = function() {
          return this.file.getModuleName();
        }, PluginPass.prototype.addImport = function() {
          this.file.addImport();
        };
      }, "./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/transformation/util/clone-deep.js": function(e2, t2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
          if ("object" != typeof e3) return e3;
          try {
            return deepClone(e3, /* @__PURE__ */ new Map(), true);
          } catch (t3) {
            return structuredClone(e3);
          }
        };
        const r2 = /* @__PURE__ */ new Set();
        let n = 0;
        function deepClone(e3, t3, s) {
          if (null !== e3) {
            if (s) {
              if (t3.has(e3)) return t3.get(e3);
            } else if (++n > 250) {
              if (r2.has(e3)) throw n = 0, r2.clear(), new Error("Babel-deepClone: Cycles are not allowed in AST");
              r2.add(e3);
            }
            let i;
            if (Array.isArray(e3)) {
              i = new Array(e3.length), s && t3.set(e3, i);
              for (let r3 = 0; r3 < e3.length; r3++) i[r3] = "object" != typeof e3[r3] ? e3[r3] : deepClone(e3[r3], t3, s);
            } else {
              i = {}, s && t3.set(e3, i);
              const r3 = Object.keys(e3);
              for (let n2 = 0; n2 < r3.length; n2++) {
                const o = r3[n2];
                i[o] = "object" != typeof e3[o] ? e3[o] : deepClone(e3[o], t3, s || "leadingComments" === o || "innerComments" === o || "trailingComments" === o || "extra" === o);
              }
            }
            return s || n-- > 250 && r2.delete(e3), i;
          }
          return e3;
        }
      }, "./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/vendor/import-meta-resolve.js": function(e2, t2, r2) {
        "use strict";
        function _assert() {
          const e3 = r2("assert");
          return _assert = function() {
            return e3;
          }, e3;
        }
        function _fs() {
          const e3 = _interopRequireWildcard(r2("fs"), true);
          return _fs = function() {
            return e3;
          }, e3;
        }
        function _process() {
          const e3 = r2("process");
          return _process = function() {
            return e3;
          }, e3;
        }
        function _url() {
          const e3 = r2("url");
          return _url = function() {
            return e3;
          }, e3;
        }
        function _path() {
          const e3 = r2("path");
          return _path = function() {
            return e3;
          }, e3;
        }
        function _module() {
          const e3 = r2("module");
          return _module = function() {
            return e3;
          }, e3;
        }
        function _v() {
          const e3 = r2("v8");
          return _v = function() {
            return e3;
          }, e3;
        }
        function _util() {
          const e3 = r2("util");
          return _util = function() {
            return e3;
          }, e3;
        }
        function _interopRequireWildcard(e3, t3) {
          if ("function" == typeof WeakMap) var r3 = /* @__PURE__ */ new WeakMap(), n2 = /* @__PURE__ */ new WeakMap();
          return (_interopRequireWildcard = function(e4, t4) {
            if (!t4 && e4 && e4.__esModule) return e4;
            var s2, i2, o2 = { __proto__: null, default: e4 };
            if (null === e4 || "object" != typeof e4 && "function" != typeof e4) return o2;
            if (s2 = t4 ? n2 : r3) {
              if (s2.has(e4)) return s2.get(e4);
              s2.set(e4, o2);
            }
            for (const t5 in e4) "default" !== t5 && {}.hasOwnProperty.call(e4, t5) && ((i2 = (s2 = Object.defineProperty) && Object.getOwnPropertyDescriptor(e4, t5)) && (i2.get || i2.set) ? s2(o2, t5, i2) : o2[t5] = e4[t5]);
            return o2;
          })(e3, t3);
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.moduleResolve = moduleResolve, t2.resolve = function(e3, t3) {
          if (!t3) throw new Error("Please pass `parent`: `import-meta-resolve` cannot ponyfill that");
          try {
            return (function(e4, t4 = {}) {
              const { parentURL: r3 } = t4;
              let n2, s2, i2;
              if (_assert()(void 0 !== r3, "expected `parentURL` to be defined"), (function(e5) {
                if (void 0 === e5) return;
                if ("string" != typeof e5 && (t5 = e5, !Boolean(t5 && "object" == typeof t5 && "href" in t5 && "string" == typeof t5.href && "protocol" in t5 && "string" == typeof t5.protocol && t5.href && t5.protocol))) throw new o.ERR_INVALID_ARG_TYPE("parentURL", ["string", "URL"], e5);
                var t5;
              })(r3), r3) try {
                n2 = new (_url()).URL(r3);
              } catch (e5) {
              }
              try {
                if (s2 = shouldBeTreatedAsRelativeOrAbsolutePath(e4) ? new (_url()).URL(e4, n2) : new (_url()).URL(e4), i2 = s2.protocol, "data:" === i2) return { url: s2.href, format: null };
              } catch (e5) {
              }
              const a2 = (function(e5, t5, r4) {
                if (r4) {
                  const n3 = r4.protocol;
                  if ("http:" === n3 || "https:" === n3) {
                    if (shouldBeTreatedAsRelativeOrAbsolutePath(e5)) {
                      const n4 = null == t5 ? void 0 : t5.protocol;
                      if (n4 && "https:" !== n4 && "http:" !== n4) throw new E(e5, r4, "remote imports cannot import from a local location.");
                      return { url: (null == t5 ? void 0 : t5.href) || "" };
                    }
                    if (_module().builtinModules.includes(e5)) throw new E(e5, r4, "remote imports cannot import from a local location.");
                    throw new E(e5, r4, "only relative and absolute specifiers are supported.");
                  }
                }
              })(e4, s2, n2);
              if (a2) return a2;
              void 0 === i2 && s2 && (i2 = s2.protocol);
              if ("node:" === i2) return { url: e4 };
              if (s2 && "node:" === s2.protocol) return { url: e4 };
              const l2 = (function(e5) {
                if (void 0 !== e5 && e5 !== g) {
                  if (!Array.isArray(e5)) throw new b("conditions", e5, "expected an array");
                  return new Set(e5);
                }
                return x;
              })(t4.conditions), p2 = moduleResolve(e4, new (_url()).URL(r3), l2, false);
              return { url: p2.href, format: defaultGetFormatWithoutErrors(p2, { parentURL: r3 }) };
            })(e3, { parentURL: t3 }).url;
          } catch (e4) {
            const t4 = e4;
            if (("ERR_UNSUPPORTED_DIR_IMPORT" === t4.code || "ERR_MODULE_NOT_FOUND" === t4.code) && "string" == typeof t4.url) return t4.url;
            throw e4;
          }
        };
        const n = {}.hasOwnProperty, s = /^([A-Z][a-z\d]*)+$/, i = /* @__PURE__ */ new Set(["string", "function", "number", "object", "Function", "Object", "boolean", "bigint", "symbol"]), o = {};
        function formatList(e3, t3 = "and") {
          return e3.length < 3 ? e3.join(` ${t3} `) : `${e3.slice(0, -1).join(", ")}, ${t3} ${e3[e3.length - 1]}`;
        }
        const a = /* @__PURE__ */ new Map();
        let l;
        function createError(e3, t3, r3) {
          return a.set(e3, t3), /* @__PURE__ */ (function(e4, t4) {
            return NodeError;
            function NodeError(...r4) {
              const n2 = Error.stackTraceLimit;
              isErrorStackTraceLimitWritable() && (Error.stackTraceLimit = 0);
              const s2 = new e4();
              isErrorStackTraceLimitWritable() && (Error.stackTraceLimit = n2);
              const i2 = (function(e5, t5, r5) {
                const n3 = a.get(e5);
                if (_assert()(void 0 !== n3, "expected `message` to be found"), "function" == typeof n3) return _assert()(n3.length <= t5.length, `Code: ${e5}; The provided arguments length (${t5.length}) does not match the required ones (${n3.length}).`), Reflect.apply(n3, r5, t5);
                const s3 = /%[dfijoOs]/g;
                let i3 = 0;
                for (; null !== s3.exec(n3); ) i3++;
                return _assert()(i3 === t5.length, `Code: ${e5}; The provided arguments length (${t5.length}) does not match the required ones (${i3}).`), 0 === t5.length ? n3 : (t5.unshift(n3), Reflect.apply(_util().format, null, t5));
              })(t4, r4, s2);
              return Object.defineProperties(s2, { message: { value: i2, enumerable: false, writable: true, configurable: true }, toString: { value() {
                return `${this.name} [${t4}]: ${this.message}`;
              }, enumerable: false, writable: true, configurable: true } }), p(s2), s2.code = t4, s2;
            }
          })(r3, e3);
        }
        function isErrorStackTraceLimitWritable() {
          try {
            if (_v().startupSnapshot.isBuildingSnapshot()) return false;
          } catch (e4) {
          }
          const e3 = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit");
          return void 0 === e3 ? Object.isExtensible(Error) : n.call(e3, "writable") && void 0 !== e3.writable ? e3.writable : void 0 !== e3.set;
        }
        o.ERR_INVALID_ARG_TYPE = createError("ERR_INVALID_ARG_TYPE", (e3, t3, r3) => {
          _assert()("string" == typeof e3, "'name' must be a string"), Array.isArray(t3) || (t3 = [t3]);
          let n2 = "The ";
          if (e3.endsWith(" argument")) n2 += `${e3} `;
          else {
            const t4 = e3.includes(".") ? "property" : "argument";
            n2 += `"${e3}" ${t4} `;
          }
          n2 += "must be ";
          const o2 = [], a2 = [], l2 = [];
          for (const e4 of t3) _assert()("string" == typeof e4, "All expected entries have to be of type string"), i.has(e4) ? o2.push(e4.toLowerCase()) : null === s.exec(e4) ? (_assert()("object" !== e4, 'The value "object" should be written as "Object"'), l2.push(e4)) : a2.push(e4);
          if (a2.length > 0) {
            const e4 = o2.indexOf("object");
            -1 !== e4 && (o2.slice(e4, 1), a2.push("Object"));
          }
          return o2.length > 0 && (n2 += `${o2.length > 1 ? "one of type" : "of type"} ${formatList(o2, "or")}`, (a2.length > 0 || l2.length > 0) && (n2 += " or ")), a2.length > 0 && (n2 += `an instance of ${formatList(a2, "or")}`, l2.length > 0 && (n2 += " or ")), l2.length > 0 && (l2.length > 1 ? n2 += `one of ${formatList(l2, "or")}` : (l2[0].toLowerCase() !== l2[0] && (n2 += "an "), n2 += `${l2[0]}`)), n2 += `. Received ${(function(e4) {
            if (null == e4) return String(e4);
            if ("function" == typeof e4 && e4.name) return `function ${e4.name}`;
            if ("object" == typeof e4) return e4.constructor && e4.constructor.name ? `an instance of ${e4.constructor.name}` : `${(0, _util().inspect)(e4, { depth: -1 })}`;
            let t4 = (0, _util().inspect)(e4, { colors: false });
            t4.length > 28 && (t4 = `${t4.slice(0, 25)}...`);
            return `type ${typeof e4} (${t4})`;
          })(r3)}`, n2;
        }, TypeError), o.ERR_INVALID_MODULE_SPECIFIER = createError("ERR_INVALID_MODULE_SPECIFIER", (e3, t3, r3 = void 0) => `Invalid module "${e3}" ${t3}${r3 ? ` imported from ${r3}` : ""}`, TypeError), o.ERR_INVALID_PACKAGE_CONFIG = createError("ERR_INVALID_PACKAGE_CONFIG", (e3, t3, r3) => `Invalid package config ${e3}${t3 ? ` while importing ${t3}` : ""}${r3 ? `. ${r3}` : ""}`, Error), o.ERR_INVALID_PACKAGE_TARGET = createError("ERR_INVALID_PACKAGE_TARGET", (e3, t3, r3, n2 = false, s2 = void 0) => {
          const i2 = "string" == typeof r3 && !n2 && r3.length > 0 && !r3.startsWith("./");
          return "." === t3 ? (_assert()(false === n2), `Invalid "exports" main target ${JSON.stringify(r3)} defined in the package config ${e3}package.json${s2 ? ` imported from ${s2}` : ""}${i2 ? '; targets must start with "./"' : ""}`) : `Invalid "${n2 ? "imports" : "exports"}" target ${JSON.stringify(r3)} defined for '${t3}' in the package config ${e3}package.json${s2 ? ` imported from ${s2}` : ""}${i2 ? '; targets must start with "./"' : ""}`;
        }, Error), o.ERR_MODULE_NOT_FOUND = createError("ERR_MODULE_NOT_FOUND", (e3, t3, r3 = false) => `Cannot find ${r3 ? "module" : "package"} '${e3}' imported from ${t3}`, Error), o.ERR_NETWORK_IMPORT_DISALLOWED = createError("ERR_NETWORK_IMPORT_DISALLOWED", "import of '%s' by %s is not supported: %s", Error), o.ERR_PACKAGE_IMPORT_NOT_DEFINED = createError("ERR_PACKAGE_IMPORT_NOT_DEFINED", (e3, t3, r3) => `Package import specifier "${e3}" is not defined${t3 ? ` in package ${t3}package.json` : ""} imported from ${r3}`, TypeError), o.ERR_PACKAGE_PATH_NOT_EXPORTED = createError("ERR_PACKAGE_PATH_NOT_EXPORTED", (e3, t3, r3 = void 0) => "." === t3 ? `No "exports" main defined in ${e3}package.json${r3 ? ` imported from ${r3}` : ""}` : `Package subpath '${t3}' is not defined by "exports" in ${e3}package.json${r3 ? ` imported from ${r3}` : ""}`, Error), o.ERR_UNSUPPORTED_DIR_IMPORT = createError("ERR_UNSUPPORTED_DIR_IMPORT", "Directory import '%s' is not supported resolving ES modules imported from %s", Error), o.ERR_UNSUPPORTED_RESOLVE_REQUEST = createError("ERR_UNSUPPORTED_RESOLVE_REQUEST", 'Failed to resolve module specifier "%s" from "%s": Invalid relative URL or base scheme is not hierarchical.', TypeError), o.ERR_UNKNOWN_FILE_EXTENSION = createError("ERR_UNKNOWN_FILE_EXTENSION", (e3, t3) => `Unknown file extension "${e3}" for ${t3}`, TypeError), o.ERR_INVALID_ARG_VALUE = createError("ERR_INVALID_ARG_VALUE", (e3, t3, r3 = "is invalid") => {
          let n2 = (0, _util().inspect)(t3);
          n2.length > 128 && (n2 = `${n2.slice(0, 128)}...`);
          return `The ${e3.includes(".") ? "property" : "argument"} '${e3}' ${r3}. Received ${n2}`;
        }, TypeError);
        const p = (function(e3) {
          const t3 = "__node_internal_" + e3.name;
          return Object.defineProperty(e3, "name", { value: t3 }), e3;
        })(function(e3) {
          const t3 = isErrorStackTraceLimitWritable();
          return t3 && (l = Error.stackTraceLimit, Error.stackTraceLimit = Number.POSITIVE_INFINITY), Error.captureStackTrace(e3), t3 && (Error.stackTraceLimit = l), e3;
        });
        const c = {}.hasOwnProperty, { ERR_INVALID_PACKAGE_CONFIG: u } = o, d = /* @__PURE__ */ new Map();
        function read(e3, { base: t3, specifier: r3 }) {
          const n2 = d.get(e3);
          if (n2) return n2;
          let s2;
          try {
            s2 = _fs().default.readFileSync(_path().toNamespacedPath(e3), "utf8");
          } catch (e4) {
            const t4 = e4;
            if ("ENOENT" !== t4.code) throw t4;
          }
          const i2 = { exists: false, pjsonPath: e3, main: void 0, name: void 0, type: "none", exports: void 0, imports: void 0 };
          if (void 0 !== s2) {
            let n3;
            try {
              n3 = JSON.parse(s2);
            } catch (n4) {
              const s3 = n4, i3 = new u(e3, (t3 ? `"${r3}" from ` : "") + (0, _url().fileURLToPath)(t3 || r3), s3.message);
              throw i3.cause = s3, i3;
            }
            i2.exists = true, c.call(n3, "name") && "string" == typeof n3.name && (i2.name = n3.name), c.call(n3, "main") && "string" == typeof n3.main && (i2.main = n3.main), c.call(n3, "exports") && (i2.exports = n3.exports), c.call(n3, "imports") && (i2.imports = n3.imports), !c.call(n3, "type") || "commonjs" !== n3.type && "module" !== n3.type || (i2.type = n3.type);
          }
          return d.set(e3, i2), i2;
        }
        function getPackageScopeConfig(e3) {
          let t3 = new URL("package.json", e3);
          for (; ; ) {
            if (t3.pathname.endsWith("node_modules/package.json")) break;
            const r3 = read((0, _url().fileURLToPath)(t3), { specifier: e3 });
            if (r3.exists) return r3;
            const n2 = t3;
            if (t3 = new URL("../package.json", t3), t3.pathname === n2.pathname) break;
          }
          return { pjsonPath: (0, _url().fileURLToPath)(t3), exists: false, type: "none" };
        }
        function getPackageType(e3) {
          return getPackageScopeConfig(e3).type;
        }
        const { ERR_UNKNOWN_FILE_EXTENSION: h } = o, m = {}.hasOwnProperty, f = { __proto__: null, ".cjs": "commonjs", ".js": "module", ".json": "json", ".mjs": "module" };
        const y = { __proto__: null, "data:": function(e3) {
          const { 1: t3 } = /^([^/]+\/[^;,]+)[^,]*?(;base64)?,/.exec(e3.pathname) || [null, null, null];
          return (function(e4) {
            return e4 && /\s*(text|application)\/javascript\s*(;\s*charset=utf-?8\s*)?/i.test(e4) ? "module" : "application/json" === e4 ? "json" : null;
          })(t3);
        }, "file:": function(e3, t3, r3) {
          const n2 = (function(e4) {
            const t4 = e4.pathname;
            let r4 = t4.length;
            for (; r4--; ) {
              const e5 = t4.codePointAt(r4);
              if (47 === e5) return "";
              if (46 === e5) return 47 === t4.codePointAt(r4 - 1) ? "" : t4.slice(r4);
            }
            return "";
          })(e3);
          if (".js" === n2) {
            const t4 = getPackageType(e3);
            return "none" !== t4 ? t4 : "commonjs";
          }
          if ("" === n2) {
            const t4 = getPackageType(e3);
            return "none" === t4 || "commonjs" === t4 ? "commonjs" : "module";
          }
          const s2 = f[n2];
          if (s2) return s2;
          if (r3) return;
          const i2 = (0, _url().fileURLToPath)(e3);
          throw new h(n2, i2);
        }, "http:": getHttpProtocolModuleFormat, "https:": getHttpProtocolModuleFormat, "node:": () => "builtin" };
        function getHttpProtocolModuleFormat() {
        }
        function defaultGetFormatWithoutErrors(e3, t3) {
          const r3 = e3.protocol;
          return m.call(y, r3) && y[r3](e3, t3, true) || null;
        }
        const { ERR_INVALID_ARG_VALUE: b } = o, g = Object.freeze(["node", "import"]), x = new Set(g);
        const v = RegExp.prototype[Symbol.replace], { ERR_NETWORK_IMPORT_DISALLOWED: E, ERR_INVALID_MODULE_SPECIFIER: T, ERR_INVALID_PACKAGE_CONFIG: S, ERR_INVALID_PACKAGE_TARGET: P, ERR_MODULE_NOT_FOUND: _, ERR_PACKAGE_IMPORT_NOT_DEFINED: A, ERR_PACKAGE_PATH_NOT_EXPORTED: C, ERR_UNSUPPORTED_DIR_IMPORT: w, ERR_UNSUPPORTED_RESOLVE_REQUEST: I } = o, D = {}.hasOwnProperty, k = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))?(\\|\/|$)/i, N = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\|\/|$)/i, O = /^\.|%|\\/, j = /\*/g, F = /%2f|%5c/i, L = /* @__PURE__ */ new Set(), M = /[/\\]{2}/;
        function emitInvalidSegmentDeprecation(e3, t3, r3, n2, s2, i2, o2) {
          if (_process().noDeprecation) return;
          const a2 = (0, _url().fileURLToPath)(n2), l2 = null !== M.exec(o2 ? e3 : t3);
          _process().emitWarning(`Use of deprecated ${l2 ? "double slash" : "leading or trailing slash matching"} resolving "${e3}" for module request "${t3}" ${t3 === r3 ? "" : `matched to "${r3}" `}in the "${s2 ? "imports" : "exports"}" field module resolution of the package at ${a2}${i2 ? ` imported from ${(0, _url().fileURLToPath)(i2)}` : ""}.`, "DeprecationWarning", "DEP0166");
        }
        function emitLegacyIndexDeprecation(e3, t3, r3, n2) {
          if (_process().noDeprecation) return;
          if ("module" !== defaultGetFormatWithoutErrors(e3, { parentURL: r3.href })) return;
          const s2 = (0, _url().fileURLToPath)(e3.href), i2 = (0, _url().fileURLToPath)(new (_url()).URL(".", t3)), o2 = (0, _url().fileURLToPath)(r3);
          n2 ? _path().resolve(i2, n2) !== s2 && _process().emitWarning(`Package ${i2} has a "main" field set to "${n2}", excluding the full filename and extension to the resolved file at "${s2.slice(i2.length)}", imported from ${o2}.
 Automatic extension resolution of the "main" field is deprecated for ES modules.`, "DeprecationWarning", "DEP0151") : _process().emitWarning(`No "main" or "exports" field defined in the package.json for ${i2} resolving the main entry point "${s2.slice(i2.length)}", imported from ${o2}.
Default "index" lookups for the main are deprecated for ES modules.`, "DeprecationWarning", "DEP0151");
        }
        function tryStatSync(e3) {
          try {
            return (0, _fs().statSync)(e3);
          } catch (e4) {
          }
        }
        function fileExists(e3) {
          const t3 = (0, _fs().statSync)(e3, { throwIfNoEntry: false }), r3 = t3 ? t3.isFile() : void 0;
          return null != r3 && r3;
        }
        function legacyMainResolve(e3, t3, r3) {
          let n2;
          if (void 0 !== t3.main) {
            if (n2 = new (_url()).URL(t3.main, e3), fileExists(n2)) return n2;
            const s3 = [`./${t3.main}.js`, `./${t3.main}.json`, `./${t3.main}.node`, `./${t3.main}/index.js`, `./${t3.main}/index.json`, `./${t3.main}/index.node`];
            let i3 = -1;
            for (; ++i3 < s3.length && (n2 = new (_url()).URL(s3[i3], e3), !fileExists(n2)); ) n2 = void 0;
            if (n2) return emitLegacyIndexDeprecation(n2, e3, r3, t3.main), n2;
          }
          const s2 = ["./index.js", "./index.json", "./index.node"];
          let i2 = -1;
          for (; ++i2 < s2.length && (n2 = new (_url()).URL(s2[i2], e3), !fileExists(n2)); ) n2 = void 0;
          if (n2) return emitLegacyIndexDeprecation(n2, e3, r3, t3.main), n2;
          throw new _((0, _url().fileURLToPath)(new (_url()).URL(".", e3)), (0, _url().fileURLToPath)(r3));
        }
        function exportsNotFound(e3, t3, r3) {
          return new C((0, _url().fileURLToPath)(new (_url()).URL(".", t3)), e3, r3 && (0, _url().fileURLToPath)(r3));
        }
        function invalidPackageTarget(e3, t3, r3, n2, s2) {
          return t3 = "object" == typeof t3 && null !== t3 ? JSON.stringify(t3, null, "") : `${t3}`, new P((0, _url().fileURLToPath)(new (_url()).URL(".", r3)), e3, t3, n2, s2 && (0, _url().fileURLToPath)(s2));
        }
        function resolvePackageTargetString(e3, t3, r3, n2, s2, i2, o2, a2, l2) {
          if ("" !== t3 && !i2 && "/" !== e3[e3.length - 1]) throw invalidPackageTarget(r3, e3, n2, o2, s2);
          if (!e3.startsWith("./")) {
            if (o2 && !e3.startsWith("../") && !e3.startsWith("/")) {
              let r4 = false;
              try {
                new (_url()).URL(e3), r4 = true;
              } catch (e4) {
              }
              if (!r4) {
                return packageResolve(i2 ? v.call(j, e3, () => t3) : e3 + t3, n2, l2);
              }
            }
            throw invalidPackageTarget(r3, e3, n2, o2, s2);
          }
          if (null !== k.exec(e3.slice(2))) {
            if (null !== N.exec(e3.slice(2))) throw invalidPackageTarget(r3, e3, n2, o2, s2);
            if (!a2) {
              const a3 = i2 ? r3.replace("*", () => t3) : r3 + t3;
              emitInvalidSegmentDeprecation(i2 ? v.call(j, e3, () => t3) : e3, a3, r3, n2, o2, s2, true);
            }
          }
          const p2 = new (_url()).URL(e3, n2), c2 = p2.pathname, u2 = new (_url()).URL(".", n2).pathname;
          if (!c2.startsWith(u2)) throw invalidPackageTarget(r3, e3, n2, o2, s2);
          if ("" === t3) return p2;
          if (null !== k.exec(t3)) {
            const l3 = i2 ? r3.replace("*", () => t3) : r3 + t3;
            if (null === N.exec(t3)) {
              if (!a2) {
                emitInvalidSegmentDeprecation(i2 ? v.call(j, e3, () => t3) : e3, l3, r3, n2, o2, s2, false);
              }
            } else !(function(e4, t4, r4, n3, s3) {
              const i3 = `request is not a valid match in pattern "${t4}" for the "${n3 ? "imports" : "exports"}" resolution of ${(0, _url().fileURLToPath)(r4)}`;
              throw new T(e4, i3, s3 && (0, _url().fileURLToPath)(s3));
            })(l3, r3, n2, o2, s2);
          }
          return i2 ? new (_url()).URL(v.call(j, p2.href, () => t3)) : new (_url()).URL(t3, p2);
        }
        function isArrayIndex(e3) {
          const t3 = Number(e3);
          return `${t3}` === e3 && (t3 >= 0 && t3 < 4294967295);
        }
        function resolvePackageTarget(e3, t3, r3, n2, s2, i2, o2, a2, l2) {
          if ("string" == typeof t3) return resolvePackageTargetString(t3, r3, n2, e3, s2, i2, o2, a2, l2);
          if (Array.isArray(t3)) {
            const p2 = t3;
            if (0 === p2.length) return null;
            let c2, u2 = -1;
            for (; ++u2 < p2.length; ) {
              const t4 = p2[u2];
              let d2;
              try {
                d2 = resolvePackageTarget(e3, t4, r3, n2, s2, i2, o2, a2, l2);
              } catch (e4) {
                if (c2 = e4, "ERR_INVALID_PACKAGE_TARGET" === e4.code) continue;
                throw e4;
              }
              if (void 0 !== d2) {
                if (null !== d2) return d2;
                c2 = null;
              }
            }
            if (null == c2) return null;
            throw c2;
          }
          if ("object" == typeof t3 && null !== t3) {
            const p2 = Object.getOwnPropertyNames(t3);
            let c2 = -1;
            for (; ++c2 < p2.length; ) {
              if (isArrayIndex(p2[c2])) throw new S((0, _url().fileURLToPath)(e3), s2, '"exports" cannot contain numeric property keys.');
            }
            for (c2 = -1; ++c2 < p2.length; ) {
              const u2 = p2[c2];
              if ("default" === u2 || l2 && l2.has(u2)) {
                const p3 = resolvePackageTarget(e3, t3[u2], r3, n2, s2, i2, o2, a2, l2);
                if (void 0 === p3) continue;
                return p3;
              }
            }
            return null;
          }
          if (null === t3) return null;
          throw invalidPackageTarget(n2, t3, e3, o2, s2);
        }
        function emitTrailingSlashPatternDeprecation(e3, t3, r3) {
          if (_process().noDeprecation) return;
          const n2 = (0, _url().fileURLToPath)(t3);
          L.has(n2 + "|" + e3) || (L.add(n2 + "|" + e3), _process().emitWarning(`Use of deprecated trailing slash pattern mapping "${e3}" in the "exports" field module resolution of the package at ${n2}${r3 ? ` imported from ${(0, _url().fileURLToPath)(r3)}` : ""}. Mapping specifiers ending in "/" is no longer supported.`, "DeprecationWarning", "DEP0155"));
        }
        function packageExportsResolve(e3, t3, r3, n2, s2) {
          let i2 = r3.exports;
          if ((function(e4, t4, r4) {
            if ("string" == typeof e4 || Array.isArray(e4)) return true;
            if ("object" != typeof e4 || null === e4) return false;
            const n3 = Object.getOwnPropertyNames(e4);
            let s3 = false, i3 = 0, o3 = -1;
            for (; ++o3 < n3.length; ) {
              const e5 = n3[o3], a3 = "" === e5 || "." !== e5[0];
              if (0 === i3++) s3 = a3;
              else if (s3 !== a3) throw new S((0, _url().fileURLToPath)(t4), r4, `"exports" cannot contain some keys starting with '.' and some not. The exports object must either be an object of package subpath keys or an object of main entry condition name keys only.`);
            }
            return s3;
          })(i2, e3, n2) && (i2 = { ".": i2 }), D.call(i2, t3) && !t3.includes("*") && !t3.endsWith("/")) {
            const r4 = resolvePackageTarget(e3, i2[t3], "", t3, n2, false, false, false, s2);
            if (null == r4) throw exportsNotFound(t3, e3, n2);
            return r4;
          }
          let o2 = "", a2 = "";
          const l2 = Object.getOwnPropertyNames(i2);
          let p2 = -1;
          for (; ++p2 < l2.length; ) {
            const r4 = l2[p2], s3 = r4.indexOf("*");
            if (-1 !== s3 && t3.startsWith(r4.slice(0, s3))) {
              t3.endsWith("/") && emitTrailingSlashPatternDeprecation(t3, e3, n2);
              const i3 = r4.slice(s3 + 1);
              t3.length >= r4.length && t3.endsWith(i3) && 1 === patternKeyCompare(o2, r4) && r4.lastIndexOf("*") === s3 && (o2 = r4, a2 = t3.slice(s3, t3.length - i3.length));
            }
          }
          if (o2) {
            const r4 = resolvePackageTarget(e3, i2[o2], a2, o2, n2, true, false, t3.endsWith("/"), s2);
            if (null == r4) throw exportsNotFound(t3, e3, n2);
            return r4;
          }
          throw exportsNotFound(t3, e3, n2);
        }
        function patternKeyCompare(e3, t3) {
          const r3 = e3.indexOf("*"), n2 = t3.indexOf("*"), s2 = -1 === r3 ? e3.length : r3 + 1, i2 = -1 === n2 ? t3.length : n2 + 1;
          return s2 > i2 ? -1 : i2 > s2 || -1 === r3 ? 1 : -1 === n2 || e3.length > t3.length ? -1 : t3.length > e3.length ? 1 : 0;
        }
        function packageImportsResolve(e3, t3, r3) {
          if ("#" === e3 || e3.startsWith("#/") || e3.endsWith("/")) {
            throw new T(e3, "is not a valid internal imports specifier name", (0, _url().fileURLToPath)(t3));
          }
          let n2;
          const s2 = getPackageScopeConfig(t3);
          if (s2.exists) {
            n2 = (0, _url().pathToFileURL)(s2.pjsonPath);
            const i2 = s2.imports;
            if (i2) if (D.call(i2, e3) && !e3.includes("*")) {
              const s3 = resolvePackageTarget(n2, i2[e3], "", e3, t3, false, true, false, r3);
              if (null != s3) return s3;
            } else {
              let s3 = "", o2 = "";
              const a2 = Object.getOwnPropertyNames(i2);
              let l2 = -1;
              for (; ++l2 < a2.length; ) {
                const t4 = a2[l2], r4 = t4.indexOf("*");
                if (-1 !== r4 && e3.startsWith(t4.slice(0, -1))) {
                  const n3 = t4.slice(r4 + 1);
                  e3.length >= t4.length && e3.endsWith(n3) && 1 === patternKeyCompare(s3, t4) && t4.lastIndexOf("*") === r4 && (s3 = t4, o2 = e3.slice(r4, e3.length - n3.length));
                }
              }
              if (s3) {
                const e4 = resolvePackageTarget(n2, i2[s3], o2, s3, t3, true, true, false, r3);
                if (null != e4) return e4;
              }
            }
          }
          throw (function(e4, t4, r4) {
            return new A(e4, t4 && (0, _url().fileURLToPath)(new (_url()).URL(".", t4)), (0, _url().fileURLToPath)(r4));
          })(e3, n2, t3);
        }
        function packageResolve(e3, t3, r3) {
          if (_module().builtinModules.includes(e3)) return new (_url()).URL("node:" + e3);
          const { packageName: n2, packageSubpath: s2, isScoped: i2 } = (function(e4, t4) {
            let r4 = e4.indexOf("/"), n3 = true, s3 = false;
            "@" === e4[0] && (s3 = true, -1 === r4 || 0 === e4.length ? n3 = false : r4 = e4.indexOf("/", r4 + 1));
            const i3 = -1 === r4 ? e4 : e4.slice(0, r4);
            if (null !== O.exec(i3) && (n3 = false), !n3) throw new T(e4, "is not a valid package name", (0, _url().fileURLToPath)(t4));
            return { packageName: i3, packageSubpath: "." + (-1 === r4 ? "" : e4.slice(r4)), isScoped: s3 };
          })(e3, t3), o2 = getPackageScopeConfig(t3);
          if (o2.exists) {
            const e4 = (0, _url().pathToFileURL)(o2.pjsonPath);
            if (o2.name === n2 && void 0 !== o2.exports && null !== o2.exports) return packageExportsResolve(e4, s2, o2, t3, r3);
          }
          let a2, l2 = new (_url()).URL("./node_modules/" + n2 + "/package.json", t3), p2 = (0, _url().fileURLToPath)(l2);
          do {
            const o3 = tryStatSync(p2.slice(0, -13));
            if (!o3 || !o3.isDirectory()) {
              a2 = p2, l2 = new (_url()).URL((i2 ? "../../../../node_modules/" : "../../../node_modules/") + n2 + "/package.json", l2), p2 = (0, _url().fileURLToPath)(l2);
              continue;
            }
            const c2 = read(p2, { base: t3, specifier: e3 });
            return void 0 !== c2.exports && null !== c2.exports ? packageExportsResolve(l2, s2, c2, t3, r3) : "." === s2 ? legacyMainResolve(l2, c2, t3) : new (_url()).URL(s2, l2);
          } while (p2.length !== a2.length);
          throw new _(n2, (0, _url().fileURLToPath)(t3), false);
        }
        function shouldBeTreatedAsRelativeOrAbsolutePath(e3) {
          return "" !== e3 && ("/" === e3[0] || (function(e4) {
            if ("." === e4[0]) {
              if (1 === e4.length || "/" === e4[1]) return true;
              if ("." === e4[1] && (2 === e4.length || "/" === e4[2])) return true;
            }
            return false;
          })(e3));
        }
        function moduleResolve(e3, t3, r3, n2) {
          const s2 = t3.protocol, i2 = "data:" === s2 || "http:" === s2 || "https:" === s2;
          let o2;
          if (shouldBeTreatedAsRelativeOrAbsolutePath(e3)) try {
            o2 = new (_url()).URL(e3, t3);
          } catch (r4) {
            const n3 = new I(e3, t3);
            throw n3.cause = r4, n3;
          }
          else if ("file:" === s2 && "#" === e3[0]) o2 = packageImportsResolve(e3, t3, r3);
          else try {
            o2 = new (_url()).URL(e3);
          } catch (n3) {
            if (i2 && !_module().builtinModules.includes(e3)) {
              const r4 = new I(e3, t3);
              throw r4.cause = n3, r4;
            }
            o2 = packageResolve(e3, t3, r3);
          }
          return _assert()(void 0 !== o2, "expected to be defined"), "file:" !== o2.protocol ? o2 : (function(e4, t4, r4) {
            if (null !== F.exec(e4.pathname)) throw new T(e4.pathname, 'must not include encoded "/" or "\\" characters', (0, _url().fileURLToPath)(t4));
            let n3;
            try {
              n3 = (0, _url().fileURLToPath)(e4);
            } catch (r5) {
              const n4 = r5;
              throw Object.defineProperty(n4, "input", { value: String(e4) }), Object.defineProperty(n4, "module", { value: String(t4) }), n4;
            }
            const s3 = tryStatSync(n3.endsWith("/") ? n3.slice(-1) : n3);
            if (s3 && s3.isDirectory()) {
              const r5 = new w(n3, (0, _url().fileURLToPath)(t4));
              throw r5.url = String(e4), r5;
            }
            if (!s3 || !s3.isFile()) {
              const r5 = new _(n3 || e4.pathname, t4 && (0, _url().fileURLToPath)(t4), true);
              throw r5.url = String(e4), r5;
            }
            if (!r4) {
              const t5 = (0, _fs().realpathSync)(n3), { search: r5, hash: s4 } = e4;
              (e4 = (0, _url().pathToFileURL)(t5 + (n3.endsWith(_path().sep) ? "/" : ""))).search = r5, e4.hash = s4;
            }
            return e4;
          })(o2, t3, n2);
        }
      }, "./node_modules/.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/lib/buffer.js": function(e2, t2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        t2.default = class {
          constructor(e3, t3) {
            this._map = null, this._buf = "", this._str = "", this._appendCount = 0, this._last = 0, this._queue = [], this._queueCursor = 0, this._canMarkIdName = true, this._indentChar = "", this._fastIndentations = [], this._position = { line: 1, column: 0 }, this._sourcePosition = { identifierName: void 0, identifierNamePos: void 0, line: void 0, column: void 0, filename: void 0 }, this._map = e3, this._indentChar = t3;
            for (let e4 = 0; e4 < 64; e4++) this._fastIndentations.push(t3.repeat(e4));
            this._allocQueue();
          }
          _allocQueue() {
            const e3 = this._queue;
            for (let t3 = 0; t3 < 16; t3++) e3.push({ char: 0, repeat: 1, line: void 0, column: void 0, identifierName: void 0, identifierNamePos: void 0, filename: "" });
          }
          _pushQueue(e3, t3, r2, n, s) {
            const i = this._queueCursor;
            i === this._queue.length && this._allocQueue();
            const o = this._queue[i];
            o.char = e3, o.repeat = t3, o.line = r2, o.column = n, o.filename = s, this._queueCursor++;
          }
          _popQueue() {
            if (0 === this._queueCursor) throw new Error("Cannot pop from empty queue");
            return this._queue[--this._queueCursor];
          }
          get() {
            this._flush();
            const e3 = this._map, t3 = { code: (this._buf + this._str).trimRight(), decodedMap: null == e3 ? void 0 : e3.getDecoded(), get __mergedMap() {
              return this.map;
            }, get map() {
              const r2 = e3 ? e3.get() : null;
              return t3.map = r2, r2;
            }, set map(e4) {
              Object.defineProperty(t3, "map", { value: e4, writable: true });
            }, get rawMappings() {
              const r2 = null == e3 ? void 0 : e3.getRawMappings();
              return t3.rawMappings = r2, r2;
            }, set rawMappings(e4) {
              Object.defineProperty(t3, "rawMappings", { value: e4, writable: true });
            } };
            return t3;
          }
          append(e3, t3) {
            this._flush(), this._append(e3, this._sourcePosition, t3);
          }
          appendChar(e3) {
            this._flush(), this._appendChar(e3, 1, this._sourcePosition);
          }
          queue(e3) {
            if (10 === e3) for (; 0 !== this._queueCursor; ) {
              const e4 = this._queue[this._queueCursor - 1].char;
              if (32 !== e4 && 9 !== e4) break;
              this._queueCursor--;
            }
            const t3 = this._sourcePosition;
            this._pushQueue(e3, 1, t3.line, t3.column, t3.filename);
          }
          queueIndentation(e3) {
            0 !== e3 && this._pushQueue(-1, e3, void 0, void 0, void 0);
          }
          _flush() {
            const e3 = this._queueCursor, t3 = this._queue;
            for (let r2 = 0; r2 < e3; r2++) {
              const e4 = t3[r2];
              this._appendChar(e4.char, e4.repeat, e4);
            }
            this._queueCursor = 0;
          }
          _appendChar(e3, t3, r2) {
            if (this._last = e3, -1 === e3) {
              const e4 = this._fastIndentations[t3];
              this._str += void 0 !== e4 ? e4 : t3 > 1 ? this._indentChar.repeat(t3) : this._indentChar;
            } else this._str += t3 > 1 ? String.fromCharCode(e3).repeat(t3) : String.fromCharCode(e3);
            10 !== e3 ? (this._mark(r2.line, r2.column, r2.identifierName, r2.identifierNamePos, r2.filename), this._position.column += t3) : (this._position.line++, this._position.column = 0), this._canMarkIdName && (r2.identifierName = void 0, r2.identifierNamePos = void 0);
          }
          _append(e3, t3, r2) {
            const n = e3.length, s = this._position;
            if (this._last = e3.charCodeAt(n - 1), ++this._appendCount > 4096 ? (this._str, this._buf += this._str, this._str = e3, this._appendCount = 0) : this._str += e3, !r2 && !this._map) return void (s.column += n);
            const { column: i, identifierName: o, identifierNamePos: a, filename: l } = t3;
            let p = t3.line;
            null == o && null == a || !this._canMarkIdName || (t3.identifierName = void 0, t3.identifierNamePos = void 0);
            let c = e3.indexOf("\n"), u = 0;
            for (0 !== c && this._mark(p, i, o, a, l); -1 !== c; ) s.line++, s.column = 0, u = c + 1, u < n && void 0 !== p && this._mark(++p, 0, null, null, l), c = e3.indexOf("\n", u);
            s.column += n - u;
          }
          _mark(e3, t3, r2, n, s) {
            var i;
            null == (i = this._map) || i.mark(this._position, e3, t3, r2, n, s);
          }
          removeTrailingNewline() {
            const e3 = this._queueCursor;
            0 !== e3 && 10 === this._queue[e3 - 1].char && this._queueCursor--;
          }
          removeLastSemicolon() {
            const e3 = this._queueCursor;
            0 !== e3 && 59 === this._queue[e3 - 1].char && this._queueCursor--;
          }
          getLastChar() {
            const e3 = this._queueCursor;
            return 0 !== e3 ? this._queue[e3 - 1].char : this._last;
          }
          getNewlineCount() {
            const e3 = this._queueCursor;
            let t3 = 0;
            if (0 === e3) return 10 === this._last ? 1 : 0;
            for (let r2 = e3 - 1; r2 >= 0 && 10 === this._queue[r2].char; r2--) t3++;
            return t3 === e3 && 10 === this._last ? t3 + 1 : t3;
          }
          endsWithCharAndNewline() {
            const e3 = this._queue, t3 = this._queueCursor;
            if (0 !== t3) {
              if (10 !== e3[t3 - 1].char) return;
              return t3 > 1 ? e3[t3 - 2].char : this._last;
            }
          }
          hasContent() {
            return 0 !== this._queueCursor || !!this._last;
          }
          exactSource(e3, t3) {
            if (!this._map) return void t3();
            this.source("start", e3);
            const r2 = e3.identifierName, n = this._sourcePosition;
            r2 && (this._canMarkIdName = false, n.identifierName = r2), t3(), r2 && (this._canMarkIdName = true, n.identifierName = void 0, n.identifierNamePos = void 0), this.source("end", e3);
          }
          source(e3, t3) {
            this._map && this._normalizePosition(e3, t3, 0);
          }
          sourceWithOffset(e3, t3, r2) {
            this._map && this._normalizePosition(e3, t3, r2);
          }
          _normalizePosition(e3, t3, r2) {
            const n = t3[e3], s = this._sourcePosition;
            n && (s.line = n.line, s.column = Math.max(n.column + r2, 0), s.filename = t3.filename);
          }
          getCurrentColumn() {
            const e3 = this._queue, t3 = this._queueCursor;
            let r2 = -1, n = 0;
            for (let s = 0; s < t3; s++) {
              const t4 = e3[s];
              10 === t4.char && (r2 = n), n += t4.repeat;
            }
            return -1 === r2 ? this._position.column + n : n - 1 - r2;
          }
          getCurrentLine() {
            let e3 = 0;
            const t3 = this._queue;
            for (let r2 = 0; r2 < this._queueCursor; r2++) 10 === t3[r2].char && e3++;
            return this._position.line + e3;
          }
        };
      }, "./node_modules/.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/lib/generators/base.js": function(e2, t2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.BlockStatement = function(e3) {
          var t3;
          this.tokenChar(123);
          const r3 = this.enterDelimited(), n2 = null == (t3 = e3.directives) ? void 0 : t3.length;
          if (n2) {
            var s;
            const t4 = e3.body.length ? 2 : 1;
            this.printSequence(e3.directives, true, t4), null != (s = e3.directives[n2 - 1].trailingComments) && s.length || this.newline(t4);
          }
          this.printSequence(e3.body, true), r3(), this.rightBrace(e3);
        }, t2.Directive = function(e3) {
          this.print(e3.value), this.semicolon();
        }, t2.DirectiveLiteral = function(e3) {
          const t3 = this.getPossibleRaw(e3);
          if (!this.format.minified && void 0 !== t3) return void this.token(t3);
          const { value: s } = e3;
          if (n.test(s)) {
            if (r2.test(s)) throw new Error("Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.");
            this.token(`'${s}'`);
          } else this.token(`"${s}"`);
        }, t2.File = function(e3) {
          e3.program && this.print(e3.program.interpreter);
          this.print(e3.program);
        }, t2.InterpreterDirective = function(e3) {
          this.token(`#!${e3.value}`), this.newline(1, true);
        }, t2.Placeholder = function(e3) {
          this.token("%%"), this.print(e3.name), this.token("%%"), "Statement" === e3.expectedNode && this.semicolon();
        }, t2.Program = function(e3) {
          var t3;
          this.noIndentInnerCommentsHere(), this.printInnerComments();
          const r3 = null == (t3 = e3.directives) ? void 0 : t3.length;
          if (r3) {
            var n2;
            const t4 = e3.body.length ? 2 : 1;
            this.printSequence(e3.directives, void 0, t4), null != (n2 = e3.directives[r3 - 1].trailingComments) && n2.length || this.newline(t4);
          }
          this.printSequence(e3.body);
        };
        const r2 = /(?:^|[^\\])(?:\\\\)*'/, n = /(?:^|[^\\])(?:\\\\)*"/;
      }, "./node_modules/.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/lib/generators/classes.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.ClassAccessorProperty = function(e3) {
          var t3;
          this.printJoin(e3.decorators);
          const r3 = null == (t3 = e3.key.loc) || null == (t3 = t3.end) ? void 0 : t3.line;
          r3 && this.catchUp(r3);
          this.tsPrintClassMemberModifiers(e3), this.word("accessor", true), this.space(), e3.computed ? (this.tokenChar(91), this.print(e3.key), this.tokenChar(93)) : (this._variance(e3), this.print(e3.key));
          e3.optional && this.tokenChar(63);
          e3.definite && this.tokenChar(33);
          this.print(e3.typeAnnotation), e3.value && (this.space(), this.tokenChar(61), this.space(), this.print(e3.value));
          this.semicolon();
        }, t2.ClassBody = function(e3) {
          if (this.tokenChar(123), 0 === e3.body.length) this.tokenChar(125);
          else {
            this.newline();
            const t3 = (function(e4, t4) {
              if (!e4.tokenMap || null == t4.start || null == t4.end) return null;
              const r4 = e4.tokenMap.getIndexes(t4);
              if (!r4) return null;
              let n2 = 1, s2 = 0, i2 = 0;
              const advanceNextLocIndex = () => {
                for (; i2 < t4.body.length && null == t4.body[i2].start; ) i2++;
              };
              return advanceNextLocIndex(), (o) => {
                i2 <= o && (i2 = o + 1, advanceNextLocIndex());
                const a = i2 === t4.body.length ? t4.end : t4.body[i2].start;
                let l;
                for (; n2 < r4.length && e4.tokenMap.matchesOriginal(l = e4._tokens[r4[n2]], ";") && l.start < a; ) e4.token(";", void 0, s2++), n2++;
              };
            })(this, e3);
            null == t3 || t3(-1);
            const r3 = this.enterDelimited();
            this.printJoin(e3.body, true, true, t3, true), r3(), this.endsWith(10) || this.newline(), this.rightBrace(e3);
          }
        }, t2.ClassExpression = t2.ClassDeclaration = function(e3, t3) {
          (s(t3) || i(t3)) && this._shouldPrintDecoratorsBeforeExport(t3) || this.printJoin(e3.decorators);
          e3.declare && (this.word("declare"), this.space());
          e3.abstract && (this.word("abstract"), this.space());
          this.word("class"), e3.id && (this.space(), this.print(e3.id));
          this.print(e3.typeParameters), e3.superClass && (this.space(), this.word("extends"), this.space(), this.print(e3.superClass), this.print(e3.superTypeParameters));
          e3.implements && (this.space(), this.word("implements"), this.space(), this.printList(e3.implements));
          this.space(), this.print(e3.body);
        }, t2.ClassMethod = function(e3) {
          this._classMethodHead(e3), this.space(), this.print(e3.body);
        }, t2.ClassPrivateMethod = function(e3) {
          this._classMethodHead(e3), this.space(), this.print(e3.body);
        }, t2.ClassPrivateProperty = function(e3) {
          this.printJoin(e3.decorators), this.tsPrintClassMemberModifiers(e3), this.print(e3.key), e3.optional && this.tokenChar(63);
          e3.definite && this.tokenChar(33);
          this.print(e3.typeAnnotation), e3.value && (this.space(), this.tokenChar(61), this.space(), this.print(e3.value));
          this.semicolon();
        }, t2.ClassProperty = function(e3) {
          if (this.printJoin(e3.decorators), !e3.static && !this.format.preserveFormat) {
            var t3;
            const r3 = null == (t3 = e3.key.loc) || null == (t3 = t3.end) ? void 0 : t3.line;
            r3 && this.catchUp(r3);
          }
          this.tsPrintClassMemberModifiers(e3), e3.computed ? (this.tokenChar(91), this.print(e3.key), this.tokenChar(93)) : (this._variance(e3), this.print(e3.key));
          e3.optional && this.tokenChar(63);
          e3.definite && this.tokenChar(33);
          this.print(e3.typeAnnotation), e3.value && (this.space(), this.tokenChar(61), this.space(), this.print(e3.value));
          this.semicolon();
        }, t2.StaticBlock = function(e3) {
          this.word("static"), this.space(), this.tokenChar(123), 0 === e3.body.length ? this.tokenChar(125) : (this.newline(), this.printSequence(e3.body, true), this.rightBrace(e3));
        }, t2._classMethodHead = function(e3) {
          if (this.printJoin(e3.decorators), !this.format.preserveFormat) {
            var t3;
            const r3 = null == (t3 = e3.key.loc) || null == (t3 = t3.end) ? void 0 : t3.line;
            r3 && this.catchUp(r3);
          }
          this.tsPrintClassMemberModifiers(e3), this._methodHead(e3);
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/index.js");
        const { isExportDefaultDeclaration: s, isExportNamedDeclaration: i } = n;
      }, "./node_modules/.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/lib/generators/deprecated.js": function(e2, t2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.addDeprecatedGenerators = function(e3) {
          {
            const t3 = { Noop() {
            }, TSExpressionWithTypeArguments(e4) {
              this.print(e4.expression), this.print(e4.typeParameters);
            }, DecimalLiteral(e4) {
              const t4 = this.getPossibleRaw(e4);
              this.format.minified || void 0 === t4 ? this.word(e4.value + "m") : this.word(t4);
            } };
            Object.assign(e3.prototype, t3);
          }
        };
      }, "./node_modules/.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/lib/generators/expressions.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.LogicalExpression = t2.BinaryExpression = t2.AssignmentExpression = function(e3) {
          this.print(e3.left), this.space(), "in" === e3.operator || "instanceof" === e3.operator ? this.word(e3.operator) : (this.token(e3.operator), this._endsWithDiv = "/" === e3.operator);
          this.space(), this.print(e3.right);
        }, t2.AssignmentPattern = function(e3) {
          this.print(e3.left), ("Identifier" === e3.left.type || p(e3.left)) && (e3.left.optional && this.tokenChar(63), this.print(e3.left.typeAnnotation));
          this.space(), this.tokenChar(61), this.space(), this.print(e3.right);
        }, t2.AwaitExpression = function(e3) {
          this.word("await"), this.space(), this.print(e3.argument);
        }, t2.BindExpression = function(e3) {
          this.print(e3.object), this.token("::"), this.print(e3.callee);
        }, t2.CallExpression = function(e3) {
          this.print(e3.callee), this.print(e3.typeArguments), this.print(e3.typeParameters), this.tokenChar(40);
          const t3 = this.enterDelimited();
          this.printList(e3.arguments, this.shouldPrintTrailingComma(")")), t3(), this.rightParens(e3);
        }, t2.ConditionalExpression = function(e3) {
          this.print(e3.test), this.space(), this.tokenChar(63), this.space(), this.print(e3.consequent), this.space(), this.tokenChar(58), this.space(), this.print(e3.alternate);
        }, t2.Decorator = function(e3) {
          this.tokenChar(64), this.print(e3.expression), this.newline();
        }, t2.DoExpression = function(e3) {
          e3.async && (this.word("async", true), this.space());
          this.word("do"), this.space(), this.print(e3.body);
        }, t2.EmptyStatement = function() {
          this.semicolon(true);
        }, t2.ExpressionStatement = function(e3) {
          this.tokenContext |= s.TokenContext.expressionStatement, this.print(e3.expression), this.semicolon();
        }, t2.Import = function() {
          this.word("import");
        }, t2.MemberExpression = function(e3) {
          if (this.print(e3.object), !e3.computed && a(e3.property)) throw new TypeError("Got a MemberExpression for MemberExpression property");
          let t3 = e3.computed;
          o(e3.property) && "number" == typeof e3.property.value && (t3 = true);
          if (t3) {
            const t4 = this.enterDelimited();
            this.tokenChar(91), this.print(e3.property), this.tokenChar(93), t4();
          } else this.tokenChar(46), this.print(e3.property);
        }, t2.MetaProperty = function(e3) {
          this.print(e3.meta), this.tokenChar(46), this.print(e3.property);
        }, t2.ModuleExpression = function(e3) {
          this.word("module", true), this.space(), this.tokenChar(123), this.indent();
          const { body: t3 } = e3;
          (t3.body.length || t3.directives.length) && this.newline();
          this.print(t3), this.dedent(), this.rightBrace(e3);
        }, t2.NewExpression = function(e3, t3) {
          if (this.word("new"), this.space(), this.print(e3.callee), this.format.minified && 0 === e3.arguments.length && !e3.optional && !i(t3, { callee: e3 }) && !a(t3) && !l(t3)) return;
          this.print(e3.typeArguments), this.print(e3.typeParameters), e3.optional && this.token("?.");
          if (0 === e3.arguments.length && this.tokenMap && !this.tokenMap.endMatches(e3, ")")) return;
          this.tokenChar(40);
          const r3 = this.enterDelimited();
          this.printList(e3.arguments, this.shouldPrintTrailingComma(")")), r3(), this.rightParens(e3);
        }, t2.OptionalCallExpression = function(e3) {
          this.print(e3.callee), this.print(e3.typeParameters), e3.optional && this.token("?.");
          this.print(e3.typeArguments), this.tokenChar(40);
          const t3 = this.enterDelimited();
          this.printList(e3.arguments), t3(), this.rightParens(e3);
        }, t2.OptionalMemberExpression = function(e3) {
          let { computed: t3 } = e3;
          const { optional: r3, property: n2 } = e3;
          if (this.print(e3.object), !t3 && a(n2)) throw new TypeError("Got a MemberExpression for MemberExpression property");
          o(n2) && "number" == typeof n2.value && (t3 = true);
          r3 && this.token("?.");
          t3 ? (this.tokenChar(91), this.print(n2), this.tokenChar(93)) : (r3 || this.tokenChar(46), this.print(n2));
        }, t2.ParenthesizedExpression = function(e3) {
          this.tokenChar(40);
          const t3 = this.enterDelimited();
          this.print(e3.expression), t3(), this.rightParens(e3);
        }, t2.PrivateName = function(e3) {
          this.tokenChar(35), this.print(e3.id);
        }, t2.SequenceExpression = function(e3) {
          this.printList(e3.expressions);
        }, t2.Super = function() {
          this.word("super");
        }, t2.ThisExpression = function() {
          this.word("this");
        }, t2.UnaryExpression = function(e3) {
          const { operator: t3 } = e3;
          "void" === t3 || "delete" === t3 || "typeof" === t3 || "throw" === t3 ? (this.word(t3), this.space()) : this.token(t3);
          this.print(e3.argument);
        }, t2.UpdateExpression = function(e3) {
          e3.prefix ? (this.token(e3.operator), this.print(e3.argument)) : (this.print(e3.argument, true), this.token(e3.operator));
        }, t2.V8IntrinsicIdentifier = function(e3) {
          this.tokenChar(37), this.word(e3.name);
        }, t2.YieldExpression = function(e3) {
          e3.delegate ? (this.word("yield", true), this.tokenChar(42), e3.argument && (this.space(), this.print(e3.argument))) : e3.argument ? (this.word("yield", true), this.space(), this.print(e3.argument)) : this.word("yield");
        }, t2._shouldPrintDecoratorsBeforeExport = function(e3) {
          if ("boolean" == typeof this.format.decoratorsBeforeExport) return this.format.decoratorsBeforeExport;
          return "number" == typeof e3.start && e3.start === e3.declaration.start;
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/index.js"), s = r2("./node_modules/.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/lib/node/index.js");
        const { isCallExpression: i, isLiteral: o, isMemberExpression: a, isNewExpression: l, isPattern: p } = n;
      }, "./node_modules/.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/lib/generators/flow.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.AnyTypeAnnotation = function() {
          this.word("any");
        }, t2.ArrayTypeAnnotation = function(e3) {
          this.print(e3.elementType, true), this.tokenChar(91), this.tokenChar(93);
        }, t2.BooleanLiteralTypeAnnotation = function(e3) {
          this.word(e3.value ? "true" : "false");
        }, t2.BooleanTypeAnnotation = function() {
          this.word("boolean");
        }, t2.DeclareClass = function(e3, t3) {
          a(t3) || (this.word("declare"), this.space());
          this.word("class"), this.space(), this._interfaceish(e3);
        }, t2.DeclareExportAllDeclaration = function(e3) {
          this.word("declare"), this.space(), s.ExportAllDeclaration.call(this, e3);
        }, t2.DeclareExportDeclaration = function(e3) {
          this.word("declare"), this.space(), this.word("export"), this.space(), e3.default && (this.word("default"), this.space());
          FlowExportDeclaration.call(this, e3);
        }, t2.DeclareFunction = function(e3, t3) {
          a(t3) || (this.word("declare"), this.space());
          this.word("function"), this.space(), this.print(e3.id), this.print(e3.id.typeAnnotation.typeAnnotation), e3.predicate && (this.space(), this.print(e3.predicate));
          this.semicolon();
        }, t2.DeclareInterface = function(e3) {
          this.word("declare"), this.space(), this.InterfaceDeclaration(e3);
        }, t2.DeclareModule = function(e3) {
          this.word("declare"), this.space(), this.word("module"), this.space(), this.print(e3.id), this.space(), this.print(e3.body);
        }, t2.DeclareModuleExports = function(e3) {
          this.word("declare"), this.space(), this.word("module"), this.tokenChar(46), this.word("exports"), this.print(e3.typeAnnotation);
        }, t2.DeclareOpaqueType = function(e3, t3) {
          a(t3) || (this.word("declare"), this.space());
          this.OpaqueType(e3);
        }, t2.DeclareTypeAlias = function(e3) {
          this.word("declare"), this.space(), this.TypeAlias(e3);
        }, t2.DeclareVariable = function(e3, t3) {
          a(t3) || (this.word("declare"), this.space());
          this.word("var"), this.space(), this.print(e3.id), this.print(e3.id.typeAnnotation), this.semicolon();
        }, t2.DeclaredPredicate = function(e3) {
          this.tokenChar(37), this.word("checks"), this.tokenChar(40), this.print(e3.value), this.tokenChar(41);
        }, t2.EmptyTypeAnnotation = function() {
          this.word("empty");
        }, t2.EnumBooleanBody = function(e3) {
          const { explicitType: t3 } = e3;
          enumExplicitType(this, "boolean", t3), enumBody(this, e3);
        }, t2.EnumBooleanMember = function(e3) {
          enumInitializedMember(this, e3);
        }, t2.EnumDeclaration = function(e3) {
          const { id: t3, body: r3 } = e3;
          this.word("enum"), this.space(), this.print(t3), this.print(r3);
        }, t2.EnumDefaultedMember = function(e3) {
          const { id: t3 } = e3;
          this.print(t3), this.tokenChar(44);
        }, t2.EnumNumberBody = function(e3) {
          const { explicitType: t3 } = e3;
          enumExplicitType(this, "number", t3), enumBody(this, e3);
        }, t2.EnumNumberMember = function(e3) {
          enumInitializedMember(this, e3);
        }, t2.EnumStringBody = function(e3) {
          const { explicitType: t3 } = e3;
          enumExplicitType(this, "string", t3), enumBody(this, e3);
        }, t2.EnumStringMember = function(e3) {
          enumInitializedMember(this, e3);
        }, t2.EnumSymbolBody = function(e3) {
          enumExplicitType(this, "symbol", true), enumBody(this, e3);
        }, t2.ExistsTypeAnnotation = function() {
          this.tokenChar(42);
        }, t2.FunctionTypeAnnotation = function(e3, t3) {
          this.print(e3.typeParameters), this.tokenChar(40), e3.this && (this.word("this"), this.tokenChar(58), this.space(), this.print(e3.this.typeAnnotation), (e3.params.length || e3.rest) && (this.tokenChar(44), this.space()));
          this.printList(e3.params), e3.rest && (e3.params.length && (this.tokenChar(44), this.space()), this.token("..."), this.print(e3.rest));
          this.tokenChar(41);
          const r3 = null == t3 ? void 0 : t3.type;
          null != r3 && ("ObjectTypeCallProperty" === r3 || "ObjectTypeInternalSlot" === r3 || "DeclareFunction" === r3 || "ObjectTypeProperty" === r3 && t3.method) ? this.tokenChar(58) : (this.space(), this.token("=>"));
          this.space(), this.print(e3.returnType);
        }, t2.FunctionTypeParam = function(e3) {
          this.print(e3.name), e3.optional && this.tokenChar(63);
          e3.name && (this.tokenChar(58), this.space());
          this.print(e3.typeAnnotation);
        }, t2.IndexedAccessType = function(e3) {
          this.print(e3.objectType, true), this.tokenChar(91), this.print(e3.indexType), this.tokenChar(93);
        }, t2.InferredPredicate = function() {
          this.tokenChar(37), this.word("checks");
        }, t2.InterfaceDeclaration = function(e3) {
          this.word("interface"), this.space(), this._interfaceish(e3);
        }, t2.GenericTypeAnnotation = t2.ClassImplements = t2.InterfaceExtends = function(e3) {
          this.print(e3.id), this.print(e3.typeParameters, true);
        }, t2.InterfaceTypeAnnotation = function(e3) {
          var t3;
          this.word("interface"), null != (t3 = e3.extends) && t3.length && (this.space(), this.word("extends"), this.space(), this.printList(e3.extends));
          this.space(), this.print(e3.body);
        }, t2.IntersectionTypeAnnotation = function(e3) {
          this.printJoin(e3.types, void 0, void 0, andSeparator);
        }, t2.MixedTypeAnnotation = function() {
          this.word("mixed");
        }, t2.NullLiteralTypeAnnotation = function() {
          this.word("null");
        }, t2.NullableTypeAnnotation = function(e3) {
          this.tokenChar(63), this.print(e3.typeAnnotation);
        }, Object.defineProperty(t2, "NumberLiteralTypeAnnotation", { enumerable: true, get: function() {
          return o.NumericLiteral;
        } }), t2.NumberTypeAnnotation = function() {
          this.word("number");
        }, t2.ObjectTypeAnnotation = function(e3) {
          e3.exact ? this.token("{|") : this.tokenChar(123);
          const t3 = [...e3.properties, ...e3.callProperties || [], ...e3.indexers || [], ...e3.internalSlots || []];
          t3.length && (this.newline(), this.space(), this.printJoin(t3, true, true, void 0, void 0, function(e4) {
            if (e4 && !t3[0]) return 1;
          }, () => {
            (1 !== t3.length || e3.inexact) && (this.tokenChar(44), this.space());
          }), this.space());
          e3.inexact && (this.indent(), this.token("..."), t3.length && this.newline(), this.dedent());
          e3.exact ? this.token("|}") : this.tokenChar(125);
        }, t2.ObjectTypeCallProperty = function(e3) {
          e3.static && (this.word("static"), this.space());
          this.print(e3.value);
        }, t2.ObjectTypeIndexer = function(e3) {
          e3.static && (this.word("static"), this.space());
          this._variance(e3), this.tokenChar(91), e3.id && (this.print(e3.id), this.tokenChar(58), this.space());
          this.print(e3.key), this.tokenChar(93), this.tokenChar(58), this.space(), this.print(e3.value);
        }, t2.ObjectTypeInternalSlot = function(e3) {
          e3.static && (this.word("static"), this.space());
          this.tokenChar(91), this.tokenChar(91), this.print(e3.id), this.tokenChar(93), this.tokenChar(93), e3.optional && this.tokenChar(63);
          e3.method || (this.tokenChar(58), this.space());
          this.print(e3.value);
        }, t2.ObjectTypeProperty = function(e3) {
          e3.proto && (this.word("proto"), this.space());
          e3.static && (this.word("static"), this.space());
          "get" !== e3.kind && "set" !== e3.kind || (this.word(e3.kind), this.space());
          this._variance(e3), this.print(e3.key), e3.optional && this.tokenChar(63);
          e3.method || (this.tokenChar(58), this.space());
          this.print(e3.value);
        }, t2.ObjectTypeSpreadProperty = function(e3) {
          this.token("..."), this.print(e3.argument);
        }, t2.OpaqueType = function(e3) {
          this.word("opaque"), this.space(), this.word("type"), this.space(), this.print(e3.id), this.print(e3.typeParameters), e3.supertype && (this.tokenChar(58), this.space(), this.print(e3.supertype));
          e3.impltype && (this.space(), this.tokenChar(61), this.space(), this.print(e3.impltype));
          this.semicolon();
        }, t2.OptionalIndexedAccessType = function(e3) {
          this.print(e3.objectType), e3.optional && this.token("?.");
          this.tokenChar(91), this.print(e3.indexType), this.tokenChar(93);
        }, t2.QualifiedTypeIdentifier = function(e3) {
          this.print(e3.qualification), this.tokenChar(46), this.print(e3.id);
        }, Object.defineProperty(t2, "StringLiteralTypeAnnotation", { enumerable: true, get: function() {
          return o.StringLiteral;
        } }), t2.StringTypeAnnotation = function() {
          this.word("string");
        }, t2.SymbolTypeAnnotation = function() {
          this.word("symbol");
        }, t2.ThisTypeAnnotation = function() {
          this.word("this");
        }, t2.TupleTypeAnnotation = function(e3) {
          this.tokenChar(91), this.printList(e3.types), this.tokenChar(93);
        }, t2.TypeAlias = function(e3) {
          this.word("type"), this.space(), this.print(e3.id), this.print(e3.typeParameters), this.space(), this.tokenChar(61), this.space(), this.print(e3.right), this.semicolon();
        }, t2.TypeAnnotation = function(e3, t3) {
          this.tokenChar(58), this.space(), "ArrowFunctionExpression" === t3.type ? this.tokenContext |= i.TokenContext.arrowFlowReturnType : e3.optional && this.tokenChar(63);
          this.print(e3.typeAnnotation);
        }, t2.TypeCastExpression = function(e3) {
          this.tokenChar(40), this.print(e3.expression), this.print(e3.typeAnnotation), this.tokenChar(41);
        }, t2.TypeParameter = function(e3) {
          this._variance(e3), this.word(e3.name), e3.bound && this.print(e3.bound);
          e3.default && (this.space(), this.tokenChar(61), this.space(), this.print(e3.default));
        }, t2.TypeParameterDeclaration = t2.TypeParameterInstantiation = function(e3) {
          this.tokenChar(60), this.printList(e3.params), this.tokenChar(62);
        }, t2.TypeofTypeAnnotation = function(e3) {
          this.word("typeof"), this.space(), this.print(e3.argument);
        }, t2.UnionTypeAnnotation = function(e3) {
          this.printJoin(e3.types, void 0, void 0, orSeparator);
        }, t2.Variance = function(e3) {
          "plus" === e3.kind ? this.tokenChar(43) : this.tokenChar(45);
        }, t2.VoidTypeAnnotation = function() {
          this.word("void");
        }, t2._interfaceish = function(e3) {
          var t3;
          this.print(e3.id), this.print(e3.typeParameters), null != (t3 = e3.extends) && t3.length && (this.space(), this.word("extends"), this.space(), this.printList(e3.extends));
          if ("DeclareClass" === e3.type) {
            var r3, n2;
            null != (r3 = e3.mixins) && r3.length && (this.space(), this.word("mixins"), this.space(), this.printList(e3.mixins)), null != (n2 = e3.implements) && n2.length && (this.space(), this.word("implements"), this.space(), this.printList(e3.implements));
          }
          this.space(), this.print(e3.body);
        }, t2._variance = function(e3) {
          var t3;
          const r3 = null == (t3 = e3.variance) ? void 0 : t3.kind;
          null != r3 && ("plus" === r3 ? this.tokenChar(43) : "minus" === r3 && this.tokenChar(45));
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/index.js"), s = r2("./node_modules/.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/lib/generators/modules.js"), i = r2("./node_modules/.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/lib/node/index.js"), o = r2("./node_modules/.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/lib/generators/types.js");
        const { isDeclareExportDeclaration: a, isStatement: l } = n;
        function enumExplicitType(e3, t3, r3) {
          r3 && (e3.space(), e3.word("of"), e3.space(), e3.word(t3)), e3.space();
        }
        function enumBody(e3, t3) {
          const { members: r3 } = t3;
          e3.token("{"), e3.indent(), e3.newline();
          for (const t4 of r3) e3.print(t4), e3.newline();
          t3.hasUnknownMembers && (e3.token("..."), e3.newline()), e3.dedent(), e3.token("}");
        }
        function enumInitializedMember(e3, t3) {
          e3.print(t3.id), e3.space(), e3.token("="), e3.space(), e3.print(t3.init), e3.token(",");
        }
        function FlowExportDeclaration(e3) {
          if (e3.declaration) {
            const t3 = e3.declaration;
            this.print(t3), l(t3) || this.semicolon();
          } else this.tokenChar(123), e3.specifiers.length && (this.space(), this.printList(e3.specifiers), this.space()), this.tokenChar(125), e3.source && (this.space(), this.word("from"), this.space(), this.print(e3.source)), this.semicolon();
        }
        function andSeparator(e3) {
          this.space(), this.token("&", false, e3), this.space();
        }
        function orSeparator(e3) {
          this.space(), this.token("|", false, e3), this.space();
        }
      }, "./node_modules/.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/lib/generators/index.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true });
        var n = r2("./node_modules/.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/lib/generators/template-literals.js");
        Object.keys(n).forEach(function(e3) {
          "default" !== e3 && "__esModule" !== e3 && (e3 in t2 && t2[e3] === n[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
            return n[e3];
          } }));
        });
        var s = r2("./node_modules/.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/lib/generators/expressions.js");
        Object.keys(s).forEach(function(e3) {
          "default" !== e3 && "__esModule" !== e3 && (e3 in t2 && t2[e3] === s[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
            return s[e3];
          } }));
        });
        var i = r2("./node_modules/.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/lib/generators/statements.js");
        Object.keys(i).forEach(function(e3) {
          "default" !== e3 && "__esModule" !== e3 && (e3 in t2 && t2[e3] === i[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
            return i[e3];
          } }));
        });
        var o = r2("./node_modules/.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/lib/generators/classes.js");
        Object.keys(o).forEach(function(e3) {
          "default" !== e3 && "__esModule" !== e3 && (e3 in t2 && t2[e3] === o[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
            return o[e3];
          } }));
        });
        var a = r2("./node_modules/.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/lib/generators/methods.js");
        Object.keys(a).forEach(function(e3) {
          "default" !== e3 && "__esModule" !== e3 && (e3 in t2 && t2[e3] === a[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
            return a[e3];
          } }));
        });
        var l = r2("./node_modules/.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/lib/generators/modules.js");
        Object.keys(l).forEach(function(e3) {
          "default" !== e3 && "__esModule" !== e3 && (e3 in t2 && t2[e3] === l[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
            return l[e3];
          } }));
        });
        var p = r2("./node_modules/.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/lib/generators/types.js");
        Object.keys(p).forEach(function(e3) {
          "default" !== e3 && "__esModule" !== e3 && (e3 in t2 && t2[e3] === p[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
            return p[e3];
          } }));
        });
        var c = r2("./node_modules/.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/lib/generators/flow.js");
        Object.keys(c).forEach(function(e3) {
          "default" !== e3 && "__esModule" !== e3 && (e3 in t2 && t2[e3] === c[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
            return c[e3];
          } }));
        });
        var u = r2("./node_modules/.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/lib/generators/base.js");
        Object.keys(u).forEach(function(e3) {
          "default" !== e3 && "__esModule" !== e3 && (e3 in t2 && t2[e3] === u[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
            return u[e3];
          } }));
        });
        var d = r2("./node_modules/.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/lib/generators/jsx.js");
        Object.keys(d).forEach(function(e3) {
          "default" !== e3 && "__esModule" !== e3 && (e3 in t2 && t2[e3] === d[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
            return d[e3];
          } }));
        });
        var h = r2("./node_modules/.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/lib/generators/typescript.js");
        Object.keys(h).forEach(function(e3) {
          "default" !== e3 && "__esModule" !== e3 && (e3 in t2 && t2[e3] === h[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
            return h[e3];
          } }));
        });
      }, "./node_modules/.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/lib/generators/jsx.js": function(e2, t2) {
        "use strict";
        function spaceSeparator() {
          this.space();
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.JSXAttribute = function(e3) {
          this.print(e3.name), e3.value && (this.tokenChar(61), this.print(e3.value));
        }, t2.JSXClosingElement = function(e3) {
          this.tokenChar(60), this.tokenChar(47), this.print(e3.name), this.tokenChar(62);
        }, t2.JSXClosingFragment = function() {
          this.token("</"), this.tokenChar(62);
        }, t2.JSXElement = function(e3) {
          const t3 = e3.openingElement;
          if (this.print(t3), t3.selfClosing) return;
          this.indent();
          for (const t4 of e3.children) this.print(t4);
          this.dedent(), this.print(e3.closingElement);
        }, t2.JSXEmptyExpression = function() {
          this.printInnerComments();
        }, t2.JSXExpressionContainer = function(e3) {
          this.tokenChar(123), this.print(e3.expression), this.rightBrace(e3);
        }, t2.JSXFragment = function(e3) {
          this.print(e3.openingFragment), this.indent();
          for (const t3 of e3.children) this.print(t3);
          this.dedent(), this.print(e3.closingFragment);
        }, t2.JSXIdentifier = function(e3) {
          this.word(e3.name);
        }, t2.JSXMemberExpression = function(e3) {
          this.print(e3.object), this.tokenChar(46), this.print(e3.property);
        }, t2.JSXNamespacedName = function(e3) {
          this.print(e3.namespace), this.tokenChar(58), this.print(e3.name);
        }, t2.JSXOpeningElement = function(e3) {
          this.tokenChar(60), this.print(e3.name), e3.typeArguments && this.print(e3.typeArguments);
          this.print(e3.typeParameters), e3.attributes.length > 0 && (this.space(), this.printJoin(e3.attributes, void 0, void 0, spaceSeparator));
          e3.selfClosing && (this.space(), this.tokenChar(47));
          this.tokenChar(62);
        }, t2.JSXOpeningFragment = function() {
          this.tokenChar(60), this.tokenChar(62);
        }, t2.JSXSpreadAttribute = function(e3) {
          this.tokenChar(123), this.token("..."), this.print(e3.argument), this.rightBrace(e3);
        }, t2.JSXSpreadChild = function(e3) {
          this.tokenChar(123), this.token("..."), this.print(e3.expression), this.rightBrace(e3);
        }, t2.JSXText = function(e3) {
          const t3 = this.getPossibleRaw(e3);
          void 0 !== t3 ? this.token(t3, true) : this.token(e3.value, true);
        };
      }, "./node_modules/.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/lib/generators/methods.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.ArrowFunctionExpression = function(e3, t3) {
          e3.async && (this.word("async", true), this.space());
          this._shouldPrintArrowParamsParens(e3) ? this._params(e3, void 0, t3) : this.print(e3.params[0], true);
          this._predicate(e3, true), this.space(), this.printInnerComments(), this.token("=>"), this.space(), this.tokenContext |= s.TokenContext.arrowBody, this.print(e3.body);
        }, t2.FunctionDeclaration = t2.FunctionExpression = function(e3, t3) {
          this._functionHead(e3, t3), this.space(), this.print(e3.body);
        }, t2._functionHead = function(e3, t3) {
          e3.async && (this.word("async"), this.format.preserveFormat || (this._endsWithInnerRaw = false), this.space());
          this.word("function"), e3.generator && (this.format.preserveFormat || (this._endsWithInnerRaw = false), this.tokenChar(42));
          this.space(), e3.id && this.print(e3.id);
          this._params(e3, e3.id, t3), "TSDeclareFunction" !== e3.type && this._predicate(e3);
        }, t2._methodHead = function(e3) {
          const t3 = e3.kind, r3 = e3.key;
          "get" !== t3 && "set" !== t3 || (this.word(t3), this.space());
          e3.async && (this.word("async", true), this.space());
          "method" !== t3 && "init" !== t3 || e3.generator && this.tokenChar(42);
          e3.computed ? (this.tokenChar(91), this.print(r3), this.tokenChar(93)) : this.print(r3);
          e3.optional && this.tokenChar(63);
          this._params(e3, e3.computed && "StringLiteral" !== e3.key.type ? void 0 : e3.key, void 0);
        }, t2._param = function(e3) {
          this.printJoin(e3.decorators), this.print(e3), e3.optional && this.tokenChar(63);
          this.print(e3.typeAnnotation);
        }, t2._parameters = function(e3, t3) {
          const r3 = this.enterDelimited(), n2 = this.shouldPrintTrailingComma(t3), s2 = e3.length;
          for (let t4 = 0; t4 < s2; t4++) this._param(e3[t4]), (n2 || t4 < s2 - 1) && (this.token(",", null, t4), this.space());
          this.token(t3), r3();
        }, t2._params = function(e3, t3, r3) {
          this.print(e3.typeParameters);
          const n2 = _getFuncIdName.call(this, t3, r3);
          n2 && this.sourceIdentifierName(n2.name, n2.pos);
          this.tokenChar(40), this._parameters(e3.params, ")");
          const s2 = "ArrowFunctionExpression" === e3.type;
          this.print(e3.returnType, s2), this._noLineTerminator = s2;
        }, t2._predicate = function(e3, t3) {
          e3.predicate && (e3.returnType || this.tokenChar(58), this.space(), this.print(e3.predicate, t3));
        }, t2._shouldPrintArrowParamsParens = function(e3) {
          var t3, r3;
          if (1 !== e3.params.length) return true;
          if (e3.typeParameters || e3.returnType || e3.predicate) return true;
          const n2 = e3.params[0];
          if (!i(n2) || n2.typeAnnotation || n2.optional || null != (t3 = n2.leadingComments) && t3.length || null != (r3 = n2.trailingComments) && r3.length) return true;
          if (this.tokenMap) {
            if (null == e3.loc) return true;
            if (null !== this.tokenMap.findMatching(e3, "(")) return true;
            const t4 = this.tokenMap.findMatching(e3, "=>");
            return null == (null == t4 ? void 0 : t4.loc) || t4.loc.start.line !== e3.loc.start.line;
          }
          return !!this.format.retainLines;
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/index.js"), s = r2("./node_modules/.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/lib/node/index.js");
        const { isIdentifier: i } = n;
        function _getFuncIdName(e3, t3) {
          let r3, n2 = e3;
          if (!n2 && t3) {
            const e4 = t3.type;
            "VariableDeclarator" === e4 ? n2 = t3.id : "AssignmentExpression" === e4 || "AssignmentPattern" === e4 ? n2 = t3.left : "ObjectProperty" === e4 || "ClassProperty" === e4 ? t3.computed && "StringLiteral" !== t3.key.type || (n2 = t3.key) : "ClassPrivateProperty" !== e4 && "ClassAccessorProperty" !== e4 || (n2 = t3.key);
          }
          if (n2) {
            var s2, i2;
            if ("Identifier" === n2.type) r3 = { pos: null == (s2 = n2.loc) ? void 0 : s2.start, name: (null == (i2 = n2.loc) ? void 0 : i2.identifierName) || n2.name };
            else if ("PrivateName" === n2.type) {
              var o;
              r3 = { pos: null == (o = n2.loc) ? void 0 : o.start, name: "#" + n2.id.name };
            } else if ("StringLiteral" === n2.type) {
              var a;
              r3 = { pos: null == (a = n2.loc) ? void 0 : a.start, name: n2.value };
            }
            return r3;
          }
        }
      }, "./node_modules/.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/lib/generators/modules.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.ExportAllDeclaration = function(e3) {
          var t3, r3;
          this.word("export"), this.space(), "type" === e3.exportKind && (this.word("type"), this.space());
          this.tokenChar(42), this.space(), this.word("from"), this.space(), null != (t3 = e3.attributes) && t3.length || null != (r3 = e3.assertions) && r3.length ? (this.print(e3.source, true), this.space(), this._printAttributes(e3, false)) : this.print(e3.source);
          this.semicolon();
        }, t2.ExportDefaultDeclaration = function(e3) {
          maybePrintDecoratorsBeforeExport(this, e3), this.word("export"), this.noIndentInnerCommentsHere(), this.space(), this.word("default"), this.space(), this.tokenContext |= s.TokenContext.exportDefault;
          const t3 = e3.declaration;
          this.print(t3), c(t3) || this.semicolon();
        }, t2.ExportDefaultSpecifier = function(e3) {
          this.print(e3.exported);
        }, t2.ExportNamedDeclaration = function(e3) {
          if (maybePrintDecoratorsBeforeExport(this, e3), this.word("export"), this.space(), e3.declaration) {
            const t4 = e3.declaration;
            this.print(t4), c(t4) || this.semicolon();
          } else {
            "type" === e3.exportKind && (this.word("type"), this.space());
            const n2 = e3.specifiers.slice(0);
            let s2 = false;
            for (; ; ) {
              const e4 = n2[0];
              if (!o(e4) && !a(e4)) break;
              s2 = true, this.print(n2.shift()), n2.length && (this.tokenChar(44), this.space());
            }
            let i2 = false;
            var t3, r3;
            if ((n2.length || !n2.length && !s2) && (i2 = true, this.tokenChar(123), n2.length && (this.space(), this.printList(n2, this.shouldPrintTrailingComma("}")), this.space()), this.tokenChar(125)), e3.source) this.space(), this.word("from"), this.space(), null != (t3 = e3.attributes) && t3.length || null != (r3 = e3.assertions) && r3.length ? (this.print(e3.source, true), this.space(), this._printAttributes(e3, i2)) : this.print(e3.source);
            this.semicolon();
          }
        }, t2.ExportNamespaceSpecifier = function(e3) {
          this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(e3.exported);
        }, t2.ExportSpecifier = function(e3) {
          "type" === e3.exportKind && (this.word("type"), this.space());
          this.print(e3.local), e3.exported && e3.local.name !== e3.exported.name && (this.space(), this.word("as"), this.space(), this.print(e3.exported));
        }, t2.ImportAttribute = function(e3) {
          this.print(e3.key), this.tokenChar(58), this.space(), this.print(e3.value);
        }, t2.ImportDeclaration = function(e3) {
          var t3, r3;
          this.word("import"), this.space();
          const n2 = "type" === e3.importKind || "typeof" === e3.importKind;
          n2 ? (this.noIndentInnerCommentsHere(), this.word(e3.importKind), this.space()) : e3.module ? (this.noIndentInnerCommentsHere(), this.word("module"), this.space()) : e3.phase && (this.noIndentInnerCommentsHere(), this.word(e3.phase), this.space());
          const s2 = e3.specifiers.slice(0), i2 = !!s2.length;
          for (; i2; ) {
            const e4 = s2[0];
            if (!l(e4) && !p(e4)) break;
            this.print(s2.shift()), s2.length && (this.tokenChar(44), this.space());
          }
          let o2 = false;
          s2.length ? (o2 = true, this.tokenChar(123), this.space(), this.printList(s2, this.shouldPrintTrailingComma("}")), this.space(), this.tokenChar(125)) : n2 && !i2 && (o2 = true, this.tokenChar(123), this.tokenChar(125));
          (i2 || n2) && (this.space(), this.word("from"), this.space());
          null != (t3 = e3.attributes) && t3.length || null != (r3 = e3.assertions) && r3.length ? (this.print(e3.source, true), this.space(), this._printAttributes(e3, o2)) : this.print(e3.source);
          this.semicolon();
        }, t2.ImportDefaultSpecifier = function(e3) {
          this.print(e3.local);
        }, t2.ImportExpression = function(e3) {
          this.word("import"), e3.phase && (this.tokenChar(46), this.word(e3.phase));
          this.tokenChar(40);
          const t3 = this.shouldPrintTrailingComma(")");
          this.print(e3.source), null != e3.options && (this.tokenChar(44), this.space(), this.print(e3.options));
          t3 && this.tokenChar(44);
          this.rightParens(e3);
        }, t2.ImportNamespaceSpecifier = function(e3) {
          this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(e3.local);
        }, t2.ImportSpecifier = function(e3) {
          "type" !== e3.importKind && "typeof" !== e3.importKind || (this.word(e3.importKind), this.space());
          this.print(e3.imported), e3.local && e3.local.name !== e3.imported.name && (this.space(), this.word("as"), this.space(), this.print(e3.local));
        }, t2._printAttributes = function(e3, t3) {
          var r3;
          const { importAttributesKeyword: n2 } = this.format, { attributes: s2, assertions: i2 } = e3;
          s2 && !n2 && e3.extra && (e3.extra.deprecatedAssertSyntax || e3.extra.deprecatedWithLegacySyntax) && !u && (u = true, console.warn('You are using import attributes, without specifying the desired output syntax.\nPlease specify the "importAttributesKeyword" generator option, whose value can be one of:\n - "with"        : `import { a } from "b" with { type: "json" };`\n - "assert"      : `import { a } from "b" assert { type: "json" };`\n - "with-legacy" : `import { a } from "b" with type: "json";`\n'));
          const o2 = "assert" === n2 || !n2 && i2;
          if (this.word(o2 ? "assert" : "with"), this.space(), !o2 && ("with-legacy" === n2 || !n2 && null != (r3 = e3.extra) && r3.deprecatedWithLegacySyntax)) return void this.printList(s2 || i2);
          const a2 = t3 ? 1 : 0;
          this.token("{", null, a2), this.space(), this.printList(s2 || i2, this.shouldPrintTrailingComma("}")), this.space(), this.token("}", null, a2);
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/index.js"), s = r2("./node_modules/.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/lib/node/index.js");
        const { isClassDeclaration: i, isExportDefaultSpecifier: o, isExportNamespaceSpecifier: a, isImportDefaultSpecifier: l, isImportNamespaceSpecifier: p, isStatement: c } = n;
        let u = false;
        function maybePrintDecoratorsBeforeExport(e3, t3) {
          i(t3.declaration) && e3._shouldPrintDecoratorsBeforeExport(t3) && e3.printJoin(t3.declaration.decorators);
        }
      }, "./node_modules/.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/lib/generators/statements.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.BreakStatement = function(e3) {
          this.word("break"), printStatementAfterKeyword(this, e3.label);
        }, t2.CatchClause = function(e3) {
          this.word("catch"), this.space(), e3.param && (this.tokenChar(40), this.print(e3.param), this.print(e3.param.typeAnnotation), this.tokenChar(41), this.space());
          this.print(e3.body);
        }, t2.ContinueStatement = function(e3) {
          this.word("continue"), printStatementAfterKeyword(this, e3.label);
        }, t2.DebuggerStatement = function() {
          this.word("debugger"), this.semicolon();
        }, t2.DoWhileStatement = function(e3) {
          this.word("do"), this.space(), this.print(e3.body), this.space(), this.word("while"), this.space(), this.tokenChar(40), this.print(e3.test), this.tokenChar(41), this.semicolon();
        }, t2.ForOfStatement = t2.ForInStatement = void 0, t2.ForStatement = function(e3) {
          this.word("for"), this.space(), this.tokenChar(40);
          {
            const t3 = this.enterForStatementInit();
            this.print(e3.init), t3();
          }
          this.tokenChar(59), e3.test && (this.space(), this.print(e3.test));
          this.token(";", false, 1), e3.update && (this.space(), this.print(e3.update));
          this.tokenChar(41), this.printBlock(e3);
        }, t2.IfStatement = function(e3) {
          this.word("if"), this.space(), this.tokenChar(40), this.print(e3.test), this.tokenChar(41), this.space();
          const t3 = e3.alternate && o(getLastStatement(e3.consequent));
          t3 && (this.tokenChar(123), this.newline(), this.indent());
          this.printAndIndentOnComments(e3.consequent), t3 && (this.dedent(), this.newline(), this.tokenChar(125));
          e3.alternate && (this.endsWith(125) && this.space(), this.word("else"), this.space(), this.printAndIndentOnComments(e3.alternate));
        }, t2.LabeledStatement = function(e3) {
          this.print(e3.label), this.tokenChar(58), this.space(), this.print(e3.body);
        }, t2.ReturnStatement = function(e3) {
          this.word("return"), printStatementAfterKeyword(this, e3.argument);
        }, t2.SwitchCase = function(e3) {
          e3.test ? (this.word("case"), this.space(), this.print(e3.test), this.tokenChar(58)) : (this.word("default"), this.tokenChar(58));
          e3.consequent.length && (this.newline(), this.printSequence(e3.consequent, true));
        }, t2.SwitchStatement = function(e3) {
          this.word("switch"), this.space(), this.tokenChar(40), this.print(e3.discriminant), this.tokenChar(41), this.space(), this.tokenChar(123), this.printSequence(e3.cases, true, void 0, function(t3, r3) {
            if (!t3 && e3.cases[e3.cases.length - 1] === r3) return -1;
          }), this.rightBrace(e3);
        }, t2.ThrowStatement = function(e3) {
          this.word("throw"), printStatementAfterKeyword(this, e3.argument);
        }, t2.TryStatement = function(e3) {
          this.word("try"), this.space(), this.print(e3.block), this.space(), e3.handlers ? this.print(e3.handlers[0]) : this.print(e3.handler);
          e3.finalizer && (this.space(), this.word("finally"), this.space(), this.print(e3.finalizer));
        }, t2.VariableDeclaration = function(e3, t3) {
          e3.declare && (this.word("declare"), this.space());
          const { kind: r3 } = e3;
          "await using" === r3 ? (this.word("await"), this.space(), this.word("using", true)) : this.word(r3, "using" === r3);
          this.space();
          let n2 = false;
          if (!s(t3)) for (const t4 of e3.declarations) t4.init && (n2 = true);
          if (this.printList(e3.declarations, void 0, void 0, e3.declarations.length > 1, n2 ? function(e4) {
            this.token(",", false, e4), this.newline();
          } : void 0), s(t3)) {
            if (i(t3)) {
              if (t3.init === e3) return;
            } else if (t3.left === e3) return;
          }
          this.semicolon();
        }, t2.VariableDeclarator = function(e3) {
          this.print(e3.id), e3.definite && this.tokenChar(33);
          this.print(e3.id.typeAnnotation), e3.init && (this.space(), this.tokenChar(61), this.space(), this.print(e3.init));
        }, t2.WhileStatement = function(e3) {
          this.word("while"), this.space(), this.tokenChar(40), this.print(e3.test), this.tokenChar(41), this.printBlock(e3);
        }, t2.WithStatement = function(e3) {
          this.word("with"), this.space(), this.tokenChar(40), this.print(e3.object), this.tokenChar(41), this.printBlock(e3);
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/index.js");
        const { isFor: s, isForStatement: i, isIfStatement: o, isStatement: a } = n;
        function getLastStatement(e3) {
          const { body: t3 } = e3;
          return false === a(t3) ? e3 : getLastStatement(t3);
        }
        function ForXStatement(e3) {
          this.word("for"), this.space();
          const t3 = "ForOfStatement" === e3.type;
          t3 && e3.await && (this.word("await"), this.space()), this.noIndentInnerCommentsHere(), this.tokenChar(40);
          {
            const r3 = this.enterForXStatementInit(t3);
            this.print(e3.left), null == r3 || r3();
          }
          this.space(), this.word(t3 ? "of" : "in"), this.space(), this.print(e3.right), this.tokenChar(41), this.printBlock(e3);
        }
        t2.ForInStatement = ForXStatement, t2.ForOfStatement = ForXStatement;
        function printStatementAfterKeyword(e3, t3) {
          t3 && (e3.space(), e3.printTerminatorless(t3)), e3.semicolon();
        }
      }, "./node_modules/.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/lib/generators/template-literals.js": function(e2, t2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.TaggedTemplateExpression = function(e3) {
          this.print(e3.tag), this.print(e3.typeParameters), this.print(e3.quasi);
        }, t2.TemplateElement = function() {
          throw new Error("TemplateElement printing is handled in TemplateLiteral");
        }, t2.TemplateLiteral = function(e3) {
          this._printTemplate(e3, e3.expressions);
        }, t2._printTemplate = function(e3, t3) {
          const r2 = e3.quasis;
          let n = "`";
          for (let s = 0; s < r2.length - 1; s++) if (n += r2[s].value.raw, this.token(n + "${", true), this.print(t3[s]), n = "}", this.tokenMap) {
            const t4 = this.tokenMap.findMatching(e3, "}", s);
            t4 && this._catchUpTo(t4.loc.start);
          }
          n += r2[r2.length - 1].value.raw, this.token(n + "`", true);
        };
      }, "./node_modules/.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/lib/generators/types.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.ArgumentPlaceholder = function() {
          this.tokenChar(63);
        }, t2.ArrayPattern = t2.ArrayExpression = function(e3) {
          const t3 = e3.elements, r3 = t3.length;
          this.tokenChar(91);
          const n2 = this.enterDelimited();
          for (let e4 = 0; e4 < t3.length; e4++) {
            const n3 = t3[e4];
            n3 ? (e4 > 0 && this.space(), this.print(n3), (e4 < r3 - 1 || this.shouldPrintTrailingComma("]")) && this.token(",", false, e4)) : this.token(",", false, e4);
          }
          n2(), this.tokenChar(93);
        }, t2.BigIntLiteral = function(e3) {
          const t3 = this.getPossibleRaw(e3);
          if (!this.format.minified && void 0 !== t3) return void this.word(t3);
          this.word(e3.value + "n");
        }, t2.BooleanLiteral = function(e3) {
          this.word(e3.value ? "true" : "false");
        }, t2.Identifier = function(e3) {
          var t3;
          this.sourceIdentifierName((null == (t3 = e3.loc) ? void 0 : t3.identifierName) || e3.name), this.word(this.tokenMap ? this._getRawIdentifier(e3) : e3.name);
        }, t2.NullLiteral = function() {
          this.word("null");
        }, t2.NumericLiteral = function(e3) {
          const t3 = this.getPossibleRaw(e3), r3 = this.format.jsescOption, n2 = e3.value, i2 = n2 + "";
          r3.numbers ? this.number(s(n2, r3), n2) : null == t3 ? this.number(i2, n2) : this.format.minified ? this.number(t3.length < i2.length ? t3 : i2, n2) : this.number(t3, n2);
        }, t2.ObjectPattern = t2.ObjectExpression = function(e3) {
          const t3 = e3.properties;
          if (this.tokenChar(123), t3.length) {
            const e4 = this.enterDelimited();
            this.space(), this.printList(t3, this.shouldPrintTrailingComma("}"), true, true), this.space(), e4();
          }
          this.sourceWithOffset("end", e3.loc, -1), this.tokenChar(125);
        }, t2.ObjectMethod = function(e3) {
          this.printJoin(e3.decorators), this._methodHead(e3), this.space(), this.print(e3.body);
        }, t2.ObjectProperty = function(e3) {
          if (this.printJoin(e3.decorators), e3.computed) this.tokenChar(91), this.print(e3.key), this.tokenChar(93);
          else {
            if (i(e3.value) && o(e3.key) && e3.key.name === e3.value.left.name) return void this.print(e3.value);
            if (this.print(e3.key), e3.shorthand && o(e3.key) && o(e3.value) && e3.key.name === e3.value.name) return;
          }
          this.tokenChar(58), this.space(), this.print(e3.value);
        }, t2.PipelineBareFunction = function(e3) {
          this.print(e3.callee);
        }, t2.PipelinePrimaryTopicReference = function() {
          this.tokenChar(35);
        }, t2.PipelineTopicExpression = function(e3) {
          this.print(e3.expression);
        }, t2.RecordExpression = function(e3) {
          const t3 = e3.properties;
          let r3, n2;
          if ("bar" === this.format.recordAndTupleSyntaxType) r3 = "{|", n2 = "|}";
          else {
            if ("hash" !== this.format.recordAndTupleSyntaxType && null != this.format.recordAndTupleSyntaxType) throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)} received).`);
            r3 = "#{", n2 = "}";
          }
          this.token(r3), t3.length && (this.space(), this.printList(t3, this.shouldPrintTrailingComma(n2), true, true), this.space());
          this.token(n2);
        }, t2.RegExpLiteral = function(e3) {
          this.word(`/${e3.pattern}/${e3.flags}`);
        }, t2.SpreadElement = t2.RestElement = function(e3) {
          this.token("..."), this.print(e3.argument);
        }, t2.StringLiteral = function(e3) {
          const t3 = this.getPossibleRaw(e3);
          if (!this.format.minified && void 0 !== t3) return void this.token(t3);
          const r3 = s(e3.value, this.format.jsescOption);
          this.token(r3);
        }, t2.TopicReference = function() {
          const { topicToken: e3 } = this.format;
          if (!p.has(e3)) {
            const t3 = JSON.stringify(e3), r3 = Array.from(p, (e4) => JSON.stringify(e4));
            throw new Error(`The "topicToken" generator option must be one of ${r3.join(", ")} (${t3} received instead).`);
          }
          this.token(e3);
        }, t2.TupleExpression = function(e3) {
          const t3 = e3.elements, r3 = t3.length;
          let n2, s2;
          if ("bar" === this.format.recordAndTupleSyntaxType) n2 = "[|", s2 = "|]";
          else {
            if ("hash" !== this.format.recordAndTupleSyntaxType) throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);
            n2 = "#[", s2 = "]";
          }
          this.token(n2);
          for (let e4 = 0; e4 < t3.length; e4++) {
            const n3 = t3[e4];
            n3 && (e4 > 0 && this.space(), this.print(n3), (e4 < r3 - 1 || this.shouldPrintTrailingComma(s2)) && this.token(",", false, e4));
          }
          this.token(s2);
        }, t2.VoidPattern = function() {
          this.word("void");
        }, t2._getRawIdentifier = function(e3) {
          if (e3 === a) return l;
          a = e3;
          const { name: t3 } = e3, r3 = this.tokenMap.find(e3, (e4) => e4.value === t3);
          if (r3) return l = this._originalCode.slice(r3.start, r3.end), l;
          return l = e3.name;
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/index.js"), s = r2("./node_modules/.pnpm/jsesc@3.1.0/node_modules/jsesc/jsesc.js");
        const { isAssignmentPattern: i, isIdentifier: o } = n;
        let a = null, l = "";
        const p = /* @__PURE__ */ new Set(["^^", "@@", "^", "%", "#"]);
      }, "./node_modules/.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/lib/generators/typescript.js": function(e2, t2) {
        "use strict";
        function maybePrintTrailingCommaOrSemicolon(e3, t3) {
          e3.tokenMap && t3.start && t3.end ? e3.tokenMap.endMatches(t3, ",") ? e3.token(",") : e3.tokenMap.endMatches(t3, ";") && e3.semicolon() : e3.semicolon();
        }
        function tsPrintUnionOrIntersectionType(e3, t3, r2) {
          var n;
          let s = 0;
          null != (n = e3.tokenMap) && n.startMatches(t3, r2) && (s = 1, e3.token(r2)), e3.printJoin(t3.types, void 0, void 0, function(e4) {
            this.space(), this.token(r2, null, e4 + s), this.space();
          });
        }
        function tokenIfPlusMinus(e3, t3) {
          true !== t3 && e3.token(t3);
        }
        function TSEnumBody(e3) {
          printBraced(this, e3, () => {
            var t3;
            return this.printList(e3.members, null == (t3 = this.shouldPrintTrailingComma("}")) || t3, true, true);
          });
        }
        function printBraced(e3, t3, r2) {
          e3.token("{");
          const n = e3.enterDelimited();
          r2(), n(), e3.rightBrace(t3);
        }
        function printModifiersList(e3, t3, r2) {
          var n;
          const s = /* @__PURE__ */ new Set();
          for (const e4 of r2) e4 && s.add(e4);
          null == (n = e3.tokenMap) || n.find(t3, (t4) => {
            if (s.has(t4.value)) return e3.token(t4.value), e3.space(), s.delete(t4.value), 0 === s.size;
          });
          for (const t4 of s) e3.word(t4), e3.space();
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.TSAnyKeyword = function() {
          this.word("any");
        }, t2.TSArrayType = function(e3) {
          this.print(e3.elementType, true), this.tokenChar(91), this.tokenChar(93);
        }, t2.TSSatisfiesExpression = t2.TSAsExpression = function(e3) {
          const { type: t3, expression: r2, typeAnnotation: n } = e3;
          this.print(r2, true), this.space(), this.word("TSAsExpression" === t3 ? "as" : "satisfies"), this.space(), this.print(n);
        }, t2.TSBigIntKeyword = function() {
          this.word("bigint");
        }, t2.TSBooleanKeyword = function() {
          this.word("boolean");
        }, t2.TSCallSignatureDeclaration = function(e3) {
          this.tsPrintSignatureDeclarationBase(e3), maybePrintTrailingCommaOrSemicolon(this, e3);
        }, t2.TSInterfaceHeritage = t2.TSClassImplements = function(e3) {
          this.print(e3.expression), this.print(e3.typeArguments);
        }, t2.TSConditionalType = function(e3) {
          this.print(e3.checkType), this.space(), this.word("extends"), this.space(), this.print(e3.extendsType), this.space(), this.tokenChar(63), this.space(), this.print(e3.trueType), this.space(), this.tokenChar(58), this.space(), this.print(e3.falseType);
        }, t2.TSConstructSignatureDeclaration = function(e3) {
          this.word("new"), this.space(), this.tsPrintSignatureDeclarationBase(e3), maybePrintTrailingCommaOrSemicolon(this, e3);
        }, t2.TSConstructorType = function(e3) {
          e3.abstract && (this.word("abstract"), this.space());
          this.word("new"), this.space(), this.tsPrintFunctionOrConstructorType(e3);
        }, t2.TSDeclareFunction = function(e3, t3) {
          e3.declare && (this.word("declare"), this.space());
          this._functionHead(e3, t3), this.semicolon();
        }, t2.TSDeclareMethod = function(e3) {
          this._classMethodHead(e3), this.semicolon();
        }, t2.TSEnumBody = TSEnumBody, t2.TSEnumDeclaration = function(e3) {
          const { declare: t3, const: r2, id: n } = e3;
          t3 && (this.word("declare"), this.space());
          r2 && (this.word("const"), this.space());
          this.word("enum"), this.space(), this.print(n), this.space(), TSEnumBody.call(this, e3);
        }, t2.TSEnumMember = function(e3) {
          const { id: t3, initializer: r2 } = e3;
          this.print(t3), r2 && (this.space(), this.tokenChar(61), this.space(), this.print(r2));
        }, t2.TSExportAssignment = function(e3) {
          this.word("export"), this.space(), this.tokenChar(61), this.space(), this.print(e3.expression), this.semicolon();
        }, t2.TSExternalModuleReference = function(e3) {
          this.token("require("), this.print(e3.expression), this.tokenChar(41);
        }, t2.TSFunctionType = function(e3) {
          this.tsPrintFunctionOrConstructorType(e3);
        }, t2.TSImportEqualsDeclaration = function(e3) {
          const { id: t3, moduleReference: r2 } = e3;
          e3.isExport && (this.word("export"), this.space());
          this.word("import"), this.space(), this.print(t3), this.space(), this.tokenChar(61), this.space(), this.print(r2), this.semicolon();
        }, t2.TSImportType = function(e3) {
          const { argument: t3, qualifier: r2, options: n } = e3;
          this.word("import"), this.tokenChar(40), this.print(t3), n && (this.tokenChar(44), this.print(n));
          this.tokenChar(41), r2 && (this.tokenChar(46), this.print(r2));
          const s = e3.typeParameters;
          s && this.print(s);
        }, t2.TSIndexSignature = function(e3) {
          const { readonly: t3, static: r2 } = e3;
          r2 && (this.word("static"), this.space());
          t3 && (this.word("readonly"), this.space());
          this.tokenChar(91), this._parameters(e3.parameters, "]"), this.print(e3.typeAnnotation), maybePrintTrailingCommaOrSemicolon(this, e3);
        }, t2.TSIndexedAccessType = function(e3) {
          this.print(e3.objectType, true), this.tokenChar(91), this.print(e3.indexType), this.tokenChar(93);
        }, t2.TSInferType = function(e3) {
          this.word("infer"), this.print(e3.typeParameter);
        }, t2.TSInstantiationExpression = function(e3) {
          this.print(e3.expression), this.print(e3.typeParameters);
        }, t2.TSInterfaceBody = function(e3) {
          printBraced(this, e3, () => this.printJoin(e3.body, true, true));
        }, t2.TSInterfaceDeclaration = function(e3) {
          const { declare: t3, id: r2, typeParameters: n, extends: s, body: i } = e3;
          t3 && (this.word("declare"), this.space());
          this.word("interface"), this.space(), this.print(r2), this.print(n), null != s && s.length && (this.space(), this.word("extends"), this.space(), this.printList(s));
          this.space(), this.print(i);
        }, t2.TSIntersectionType = function(e3) {
          tsPrintUnionOrIntersectionType(this, e3, "&");
        }, t2.TSIntrinsicKeyword = function() {
          this.word("intrinsic");
        }, t2.TSLiteralType = function(e3) {
          this.print(e3.literal);
        }, t2.TSMappedType = function(e3) {
          const { nameType: t3, optional: r2, readonly: n, typeAnnotation: s } = e3;
          this.tokenChar(123);
          const i = this.enterDelimited();
          this.space(), n && (tokenIfPlusMinus(this, n), this.word("readonly"), this.space());
          this.tokenChar(91), this.word(e3.typeParameter.name), this.space(), this.word("in"), this.space(), this.print(e3.typeParameter.constraint), t3 && (this.space(), this.word("as"), this.space(), this.print(t3));
          this.tokenChar(93), r2 && (tokenIfPlusMinus(this, r2), this.tokenChar(63));
          s && (this.tokenChar(58), this.space(), this.print(s));
          this.space(), i(), this.tokenChar(125);
        }, t2.TSMethodSignature = function(e3) {
          const { kind: t3 } = e3;
          "set" !== t3 && "get" !== t3 || (this.word(t3), this.space());
          this.tsPrintPropertyOrMethodName(e3), this.tsPrintSignatureDeclarationBase(e3), maybePrintTrailingCommaOrSemicolon(this, e3);
        }, t2.TSModuleBlock = function(e3) {
          printBraced(this, e3, () => this.printSequence(e3.body, true));
        }, t2.TSModuleDeclaration = function(e3) {
          const { declare: t3, id: r2, kind: n } = e3;
          t3 && (this.word("declare"), this.space());
          {
            if (e3.global || (this.word(null != n ? n : "Identifier" === r2.type ? "namespace" : "module"), this.space()), this.print(r2), !e3.body) return void this.semicolon();
            let t4 = e3.body;
            for (; "TSModuleDeclaration" === t4.type; ) this.tokenChar(46), this.print(t4.id), t4 = t4.body;
            this.space(), this.print(t4);
          }
        }, t2.TSNamedTupleMember = function(e3) {
          this.print(e3.label), e3.optional && this.tokenChar(63);
          this.tokenChar(58), this.space(), this.print(e3.elementType);
        }, t2.TSNamespaceExportDeclaration = function(e3) {
          this.word("export"), this.space(), this.word("as"), this.space(), this.word("namespace"), this.space(), this.print(e3.id), this.semicolon();
        }, t2.TSNeverKeyword = function() {
          this.word("never");
        }, t2.TSNonNullExpression = function(e3) {
          this.print(e3.expression), this.tokenChar(33);
        }, t2.TSNullKeyword = function() {
          this.word("null");
        }, t2.TSNumberKeyword = function() {
          this.word("number");
        }, t2.TSObjectKeyword = function() {
          this.word("object");
        }, t2.TSOptionalType = function(e3) {
          this.print(e3.typeAnnotation), this.tokenChar(63);
        }, t2.TSParameterProperty = function(e3) {
          e3.accessibility && (this.word(e3.accessibility), this.space());
          e3.readonly && (this.word("readonly"), this.space());
          this._param(e3.parameter);
        }, t2.TSParenthesizedType = function(e3) {
          this.tokenChar(40), this.print(e3.typeAnnotation), this.tokenChar(41);
        }, t2.TSPropertySignature = function(e3) {
          const { readonly: t3 } = e3;
          t3 && (this.word("readonly"), this.space());
          this.tsPrintPropertyOrMethodName(e3), this.print(e3.typeAnnotation), maybePrintTrailingCommaOrSemicolon(this, e3);
        }, t2.TSQualifiedName = function(e3) {
          this.print(e3.left), this.tokenChar(46), this.print(e3.right);
        }, t2.TSRestType = function(e3) {
          this.token("..."), this.print(e3.typeAnnotation);
        }, t2.TSStringKeyword = function() {
          this.word("string");
        }, t2.TSSymbolKeyword = function() {
          this.word("symbol");
        }, t2.TSTemplateLiteralType = function(e3) {
          this._printTemplate(e3, e3.types);
        }, t2.TSThisType = function() {
          this.word("this");
        }, t2.TSTupleType = function(e3) {
          this.tokenChar(91), this.printList(e3.elementTypes, this.shouldPrintTrailingComma("]")), this.tokenChar(93);
        }, t2.TSTypeAliasDeclaration = function(e3) {
          const { declare: t3, id: r2, typeParameters: n, typeAnnotation: s } = e3;
          t3 && (this.word("declare"), this.space());
          this.word("type"), this.space(), this.print(r2), this.print(n), this.space(), this.tokenChar(61), this.space(), this.print(s), this.semicolon();
        }, t2.TSTypeAnnotation = function(e3, t3) {
          this.token("TSFunctionType" !== t3.type && "TSConstructorType" !== t3.type || t3.typeAnnotation !== e3 ? ":" : "=>"), this.space(), e3.optional && this.tokenChar(63);
          this.print(e3.typeAnnotation);
        }, t2.TSTypeAssertion = function(e3) {
          const { typeAnnotation: t3, expression: r2 } = e3;
          this.tokenChar(60), this.print(t3), this.tokenChar(62), this.space(), this.print(r2);
        }, t2.TSTypeLiteral = function(e3) {
          printBraced(this, e3, () => this.printJoin(e3.members, true, true));
        }, t2.TSTypeOperator = function(e3) {
          this.word(e3.operator), this.space(), this.print(e3.typeAnnotation);
        }, t2.TSTypeParameter = function(e3) {
          e3.const && (this.word("const"), this.space());
          e3.in && (this.word("in"), this.space());
          e3.out && (this.word("out"), this.space());
          this.word(e3.name), e3.constraint && (this.space(), this.word("extends"), this.space(), this.print(e3.constraint));
          e3.default && (this.space(), this.tokenChar(61), this.space(), this.print(e3.default));
        }, t2.TSTypeParameterDeclaration = t2.TSTypeParameterInstantiation = function(e3, t3) {
          this.tokenChar(60);
          let r2 = "ArrowFunctionExpression" === t3.type && 1 === e3.params.length;
          this.tokenMap && null != e3.start && null != e3.end && (r2 && (r2 = !!this.tokenMap.find(e3, (e4) => this.tokenMap.matchesOriginal(e4, ","))), r2 || (r2 = this.shouldPrintTrailingComma(">")));
          this.printList(e3.params, r2), this.tokenChar(62);
        }, t2.TSTypePredicate = function(e3) {
          e3.asserts && (this.word("asserts"), this.space());
          this.print(e3.parameterName), e3.typeAnnotation && (this.space(), this.word("is"), this.space(), this.print(e3.typeAnnotation.typeAnnotation));
        }, t2.TSTypeQuery = function(e3) {
          this.word("typeof"), this.space(), this.print(e3.exprName);
          const t3 = e3.typeParameters;
          t3 && this.print(t3);
        }, t2.TSTypeReference = function(e3) {
          const t3 = e3.typeParameters;
          this.print(e3.typeName, !!t3), this.print(t3);
        }, t2.TSUndefinedKeyword = function() {
          this.word("undefined");
        }, t2.TSUnionType = function(e3) {
          tsPrintUnionOrIntersectionType(this, e3, "|");
        }, t2.TSUnknownKeyword = function() {
          this.word("unknown");
        }, t2.TSVoidKeyword = function() {
          this.word("void");
        }, t2.tsPrintClassMemberModifiers = function(e3) {
          const t3 = "ClassPrivateProperty" === e3.type, r2 = "ClassAccessorProperty" === e3.type || "ClassProperty" === e3.type;
          printModifiersList(this, e3, [r2 && e3.declare && "declare", !t3 && e3.accessibility]), e3.static && (this.word("static"), this.space());
          printModifiersList(this, e3, [!t3 && e3.abstract && "abstract", !t3 && e3.override && "override", (r2 || t3) && e3.readonly && "readonly"]);
        }, t2.tsPrintFunctionOrConstructorType = function(e3) {
          const { typeParameters: t3 } = e3, r2 = e3.parameters;
          this.print(t3), this.tokenChar(40), this._parameters(r2, ")"), this.space();
          const n = e3.typeAnnotation;
          this.print(n);
        }, t2.tsPrintPropertyOrMethodName = function(e3) {
          e3.computed && this.tokenChar(91);
          this.print(e3.key), e3.computed && this.tokenChar(93);
          e3.optional && this.tokenChar(63);
        }, t2.tsPrintSignatureDeclarationBase = function(e3) {
          const { typeParameters: t3 } = e3, r2 = e3.parameters;
          this.print(t3), this.tokenChar(40), this._parameters(r2, ")");
          const n = e3.typeAnnotation;
          this.print(n);
        };
      }, "./node_modules/.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/lib/index.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0, t2.generate = generate;
        var n = r2("./node_modules/.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/lib/source-map.js"), s = r2("./node_modules/.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/lib/printer.js");
        function normalizeOptions(e3, t3, r3) {
          if (t3.experimental_preserveFormat) {
            if ("string" != typeof e3) throw new Error("`experimental_preserveFormat` requires the original `code` to be passed to @babel/generator as a string");
            if (!t3.retainLines) throw new Error("`experimental_preserveFormat` requires `retainLines` to be set to `true`");
            if (t3.compact && "auto" !== t3.compact) throw new Error("`experimental_preserveFormat` is not compatible with the `compact` option");
            if (t3.minified) throw new Error("`experimental_preserveFormat` is not compatible with the `minified` option");
            if (t3.jsescOption) throw new Error("`experimental_preserveFormat` is not compatible with the `jsescOption` option");
            if (!Array.isArray(r3.tokens)) throw new Error("`experimental_preserveFormat` requires the AST to have attached the token of the input code. Make sure to enable the `tokens: true` parser option.");
          }
          const n2 = { auxiliaryCommentBefore: t3.auxiliaryCommentBefore, auxiliaryCommentAfter: t3.auxiliaryCommentAfter, shouldPrintComment: t3.shouldPrintComment, preserveFormat: t3.experimental_preserveFormat, retainLines: t3.retainLines, retainFunctionParens: t3.retainFunctionParens, comments: null == t3.comments || t3.comments, compact: t3.compact, minified: t3.minified, concise: t3.concise, indent: { adjustMultilineComment: true, style: "  " }, jsescOption: Object.assign({ quotes: "double", wrap: true, minimal: false }, t3.jsescOption), topicToken: t3.topicToken, importAttributesKeyword: t3.importAttributesKeyword };
          var s2;
          n2.decoratorsBeforeExport = t3.decoratorsBeforeExport, n2.jsescOption.json = t3.jsonCompatibleStrings, n2.recordAndTupleSyntaxType = null != (s2 = t3.recordAndTupleSyntaxType) ? s2 : "hash", n2.minified ? (n2.compact = true, n2.shouldPrintComment = n2.shouldPrintComment || (() => n2.comments)) : n2.shouldPrintComment = n2.shouldPrintComment || ((e4) => n2.comments || e4.includes("@license") || e4.includes("@preserve")), "auto" === n2.compact && (n2.compact = "string" == typeof e3 && e3.length > 5e5, n2.compact && console.error(`[BABEL] Note: The code generator has deoptimised the styling of ${t3.filename} as it exceeds the max of 500KB.`)), (n2.compact || n2.preserveFormat) && (n2.indent.adjustMultilineComment = false);
          const { auxiliaryCommentBefore: i, auxiliaryCommentAfter: o, shouldPrintComment: a } = n2;
          return i && !a(i) && (n2.auxiliaryCommentBefore = void 0), o && !a(o) && (n2.auxiliaryCommentAfter = void 0), n2;
        }
        function generate(e3, t3 = {}, r3) {
          const i = normalizeOptions(r3, t3, e3), o = t3.sourceMaps ? new n.default(t3, r3) : null;
          return new s.default(i, o, e3.tokens, "string" == typeof r3 ? r3 : null).generate(e3);
        }
        t2.CodeGenerator = class {
          constructor(e3, t3 = {}, r3) {
            this._ast = void 0, this._format = void 0, this._map = void 0, this._ast = e3, this._format = normalizeOptions(r3, t3, e3), this._map = t3.sourceMaps ? new n.default(t3, r3) : null;
          }
          generate() {
            return new s.default(this._format, this._map).generate(this._ast);
          }
        };
        t2.default = generate;
      }, "./node_modules/.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/lib/node/index.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.TokenContext = void 0, t2.isLastChild = function(e3, t3) {
          const r3 = a[e3.type];
          for (let n2 = r3.length - 1; n2 >= 0; n2--) {
            const s2 = e3[r3[n2]];
            if (s2 === t3) return true;
            if (Array.isArray(s2)) {
              let e4 = s2.length - 1;
              for (; e4 >= 0 && null === s2[e4]; ) e4--;
              return e4 >= 0 && s2[e4] === t3;
            }
            if (s2) return false;
          }
          return false;
        }, t2.needsParens = function(e3, t3, r3, n2) {
          var s2;
          if (!t3) return false;
          if (d(t3) && t3.callee === e3 && isOrHasCallExpression(e3)) return true;
          if (p(t3)) return !(isDecoratorMemberExpression(e3) || l(e3) && isDecoratorMemberExpression(e3.callee) || h(e3));
          return null == (s2 = m.get(e3.type)) ? void 0 : s2(e3, t3, r3, n2);
        }, t2.needsWhitespace = needsWhitespace, t2.needsWhitespaceAfter = function(e3, t3) {
          return needsWhitespace(e3, t3, 2);
        }, t2.needsWhitespaceBefore = function(e3, t3) {
          return needsWhitespace(e3, t3, 1);
        };
        var n = r2("./node_modules/.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/lib/node/whitespace.js"), s = r2("./node_modules/.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/lib/node/parentheses.js"), i = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/index.js");
        const { FLIPPED_ALIAS_KEYS: o, VISITOR_KEYS: a, isCallExpression: l, isDecorator: p, isExpressionStatement: c, isMemberExpression: u, isNewExpression: d, isParenthesizedExpression: h } = i;
        t2.TokenContext = { normal: 0, expressionStatement: 1, arrowBody: 2, exportDefault: 4, arrowFlowReturnType: 8, forInitHead: 16, forInHead: 32, forOfHead: 64, forInOrInitHeadAccumulate: 128, forInOrInitHeadAccumulatePassThroughMask: 128 };
        function expandAliases(e3) {
          const t3 = /* @__PURE__ */ new Map();
          function add(e4, r3) {
            const n2 = t3.get(e4);
            t3.set(e4, n2 ? function(e5, t4, s2, i2) {
              var o2;
              return null != (o2 = n2(e5, t4, s2, i2)) ? o2 : r3(e5, t4, s2, i2);
            } : r3);
          }
          for (const t4 of Object.keys(e3)) {
            const r3 = o[t4];
            if (r3) for (const n2 of r3) add(n2, e3[t4]);
            else add(t4, e3[t4]);
          }
          return t3;
        }
        const m = expandAliases(s), f = expandAliases(n.nodes);
        function isOrHasCallExpression(e3) {
          return !!l(e3) || u(e3) && isOrHasCallExpression(e3.object);
        }
        function needsWhitespace(e3, t3, r3) {
          var n2;
          if (!e3) return false;
          c(e3) && (e3 = e3.expression);
          const s2 = null == (n2 = f.get(e3.type)) ? void 0 : n2(e3, t3);
          return "number" == typeof s2 && 0 !== (s2 & r3);
        }
        function isDecoratorMemberExpression(e3) {
          switch (e3.type) {
            case "Identifier":
              return true;
            case "MemberExpression":
              return !e3.computed && "Identifier" === e3.property.type && isDecoratorMemberExpression(e3.object);
            default:
              return false;
          }
        }
      }, "./node_modules/.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/lib/node/parentheses.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.AssignmentExpression = function(e3, t3, r3) {
          return !(!needsParenBeforeExpressionBrace(r3) || !u(e3.left)) || ConditionalExpression(e3, t3);
        }, t2.Binary = Binary, t2.BinaryExpression = function(e3, t3, r3) {
          return "in" === e3.operator && Boolean(r3 & s.TokenContext.forInOrInitHeadAccumulate);
        }, t2.ClassExpression = function(e3, t3, r3) {
          return Boolean(r3 & (s.TokenContext.expressionStatement | s.TokenContext.exportDefault));
        }, t2.ArrowFunctionExpression = t2.ConditionalExpression = ConditionalExpression, t2.DoExpression = function(e3, t3, r3) {
          return !e3.async && Boolean(r3 & s.TokenContext.expressionStatement);
        }, t2.FunctionExpression = function(e3, t3, r3) {
          return Boolean(r3 & (s.TokenContext.expressionStatement | s.TokenContext.exportDefault));
        }, t2.FunctionTypeAnnotation = function(e3, t3, r3) {
          const n2 = t3.type;
          return "UnionTypeAnnotation" === n2 || "IntersectionTypeAnnotation" === n2 || "ArrayTypeAnnotation" === n2 || Boolean(r3 & s.TokenContext.arrowFlowReturnType);
        }, t2.Identifier = function(e3, t3, r3, n2) {
          var i2;
          const o2 = t3.type;
          if (null != (i2 = e3.extra) && i2.parenthesized && "AssignmentExpression" === o2 && t3.left === e3) {
            const e4 = t3.right.type;
            if (("FunctionExpression" === e4 || "ClassExpression" === e4) && null == t3.right.id) return true;
          }
          if (n2 && n2(e3) !== e3.name) return false;
          if ("let" === e3.name) {
            return !!((c(t3, { object: e3, computed: true }) || d(t3, { object: e3, computed: true, optional: false })) && r3 & (s.TokenContext.expressionStatement | s.TokenContext.forInitHead | s.TokenContext.forInHead)) || Boolean(r3 & s.TokenContext.forOfHead);
          }
          return "async" === e3.name && l(t3, { left: e3, await: false });
        }, t2.LogicalExpression = function(e3, t3) {
          const r3 = t3.type;
          if (isTSTypeExpression(r3)) return true;
          if ("LogicalExpression" !== r3) return false;
          switch (e3.operator) {
            case "||":
              return "??" === t3.operator || "&&" === t3.operator;
            case "&&":
              return "??" === t3.operator;
            case "??":
              return "??" !== t3.operator;
          }
        }, t2.NullableTypeAnnotation = function(e3, t3) {
          return i(t3);
        }, t2.ObjectExpression = function(e3, t3, r3) {
          return needsParenBeforeExpressionBrace(r3);
        }, t2.OptionalIndexedAccessType = function(e3, t3) {
          return p(t3) && t3.objectType === e3;
        }, t2.OptionalCallExpression = t2.OptionalMemberExpression = function(e3, t3) {
          return a(t3) && t3.callee === e3 || c(t3) && t3.object === e3;
        }, t2.SequenceExpression = function(e3, t3) {
          const r3 = t3.type;
          if ("SequenceExpression" === r3 || "ParenthesizedExpression" === r3 || "MemberExpression" === r3 && t3.property === e3 || "OptionalMemberExpression" === r3 && t3.property === e3 || "TemplateLiteral" === r3) return false;
          if ("ClassDeclaration" === r3) return true;
          if ("ForOfStatement" === r3) return t3.right === e3;
          if ("ExportDefaultDeclaration" === r3) return true;
          return !m(t3);
        }, t2.TSSatisfiesExpression = t2.TSAsExpression = function(e3, t3) {
          if (("AssignmentExpression" === t3.type || "AssignmentPattern" === t3.type) && t3.left === e3) return true;
          if ("BinaryExpression" === t3.type && ("|" === t3.operator || "&" === t3.operator) && e3 === t3.left) return true;
          return Binary(e3, t3);
        }, t2.TSConditionalType = function(e3, t3) {
          const r3 = t3.type;
          if ("TSArrayType" === r3 || "TSIndexedAccessType" === r3 && t3.objectType === e3 || "TSOptionalType" === r3 || "TSTypeOperator" === r3 || "TSTypeParameter" === r3) return true;
          if (("TSIntersectionType" === r3 || "TSUnionType" === r3) && t3.types[0] === e3) return true;
          if ("TSConditionalType" === r3 && (t3.checkType === e3 || t3.extendsType === e3)) return true;
          return false;
        }, t2.TSConstructorType = t2.TSFunctionType = function(e3, t3) {
          const r3 = t3.type;
          return "TSIntersectionType" === r3 || "TSUnionType" === r3 || "TSTypeOperator" === r3 || "TSOptionalType" === r3 || "TSArrayType" === r3 || "TSIndexedAccessType" === r3 && t3.objectType === e3 || "TSConditionalType" === r3 && (t3.checkType === e3 || t3.extendsType === e3);
        }, t2.TSInferType = function(e3, t3) {
          const r3 = t3.type;
          if ("TSArrayType" === r3 || "TSIndexedAccessType" === r3 && t3.objectType === e3 || "TSOptionalType" === r3) return true;
          if (e3.typeParameter.constraint && ("TSIntersectionType" === r3 || "TSUnionType" === r3) && t3.types[0] === e3) return true;
          return false;
        }, t2.TSInstantiationExpression = function(e3, t3) {
          const r3 = t3.type;
          return ("CallExpression" === r3 || "OptionalCallExpression" === r3 || "NewExpression" === r3 || "TSInstantiationExpression" === r3) && !!t3.typeParameters;
        }, t2.TSIntersectionType = function(e3, t3) {
          const r3 = t3.type;
          return "TSTypeOperator" === r3 || "TSArrayType" === r3 || "TSIndexedAccessType" === r3 && t3.objectType === e3 || "TSOptionalType" === r3;
        }, t2.UnaryLike = t2.TSTypeAssertion = UnaryLike, t2.TSTypeOperator = function(e3, t3) {
          const r3 = t3.type;
          return "TSArrayType" === r3 || "TSIndexedAccessType" === r3 && t3.objectType === e3 || "TSOptionalType" === r3;
        }, t2.TSUnionType = function(e3, t3) {
          const r3 = t3.type;
          return "TSIntersectionType" === r3 || "TSTypeOperator" === r3 || "TSArrayType" === r3 || "TSIndexedAccessType" === r3 && t3.objectType === e3 || "TSOptionalType" === r3;
        }, t2.IntersectionTypeAnnotation = t2.UnionTypeAnnotation = function(e3, t3) {
          const r3 = t3.type;
          return "ArrayTypeAnnotation" === r3 || "NullableTypeAnnotation" === r3 || "IntersectionTypeAnnotation" === r3 || "UnionTypeAnnotation" === r3;
        }, t2.UpdateExpression = function(e3, t3) {
          return hasPostfixPart(e3, t3) || isClassExtendsClause(e3, t3);
        }, t2.AwaitExpression = t2.YieldExpression = function(e3, t3) {
          const r3 = t3.type;
          return "BinaryExpression" === r3 || "LogicalExpression" === r3 || "UnaryExpression" === r3 || "SpreadElement" === r3 || hasPostfixPart(e3, t3) || "AwaitExpression" === r3 && h(e3) || "ConditionalExpression" === r3 && e3 === t3.test || isClassExtendsClause(e3, t3) || isTSTypeExpression(r3);
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/index.js"), s = r2("./node_modules/.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/lib/node/index.js");
        const { isArrayTypeAnnotation: i, isBinaryExpression: o, isCallExpression: a, isForOfStatement: l, isIndexedAccessType: p, isMemberExpression: c, isObjectPattern: u, isOptionalMemberExpression: d, isYieldExpression: h, isStatement: m } = n, f = /* @__PURE__ */ new Map([["||", 0], ["??", 0], ["|>", 0], ["&&", 1], ["|", 2], ["^", 3], ["&", 4], ["==", 5], ["===", 5], ["!=", 5], ["!==", 5], ["<", 6], [">", 6], ["<=", 6], [">=", 6], ["in", 6], ["instanceof", 6], [">>", 7], ["<<", 7], [">>>", 7], ["+", 8], ["-", 8], ["*", 9], ["/", 9], ["%", 9], ["**", 10]]);
        function getBinaryPrecedence(e3, t3) {
          return "BinaryExpression" === t3 || "LogicalExpression" === t3 ? f.get(e3.operator) : "TSAsExpression" === t3 || "TSSatisfiesExpression" === t3 ? f.get("in") : void 0;
        }
        function isTSTypeExpression(e3) {
          return "TSAsExpression" === e3 || "TSSatisfiesExpression" === e3 || "TSTypeAssertion" === e3;
        }
        const isClassExtendsClause = (e3, t3) => {
          const r3 = t3.type;
          return ("ClassDeclaration" === r3 || "ClassExpression" === r3) && t3.superClass === e3;
        }, hasPostfixPart = (e3, t3) => {
          const r3 = t3.type;
          return ("MemberExpression" === r3 || "OptionalMemberExpression" === r3) && t3.object === e3 || ("CallExpression" === r3 || "OptionalCallExpression" === r3 || "NewExpression" === r3) && t3.callee === e3 || "TaggedTemplateExpression" === r3 && t3.tag === e3 || "TSNonNullExpression" === r3;
        };
        function needsParenBeforeExpressionBrace(e3) {
          return Boolean(e3 & (s.TokenContext.expressionStatement | s.TokenContext.arrowBody));
        }
        function Binary(e3, t3) {
          const r3 = t3.type;
          if ("BinaryExpression" === e3.type && "**" === e3.operator && "BinaryExpression" === r3 && "**" === t3.operator) return t3.left === e3;
          if (isClassExtendsClause(e3, t3)) return true;
          if (hasPostfixPart(e3, t3) || "UnaryExpression" === r3 || "SpreadElement" === r3 || "AwaitExpression" === r3) return true;
          const n2 = getBinaryPrecedence(t3, r3);
          if (null != n2) {
            const s2 = getBinaryPrecedence(e3, e3.type);
            if (n2 === s2 && "BinaryExpression" === r3 && t3.right === e3 || n2 > s2) return true;
          }
        }
        function UnaryLike(e3, t3) {
          return hasPostfixPart(e3, t3) || o(t3) && "**" === t3.operator && t3.left === e3 || isClassExtendsClause(e3, t3);
        }
        function ConditionalExpression(e3, t3) {
          const r3 = t3.type;
          return !!("UnaryExpression" === r3 || "SpreadElement" === r3 || "BinaryExpression" === r3 || "LogicalExpression" === r3 || "ConditionalExpression" === r3 && t3.test === e3 || "AwaitExpression" === r3 || isTSTypeExpression(r3)) || UnaryLike(e3, t3);
        }
      }, "./node_modules/.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/lib/node/whitespace.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.nodes = void 0;
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/index.js");
        const { FLIPPED_ALIAS_KEYS: s, isArrayExpression: i, isAssignmentExpression: o, isBinary: a, isBlockStatement: l, isCallExpression: p, isFunction: c, isIdentifier: u, isLiteral: d, isMemberExpression: h, isObjectExpression: m, isOptionalCallExpression: f, isOptionalMemberExpression: y, isStringLiteral: b } = n;
        function crawlInternal(e3, t3) {
          return e3 ? (h(e3) || y(e3) ? (crawlInternal(e3.object, t3), e3.computed && crawlInternal(e3.property, t3)) : a(e3) || o(e3) ? (crawlInternal(e3.left, t3), crawlInternal(e3.right, t3)) : p(e3) || f(e3) ? (t3.hasCall = true, crawlInternal(e3.callee, t3)) : c(e3) ? t3.hasFunction = true : u(e3) && (t3.hasHelper = t3.hasHelper || e3.callee && isHelper(e3.callee)), t3) : t3;
        }
        function crawl(e3) {
          return crawlInternal(e3, { hasCall: false, hasFunction: false, hasHelper: false });
        }
        function isHelper(e3) {
          return !!e3 && (h(e3) ? isHelper(e3.object) || isHelper(e3.property) : u(e3) ? "require" === e3.name || 95 === e3.name.charCodeAt(0) : p(e3) ? isHelper(e3.callee) : !(!a(e3) && !o(e3)) && (u(e3.left) && isHelper(e3.left) || isHelper(e3.right)));
        }
        function isType(e3) {
          return d(e3) || m(e3) || i(e3) || u(e3) || h(e3);
        }
        const g = t2.nodes = { AssignmentExpression(e3) {
          const t3 = crawl(e3.right);
          if (t3.hasCall && t3.hasHelper || t3.hasFunction) return t3.hasFunction ? 3 : 2;
        }, SwitchCase: (e3, t3) => (e3.consequent.length || t3.cases[0] === e3 ? 1 : 0) | (e3.consequent.length || t3.cases[t3.cases.length - 1] !== e3 ? 0 : 2), LogicalExpression(e3) {
          if (c(e3.left) || c(e3.right)) return 2;
        }, Literal(e3) {
          if (b(e3) && "use strict" === e3.value) return 2;
        }, CallExpression(e3) {
          if (c(e3.callee) || isHelper(e3)) return 3;
        }, OptionalCallExpression(e3) {
          if (c(e3.callee)) return 3;
        }, VariableDeclaration(e3) {
          for (let t3 = 0; t3 < e3.declarations.length; t3++) {
            const r3 = e3.declarations[t3];
            let n2 = isHelper(r3.id) && !isType(r3.init);
            if (!n2 && r3.init) {
              const e4 = crawl(r3.init);
              n2 = isHelper(r3.init) && e4.hasCall || e4.hasFunction;
            }
            if (n2) return 3;
          }
        }, IfStatement(e3) {
          if (l(e3.consequent)) return 3;
        } };
        g.ObjectProperty = g.ObjectTypeProperty = g.ObjectMethod = function(e3, t3) {
          if (t3.properties[0] === e3) return 1;
        }, g.ObjectTypeCallProperty = function(e3, t3) {
          var r3;
          if (t3.callProperties[0] === e3 && (null == (r3 = t3.properties) || !r3.length)) return 1;
        }, g.ObjectTypeIndexer = function(e3, t3) {
          var r3, n2;
          if (!(t3.indexers[0] !== e3 || null != (r3 = t3.properties) && r3.length || null != (n2 = t3.callProperties) && n2.length)) return 1;
        }, g.ObjectTypeInternalSlot = function(e3, t3) {
          var r3, n2, s2;
          if (!(t3.internalSlots[0] !== e3 || null != (r3 = t3.properties) && r3.length || null != (n2 = t3.callProperties) && n2.length || null != (s2 = t3.indexers) && s2.length)) return 1;
        }, [["Function", true], ["Class", true], ["Loop", true], ["LabeledStatement", true], ["SwitchStatement", true], ["TryStatement", true]].forEach(function([e3, t3]) {
          [e3].concat(s[e3] || []).forEach(function(e4) {
            const r3 = t3 ? 3 : 0;
            g[e4] = () => r3;
          });
        });
      }, "./node_modules/.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/lib/printer.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var n = r2("./node_modules/.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/lib/buffer.js"), s = r2("./node_modules/.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/lib/node/index.js"), i = s, o = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/index.js"), a = r2("./node_modules/.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/lib/token-map.js"), l = r2("./node_modules/.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/lib/generators/index.js"), p = r2("./node_modules/.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/lib/generators/deprecated.js");
        const { isExpression: c, isFunction: u, isStatement: d, isClassBody: h, isTSInterfaceBody: m, isTSEnumMember: f } = o, y = /e/i, b = /\.0+$/, g = /[\n\r\u2028\u2029]/, x = /[\n\r\u2028\u2029]|\*\//;
        function commentIsNewline(e3) {
          return "CommentLine" === e3.type || g.test(e3.value);
        }
        const { needsParens: v } = i;
        class Printer {
          constructor(e3, t3, r3, i2) {
            this.tokenContext = s.TokenContext.normal, this._tokens = null, this._originalCode = null, this._currentNode = null, this._indent = 0, this._indentRepeat = 0, this._insideAux = false, this._noLineTerminator = false, this._noLineTerminatorAfterNode = null, this._printAuxAfterOnNextUserNode = false, this._printedComments = /* @__PURE__ */ new Set(), this._endsWithInteger = false, this._endsWithWord = false, this._endsWithDiv = false, this._lastCommentLine = 0, this._endsWithInnerRaw = false, this._indentInnerComments = true, this.tokenMap = null, this._boundGetRawIdentifier = this._getRawIdentifier.bind(this), this._printSemicolonBeforeNextNode = -1, this._printSemicolonBeforeNextToken = -1, this.format = e3, this._tokens = r3, this._originalCode = i2, this._indentRepeat = e3.indent.style.length, this._inputMap = null == t3 ? void 0 : t3._inputMap, this._buf = new n.default(t3, e3.indent.style[0]);
          }
          enterForStatementInit() {
            return this.tokenContext |= s.TokenContext.forInitHead | s.TokenContext.forInOrInitHeadAccumulate, () => this.tokenContext = s.TokenContext.normal;
          }
          enterForXStatementInit(e3) {
            return e3 ? (this.tokenContext |= s.TokenContext.forOfHead, null) : (this.tokenContext |= s.TokenContext.forInHead | s.TokenContext.forInOrInitHeadAccumulate, () => this.tokenContext = s.TokenContext.normal);
          }
          enterDelimited() {
            const e3 = this.tokenContext, t3 = this._noLineTerminatorAfterNode;
            return e3 & s.TokenContext.forInOrInitHeadAccumulate || null !== t3 ? (this._noLineTerminatorAfterNode = null, this.tokenContext = s.TokenContext.normal, () => {
              this._noLineTerminatorAfterNode = t3, this.tokenContext = e3;
            }) : () => {
            };
          }
          generate(e3) {
            return this.format.preserveFormat && (this.tokenMap = new a.TokenMap(e3, this._tokens, this._originalCode)), this.print(e3), this._maybeAddAuxComment(), this._buf.get();
          }
          indent() {
            const { format: e3 } = this;
            e3.preserveFormat || e3.compact || e3.concise || this._indent++;
          }
          dedent() {
            const { format: e3 } = this;
            e3.preserveFormat || e3.compact || e3.concise || this._indent--;
          }
          semicolon(e3 = false) {
            if (this._maybeAddAuxComment(), e3) return this._appendChar(59), void (this._noLineTerminator = false);
            if (this.tokenMap) {
              const e4 = this._currentNode;
              if (null != e4.start && null != e4.end) {
                if (!this.tokenMap.endMatches(e4, ";")) return void (this._printSemicolonBeforeNextNode = this._buf.getCurrentLine());
                const t3 = this.tokenMap.getIndexes(this._currentNode);
                this._catchUpTo(this._tokens[t3[t3.length - 1]].loc.start);
              }
            }
            this._queue(59), this._noLineTerminator = false;
          }
          rightBrace(e3) {
            this.format.minified && this._buf.removeLastSemicolon(), this.sourceWithOffset("end", e3.loc, -1), this.tokenChar(125);
          }
          rightParens(e3) {
            this.sourceWithOffset("end", e3.loc, -1), this.tokenChar(41);
          }
          space(e3 = false) {
            const { format: t3 } = this;
            if (!t3.compact && !t3.preserveFormat) {
              if (e3) this._space();
              else if (this._buf.hasContent()) {
                const e4 = this.getLastChar();
                32 !== e4 && 10 !== e4 && this._space();
              }
            }
          }
          word(e3, t3 = false) {
            this.tokenContext &= s.TokenContext.forInOrInitHeadAccumulatePassThroughMask, this._maybePrintInnerComments(e3), this._maybeAddAuxComment(), this.tokenMap && this._catchUpToCurrentToken(e3), (this._endsWithWord || this._endsWithDiv && 47 === e3.charCodeAt(0)) && this._space(), this._append(e3, false), this._endsWithWord = true, this._noLineTerminator = t3;
          }
          number(e3, t3) {
            this.word(e3), this._endsWithInteger = Number.isInteger(t3) && !(function(e4) {
              if (e4.length > 2 && 48 === e4.charCodeAt(0)) {
                const t4 = e4.charCodeAt(1);
                return 98 === t4 || 111 === t4 || 120 === t4;
              }
              return false;
            })(e3) && !y.test(e3) && !b.test(e3) && 46 !== e3.charCodeAt(e3.length - 1);
          }
          token(e3, t3 = false, r3 = 0) {
            this.tokenContext &= s.TokenContext.forInOrInitHeadAccumulatePassThroughMask, this._maybePrintInnerComments(e3, r3), this._maybeAddAuxComment(), this.tokenMap && this._catchUpToCurrentToken(e3, r3);
            const n2 = this.getLastChar(), i2 = e3.charCodeAt(0);
            (33 === n2 && ("--" === e3 || 61 === i2) || 43 === i2 && 43 === n2 || 45 === i2 && 45 === n2 || 46 === i2 && this._endsWithInteger) && this._space(), this._append(e3, t3), this._noLineTerminator = false;
          }
          tokenChar(e3) {
            this.tokenContext &= s.TokenContext.forInOrInitHeadAccumulatePassThroughMask;
            const t3 = String.fromCharCode(e3);
            this._maybePrintInnerComments(t3), this._maybeAddAuxComment(), this.tokenMap && this._catchUpToCurrentToken(t3);
            const r3 = this.getLastChar();
            (43 === e3 && 43 === r3 || 45 === e3 && 45 === r3 || 46 === e3 && this._endsWithInteger) && this._space(), this._appendChar(e3), this._noLineTerminator = false;
          }
          newline(e3 = 1, t3) {
            if (!(e3 <= 0)) {
              if (!t3) {
                if (this.format.retainLines || this.format.compact) return;
                if (this.format.concise) return void this.space();
              }
              e3 > 2 && (e3 = 2), e3 -= this._buf.getNewlineCount();
              for (let t4 = 0; t4 < e3; t4++) this._newline();
            }
          }
          endsWith(e3) {
            return this.getLastChar() === e3;
          }
          getLastChar() {
            return this._buf.getLastChar();
          }
          endsWithCharAndNewline() {
            return this._buf.endsWithCharAndNewline();
          }
          removeTrailingNewline() {
            this._buf.removeTrailingNewline();
          }
          exactSource(e3, t3) {
            e3 ? (this._catchUp("start", e3), this._buf.exactSource(e3, t3)) : t3();
          }
          source(e3, t3) {
            t3 && (this._catchUp(e3, t3), this._buf.source(e3, t3));
          }
          sourceWithOffset(e3, t3, r3) {
            t3 && !this.format.preserveFormat && (this._catchUp(e3, t3), this._buf.sourceWithOffset(e3, t3, r3));
          }
          sourceIdentifierName(e3, t3) {
            if (!this._buf._canMarkIdName) return;
            const r3 = this._buf._sourcePosition;
            r3.identifierNamePos = t3, r3.identifierName = e3;
          }
          _space() {
            this._queue(32);
          }
          _newline() {
            this._queue(10);
          }
          _catchUpToCurrentToken(e3, t3 = 0) {
            const r3 = this.tokenMap.findMatching(this._currentNode, e3, t3);
            r3 && this._catchUpTo(r3.loc.start), -1 !== this._printSemicolonBeforeNextToken && this._printSemicolonBeforeNextToken === this._buf.getCurrentLine() && (this._buf.appendChar(59), this._endsWithWord = false, this._endsWithInteger = false, this._endsWithDiv = false), this._printSemicolonBeforeNextToken = -1, this._printSemicolonBeforeNextNode = -1;
          }
          _append(e3, t3) {
            this._maybeIndent(e3.charCodeAt(0)), this._buf.append(e3, t3), this._endsWithWord = false, this._endsWithInteger = false, this._endsWithDiv = false;
          }
          _appendChar(e3) {
            this._maybeIndent(e3), this._buf.appendChar(e3), this._endsWithWord = false, this._endsWithInteger = false, this._endsWithDiv = false;
          }
          _queue(e3) {
            this._maybeIndent(e3), this._buf.queue(e3), this._endsWithWord = false, this._endsWithInteger = false;
          }
          _maybeIndent(e3) {
            this._indent && 10 !== e3 && this.endsWith(10) && this._buf.queueIndentation(this._getIndent());
          }
          _shouldIndent(e3) {
            if (this._indent && 10 !== e3 && this.endsWith(10)) return true;
          }
          catchUp(e3) {
            if (!this.format.retainLines) return;
            const t3 = e3 - this._buf.getCurrentLine();
            for (let e4 = 0; e4 < t3; e4++) this._newline();
          }
          _catchUp(e3, t3) {
            const { format: r3 } = this;
            if (!r3.preserveFormat) return void (r3.retainLines && null != t3 && t3[e3] && this.catchUp(t3[e3].line));
            const n2 = null == t3 ? void 0 : t3[e3];
            null != n2 && this._catchUpTo(n2);
          }
          _catchUpTo({ line: e3, column: t3, index: r3 }) {
            const n2 = e3 - this._buf.getCurrentLine();
            if (n2 > 0 && this._noLineTerminator) return;
            for (let e4 = 0; e4 < n2; e4++) this._newline();
            const s2 = n2 > 0 ? t3 : t3 - this._buf.getCurrentColumn();
            if (s2 > 0) {
              const e4 = this._originalCode ? this._originalCode.slice(r3 - s2, r3).replace(/[^\t\x0B\f \xA0\u1680\u2000-\u200A\u202F\u205F\u3000\uFEFF]/gu, " ") : " ".repeat(s2);
              this._append(e4, false);
            }
          }
          _getIndent() {
            return this._indentRepeat * this._indent;
          }
          printTerminatorless(e3) {
            this._noLineTerminator = true, this.print(e3);
          }
          print(e3, t3, r3) {
            var n2, o2, a2;
            if (!e3) return;
            this._endsWithInnerRaw = false;
            const l2 = e3.type, p2 = this.format, u2 = p2.concise;
            e3._compact && (p2.concise = true);
            const d2 = this[l2];
            if (void 0 === d2) throw new ReferenceError(`unknown node of type ${JSON.stringify(l2)} with constructor ${JSON.stringify(e3.constructor.name)}`);
            const h2 = this._currentNode;
            this._currentNode = e3, this.tokenMap && (this._printSemicolonBeforeNextToken = this._printSemicolonBeforeNextNode);
            const m2 = this._insideAux;
            this._insideAux = null == e3.loc, this._maybeAddAuxComment(this._insideAux && !m2);
            const f2 = null == (n2 = e3.extra) ? void 0 : n2.parenthesized;
            let y2 = f2 && p2.preserveFormat || f2 && p2.retainFunctionParens && "FunctionExpression" === l2 || v(e3, h2, this.tokenContext, p2.preserveFormat ? this._boundGetRawIdentifier : void 0);
            if (!y2 && f2 && null != (o2 = e3.leadingComments) && o2.length && "CommentBlock" === e3.leadingComments[0].type) {
              switch (null == h2 ? void 0 : h2.type) {
                case "ExpressionStatement":
                case "VariableDeclarator":
                case "AssignmentExpression":
                case "ReturnStatement":
                  break;
                case "CallExpression":
                case "OptionalCallExpression":
                case "NewExpression":
                  if (h2.callee !== e3) break;
                default:
                  y2 = true;
              }
            }
            let b2, g2, x2 = false;
            var E;
            (!y2 && this._noLineTerminator && (null != (a2 = e3.leadingComments) && a2.some(commentIsNewline) || this.format.retainLines && e3.loc && e3.loc.start.line > this._buf.getCurrentLine()) && (y2 = true, x2 = true), y2) || (t3 || (t3 = h2 && this._noLineTerminatorAfterNode === h2 && i.isLastChild(h2, e3)), t3 && (null != (E = e3.trailingComments) && E.some(commentIsNewline) ? c(e3) && (y2 = true) : (b2 = this._noLineTerminatorAfterNode, this._noLineTerminatorAfterNode = e3)));
            y2 && (this.tokenChar(40), x2 && this.indent(), this._endsWithInnerRaw = false, this.tokenContext & s.TokenContext.forInOrInitHeadAccumulate && (g2 = this.tokenContext, this.tokenContext = s.TokenContext.normal), b2 = this._noLineTerminatorAfterNode, this._noLineTerminatorAfterNode = null), this._lastCommentLine = 0, this._printLeadingComments(e3, h2);
            const T = "Program" === l2 || "File" === l2 ? null : e3.loc;
            this.exactSource(T, d2.bind(this, e3, h2)), y2 ? (this._printTrailingComments(e3, h2), x2 && (this.dedent(), this.newline()), this.tokenChar(41), this._noLineTerminator = t3, g2 && (this.tokenContext = g2)) : t3 && !this._noLineTerminator ? (this._noLineTerminator = true, this._printTrailingComments(e3, h2)) : this._printTrailingComments(e3, h2, r3), this._currentNode = h2, p2.concise = u2, this._insideAux = m2, void 0 !== b2 && (this._noLineTerminatorAfterNode = b2), this._endsWithInnerRaw = false;
          }
          _maybeAddAuxComment(e3) {
            e3 && this._printAuxBeforeComment(), this._insideAux || this._printAuxAfterComment();
          }
          _printAuxBeforeComment() {
            if (this._printAuxAfterOnNextUserNode) return;
            this._printAuxAfterOnNextUserNode = true;
            const e3 = this.format.auxiliaryCommentBefore;
            e3 && this._printComment({ type: "CommentBlock", value: e3 }, 0);
          }
          _printAuxAfterComment() {
            if (!this._printAuxAfterOnNextUserNode) return;
            this._printAuxAfterOnNextUserNode = false;
            const e3 = this.format.auxiliaryCommentAfter;
            e3 && this._printComment({ type: "CommentBlock", value: e3 }, 0);
          }
          getPossibleRaw(e3) {
            const t3 = e3.extra;
            if (null != (null == t3 ? void 0 : t3.raw) && null != t3.rawValue && e3.value === t3.rawValue) return t3.raw;
          }
          printJoin(e3, t3, r3, n2, s2, i2, o2, a2) {
            if (null == e3 || !e3.length) return;
            if (null == r3 && this.format.retainLines) {
              var l2;
              const t4 = null == (l2 = e3[0].loc) ? void 0 : l2.start.line;
              null != t4 && t4 !== this._buf.getCurrentLine() && (r3 = true);
            }
            r3 && this.indent();
            const p2 = { addNewlines: i2, nextNodeStartLine: 0 }, c2 = null == n2 ? void 0 : n2.bind(this), u2 = e3.length;
            for (let r4 = 0; r4 < u2; r4++) {
              const n3 = e3[r4];
              var d2;
              if (n3) {
                if (t3 && this._printNewline(0 === r4, p2), this.print(n3, void 0, a2 || 0), null == o2 || o2(n3, r4), null != c2 && (r4 < u2 - 1 ? c2(r4, false) : s2 && c2(r4, true)), t3) if (null != (d2 = n3.trailingComments) && d2.length || (this._lastCommentLine = 0), r4 + 1 === u2) this.newline(1);
                else {
                  var h2;
                  const t4 = e3[r4 + 1];
                  p2.nextNodeStartLine = (null == (h2 = t4.loc) ? void 0 : h2.start.line) || 0, this._printNewline(true, p2);
                }
              }
            }
            r3 && this.dedent();
          }
          printAndIndentOnComments(e3) {
            const t3 = e3.leadingComments && e3.leadingComments.length > 0;
            t3 && this.indent(), this.print(e3), t3 && this.dedent();
          }
          printBlock(e3) {
            const t3 = e3.body;
            "EmptyStatement" !== t3.type && this.space(), this.print(t3);
          }
          _printTrailingComments(e3, t3, r3) {
            const { innerComments: n2, trailingComments: s2 } = e3;
            null != n2 && n2.length && this._printComments(2, n2, e3, t3, r3), null != s2 && s2.length && this._printComments(2, s2, e3, t3, r3);
          }
          _printLeadingComments(e3, t3) {
            const r3 = e3.leadingComments;
            null != r3 && r3.length && this._printComments(0, r3, e3, t3);
          }
          _maybePrintInnerComments(e3, t3) {
            var r3;
            this._endsWithInnerRaw && this.printInnerComments(null == (r3 = this.tokenMap) ? void 0 : r3.findMatching(this._currentNode, e3, t3));
            this._endsWithInnerRaw = true, this._indentInnerComments = true;
          }
          printInnerComments(e3) {
            const t3 = this._currentNode, r3 = t3.innerComments;
            if (null == r3 || !r3.length) return;
            const n2 = this.endsWith(32), s2 = this._indentInnerComments, i2 = this._printedComments.size;
            s2 && this.indent(), this._printComments(1, r3, t3, void 0, void 0, e3), n2 && i2 !== this._printedComments.size && this.space(), s2 && this.dedent();
          }
          noIndentInnerCommentsHere() {
            this._indentInnerComments = false;
          }
          printSequence(e3, t3, r3, n2) {
            this.printJoin(e3, true, null != t3 && t3, void 0, void 0, n2, void 0, r3);
          }
          printList(e3, t3, r3, n2, s2, i2) {
            this.printJoin(e3, r3, n2, null != s2 ? s2 : commaSeparator, t3, void 0, i2);
          }
          shouldPrintTrailingComma(e3) {
            if (!this.tokenMap) return null;
            const t3 = this.tokenMap.findLastIndex(this._currentNode, (t4) => this.tokenMap.matchesOriginal(t4, e3));
            return t3 <= 0 ? null : this.tokenMap.matchesOriginal(this._tokens[t3 - 1], ",");
          }
          _printNewline(e3, t3) {
            const r3 = this.format;
            if (r3.retainLines || r3.compact) return;
            if (r3.concise) return void this.space();
            if (!e3) return;
            const n2 = t3.nextNodeStartLine, s2 = this._lastCommentLine;
            if (n2 > 0 && s2 > 0) {
              const e4 = n2 - s2;
              if (e4 >= 0) return void this.newline(e4 || 1);
            }
            this._buf.hasContent() && this.newline(1);
          }
          _shouldPrintComment(e3, t3) {
            if (e3.ignore) return 0;
            if (this._printedComments.has(e3)) return 0;
            if (this._noLineTerminator && x.test(e3.value)) return 2;
            if (t3 && this.tokenMap) {
              const r3 = this.tokenMap.find(this._currentNode, (t4) => t4.value === e3.value);
              if (r3 && r3.start > t3.start) return 2;
            }
            return this._printedComments.add(e3), this.format.shouldPrintComment(e3.value) ? 1 : 0;
          }
          _printComment(e3, t3) {
            const r3 = this._noLineTerminator, n2 = "CommentBlock" === e3.type, s2 = n2 && 1 !== t3 && !this._noLineTerminator;
            s2 && this._buf.hasContent() && 2 !== t3 && this.newline(1);
            const i2 = this.getLastChar();
            let o2;
            if (91 !== i2 && 123 !== i2 && 40 !== i2 && this.space(), n2) {
              if (o2 = `/*${e3.value}*/`, this.format.indent.adjustMultilineComment) {
                var a2;
                const t4 = null == (a2 = e3.loc) ? void 0 : a2.start.column;
                if (t4) {
                  const e4 = new RegExp("\\n\\s{1," + t4 + "}", "g");
                  o2 = o2.replace(e4, "\n");
                }
                if (this.format.concise) o2 = o2.replace(/\n(?!$)/g, "\n");
                else {
                  let e4 = this.format.retainLines ? 0 : this._buf.getCurrentColumn();
                  (this._shouldIndent(47) || this.format.retainLines) && (e4 += this._getIndent()), o2 = o2.replace(/\n(?!$)/g, `
${" ".repeat(e4)}`);
                }
              }
            } else o2 = r3 ? `/*${e3.value}*/` : `//${e3.value}`;
            if (this._endsWithDiv && this._space(), this.tokenMap) {
              const { _printSemicolonBeforeNextToken: t4, _printSemicolonBeforeNextNode: r4 } = this;
              this._printSemicolonBeforeNextToken = -1, this._printSemicolonBeforeNextNode = -1, this.source("start", e3.loc), this._append(o2, n2), this._printSemicolonBeforeNextNode = r4, this._printSemicolonBeforeNextToken = t4;
            } else this.source("start", e3.loc), this._append(o2, n2);
            n2 || r3 || this.newline(1, true), s2 && 3 !== t3 && this.newline(1);
          }
          _printComments(e3, t3, r3, n2, s2 = 0, i2) {
            const o2 = r3.loc, a2 = t3.length;
            let l2 = !!o2;
            const p2 = l2 ? o2.start.line : 0, c2 = l2 ? o2.end.line : 0;
            let y2 = 0, b2 = 0;
            const x2 = this._noLineTerminator ? function() {
            } : this.newline.bind(this);
            for (let o3 = 0; o3 < a2; o3++) {
              const v2 = t3[o3], E = this._shouldPrintComment(v2, i2);
              if (2 === E) {
                l2 = false;
                break;
              }
              if (l2 && v2.loc && 1 === E) {
                const t4 = v2.loc.start.line, r4 = v2.loc.end.line;
                if (0 === e3) {
                  let e4 = 0;
                  0 === o3 ? !this._buf.hasContent() || "CommentLine" !== v2.type && t4 === r4 || (e4 = b2 = 1) : e4 = t4 - y2, y2 = r4, x2(e4), this._printComment(v2, 1), o3 + 1 === a2 && (x2(Math.max(p2 - y2, b2)), y2 = p2);
                } else if (1 === e3) {
                  const e4 = t4 - (0 === o3 ? p2 : y2);
                  y2 = r4, x2(e4), this._printComment(v2, 1), o3 + 1 === a2 && (x2(Math.min(1, c2 - y2)), y2 = c2);
                } else {
                  const e4 = t4 - (0 === o3 ? c2 - s2 : y2);
                  y2 = r4, x2(e4), this._printComment(v2, 1);
                }
              } else {
                if (l2 = false, 1 !== E) continue;
                if (1 === a2) {
                  const t4 = v2.loc ? v2.loc.start.line === v2.loc.end.line : !g.test(v2.value), s3 = t4 && !d(r3) && !h(n2) && !m(n2) && !f(r3);
                  0 === e3 ? this._printComment(v2, s3 && "ObjectExpression" !== r3.type || t4 && u(n2, { body: r3 }) ? 1 : 0) : s3 && 2 === e3 ? this._printComment(v2, 1) : this._printComment(v2, 0);
                } else 1 !== e3 || "ObjectExpression" === r3.type && r3.properties.length > 1 || "ClassBody" === r3.type || "TSInterfaceBody" === r3.type ? this._printComment(v2, 0) : this._printComment(v2, 0 === o3 ? 2 : o3 === a2 - 1 ? 3 : 0);
              }
            }
            2 === e3 && l2 && y2 && (this._lastCommentLine = y2);
          }
        }
        Object.assign(Printer.prototype, l), (0, p.addDeprecatedGenerators)(Printer);
        t2.default = Printer;
        function commaSeparator(e3, t3) {
          this.token(",", false, e3), t3 || this.space();
        }
      }, "./node_modules/.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/lib/source-map.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var n = r2("./node_modules/.pnpm/@jridgewell+gen-mapping@0.3.13/node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js"), s = r2("./node_modules/.pnpm/@jridgewell+trace-mapping@0.3.31/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js");
        t2.default = class {
          constructor(e3, t3) {
            var r3;
            this._map = void 0, this._rawMappings = void 0, this._sourceFileName = void 0, this._lastGenLine = 0, this._lastSourceLine = 0, this._lastSourceColumn = 0, this._inputMap = void 0;
            const i = this._map = new n.GenMapping({ sourceRoot: e3.sourceRoot });
            if (this._sourceFileName = null == (r3 = e3.sourceFileName) ? void 0 : r3.replace(/\\/g, "/"), this._rawMappings = void 0, e3.inputSourceMap) {
              this._inputMap = new s.TraceMap(e3.inputSourceMap);
              const t4 = this._inputMap.resolvedSources;
              if (t4.length) for (let e4 = 0; e4 < t4.length; e4++) {
                var o;
                (0, n.setSourceContent)(i, t4[e4], null == (o = this._inputMap.sourcesContent) ? void 0 : o[e4]);
              }
            }
            if ("string" != typeof t3 || e3.inputSourceMap) {
              if ("object" == typeof t3) for (const e4 of Object.keys(t3)) (0, n.setSourceContent)(i, e4.replace(/\\/g, "/"), t3[e4]);
            } else (0, n.setSourceContent)(i, this._sourceFileName, t3);
          }
          get() {
            return (0, n.toEncodedMap)(this._map);
          }
          getDecoded() {
            return (0, n.toDecodedMap)(this._map);
          }
          getRawMappings() {
            return this._rawMappings || (this._rawMappings = (0, n.allMappings)(this._map));
          }
          mark(e3, t3, r3, i, o, a) {
            var l;
            let p;
            if (this._rawMappings = void 0, null != t3) if (this._inputMap) {
              if (p = (0, s.originalPositionFor)(this._inputMap, { line: t3, column: r3 }), !p.name && o) {
                const e4 = (0, s.originalPositionFor)(this._inputMap, o);
                e4.name && (i = e4.name);
              }
            } else p = { source: (null == a ? void 0 : a.replace(/\\/g, "/")) || this._sourceFileName, line: t3, column: r3 };
            (0, n.maybeAddMapping)(this._map, { name: i, generated: e3, source: null == (l = p) ? void 0 : l.source, original: p });
          }
        };
      }, "./node_modules/.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/lib/token-map.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.TokenMap = void 0;
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/index.js");
        const { traverseFast: s, VISITOR_KEYS: i } = n;
        t2.TokenMap = class {
          constructor(e3, t3, r3) {
            this._tokens = void 0, this._source = void 0, this._nodesToTokenIndexes = /* @__PURE__ */ new Map(), this._nodesOccurrencesCountCache = /* @__PURE__ */ new Map(), this._tokensCache = /* @__PURE__ */ new Map(), this._tokens = t3, this._source = r3, s(e3, (e4) => {
              const t4 = this._getTokensIndexesOfNode(e4);
              t4.length > 0 && this._nodesToTokenIndexes.set(e4, t4);
            }), this._tokensCache = null;
          }
          has(e3) {
            return this._nodesToTokenIndexes.has(e3);
          }
          getIndexes(e3) {
            return this._nodesToTokenIndexes.get(e3);
          }
          find(e3, t3) {
            const r3 = this._nodesToTokenIndexes.get(e3);
            if (r3) for (let e4 = 0; e4 < r3.length; e4++) {
              const n2 = r3[e4], s2 = this._tokens[n2];
              if (t3(s2, n2)) return s2;
            }
            return null;
          }
          findLastIndex(e3, t3) {
            const r3 = this._nodesToTokenIndexes.get(e3);
            if (r3) for (let e4 = r3.length - 1; e4 >= 0; e4--) {
              const n2 = r3[e4];
              if (t3(this._tokens[n2], n2)) return n2;
            }
            return -1;
          }
          findMatching(e3, t3, r3 = 0) {
            const n2 = this._nodesToTokenIndexes.get(e3);
            if (n2) {
              let s2 = 0;
              const i2 = r3;
              if (i2 > 1) {
                const n3 = this._nodesOccurrencesCountCache.get(e3);
                n3 && n3.test === t3 && n3.count < i2 && (s2 = n3.i + 1, r3 -= n3.count + 1);
              }
              for (; s2 < n2.length; s2++) {
                const o = this._tokens[n2[s2]];
                if (this.matchesOriginal(o, t3)) {
                  if (0 === r3) return i2 > 0 && this._nodesOccurrencesCountCache.set(e3, { test: t3, count: i2, i: s2 }), o;
                  r3--;
                }
              }
            }
            return null;
          }
          matchesOriginal(e3, t3) {
            return e3.end - e3.start === t3.length && (null != e3.value ? e3.value === t3 : this._source.startsWith(t3, e3.start));
          }
          startMatches(e3, t3) {
            const r3 = this._nodesToTokenIndexes.get(e3);
            if (!r3) return false;
            const n2 = this._tokens[r3[0]];
            return n2.start === e3.start && this.matchesOriginal(n2, t3);
          }
          endMatches(e3, t3) {
            const r3 = this._nodesToTokenIndexes.get(e3);
            if (!r3) return false;
            const n2 = this._tokens[r3[r3.length - 1]];
            return n2.end === e3.end && this.matchesOriginal(n2, t3);
          }
          _getTokensIndexesOfNode(e3) {
            if (null == e3.start || null == e3.end) return [];
            const { first: t3, last: r3 } = this._findTokensOfNode(e3, 0, this._tokens.length - 1);
            let n2 = t3;
            const s2 = (function* (e4) {
              if ("TemplateLiteral" === e4.type) {
                yield e4.quasis[0];
                for (let t5 = 1; t5 < e4.quasis.length; t5++) yield e4.expressions[t5 - 1], yield e4.quasis[t5];
                return;
              }
              const t4 = i[e4.type];
              for (const r4 of t4) {
                const t5 = e4[r4];
                t5 && (Array.isArray(t5) ? yield* t5 : yield t5);
              }
            })(e3);
            "ExportNamedDeclaration" !== e3.type && "ExportDefaultDeclaration" !== e3.type || !e3.declaration || "ClassDeclaration" !== e3.declaration.type || s2.next();
            const o = [];
            for (const e4 of s2) {
              if (null == e4) continue;
              if (null == e4.start || null == e4.end) continue;
              const t4 = this._findTokensOfNode(e4, n2, r3), s3 = t4.first;
              for (let e5 = n2; e5 < s3; e5++) o.push(e5);
              n2 = t4.last + 1;
            }
            for (let e4 = n2; e4 <= r3; e4++) o.push(e4);
            return o;
          }
          _findTokensOfNode(e3, t3, r3) {
            const n2 = this._tokensCache.get(e3);
            if (n2) return n2;
            const s2 = this._findFirstTokenOfNode(e3.start, t3, r3), i2 = this._findLastTokenOfNode(e3.end, s2, r3);
            return this._tokensCache.set(e3, { first: s2, last: i2 }), { first: s2, last: i2 };
          }
          _findFirstTokenOfNode(e3, t3, r3) {
            for (; t3 <= r3; ) {
              const n2 = r3 + t3 >> 1;
              if (e3 < this._tokens[n2].start) r3 = n2 - 1;
              else {
                if (!(e3 > this._tokens[n2].start)) return n2;
                t3 = n2 + 1;
              }
            }
            return t3;
          }
          _findLastTokenOfNode(e3, t3, r3) {
            for (; t3 <= r3; ) {
              const n2 = r3 + t3 >> 1;
              if (e3 < this._tokens[n2].end) r3 = n2 - 1;
              else {
                if (!(e3 > this._tokens[n2].end)) return n2;
                t3 = n2 + 1;
              }
            }
            return r3;
          }
        };
      }, "./node_modules/.pnpm/@babel+helper-annotate-as-pure@7.27.3/node_modules/@babel/helper-annotate-as-pure/lib/index.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
          const t3 = e3.node || e3;
          if (isPureAnnotated(t3)) return;
          s(t3, "leading", i);
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/index.js");
        const { addComment: s } = n, i = "#__PURE__", isPureAnnotated = ({ leadingComments: e3 }) => !!e3 && e3.some((e4) => /[@#]__PURE__/.test(e4.value));
      }, "./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.28.3_@babel+core@7.28.4/node_modules/@babel/helper-create-class-features-plugin/lib/decorators-2018-09.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.buildDecoratedClass = function(e3, t3, i, o) {
          const { node: a, scope: l } = t3, p = l.generateUidIdentifier("initialize"), c = a.id && t3.isDeclaration(), u = t3.isInStrictMode(), { superClass: d } = a;
          a.type = "ClassDeclaration", a.id || (a.id = n.types.cloneNode(e3));
          let h;
          d && (h = l.generateUidIdentifierBasedOnNode(a.superClass, "super"), a.superClass = h);
          const m = takeDecorators(a), f = n.types.arrayExpression(i.filter((e4) => !e4.node.abstract && "TSIndexSignature" !== e4.node.type).map((e4) => (function(e5, t4, i2, o2) {
            const a2 = o2.isClassMethod();
            if (o2.isPrivate()) throw o2.buildCodeFrameError(`Private ${a2 ? "methods" : "fields"} in decorated classes are not supported yet.`);
            if ("ClassAccessorProperty" === o2.node.type) throw o2.buildCodeFrameError('Accessor properties are not supported in 2018-09 decorator transform, please specify { "version": "2021-12" } instead.');
            if ("StaticBlock" === o2.node.type) throw o2.buildCodeFrameError('Static blocks are not supported in 2018-09 decorator transform, please specify { "version": "2021-12" } instead.');
            const { node: l2, scope: p2 } = o2;
            o2.isTSDeclareMethod() || new s.default({ methodPath: o2, objectRef: t4, superRef: i2, file: e5, refToPreserve: t4 }).replace();
            const c2 = [prop("kind", n.types.stringLiteral(n.types.isClassMethod(l2) ? l2.kind : "field")), prop("decorators", takeDecorators(l2)), prop("static", l2.static && n.types.booleanLiteral(true)), prop("key", getKey(l2))].filter(Boolean);
            if (a2) {
              null != o2.ensureFunctionName || (o2.ensureFunctionName = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/index.js").NodePath.prototype.ensureFunctionName), o2.ensureFunctionName(false), c2.push(prop("value", n.types.toExpression(o2.node)));
            } else n.types.isClassProperty(l2) && l2.value ? c2.push((u2 = "value", d2 = n.template.statements.ast`return ${l2.value}`, n.types.objectMethod("method", n.types.identifier(u2), [], n.types.blockStatement(d2)))) : c2.push(prop("value", p2.buildUndefinedNode()));
            var u2, d2;
            return o2.remove(), n.types.objectExpression(c2);
          })(o, a.id, h, e4))), y = n.template.expression.ast`
    ${(function(e4) {
            return e4.addHelper("decorate");
          })(o)}(
      ${m || n.types.nullLiteral()},
      function (${p}, ${d ? n.types.cloneNode(h) : null}) {
        ${a}
        return { F: ${n.types.cloneNode(a.id)}, d: ${f} };
      },
      ${d}
    )
  `;
          u || y.arguments[1].body.directives.push(n.types.directive(n.types.directiveLiteral("use strict")));
          let b = y, g = "arguments.1.body.body.0";
          c && (b = n.template.statement.ast`let ${e3} = ${y}`, g = "declarations.0.init." + g);
          return { instanceNodes: [n.template.statement.ast`
        ${n.types.cloneNode(p)}(this)
      `], wrapClass: (e4) => (e4.replaceWith(b), e4.get(g)) };
        };
        var n = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/index.js"), s = r2("./node_modules/.pnpm/@babel+helper-replace-supers@7.27.1_@babel+core@7.28.4/node_modules/@babel/helper-replace-supers/lib/index.js");
        function prop(e3, t3) {
          return t3 ? n.types.objectProperty(n.types.identifier(e3), t3) : null;
        }
        function takeDecorators(e3) {
          let t3;
          return e3.decorators && e3.decorators.length > 0 && (t3 = n.types.arrayExpression(e3.decorators.map((e4) => e4.expression))), e3.decorators = void 0, t3;
        }
        function getKey(e3) {
          return e3.computed ? e3.key : n.types.isIdentifier(e3.key) ? n.types.stringLiteral(e3.key.name) : n.types.stringLiteral(String(e3.key.value));
        }
      }, "./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.28.3_@babel+core@7.28.4/node_modules/@babel/helper-create-class-features-plugin/lib/decorators.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.buildNamedEvaluationVisitor = buildNamedEvaluationVisitor, t2.default = function({ assertVersion: e3, assumption: t3 }, { loose: i2 }, c2, y) {
          var b, g;
          e3("2023-11" === c2 || "2023-05" === c2 || "2023-01" === c2 ? "^7.21.0" : "2021-12" === c2 ? "^7.16.0" : "^7.19.0");
          const x = /* @__PURE__ */ new WeakSet(), v = null != (b = t3("constantSuper")) ? b : i2, E = null != (g = t3("ignoreFunctionLength")) ? g : i2, T = buildNamedEvaluationVisitor(isDecoratedAnonymousClassExpression, visitClass);
          function visitClass(e4, t4, r3) {
            var i3;
            if (x.has(e4)) return;
            const { node: y2 } = e4;
            null != r3 || (r3 = null == (i3 = y2.id) ? void 0 : i3.name);
            const b2 = (function(e5, t5, r4, i4, c3, y3, b3) {
              var g2;
              const x2 = e5.get("body.body"), v2 = e5.node.decorators;
              let E2 = false, T2 = false, S = false;
              const P = /* @__PURE__ */ (function(e6) {
                let t6;
                return () => (t6 || (t6 = (function(e7) {
                  const t7 = [], r5 = /* @__PURE__ */ new Set();
                  return e7.traverse({ PrivateName(e8) {
                    r5.add(e8.node.id.name);
                  } }), () => {
                    let e8;
                    do {
                      incrementId(t7), e8 = String.fromCharCode(...t7);
                    } while (r5.has(e8));
                    return n.types.privateName(n.types.identifier(e8));
                  };
                })(e6)), t6());
              })(e5), _ = [], A = e5.scope.parent, memoiseExpression = (e6, t6, r5) => {
                const s2 = generateLetUidIdentifier(A, t6);
                return r5.push(n.types.assignmentExpression("=", s2, e6)), n.types.cloneNode(s2);
              };
              let C, w;
              const I = null == (g2 = e5.node.id) ? void 0 : g2.name, D = "object" == typeof c3 ? c3 : void 0, usesFunctionContextOrYieldAwait = (e6) => {
                try {
                  return n.types.traverseFast(e6, (e7) => {
                    if (n.types.isThisExpression(e7) || n.types.isSuper(e7) || n.types.isYieldExpression(e7) || n.types.isAwaitExpression(e7) || n.types.isIdentifier(e7, { name: "arguments" }) || I && n.types.isIdentifier(e7, { name: I }) || n.types.isMetaProperty(e7) && "import" !== e7.meta.name) throw null;
                  }), false;
                } catch (e7) {
                  return true;
                }
              }, k = [];
              for (const r5 of x2) {
                if (!isClassDecoratableElementPath(r5)) continue;
                const s2 = r5.node;
                if (!s2.static && n.types.isPrivateName(s2.key) && k.push(s2.key.id.name), isDecorated(s2)) {
                  switch (s2.type) {
                    case "ClassProperty":
                      y3.ClassProperty(r5, t5);
                      break;
                    case "ClassPrivateProperty":
                      y3.ClassPrivateProperty(r5, t5);
                      break;
                    case "ClassAccessorProperty":
                      if (y3.ClassAccessorProperty(r5, t5), "2023-11" === b3) break;
                    default:
                      s2.static ? null != w || (w = generateLetUidIdentifier(A, "initStatic")) : null != C || (C = generateLetUidIdentifier(A, "initProto"));
                  }
                  E2 = true, S || (S = s2.decorators.some(usesFunctionContextOrYieldAwait));
                } else if ("ClassAccessorProperty" === s2.type) {
                  y3.ClassAccessorProperty(r5, t5);
                  const { key: i5, value: o2, static: l2, computed: p2 } = s2, u2 = P(), d2 = generateClassProperty(u2, o2, l2), h2 = r5.get("key"), [m2] = r5.replaceWith(d2);
                  let f2, g3;
                  p2 && !h2.isConstantExpression() ? (f2 = (0, a.memoiseComputedKey)(createToPropertyKeyCall(t5, i5), A, A.generateUid("computedKey")), g3 = n.types.cloneNode(f2.left)) : (f2 = n.types.cloneNode(i5), g3 = n.types.cloneNode(i5)), assignIdForAnonymousClass(e5, c3), addProxyAccessorsFor(e5.node.id, m2, f2, g3, u2, p2, l2, b3);
                }
                "computed" in r5.node && r5.node.computed && (T2 || (T2 = !A.isStatic(r5.node.key)));
              }
              if (!v2 && !E2) return e5.node.id || "string" != typeof c3 || (e5.node.id = n.types.identifier(c3)), void (D && e5.node.body.body.unshift(createStaticBlockFromExpressions([createSetFunctionNameCall(t5, D)])));
              const N = [];
              let O;
              const j = /* @__PURE__ */ new Set();
              let F, L, M = null;
              function handleDecorators(e6) {
                let t6 = false, r5 = false;
                const s2 = [];
                for (const i5 of e6) {
                  const { expression: e7 } = i5;
                  let o2;
                  "2023-11" !== b3 && "2023-05" !== b3 || !n.types.isMemberExpression(e7) || (n.types.isSuper(e7.object) ? o2 = n.types.thisExpression() : A.isStatic(e7.object) ? o2 = n.types.cloneNode(e7.object) : (null != M || (M = generateLetUidIdentifier(A, "obj")), o2 = n.types.assignmentExpression("=", n.types.cloneNode(M), e7.object), e7.object = n.types.cloneNode(M))), s2.push(o2), t6 || (t6 = !A.isStatic(e7)), r5 || (r5 = usesFunctionContextOrYieldAwait(i5));
                }
                return { hasSideEffects: t6, usesFnContext: r5, decoratorsThis: s2 };
              }
              const B = T2 || S || "2023-11" !== b3;
              let R, U, V = false, $ = 0, K = [], W = [];
              if (v2) {
                F = generateLetUidIdentifier(A, "initClass"), V = e5.isClassDeclaration(), { id: L, path: e5 } = (function(e6, t7) {
                  const r6 = e6.node.id, s3 = e6.scope;
                  if ("ClassDeclaration" === e6.type) {
                    const t8 = r6.name, i6 = s3.generateUidIdentifierBasedOnNode(r6), o3 = n.types.identifier(t8);
                    return s3.rename(t8, i6.name), e6.get("id").replaceWith(o3), { id: n.types.cloneNode(i6), path: e6 };
                  }
                  {
                    let i6;
                    r6 ? (t7 = r6.name, i6 = generateLetUidIdentifier(s3.parent, t7), s3.rename(t7, i6.name)) : i6 = generateLetUidIdentifier(s3.parent, "string" == typeof t7 ? t7 : "decorated_class");
                    const o3 = n.types.classExpression("string" == typeof t7 ? n.types.identifier(t7) : null, e6.node.superClass, e6.node.body), [a2] = e6.replaceWith(n.types.sequenceExpression([o3, i6]));
                    return { id: n.types.cloneNode(i6), path: a2.get("expressions.0") };
                  }
                })(e5, c3), e5.node.decorators = null;
                const t6 = v2.some(usesPrivateField), { hasSideEffects: r5, usesFnContext: s2, decoratorsThis: i5 } = handleDecorators(v2), { haveThis: o2, decs: l2 } = generateDecorationList(v2, i5, b3);
                if ($ = o2 ? 1 : 0, K = l2, (s2 || r5 && B || t6) && (R = memoiseExpression(n.types.arrayExpression(K), "classDecs", _)), !E2) for (const t7 of e5.get("body.body")) {
                  const { node: e6 } = t7;
                  if ("computed" in e6 && e6.computed) if (t7.isClassProperty({ static: true })) {
                    if (!t7.get("key").isConstantExpression()) {
                      const t8 = e6.key, r6 = (0, a.memoiseComputedKey)(t8, A, A.generateUid("computedKey"));
                      null != r6 && (e6.key = n.types.cloneNode(r6.left), W.push(r6));
                    }
                  } else W.length > 0 && (prependExpressionsToComputedKey(W, t7), W = []);
                }
              } else assignIdForAnonymousClass(e5, c3), L = n.types.cloneNode(e5.node.id);
              let q = false, H = [], z = [];
              if (E2) {
                if (C) {
                  const e6 = n.types.callExpression(n.types.cloneNode(C), [n.types.thisExpression()]);
                  H.push(e6);
                }
                for (const i5 of x2) {
                  if (!isClassDecoratableElementPath(i5)) {
                    z.length > 0 && i5.isStaticBlock() && (prependExpressionsToStaticBlock(z, i5), z = []);
                    continue;
                  }
                  const { node: o2 } = i5, h2 = o2.decorators, m2 = !(null == h2 || !h2.length), f2 = "computed" in o2 && o2.computed;
                  let y4, g3, x3 = "computedKey";
                  if ("PrivateName" === o2.key.type ? x3 = o2.key.id.name : f2 || "Identifier" !== o2.key.type || (x3 = o2.key.name), m2) {
                    const { hasSideEffects: e6, usesFnContext: t6, decoratorsThis: r5 } = handleDecorators(h2), { decs: s2, haveThis: i6 } = generateDecorationList(h2, r5, b3);
                    g3 = i6, y4 = 1 === s2.length ? s2[0] : n.types.arrayExpression(s2), (t6 || e6 && B) && (y4 = memoiseExpression(y4, x3 + "Decs", W));
                  }
                  if (f2 && !i5.get("key").isConstantExpression()) {
                    const e6 = o2.key, r5 = (0, a.memoiseComputedKey)(m2 ? createToPropertyKeyCall(t5, e6) : e6, A, A.generateUid("computedKey"));
                    null != r5 && (v2 && i5.isClassProperty({ static: true }) ? (o2.key = n.types.cloneNode(r5.left), W.push(r5)) : o2.key = r5);
                  }
                  const { key: E3, static: T3 } = o2, S2 = "PrivateName" === E3.type, _2 = getElementKind(i5);
                  let C2;
                  if (S2 && !T3 && (m2 && (q = true), !n.types.isClassPrivateProperty(o2) && U || (U = E3)), i5.isClassMethod({ kind: "constructor" }) && (O = i5), m2) {
                    let o3, a2;
                    if (a2 = f2 ? getComputedKeyMemoiser(i5.get("key")) : "PrivateName" === E3.type ? n.types.stringLiteral(E3.id.name) : "Identifier" === E3.type ? n.types.stringLiteral(E3.name) : n.types.cloneNode(E3), _2 === p) {
                      const { value: t6 } = i5.node, r5 = "2023-11" === b3 && T3 ? [] : [n.types.thisExpression()];
                      t6 && r5.push(n.types.cloneNode(t6));
                      const s2 = P(), a3 = generateLetUidIdentifier(A, `init_${x3}`), l2 = generateClassProperty(s2, n.types.callExpression(n.types.cloneNode(a3), r5), T3), [p2] = i5.replaceWith(l2);
                      if (S2) {
                        o3 = extractProxyAccessorsFor(s2, b3);
                        const e6 = generateLetUidIdentifier(A, `get_${x3}`), t7 = generateLetUidIdentifier(A, `set_${x3}`);
                        addCallAccessorsFor(b3, p2, E3, e6, t7, T3), C2 = [a3, e6, t7];
                      } else assignIdForAnonymousClass(e5, c3), addProxyAccessorsFor(e5.node.id, p2, n.types.cloneNode(E3), n.types.isAssignmentExpression(E3) ? n.types.cloneNode(E3.left) : n.types.cloneNode(E3), s2, f2, T3, b3), C2 = [a3];
                    } else if (_2 === l) {
                      const e6 = generateLetUidIdentifier(A, `init_${x3}`), t6 = i5.get("value"), r5 = "2023-11" === b3 && T3 ? [] : [n.types.thisExpression()];
                      t6.node && r5.push(t6.node), t6.replaceWith(n.types.callExpression(n.types.cloneNode(e6), r5)), C2 = [e6], S2 && (o3 = extractProxyAccessorsFor(E3, b3));
                    } else if (S2) {
                      const a3 = generateLetUidIdentifier(A, `call_${x3}`);
                      C2 = [a3];
                      if (new s.default({ constantSuper: r4, methodPath: i5, objectRef: L, superRef: e5.node.superClass, file: t5.file, refToPreserve: L }).replace(), o3 = [createFunctionExpressionFromPrivateMethod(i5.node)], _2 === u || _2 === d) movePrivateAccessor(i5, n.types.cloneNode(E3), n.types.cloneNode(a3), T3);
                      else {
                        const t6 = i5.node;
                        e5.node.body.body.unshift(n.types.classPrivateProperty(E3, n.types.cloneNode(a3), [], t6.static)), j.add(E3.id.name), i5.remove();
                      }
                    }
                    N.push({ kind: _2, decoratorsArray: y4, decoratorsHaveThis: g3, name: a2, isStatic: T3, privateMethods: o3, locals: C2 }), i5.node && (i5.node.decorators = null);
                  }
                  if (f2 && W.length > 0 && (v2 && i5.isClassProperty({ static: true }) || (prependExpressionsToComputedKey(W, _2 === p ? i5.getNextSibling() : i5), W = [])), H.length > 0 && !T3 && (_2 === l || _2 === p) && (prependExpressionsToFieldInitializer(H, i5), H = []), z.length > 0 && T3 && (_2 === l || _2 === p) && (prependExpressionsToFieldInitializer(z, i5), z = []), m2 && "2023-11" === b3 && (_2 === l || _2 === p)) {
                    const e6 = generateLetUidIdentifier(A, `init_extra_${x3}`);
                    C2.push(e6);
                    const t6 = n.types.callExpression(n.types.cloneNode(e6), T3 ? [] : [n.types.thisExpression()]);
                    T3 ? z.push(t6) : H.push(t6);
                  }
                }
              }
              if (W.length > 0) {
                const t6 = e5.get("body.body");
                let r5;
                for (let e6 = t6.length - 1; e6 >= 0; e6--) {
                  const s2 = t6[e6], i5 = s2.node;
                  if (i5.computed) {
                    if (v2 && n.types.isClassProperty(i5, { static: true })) continue;
                    r5 = s2;
                    break;
                  }
                }
                null != r5 && (!(function(e6, t7) {
                  const r6 = t7.get("key"), s2 = getComputedKeyLastElement(r6);
                  if (s2.isConstantExpression()) prependExpressionsToComputedKey(e6, t7);
                  else {
                    const i5 = r6.scope.parent, o2 = (0, a.memoiseComputedKey)(s2.node, i5, i5.generateUid("computedKey"));
                    if (o2) {
                      const t8 = [...e6, n.types.cloneNode(o2.left)], r7 = s2.parentPath;
                      r7.isSequenceExpression() ? r7.pushContainer("expressions", t8) : s2.replaceWith(maybeSequenceExpression([n.types.cloneNode(o2), ...t8]));
                    } else prependExpressionsToComputedKey(e6, t7);
                  }
                })(W, r5), W = []);
              }
              if (H.length > 0) {
                const t6 = !!e5.node.superClass;
                O ? t6 ? (function(e6, t7, r5) {
                  t7.traverse({ CallExpression: { exit(t8) {
                    if (!t8.get("callee").isSuper()) return;
                    const s2 = [t8.node, ...e6.map((e7) => n.types.cloneNode(e7))];
                    t8.isCompletionRecord() && s2.push(n.types.thisExpression()), t8.replaceWith((function(e7, t9) {
                      if (t9) {
                        if (e7.length >= 2 && isProtoInitCallExpression(e7[1], t9)) {
                          const r6 = n.types.callExpression(n.types.cloneNode(t9), [e7[0]]);
                          e7.splice(0, 2, r6);
                        }
                        e7.length >= 2 && n.types.isThisExpression(e7[e7.length - 1]) && isProtoInitCallExpression(e7[e7.length - 2], t9) && e7.splice(e7.length - 1, 1);
                      }
                      return maybeSequenceExpression(e7);
                    })(s2, r5)), t8.skip();
                  } }, ClassMethod(e7) {
                    "constructor" === e7.node.kind && e7.skip();
                  } });
                })(H, O, C) : (function(e6, t7) {
                  t7.node.body.body.unshift(n.types.expressionStatement(maybeSequenceExpression(e6)));
                })(H, O) : e5.node.body.body.unshift(createConstructorFromExpressions(H, t6)), H = [];
              }
              z.length > 0 && (e5.node.body.body.push(createStaticBlockFromExpressions(z)), z = []);
              const G = (Y = N, [...Y.filter((e6) => e6.isStatic && e6.kind >= p && e6.kind <= d), ...Y.filter((e6) => !e6.isStatic && e6.kind >= p && e6.kind <= d), ...Y.filter((e6) => e6.isStatic && e6.kind === l), ...Y.filter((e6) => !e6.isStatic && e6.kind === l)]), X = (function(e6, t6) {
                return n.types.arrayExpression(e6.map((e7) => {
                  let r5 = e7.kind;
                  return e7.isStatic && (r5 += "2023-11" === t6 || "2023-05" === t6 ? m : h), e7.decoratorsHaveThis && (r5 += f), n.types.arrayExpression([e7.decoratorsArray, n.types.numericLiteral(r5), e7.name, ...e7.privateMethods || []]);
                }));
              })("2023-11" === b3 ? N : G, b3), J = (function(e6) {
                const t6 = [];
                for (const r5 of e6) {
                  const { locals: e7 } = r5;
                  Array.isArray(e7) ? t6.push(...e7) : void 0 !== e7 && t6.push(e7);
                }
                return t6;
              })(G);
              var Y;
              C && J.push(C);
              w && J.push(w);
              const Q = [];
              let Z = false;
              const ee = F && n.types.callExpression(n.types.cloneNode(F), []);
              let te = e5;
              const re = e5.node, ne = [];
              if (v2) {
                Q.push(L, F);
                const o2 = [];
                if (e5.get("body.body").forEach((a2) => {
                  if (a2.isStaticBlock()) {
                    if (hasInstancePrivateAccess(a2, k)) {
                      const e6 = memoiseExpression((l2 = a2.node, n.types.functionExpression(null, [], n.types.blockStatement(l2.body))), "staticBlock", ne);
                      z.push(n.types.callExpression(n.types.memberExpression(e6, n.types.identifier("call")), [n.types.thisExpression()]));
                    } else z.push((function(e6) {
                      return n.types.callExpression(n.types.arrowFunctionExpression([], n.types.blockStatement(e6.body)), []);
                    })(a2.node));
                    a2.remove();
                  } else {
                    var l2;
                    if ((a2.isClassProperty() || a2.isClassPrivateProperty()) && a2.node.static) {
                      const e6 = a2.get("value");
                      if (hasInstancePrivateAccess(e6, k)) {
                        const t6 = memoiseExpression((function(e7) {
                          return n.types.functionExpression(null, [], n.types.blockStatement([n.types.returnStatement(e7)]));
                        })(e6.node), "fieldValue", ne);
                        e6.replaceWith(n.types.callExpression(n.types.memberExpression(t6, n.types.identifier("call")), [n.types.thisExpression()]));
                      }
                      z.length > 0 && (prependExpressionsToFieldInitializer(z, a2), z = []), a2.node.static = false, o2.push(a2.node), a2.remove();
                    } else if (a2.isClassPrivateMethod({ static: true })) {
                      if (hasInstancePrivateAccess(a2, k)) {
                        new s.default({ constantSuper: r4, methodPath: a2, objectRef: L, superRef: e5.node.superClass, file: t5.file, refToPreserve: L }).replace();
                        const o3 = memoiseExpression(createFunctionExpressionFromPrivateMethod(a2.node), a2.get("key.id").node.name, ne);
                        i4 ? (a2.node.params = [n.types.restElement(n.types.identifier("arg"))], a2.node.body = n.types.blockStatement([n.types.returnStatement(n.types.callExpression(n.types.memberExpression(o3, n.types.identifier("apply")), [n.types.thisExpression(), n.types.identifier("arg")]))])) : (a2.node.params = a2.node.params.map((e6, t6) => n.types.isRestElement(e6) ? n.types.restElement(n.types.identifier("arg")) : n.types.identifier("_" + t6)), a2.node.body = n.types.blockStatement([n.types.returnStatement(n.types.callExpression(n.types.memberExpression(o3, n.types.identifier("apply")), [n.types.thisExpression(), n.types.identifier("arguments")]))]));
                      }
                      a2.node.static = false, o2.push(a2.node), a2.remove();
                    }
                  }
                }), o2.length > 0 || z.length > 0) {
                  const r5 = n.template.expression.ast`
        class extends ${t5.addHelper("identity")} {}
      `;
                  r5.body.body = [n.types.classProperty(n.types.toExpression(re), void 0, void 0, void 0, true, true), ...o2];
                  const s2 = [], i5 = n.types.newExpression(r5, []);
                  z.length > 0 && s2.push(...z), ee && (Z = true, s2.push(ee)), s2.length > 0 ? (s2.unshift(n.types.callExpression(n.types.super(), [n.types.cloneNode(L)])), r5.body.body.push(createConstructorFromExpressions(s2, false))) : i5.arguments.push(n.types.cloneNode(L));
                  const [a2] = e5.replaceWith(i5);
                  te = a2.get("callee").get("body").get("body.0.key");
                }
              }
              !Z && ee && e5.node.body.body.push(n.types.staticBlock([n.types.expressionStatement(ee)]));
              let { superClass: se } = re;
              if (se && ("2023-11" === b3 || "2023-05" === b3)) {
                const t6 = e5.scope.maybeGenerateMemoised(se);
                t6 && (re.superClass = n.types.assignmentExpression("=", t6, se), se = t6);
              }
              const ie = n.types.staticBlock([]);
              re.body.body.unshift(ie);
              const oe = ie.body;
              if (W.length > 0) {
                const e6 = te.get("body.body");
                let t6;
                for (const r5 of e6) if ((r5.isClassProperty() || r5.isClassMethod()) && "constructor" !== r5.node.kind) {
                  t6 = r5;
                  break;
                }
                null != t6 ? (!(function(e7) {
                  const { node: t7 } = e7;
                  t7.computed = true, n.types.isIdentifier(t7.key) && (t7.key = n.types.stringLiteral(t7.key.name));
                })(t6), prependExpressionsToComputedKey(W, t6)) : (re.body.body.unshift(n.types.classProperty(n.types.sequenceExpression([...W, n.types.stringLiteral("_")]), void 0, void 0, void 0, true, true)), oe.push(n.types.expressionStatement(n.types.unaryExpression("delete", n.types.memberExpression(n.types.thisExpression(), n.types.identifier("_")))))), W = [];
              }
              oe.push(n.types.expressionStatement((function(e6, t6, r5, s2, i5, o2, a2, l2, p2, c4) {
                let u2, d2;
                const h2 = [a2 ? createSetFunctionNameCall(p2, a2) : n.types.thisExpression(), s2, r5];
                "2023-11" !== c4 && h2.splice(1, 2, r5, s2);
                if ("2021-12" === c4 || "2022-03" === c4 && !p2.availableHelper("applyDecs2203R")) return u2 = n.types.arrayPattern([...e6, ...t6]), d2 = n.types.callExpression(p2.addHelper("2021-12" === c4 ? "applyDecs" : "applyDecs2203"), h2), n.types.assignmentExpression("=", u2, d2);
                "2022-03" === c4 ? d2 = n.types.callExpression(p2.addHelper("applyDecs2203R"), h2) : "2023-01" === c4 ? (o2 && h2.push(createPrivateBrandCheckClosure(o2)), d2 = n.types.callExpression(p2.addHelper("applyDecs2301"), h2)) : "2023-05" === c4 && ((o2 || l2 || 0 !== i5.value) && h2.push(i5), o2 ? h2.push(createPrivateBrandCheckClosure(o2)) : l2 && h2.push(n.types.unaryExpression("void", n.types.numericLiteral(0))), l2 && h2.push(l2), d2 = n.types.callExpression(p2.addHelper("applyDecs2305"), h2));
                "2023-11" === c4 && ((o2 || l2 || 0 !== i5.value) && h2.push(i5), o2 ? h2.push(createPrivateBrandCheckClosure(o2)) : l2 && h2.push(n.types.unaryExpression("void", n.types.numericLiteral(0))), l2 && h2.push(l2), d2 = n.types.callExpression(p2.addHelper("applyDecs2311"), h2));
                e6.length > 0 ? t6.length > 0 ? u2 = n.types.objectPattern([n.types.objectProperty(n.types.identifier("e"), n.types.arrayPattern(e6)), n.types.objectProperty(n.types.identifier("c"), n.types.arrayPattern(t6))]) : (u2 = n.types.arrayPattern(e6), d2 = n.types.memberExpression(d2, n.types.identifier("e"), false, false)) : (u2 = n.types.arrayPattern(t6), d2 = n.types.memberExpression(d2, n.types.identifier("c"), false, false));
                return n.types.assignmentExpression("=", u2, d2);
              })(J, Q, X, null != R ? R : n.types.arrayExpression(K), n.types.numericLiteral($), q ? U : null, D, n.types.cloneNode(se), t5, b3))), w && oe.push(n.types.expressionStatement(n.types.callExpression(n.types.cloneNode(w), [n.types.thisExpression()])));
              ne.length > 0 && oe.push(...ne.map((e6) => n.types.expressionStatement(e6)));
              if (e5.insertBefore(_.map((e6) => n.types.expressionStatement(e6))), V) {
                if (A.getBinding(L.name).constantViolations.length) {
                  const t6 = A.generateUidIdentifier("t" + L.name), r5 = L;
                  e5.replaceWithMultiple([n.types.variableDeclaration("let", [n.types.variableDeclarator(n.types.cloneNode(r5)), n.types.variableDeclarator(t6)]), n.types.blockStatement([n.types.variableDeclaration("let", [n.types.variableDeclarator(n.types.cloneNode(L))]), e5.node, n.types.expressionStatement(n.types.assignmentExpression("=", n.types.cloneNode(t6), n.types.cloneNode(L)))]), n.types.expressionStatement(n.types.assignmentExpression("=", n.types.cloneNode(r5), n.types.cloneNode(t6)))]);
                } else e5.insertBefore(n.types.variableDeclaration("let", [n.types.variableDeclarator(n.types.cloneNode(L))]));
              }
              j.size > 0 && (function(e6, t6) {
                const r5 = (0, o.privateNameVisitorFactory)({ PrivateName(e7, t7) {
                  if (!t7.privateNamesMap.has(e7.node.id.name)) return;
                  const r6 = e7.parentPath, n3 = r6.parentPath;
                  if ("AssignmentExpression" === n3.node.type && n3.node.left === r6.node || "UpdateExpression" === n3.node.type || "RestElement" === n3.node.type || "ArrayPattern" === n3.node.type || "ObjectProperty" === n3.node.type && n3.node.value === r6.node && "ObjectPattern" === n3.parentPath.type || "ForOfStatement" === n3.node.type && n3.node.left === r6.node) throw e7.buildCodeFrameError(`Decorated private methods are read-only, but "#${e7.node.id.name}" is updated via this expression.`);
                } }), n2 = /* @__PURE__ */ new Map();
                for (const e7 of t6) n2.set(e7, null);
                e6.traverse(r5, { privateNamesMap: n2 });
              })(e5, j);
              return e5.scope.crawl(), e5;
            })(e4, t4, v, E, r3, T, c2);
            b2 ? x.add(b2) : x.add(e4);
          }
          return { name: "proposal-decorators", inherits: y, visitor: Object.assign({ ExportDefaultDeclaration(e4, t4) {
            const { declaration: s2 } = e4.node;
            if ("ClassDeclaration" === (null == s2 ? void 0 : s2.type) && isDecorated(s2)) {
              const i3 = !s2.id;
              null != e4.splitExportDeclaration || (e4.splitExportDeclaration = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/index.js").NodePath.prototype.splitExportDeclaration);
              const o2 = e4.splitExportDeclaration();
              i3 && visitClass(o2, t4, n.types.stringLiteral("default"));
            }
          }, ExportNamedDeclaration(e4) {
            const { declaration: t4 } = e4.node;
            "ClassDeclaration" === (null == t4 ? void 0 : t4.type) && isDecorated(t4) && (null != e4.splitExportDeclaration || (e4.splitExportDeclaration = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/index.js").NodePath.prototype.splitExportDeclaration), e4.splitExportDeclaration());
          }, Class(e4, t4) {
            visitClass(e4, t4, void 0);
          } }, T) };
        }, t2.hasDecorators = function(e3) {
          return hasOwnDecorators(e3) || e3.body.body.some(hasOwnDecorators);
        }, t2.hasOwnDecorators = hasOwnDecorators;
        var n = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/index.js"), s = r2("./node_modules/.pnpm/@babel+helper-replace-supers@7.27.1_@babel+core@7.28.4/node_modules/@babel/helper-replace-supers/lib/index.js"), i = r2("./node_modules/.pnpm/@babel+helper-skip-transparent-expression-wrappers@7.27.1/node_modules/@babel/helper-skip-transparent-expression-wrappers/lib/index.js"), o = r2("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.28.3_@babel+core@7.28.4/node_modules/@babel/helper-create-class-features-plugin/lib/fields.js"), a = r2("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.28.3_@babel+core@7.28.4/node_modules/@babel/helper-create-class-features-plugin/lib/misc.js");
        function hasOwnDecorators(e3) {
          var t3;
          return !(null == (t3 = e3.decorators) || !t3.length);
        }
        function incrementId(e3, t3 = e3.length - 1) {
          if (-1 === t3) return void e3.unshift(65);
          const r3 = e3[t3];
          90 === r3 ? e3[t3] = 97 : 122 === r3 ? (e3[t3] = 65, incrementId(e3, t3 - 1)) : e3[t3] = r3 + 1;
        }
        function generateClassProperty(e3, t3, r3) {
          return "PrivateName" === e3.type ? n.types.classPrivateProperty(e3, t3, void 0, r3) : n.types.classProperty(e3, t3, void 0, void 0, r3);
        }
        function assignIdForAnonymousClass(e3, t3) {
          e3.node.id || (e3.node.id = "string" == typeof t3 ? n.types.identifier(t3) : e3.scope.generateUidIdentifier("Class"));
        }
        function addProxyAccessorsFor(e3, t3, r3, s2, i2, o2, a2, l2) {
          const p2 = "2023-11" !== l2 && "2023-05" !== l2 || !a2 ? n.types.thisExpression() : e3, c2 = n.types.blockStatement([n.types.returnStatement(n.types.memberExpression(n.types.cloneNode(p2), n.types.cloneNode(i2)))]), u2 = n.types.blockStatement([n.types.expressionStatement(n.types.assignmentExpression("=", n.types.memberExpression(n.types.cloneNode(p2), n.types.cloneNode(i2)), n.types.identifier("v")))]);
          let d2, h2;
          "PrivateName" === r3.type ? (d2 = n.types.classPrivateMethod("get", r3, [], c2, a2), h2 = n.types.classPrivateMethod("set", s2, [n.types.identifier("v")], u2, a2)) : (d2 = n.types.classMethod("get", r3, [], c2, o2, a2), h2 = n.types.classMethod("set", s2, [n.types.identifier("v")], u2, o2, a2)), t3.insertAfter(h2), t3.insertAfter(d2);
        }
        function extractProxyAccessorsFor(e3, t3) {
          return "2023-11" !== t3 && "2023-05" !== t3 && "2023-01" !== t3 ? [n.template.expression.ast`
        function () {
          return this.${n.types.cloneNode(e3)};
        }
      `, n.template.expression.ast`
        function (value) {
          this.${n.types.cloneNode(e3)} = value;
        }
      `] : [n.template.expression.ast`
      o => o.${n.types.cloneNode(e3)}
    `, n.template.expression.ast`
      (o, v) => o.${n.types.cloneNode(e3)} = v
    `];
        }
        function getComputedKeyLastElement(e3) {
          if ((e3 = (0, i.skipTransparentExprWrappers)(e3)).isSequenceExpression()) {
            const t3 = e3.get("expressions");
            return getComputedKeyLastElement(t3[t3.length - 1]);
          }
          return e3;
        }
        function getComputedKeyMemoiser(e3) {
          const t3 = getComputedKeyLastElement(e3);
          if (t3.isConstantExpression()) return n.types.cloneNode(e3.node);
          if (t3.isIdentifier() && e3.scope.hasUid(t3.node.name)) return n.types.cloneNode(e3.node);
          if (t3.isAssignmentExpression() && t3.get("left").isIdentifier()) return n.types.cloneNode(t3.node.left);
          throw new Error(`Internal Error: the computed key ${e3.toString()} has not yet been memoised.`);
        }
        function prependExpressionsToComputedKey(e3, t3) {
          const r3 = t3.get("key");
          r3.isSequenceExpression() ? e3.push(...r3.node.expressions) : e3.push(r3.node), r3.replaceWith(maybeSequenceExpression(e3));
        }
        function prependExpressionsToFieldInitializer(e3, t3) {
          const r3 = t3.get("value");
          r3.node ? e3.push(r3.node) : e3.length > 0 && (e3[e3.length - 1] = n.types.unaryExpression("void", e3[e3.length - 1])), r3.replaceWith(maybeSequenceExpression(e3));
        }
        function prependExpressionsToStaticBlock(e3, t3) {
          t3.unshiftContainer("body", n.types.expressionStatement(maybeSequenceExpression(e3)));
        }
        function isProtoInitCallExpression(e3, t3) {
          return n.types.isCallExpression(e3) && n.types.isIdentifier(e3.callee, { name: t3.name });
        }
        function createConstructorFromExpressions(e3, t3) {
          const r3 = [n.types.expressionStatement(maybeSequenceExpression(e3))];
          return t3 && r3.unshift(n.types.expressionStatement(n.types.callExpression(n.types.super(), [n.types.spreadElement(n.types.identifier("args"))]))), n.types.classMethod("constructor", n.types.identifier("constructor"), t3 ? [n.types.restElement(n.types.identifier("args"))] : [], n.types.blockStatement(r3));
        }
        function createStaticBlockFromExpressions(e3) {
          return n.types.staticBlock([n.types.expressionStatement(maybeSequenceExpression(e3))]);
        }
        const l = 0, p = 1, c = 2, u = 3, d = 4, h = 5, m = 8, f = 16;
        function getElementKind(e3) {
          switch (e3.node.type) {
            case "ClassProperty":
            case "ClassPrivateProperty":
              return l;
            case "ClassAccessorProperty":
              return p;
            case "ClassMethod":
            case "ClassPrivateMethod":
              return "get" === e3.node.kind ? u : "set" === e3.node.kind ? d : c;
          }
        }
        function generateDecorationList(e3, t3, r3) {
          const s2 = e3.length, i2 = t3.some(Boolean), o2 = [];
          for (let a2 = 0; a2 < s2; a2++) "2023-11" !== r3 && "2023-05" !== r3 || !i2 || o2.push(t3[a2] || n.types.unaryExpression("void", n.types.numericLiteral(0))), o2.push(e3[a2].expression);
          return { haveThis: i2, decs: o2 };
        }
        function addCallAccessorsFor(e3, t3, r3, s2, i2, o2) {
          t3.insertAfter(n.types.classPrivateMethod("get", n.types.cloneNode(r3), [], n.types.blockStatement([n.types.returnStatement(n.types.callExpression(n.types.cloneNode(s2), "2023-11" === e3 && o2 ? [] : [n.types.thisExpression()]))]), o2)), t3.insertAfter(n.types.classPrivateMethod("set", n.types.cloneNode(r3), [n.types.identifier("v")], n.types.blockStatement([n.types.expressionStatement(n.types.callExpression(n.types.cloneNode(i2), "2023-11" === e3 && o2 ? [n.types.identifier("v")] : [n.types.thisExpression(), n.types.identifier("v")]))]), o2));
        }
        function movePrivateAccessor(e3, t3, r3, s2) {
          let i2, o2;
          "set" === e3.node.kind ? (i2 = [n.types.identifier("v")], o2 = [n.types.expressionStatement(n.types.callExpression(r3, [n.types.thisExpression(), n.types.identifier("v")]))]) : (i2 = [], o2 = [n.types.returnStatement(n.types.callExpression(r3, [n.types.thisExpression()]))]), e3.replaceWith(n.types.classPrivateMethod(e3.node.kind, n.types.cloneNode(t3), i2, n.types.blockStatement(o2), s2));
        }
        function isClassDecoratableElementPath(e3) {
          const { type: t3 } = e3;
          return "TSDeclareMethod" !== t3 && "TSIndexSignature" !== t3 && "StaticBlock" !== t3;
        }
        function maybeSequenceExpression(e3) {
          return 0 === e3.length ? n.types.unaryExpression("void", n.types.numericLiteral(0)) : 1 === e3.length ? e3[0] : n.types.sequenceExpression(e3);
        }
        function createFunctionExpressionFromPrivateMethod(e3) {
          const { params: t3, body: r3, generator: s2, async: i2 } = e3;
          return n.types.functionExpression(void 0, t3, r3, s2, i2);
        }
        function createSetFunctionNameCall(e3, t3) {
          return n.types.callExpression(e3.addHelper("setFunctionName"), [n.types.thisExpression(), t3]);
        }
        function createToPropertyKeyCall(e3, t3) {
          return n.types.callExpression(e3.addHelper("toPropertyKey"), [t3]);
        }
        function createPrivateBrandCheckClosure(e3) {
          return n.types.arrowFunctionExpression([n.types.identifier("_")], n.types.binaryExpression("in", n.types.cloneNode(e3), n.types.identifier("_")));
        }
        function usesPrivateField(e3) {
          try {
            return n.types.traverseFast(e3, (e4) => {
              if (n.types.isPrivateName(e4)) throw null;
            }), false;
          } catch (e4) {
            return true;
          }
        }
        function hasInstancePrivateAccess(e3, t3) {
          let r3 = false;
          if (t3.length > 0) {
            const n2 = (0, o.privateNameVisitorFactory)({ PrivateName(e4, t4) {
              t4.privateNamesMap.has(e4.node.id.name) && (r3 = true, e4.stop());
            } }), s2 = /* @__PURE__ */ new Map();
            for (const e4 of t3) s2.set(e4, null);
            e3.traverse(n2, { privateNamesMap: s2 });
          }
          return r3;
        }
        function isProtoKey(e3) {
          return "Identifier" === e3.type ? "__proto__" === e3.name : "__proto__" === e3.value;
        }
        function isDecorated(e3) {
          return e3.decorators && e3.decorators.length > 0;
        }
        function shouldTransformElement(e3) {
          switch (e3.type) {
            case "ClassAccessorProperty":
              return true;
            case "ClassMethod":
            case "ClassProperty":
            case "ClassPrivateMethod":
            case "ClassPrivateProperty":
              return isDecorated(e3);
            default:
              return false;
          }
        }
        function buildNamedEvaluationVisitor(e3, t3) {
          function handleComputedProperty(e4, t4, r3) {
            switch (t4.type) {
              case "StringLiteral":
                return n.types.stringLiteral(t4.value);
              case "NumericLiteral":
              case "BigIntLiteral": {
                const r4 = t4.value + "";
                return e4.get("key").replaceWith(n.types.stringLiteral(r4)), n.types.stringLiteral(r4);
              }
              default: {
                const s2 = e4.scope.maybeGenerateMemoised(t4);
                return e4.get("key").replaceWith(n.types.assignmentExpression("=", s2, createToPropertyKeyCall(r3, t4))), n.types.cloneNode(s2);
              }
            }
          }
          return { VariableDeclarator(r3, n2) {
            const s2 = r3.node.id;
            if ("Identifier" === s2.type) {
              const o2 = (0, i.skipTransparentExprWrappers)(r3.get("init"));
              if (e3(o2)) {
                const e4 = s2.name;
                t3(o2, n2, e4);
              }
            }
          }, AssignmentExpression(r3, n2) {
            const s2 = r3.node.left;
            if ("Identifier" === s2.type) {
              const o2 = (0, i.skipTransparentExprWrappers)(r3.get("right"));
              if (e3(o2)) switch (r3.node.operator) {
                case "=":
                case "&&=":
                case "||=":
                case "??=":
                  t3(o2, n2, s2.name);
              }
            }
          }, AssignmentPattern(r3, n2) {
            const s2 = r3.node.left;
            if ("Identifier" === s2.type) {
              const o2 = (0, i.skipTransparentExprWrappers)(r3.get("right"));
              if (e3(o2)) {
                const e4 = s2.name;
                t3(o2, n2, e4);
              }
            }
          }, ObjectExpression(r3, s2) {
            for (const o2 of r3.get("properties")) {
              if (!o2.isObjectProperty()) continue;
              const { node: r4 } = o2, a2 = r4.key, l2 = (0, i.skipTransparentExprWrappers)(o2.get("value"));
              if (e3(l2)) {
                if (r4.computed) {
                  const e4 = handleComputedProperty(o2, a2, s2);
                  t3(l2, s2, e4);
                } else if (!isProtoKey(a2)) if ("Identifier" === a2.type) t3(l2, s2, a2.name);
                else {
                  const e4 = n.types.stringLiteral(a2.value + "");
                  t3(l2, s2, e4);
                }
              }
            }
          }, ClassPrivateProperty(r3, s2) {
            const { node: o2 } = r3, a2 = (0, i.skipTransparentExprWrappers)(r3.get("value"));
            if (e3(a2)) {
              const e4 = n.types.stringLiteral("#" + o2.key.id.name);
              t3(a2, s2, e4);
            }
          }, ClassAccessorProperty(r3, s2) {
            const { node: o2 } = r3, a2 = o2.key, l2 = (0, i.skipTransparentExprWrappers)(r3.get("value"));
            if (e3(l2)) if (o2.computed) {
              const e4 = handleComputedProperty(r3, a2, s2);
              t3(l2, s2, e4);
            } else if ("Identifier" === a2.type) t3(l2, s2, a2.name);
            else if ("PrivateName" === a2.type) {
              const e4 = n.types.stringLiteral("#" + a2.id.name);
              t3(l2, s2, e4);
            } else {
              const e4 = n.types.stringLiteral(a2.value + "");
              t3(l2, s2, e4);
            }
          }, ClassProperty(r3, s2) {
            const { node: o2 } = r3, a2 = o2.key, l2 = (0, i.skipTransparentExprWrappers)(r3.get("value"));
            if (e3(l2)) if (o2.computed) {
              const e4 = handleComputedProperty(r3, a2, s2);
              t3(l2, s2, e4);
            } else if ("Identifier" === a2.type) t3(l2, s2, a2.name);
            else {
              const e4 = n.types.stringLiteral(a2.value + "");
              t3(l2, s2, e4);
            }
          } };
        }
        function isDecoratedAnonymousClassExpression(e3) {
          return e3.isClassExpression({ id: null }) && (isDecorated(t3 = e3.node) || t3.body.body.some(shouldTransformElement));
          var t3;
        }
        function generateLetUidIdentifier(e3, t3) {
          const r3 = e3.generateUidIdentifier(t3);
          return e3.push({ id: r3, kind: "let" }), n.types.cloneNode(r3);
        }
      }, "./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.28.3_@babel+core@7.28.4/node_modules/@babel/helper-create-class-features-plugin/lib/features.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.FEATURES = void 0, t2.enableFeature = function(e3, t3, r3) {
          hasFeature(e3, t3) && !canIgnoreLoose(e3, t3) || (e3.set(o, e3.get(o) | t3), "#__internal__@babel/preset-env__prefer-true-but-false-is-ok-if-it-prevents-an-error" === r3 ? (setLoose(e3, t3, true), e3.set(l, e3.get(l) | t3)) : "#__internal__@babel/preset-env__prefer-false-but-true-is-ok-if-it-prevents-an-error" === r3 ? (setLoose(e3, t3, false), e3.set(l, e3.get(l) | t3)) : setLoose(e3, t3, r3));
          let n2;
          for (const [t4, r4] of i) {
            if (!hasFeature(e3, t4)) continue;
            if (canIgnoreLoose(e3, t4)) continue;
            const i2 = isLoose(e3, t4);
            if (n2 === !i2) throw new Error("'loose' mode configuration must be the same for @babel/plugin-transform-class-properties, @babel/plugin-transform-private-methods and @babel/plugin-transform-private-property-in-object (when they are enabled).\n\n" + getBabelShowConfigForHint(e3));
            n2 = i2;
            var s2 = r4;
          }
          if (void 0 !== n2) for (const [t4, r4] of i) hasFeature(e3, t4) && isLoose(e3, t4) !== n2 && (setLoose(e3, t4, n2), console.warn(`Though the "loose" option was set to "${!n2}" in your @babel/preset-env config, it will not be used for ${r4} since the "loose" mode option was set to "${n2}" for ${s2}.
The "loose" option must be the same for @babel/plugin-transform-class-properties, @babel/plugin-transform-private-methods and @babel/plugin-transform-private-property-in-object (when they are enabled): you can silence this warning by explicitly adding
	["${r4}", { "loose": ${n2} }]
to the "plugins" section of your Babel config.

` + getBabelShowConfigForHint(e3)));
        }, t2.isLoose = isLoose, t2.shouldTransform = function(e3, t3) {
          let r3 = null, i2 = null, o2 = null, a2 = null, l2 = null;
          (0, n.hasOwnDecorators)(e3.node) && (r3 = e3.get("decorators.0"));
          for (const t4 of e3.get("body.body")) !r3 && (0, n.hasOwnDecorators)(t4.node) && (r3 = t4.get("decorators.0")), !i2 && t4.isClassProperty() && (i2 = t4), !o2 && t4.isClassPrivateProperty() && (o2 = t4), !a2 && null != t4.isClassPrivateMethod && t4.isClassPrivateMethod() && (a2 = t4), !l2 && null != t4.isStaticBlock && t4.isStaticBlock() && (l2 = t4);
          if (r3 && o2) throw o2.buildCodeFrameError("Private fields in decorated classes are not supported yet.");
          if (r3 && a2) throw a2.buildCodeFrameError("Private methods in decorated classes are not supported yet.");
          if (r3 && !hasFeature(t3, s.decorators)) throw e3.buildCodeFrameError('Decorators are not enabled.\nIf you are using ["@babel/plugin-proposal-decorators", { "version": "legacy" }], make sure it comes *before* "@babel/plugin-transform-class-properties" and enable loose mode, like so:\n	["@babel/plugin-proposal-decorators", { "version": "legacy" }]\n	["@babel/plugin-transform-class-properties", { "loose": true }]');
          if (a2 && !hasFeature(t3, s.privateMethods)) throw a2.buildCodeFrameError("Class private methods are not enabled. Please add `@babel/plugin-transform-private-methods` to your configuration.");
          if ((i2 || o2) && !hasFeature(t3, s.fields) && !hasFeature(t3, s.privateMethods)) throw e3.buildCodeFrameError("Class fields are not enabled. Please add `@babel/plugin-transform-class-properties` to your configuration.");
          if (l2 && !hasFeature(t3, s.staticBlocks)) throw e3.buildCodeFrameError("Static class blocks are not enabled. Please add `@babel/plugin-transform-class-static-block` to your configuration.");
          if (r3 || a2 || l2) return true;
          if ((i2 || o2) && hasFeature(t3, s.fields)) return true;
          return false;
        };
        var n = r2("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.28.3_@babel+core@7.28.4/node_modules/@babel/helper-create-class-features-plugin/lib/decorators.js");
        const s = t2.FEATURES = Object.freeze({ fields: 2, privateMethods: 4, decorators: 8, privateIn: 16, staticBlocks: 32 }), i = /* @__PURE__ */ new Map([[s.fields, "@babel/plugin-transform-class-properties"], [s.privateMethods, "@babel/plugin-transform-private-methods"], [s.privateIn, "@babel/plugin-transform-private-property-in-object"]]), o = "@babel/plugin-class-features/featuresKey", a = "@babel/plugin-class-features/looseKey";
        var l = "@babel/plugin-class-features/looseLowPriorityKey/#__internal__@babel/preset-env__please-overwrite-loose-instead-of-throwing", canIgnoreLoose = function(e3, t3) {
          return !!(e3.get(l) & t3);
        };
        function getBabelShowConfigForHint(e3) {
          let { filename: t3 } = e3.opts;
          return t3 && "unknown" !== t3 || (t3 = "[name of the input file]"), `If you already set the same 'loose' mode for these plugins in your config, it's possible that they are enabled multiple times with different options.
You can re-run Babel with the BABEL_SHOW_CONFIG_FOR environment variable to show the loaded configuration:
	npx cross-env BABEL_SHOW_CONFIG_FOR=${t3} <your build command>
See https://babeljs.io/docs/configuration#print-effective-configs for more info.`;
        }
        function hasFeature(e3, t3) {
          return !!(e3.get(o) & t3);
        }
        function isLoose(e3, t3) {
          return !!(e3.get(a) & t3);
        }
        function setLoose(e3, t3, r3) {
          r3 ? e3.set(a, e3.get(a) | t3) : e3.set(a, e3.get(a) & ~t3), e3.set(l, e3.get(l) & ~t3);
        }
      }, "./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.28.3_@babel+core@7.28.4/node_modules/@babel/helper-create-class-features-plugin/lib/fields.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.buildCheckInRHS = buildCheckInRHS, t2.buildFieldsInitNodes = function(e3, t3, r3, s2, o2, a2, l2, p2, u2, d2) {
          let h2, m2 = 0;
          const f2 = [], y2 = [];
          let b = false;
          const g = [];
          let x = null;
          const v = n.types.isIdentifier(t3) ? () => t3 : () => (null != h2 || (h2 = r3[0].scope.generateUidIdentifierBasedOnNode(t3)), h2), E = null != e3 ? e3 : r3[0].scope.generateUidIdentifier((null == d2 ? void 0 : d2.name) || "Class");
          null != e3 || (e3 = n.types.cloneNode(d2));
          for (const t4 of r3) {
            t4.isClassProperty() && c.assertFieldTransformed(t4);
            const r4 = !(null != n.types.isStaticBlock && n.types.isStaticBlock(t4.node)) && t4.node.static, h3 = !r4, x2 = t4.isPrivate(), T = !x2, S = t4.isProperty(), P = !S, _ = null == t4.isStaticBlock ? void 0 : t4.isStaticBlock();
            if (r4 && (m2 |= 1), r4 || P && x2 || _) {
              new i.default({ methodPath: t4, constantSuper: u2, file: o2, refToPreserve: d2, getSuperRef: v, getObjectRef: () => (m2 |= 2, r4 || _ ? E : n.types.memberExpression(E, n.types.identifier("prototype"))) }).replace();
              replaceThisContext(t4, E, d2) && (m2 |= 2);
            }
            switch (b = false, true) {
              case _: {
                const e4 = t4.node.body;
                1 === e4.length && n.types.isExpressionStatement(e4[0]) ? f2.push(inheritPropComments(e4[0], t4)) : f2.push(n.types.inheritsComments(n.template.statement.ast`(() => { ${e4} })()`, t4.node));
                break;
              }
              case (r4 && x2 && S && l2):
                f2.push(buildPrivateFieldInitLoose(n.types.cloneNode(e3), t4, s2));
                break;
              case (r4 && x2 && S && !l2):
                newHelpers(o2) ? f2.push(buildPrivateStaticFieldInitSpec(t4, s2, p2)) : f2.push(buildPrivateStaticFieldInitSpecOld(t4, s2));
                break;
              case (r4 && T && S && a2):
                if (!isNameOrLength(t4.node)) {
                  f2.push(buildPublicFieldInitLoose(n.types.cloneNode(e3), t4));
                  break;
                }
              case (r4 && T && S && !a2):
                f2.push(buildPublicFieldInitSpec(n.types.cloneNode(e3), t4, o2));
                break;
              case (h3 && x2 && S && l2):
                y2.push(buildPrivateFieldInitLoose(n.types.thisExpression(), t4, s2));
                break;
              case (h3 && x2 && S && !l2):
                y2.push(buildPrivateInstanceFieldInitSpec(n.types.thisExpression(), t4, s2, o2));
                break;
              case (h3 && x2 && P && l2):
                y2.unshift(buildPrivateMethodInitLoose(n.types.thisExpression(), t4, s2)), g.push(buildPrivateMethodDeclaration(o2, t4, s2, l2));
                break;
              case (h3 && x2 && P && !l2):
                y2.unshift(buildPrivateInstanceMethodInitSpec(n.types.thisExpression(), t4, s2, o2)), g.push(buildPrivateMethodDeclaration(o2, t4, s2, l2));
                break;
              case (r4 && x2 && P && !l2):
                newHelpers(o2) || f2.unshift(buildPrivateStaticFieldInitSpecOld(t4, s2)), g.push(buildPrivateMethodDeclaration(o2, t4, s2, l2));
                break;
              case (r4 && x2 && P && l2):
                f2.unshift(buildPrivateStaticMethodInitLoose(n.types.cloneNode(e3), t4, o2, s2)), g.push(buildPrivateMethodDeclaration(o2, t4, s2, l2));
                break;
              case (h3 && T && S && a2):
                y2.push(buildPublicFieldInitLoose(n.types.thisExpression(), t4));
                break;
              case (h3 && T && S && !a2):
                b = true, y2.push(buildPublicFieldInitSpec(n.types.thisExpression(), t4, o2));
                break;
              default:
                throw new Error("Unreachable.");
            }
          }
          2 & m2 && null != d2 && (x = n.types.expressionStatement(n.types.assignmentExpression("=", n.types.cloneNode(E), n.types.cloneNode(d2))));
          return { staticNodes: f2.filter(Boolean), instanceNodes: y2.filter(Boolean), lastInstanceNodeReturnsThis: b, pureStaticNodes: g.filter(Boolean), classBindingNode: x, wrapClass(t4) {
            for (const e4 of r3) e4.node.leadingComments = null, e4.remove();
            return h2 && (t4.scope.push({ id: n.types.cloneNode(h2) }), t4.set("superClass", n.types.assignmentExpression("=", h2, t4.node.superClass))), 0 !== m2 && (t4.isClassExpression() ? (t4.scope.push({ id: e3 }), t4.replaceWith(n.types.assignmentExpression("=", n.types.cloneNode(e3), t4.node))) : (null == d2 && (t4.node.id = e3), null != x && t4.scope.push({ id: E }))), t4;
          } };
        }, t2.buildPrivateNamesMap = function(e3, t3, r3, s2) {
          const i2 = /* @__PURE__ */ new Map();
          let o2;
          for (const a2 of r3) if (a2.isPrivate()) {
            const { name: r4 } = a2.node.key.id;
            let l2 = i2.get(r4);
            if (!l2) {
              const n2 = !a2.isProperty(), p2 = a2.node.static;
              let c2, u2 = false;
              !t3 && newHelpers(s2) && n2 && !p2 ? (u2 = !!o2, null != o2 || (o2 = a2.scope.generateUidIdentifier(`${e3}_brand`)), c2 = o2) : c2 = a2.scope.generateUidIdentifier(r4), l2 = { id: c2, static: p2, method: n2, initAdded: u2 }, i2.set(r4, l2);
            }
            if (a2.isClassPrivateMethod()) if ("get" === a2.node.kind) {
              const { body: e4 } = a2.node.body;
              let t4;
              1 === e4.length && n.types.isReturnStatement(t4 = e4[0]) && n.types.isCallExpression(t4 = t4.argument) && 1 === t4.arguments.length && n.types.isThisExpression(t4.arguments[0]) && n.types.isIdentifier(t4 = t4.callee) ? (l2.getId = n.types.cloneNode(t4), l2.getterDeclared = true) : l2.getId = a2.scope.generateUidIdentifier(`get_${r4}`);
            } else if ("set" === a2.node.kind) {
              const { params: e4 } = a2.node, { body: t4 } = a2.node.body;
              let s3;
              1 === t4.length && n.types.isExpressionStatement(s3 = t4[0]) && n.types.isCallExpression(s3 = s3.expression) && 2 === s3.arguments.length && n.types.isThisExpression(s3.arguments[0]) && n.types.isIdentifier(s3.arguments[1], { name: e4[0].name }) && n.types.isIdentifier(s3 = s3.callee) ? (l2.setId = n.types.cloneNode(s3), l2.setterDeclared = true) : l2.setId = a2.scope.generateUidIdentifier(`set_${r4}`);
            } else "method" === a2.node.kind && (l2.methodId = a2.scope.generateUidIdentifier(r4));
            i2.set(r4, l2);
          }
          return i2;
        }, t2.buildPrivateNamesNodes = function(e3, t3, r3, s2) {
          const i2 = [], o2 = /* @__PURE__ */ new Set();
          for (const [a2, p2] of e3) {
            const { static: e4, method: c2, getId: u2, setId: d2 } = p2, h2 = u2 || d2, m2 = n.types.cloneNode(p2.id);
            let f2;
            if (t3) f2 = n.types.callExpression(s2.addHelper("classPrivateFieldLooseKey"), [n.types.stringLiteral(a2)]);
            else if (r3) f2 = n.types.callExpression(n.types.identifier("Symbol"), [n.types.stringLiteral(a2)]);
            else if (!e4) {
              if (o2.has(m2.name)) continue;
              o2.add(m2.name), f2 = n.types.newExpression(n.types.identifier(!c2 || h2 && !newHelpers(s2) ? "WeakMap" : "WeakSet"), []);
            }
            f2 && (r3 || (0, l.default)(f2), i2.push(n.template.statement.ast`var ${m2} = ${f2}`));
          }
          return i2;
        }, t2.privateNameVisitorFactory = privateNameVisitorFactory, t2.transformPrivateNamesUsage = function(e3, t3, r3, { privateFieldsAsProperties: n2, noUninitializedPrivateFieldAccess: s2, noDocumentAll: i2, innerBinding: a2 }, l2) {
          if (!r3.size) return;
          const p2 = t3.get("body"), c2 = n2 ? m : h;
          (0, o.default)(p2, u, Object.assign({ privateNamesMap: r3, classRef: e3, file: l2 }, c2, { noDocumentAll: i2, noUninitializedPrivateFieldAccess: s2, innerBinding: a2 })), p2.traverse(d, { privateNamesMap: r3, classRef: e3, file: l2, privateFieldsAsProperties: n2, innerBinding: a2 });
        };
        var n = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/index.js"), s = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/index.js"), i = r2("./node_modules/.pnpm/@babel+helper-replace-supers@7.27.1_@babel+core@7.28.4/node_modules/@babel/helper-replace-supers/lib/index.js"), o = r2("./node_modules/.pnpm/@babel+helper-member-expression-to-functions@7.27.1/node_modules/@babel/helper-member-expression-to-functions/lib/index.js"), a = r2("./node_modules/.pnpm/@babel+helper-optimise-call-expression@7.27.1/node_modules/@babel/helper-optimise-call-expression/lib/index.js"), l = r2("./node_modules/.pnpm/@babel+helper-annotate-as-pure@7.27.3/node_modules/@babel/helper-annotate-as-pure/lib/index.js"), p = r2("./node_modules/.pnpm/@babel+helper-skip-transparent-expression-wrappers@7.27.1/node_modules/@babel/helper-skip-transparent-expression-wrappers/lib/index.js"), c = r2("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.28.3_@babel+core@7.28.4/node_modules/@babel/helper-create-class-features-plugin/lib/typescript.js"), newHelpers = (e3) => e3.availableHelper("classPrivateFieldGet2");
        function privateNameVisitorFactory(e3) {
          const t3 = s.visitors.environmentVisitor(Object.assign({}, e3)), r3 = Object.assign({}, e3, { Class(e4) {
            const { privateNamesMap: n2 } = this, s2 = e4.get("body.body"), i2 = new Map(n2), o2 = [];
            for (const e5 of s2) {
              if (!e5.isPrivate()) continue;
              const { name: t4 } = e5.node.key.id;
              i2.delete(t4), o2.push(t4);
            }
            o2.length && (e4.get("body").traverse(t3, Object.assign({}, this, { redeclared: o2 })), e4.traverse(r3, Object.assign({}, this, { privateNamesMap: i2 })), e4.skipKey("body"));
          } });
          return r3;
        }
        const u = privateNameVisitorFactory({ PrivateName(e3, { noDocumentAll: t3 }) {
          const { privateNamesMap: r3, redeclared: n2 } = this, { node: s2, parentPath: i2 } = e3;
          if (!i2.isMemberExpression({ property: s2 }) && !i2.isOptionalMemberExpression({ property: s2 })) return;
          const { name: o2 } = s2.id;
          r3.has(o2) && (null != n2 && n2.includes(o2) || this.handle(i2, t3));
        } });
        function unshadow(e3, t3, r3) {
          for (; null != (n2 = t3) && n2.hasBinding(e3) && !t3.bindingIdentifierEquals(e3, r3); ) {
            var n2;
            t3.rename(e3), t3 = t3.parent;
          }
        }
        function buildCheckInRHS(e3, t3, r3) {
          return r3 || null == t3.availableHelper || !t3.availableHelper("checkInRHS") ? e3 : n.types.callExpression(t3.addHelper("checkInRHS"), [e3]);
        }
        const d = privateNameVisitorFactory({ BinaryExpression(e3, { file: t3 }) {
          const { operator: r3, left: s2, right: i2 } = e3.node;
          if ("in" !== r3) return;
          if (!n.types.isPrivateName(s2)) return;
          const { privateFieldsAsProperties: o2, privateNamesMap: a2, redeclared: l2 } = this, { name: p2 } = s2.id;
          if (!a2.has(p2)) return;
          if (null != l2 && l2.includes(p2)) return;
          if (unshadow(this.classRef.name, e3.scope, this.innerBinding), o2) {
            const { id: r4 } = a2.get(p2);
            return void e3.replaceWith(n.template.expression.ast`
        Object.prototype.hasOwnProperty.call(${buildCheckInRHS(i2, t3)}, ${n.types.cloneNode(r4)})
      `);
          }
          const { id: c2, static: u2 } = a2.get(p2);
          u2 ? e3.replaceWith(n.template.expression.ast`${buildCheckInRHS(i2, t3)} === ${n.types.cloneNode(this.classRef)}`) : e3.replaceWith(n.template.expression.ast`${n.types.cloneNode(c2)}.has(${buildCheckInRHS(i2, t3)})`);
        } });
        function readOnlyError(e3, t3) {
          return n.types.callExpression(e3.addHelper("readOnlyError"), [n.types.stringLiteral(`#${t3}`)]);
        }
        function writeOnlyError(e3, t3) {
          return e3.availableHelper("writeOnlyError") ? n.types.callExpression(e3.addHelper("writeOnlyError"), [n.types.stringLiteral(`#${t3}`)]) : (console.warn("@babel/helpers is outdated, update it to silence this warning."), n.types.buildUndefinedNode());
        }
        function buildStaticPrivateFieldAccess(e3, t3) {
          return t3 ? e3 : n.types.memberExpression(e3, n.types.identifier("_"));
        }
        function autoInherits(e3) {
          return function(t3) {
            return n.types.inherits(e3.apply(this, arguments), t3.node);
          };
        }
        const h = { memoise(e3, t3) {
          const { scope: r3 } = e3, { object: n2 } = e3.node, s2 = r3.maybeGenerateMemoised(n2);
          s2 && this.memoiser.set(n2, s2, t3);
        }, receiver(e3) {
          const { object: t3 } = e3.node;
          return this.memoiser.has(t3) ? n.types.cloneNode(this.memoiser.get(t3)) : n.types.cloneNode(t3);
        }, get: autoInherits(function(e3) {
          const { classRef: t3, privateNamesMap: r3, file: s2, innerBinding: i2, noUninitializedPrivateFieldAccess: o2 } = this, a2 = e3.node.property, { name: l2 } = a2.id, { id: p2, static: c2, method: u2, methodId: d2, getId: h2, setId: m2 } = r3.get(l2), f2 = h2 || m2, cloneId = (e4) => n.types.inherits(n.types.cloneNode(e4), a2);
          if (c2) {
            if (unshadow(t3.name, e3.scope, i2), !newHelpers(s2)) {
              const r5 = u2 && !f2 ? "classStaticPrivateMethodGet" : "classStaticPrivateFieldSpecGet";
              return n.types.callExpression(s2.addHelper(r5), [this.receiver(e3), n.types.cloneNode(t3), cloneId(p2)]);
            }
            const r4 = this.receiver(e3), a3 = n.types.isIdentifier(r4) && r4.name === t3.name;
            if (!u2) return buildStaticPrivateFieldAccess(a3 ? cloneId(p2) : n.types.callExpression(s2.addHelper("assertClassBrand"), [n.types.cloneNode(t3), r4, cloneId(p2)]), o2);
            if (h2) return a3 ? n.types.callExpression(cloneId(h2), [r4]) : n.types.callExpression(s2.addHelper("classPrivateGetter"), [n.types.cloneNode(t3), r4, cloneId(h2)]);
            if (m2) {
              const e4 = n.types.buildUndefinedNode();
              return a3 ? e4 : n.types.sequenceExpression([n.types.callExpression(s2.addHelper("assertClassBrand"), [n.types.cloneNode(t3), r4]), e4]);
            }
            return a3 ? cloneId(p2) : n.types.callExpression(s2.addHelper("assertClassBrand"), [n.types.cloneNode(t3), r4, cloneId(p2)]);
          }
          return u2 ? f2 ? h2 ? newHelpers(s2) ? n.types.callExpression(s2.addHelper("classPrivateGetter"), [n.types.cloneNode(p2), this.receiver(e3), cloneId(h2)]) : n.types.callExpression(s2.addHelper("classPrivateFieldGet"), [this.receiver(e3), cloneId(p2)]) : n.types.sequenceExpression([this.receiver(e3), writeOnlyError(s2, l2)]) : newHelpers(s2) ? n.types.callExpression(s2.addHelper("assertClassBrand"), [n.types.cloneNode(p2), this.receiver(e3), cloneId(d2)]) : n.types.callExpression(s2.addHelper("classPrivateMethodGet"), [this.receiver(e3), n.types.cloneNode(p2), cloneId(d2)]) : newHelpers(s2) ? n.types.callExpression(s2.addHelper("classPrivateFieldGet2"), [cloneId(p2), this.receiver(e3)]) : n.types.callExpression(s2.addHelper("classPrivateFieldGet"), [this.receiver(e3), cloneId(p2)]);
        }), boundGet(e3) {
          return this.memoise(e3, 1), n.types.callExpression(n.types.memberExpression(this.get(e3), n.types.identifier("bind")), [this.receiver(e3)]);
        }, set: autoInherits(function(e3, t3) {
          const { classRef: r3, privateNamesMap: s2, file: i2, noUninitializedPrivateFieldAccess: o2 } = this, a2 = e3.node.property, { name: l2 } = a2.id, { id: p2, static: c2, method: u2, setId: d2, getId: h2 } = s2.get(l2), m2 = h2 || d2, cloneId = (e4) => n.types.inherits(n.types.cloneNode(e4), a2);
          if (c2) {
            if (!newHelpers(i2)) {
              const s4 = u2 && !m2 ? "classStaticPrivateMethodSet" : "classStaticPrivateFieldSpecSet";
              return n.types.callExpression(i2.addHelper(s4), [this.receiver(e3), n.types.cloneNode(r3), cloneId(p2), t3]);
            }
            const s3 = this.receiver(e3), a3 = n.types.isIdentifier(s3) && s3.name === r3.name;
            if (u2 && !d2) {
              const e4 = readOnlyError(i2, l2);
              return a3 ? n.types.sequenceExpression([t3, e4]) : n.types.sequenceExpression([t3, n.types.callExpression(i2.addHelper("assertClassBrand"), [n.types.cloneNode(r3), s3]), readOnlyError(i2, l2)]);
            }
            return d2 ? a3 ? n.types.callExpression(n.types.cloneNode(d2), [s3, t3]) : n.types.callExpression(i2.addHelper("classPrivateSetter"), [n.types.cloneNode(r3), cloneId(d2), s3, t3]) : n.types.assignmentExpression("=", buildStaticPrivateFieldAccess(cloneId(p2), o2), a3 ? t3 : n.types.callExpression(i2.addHelper("assertClassBrand"), [n.types.cloneNode(r3), s3, t3]));
          }
          return u2 ? d2 ? newHelpers(i2) ? n.types.callExpression(i2.addHelper("classPrivateSetter"), [n.types.cloneNode(p2), cloneId(d2), this.receiver(e3), t3]) : n.types.callExpression(i2.addHelper("classPrivateFieldSet"), [this.receiver(e3), cloneId(p2), t3]) : n.types.sequenceExpression([this.receiver(e3), t3, readOnlyError(i2, l2)]) : newHelpers(i2) ? n.types.callExpression(i2.addHelper("classPrivateFieldSet2"), [cloneId(p2), this.receiver(e3), t3]) : n.types.callExpression(i2.addHelper("classPrivateFieldSet"), [this.receiver(e3), cloneId(p2), t3]);
        }), destructureSet(e3) {
          const { classRef: t3, privateNamesMap: r3, file: s2, noUninitializedPrivateFieldAccess: i2 } = this, o2 = e3.node.property, { name: a2 } = o2.id, { id: l2, static: p2, method: c2, setId: u2 } = r3.get(a2), cloneId = (e4) => n.types.inherits(n.types.cloneNode(e4), o2);
          if (!newHelpers(s2)) {
            if (p2) {
              try {
                var d2 = s2.addHelper("classStaticPrivateFieldDestructureSet");
              } catch (e4) {
                throw new Error("Babel can not transpile `[C.#p] = [0]` with @babel/helpers < 7.13.10, \nplease update @babel/helpers to the latest version.");
              }
              return n.types.memberExpression(n.types.callExpression(d2, [this.receiver(e3), n.types.cloneNode(t3), cloneId(l2)]), n.types.identifier("value"));
            }
            return n.types.memberExpression(n.types.callExpression(s2.addHelper("classPrivateFieldDestructureSet"), [this.receiver(e3), cloneId(l2)]), n.types.identifier("value"));
          }
          if (c2 && !u2) return n.types.memberExpression(n.types.sequenceExpression([e3.node.object, readOnlyError(s2, a2)]), n.types.identifier("_"));
          if (p2 && !c2) {
            const t4 = this.get(e3);
            if (!i2 || !n.types.isCallExpression(t4)) return t4;
            const r4 = t4.arguments.pop();
            return t4.arguments.push(n.template.expression.ast`(_) => ${r4} = _`), n.types.memberExpression(n.types.callExpression(s2.addHelper("toSetter"), [t4]), n.types.identifier("_"));
          }
          const h2 = this.set(e3, n.types.identifier("_"));
          if (!n.types.isCallExpression(h2) || !n.types.isIdentifier(h2.arguments[h2.arguments.length - 1], { name: "_" })) throw e3.buildCodeFrameError("Internal Babel error while compiling this code. This is a Babel bug. Please report it at https://github.com/babel/babel/issues.");
          let m2;
          return m2 = n.types.isMemberExpression(h2.callee, { computed: false }) && n.types.isIdentifier(h2.callee.property) && "call" === h2.callee.property.name ? [h2.callee.object, n.types.arrayExpression(h2.arguments.slice(1, -1)), h2.arguments[0]] : [h2.callee, n.types.arrayExpression(h2.arguments.slice(0, -1))], n.types.memberExpression(n.types.callExpression(s2.addHelper("toSetter"), m2), n.types.identifier("_"));
        }, call(e3, t3) {
          return this.memoise(e3, 1), (0, a.default)(this.get(e3), this.receiver(e3), t3, false);
        }, optionalCall(e3, t3) {
          return this.memoise(e3, 1), (0, a.default)(this.get(e3), this.receiver(e3), t3, true);
        }, delete() {
          throw new Error("Internal Babel error: deleting private elements is a parsing error.");
        } }, m = { get(e3) {
          const { privateNamesMap: t3, file: r3 } = this, { object: s2 } = e3.node, { name: i2 } = e3.node.property.id;
          return n.template.expression`BASE(REF, PROP)[PROP]`({ BASE: r3.addHelper("classPrivateFieldLooseBase"), REF: n.types.cloneNode(s2), PROP: n.types.cloneNode(t3.get(i2).id) });
        }, set() {
          throw new Error("private name handler with loose = true don't need set()");
        }, boundGet(e3) {
          return n.types.callExpression(n.types.memberExpression(this.get(e3), n.types.identifier("bind")), [n.types.cloneNode(e3.node.object)]);
        }, simpleSet(e3) {
          return this.get(e3);
        }, destructureSet(e3) {
          return this.get(e3);
        }, call(e3, t3) {
          return n.types.callExpression(this.get(e3), t3);
        }, optionalCall(e3, t3) {
          return n.types.optionalCallExpression(this.get(e3), t3, true);
        }, delete() {
          throw new Error("Internal Babel error: deleting private elements is a parsing error.");
        } };
        function buildPrivateFieldInitLoose(e3, t3, r3) {
          const { id: s2 } = r3.get(t3.node.key.id.name), i2 = t3.node.value || t3.scope.buildUndefinedNode();
          return inheritPropComments(n.template.statement.ast`
      Object.defineProperty(${e3}, ${n.types.cloneNode(s2)}, {
        // configurable is false by default
        // enumerable is false by default
        writable: true,
        value: ${i2}
      });
    `, t3);
        }
        function buildPrivateInstanceFieldInitSpec(e3, t3, r3, s2) {
          const { id: i2 } = r3.get(t3.node.key.id.name), o2 = t3.node.value || t3.scope.buildUndefinedNode();
          if (!s2.availableHelper("classPrivateFieldInitSpec")) return inheritPropComments(n.template.statement.ast`${n.types.cloneNode(i2)}.set(${e3}, {
          // configurable is always false for private elements
          // enumerable is always false for private elements
          writable: true,
          value: ${o2},
        })`, t3);
          const a2 = s2.addHelper("classPrivateFieldInitSpec");
          return inheritLoc(inheritPropComments(n.types.expressionStatement(n.types.callExpression(a2, [n.types.thisExpression(), inheritLoc(n.types.cloneNode(i2), t3.node.key), newHelpers(s2) ? o2 : n.template.expression.ast`{ writable: true, value: ${o2} }`])), t3), t3.node);
        }
        function buildPrivateStaticFieldInitSpec(e3, t3, r3) {
          const s2 = t3.get(e3.node.key.id.name), i2 = r3 ? e3.node.value : n.template.expression.ast`{
        _: ${e3.node.value || n.types.buildUndefinedNode()}
      }`;
          return inheritPropComments(n.types.variableDeclaration("var", [n.types.variableDeclarator(n.types.cloneNode(s2.id), i2)]), e3);
        }
        var buildPrivateStaticFieldInitSpecOld = function(e3, t3) {
          const r3 = t3.get(e3.node.key.id.name), { id: s2, getId: i2, setId: o2, initAdded: a2 } = r3, l2 = i2 || o2;
          if (!e3.isProperty() && (a2 || !l2)) return;
          if (l2) return t3.set(e3.node.key.id.name, Object.assign({}, r3, { initAdded: true })), inheritPropComments(n.template.statement.ast`
          var ${n.types.cloneNode(s2)} = {
            // configurable is false by default
            // enumerable is false by default
            // writable is false by default
            get: ${i2 ? i2.name : e3.scope.buildUndefinedNode()},
            set: ${o2 ? o2.name : e3.scope.buildUndefinedNode()}
          }
        `, e3);
          const p2 = e3.node.value || e3.scope.buildUndefinedNode();
          return inheritPropComments(n.template.statement.ast`
        var ${n.types.cloneNode(s2)} = {
          // configurable is false by default
          // enumerable is false by default
          writable: true,
          value: ${p2}
        };
      `, e3);
        };
        function buildPrivateMethodInitLoose(e3, t3, r3) {
          const s2 = r3.get(t3.node.key.id.name), { methodId: i2, id: o2, getId: a2, setId: l2, initAdded: p2 } = s2;
          if (p2) return;
          if (i2) return inheritPropComments(n.template.statement.ast`
        Object.defineProperty(${e3}, ${o2}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          value: ${i2.name}
        });
      `, t3);
          return a2 || l2 ? (r3.set(t3.node.key.id.name, Object.assign({}, s2, { initAdded: true })), inheritPropComments(n.template.statement.ast`
        Object.defineProperty(${e3}, ${o2}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          get: ${a2 ? a2.name : t3.scope.buildUndefinedNode()},
          set: ${l2 ? l2.name : t3.scope.buildUndefinedNode()}
        });
      `, t3)) : void 0;
        }
        function buildPrivateInstanceMethodInitSpec(e3, t3, r3, s2) {
          const i2 = r3.get(t3.node.key.id.name);
          if (!i2.initAdded) {
            if (!newHelpers(s2)) {
              if (i2.getId || i2.setId) return (function(e4, t4, r4, s3) {
                const i3 = r4.get(t4.node.key.id.name), { id: o2, getId: a2, setId: l2 } = i3;
                if (r4.set(t4.node.key.id.name, Object.assign({}, i3, { initAdded: true })), !s3.availableHelper("classPrivateFieldInitSpec")) return inheritPropComments(n.template.statement.ast`
          ${o2}.set(${e4}, {
            get: ${a2 ? a2.name : t4.scope.buildUndefinedNode()},
            set: ${l2 ? l2.name : t4.scope.buildUndefinedNode()}
          });
        `, t4);
                const p2 = s3.addHelper("classPrivateFieldInitSpec");
                return inheritLoc(inheritPropComments(n.template.statement.ast`${p2}(
      ${n.types.thisExpression()},
      ${n.types.cloneNode(o2)},
      {
        get: ${a2 ? a2.name : t4.scope.buildUndefinedNode()},
        set: ${l2 ? l2.name : t4.scope.buildUndefinedNode()}
      },
    )`, t4), t4.node);
              })(e3, t3, r3, s2);
            }
            return (function(e4, t4, r4, s3) {
              const i3 = r4.get(t4.node.key.id.name), { id: o2 } = i3;
              if (!s3.availableHelper("classPrivateMethodInitSpec")) return inheritPropComments(n.template.statement.ast`${o2}.add(${e4})`, t4);
              const a2 = s3.addHelper("classPrivateMethodInitSpec");
              return inheritPropComments(n.template.statement.ast`${a2}(
      ${n.types.thisExpression()},
      ${n.types.cloneNode(o2)}
    )`, t4);
            })(e3, t3, r3, s2);
          }
        }
        function buildPublicFieldInitLoose(e3, t3) {
          const { key: r3, computed: s2 } = t3.node, i2 = t3.node.value || t3.scope.buildUndefinedNode();
          return inheritPropComments(n.types.expressionStatement(n.types.assignmentExpression("=", n.types.memberExpression(e3, r3, s2 || n.types.isLiteral(r3)), i2)), t3);
        }
        function buildPublicFieldInitSpec(e3, t3, r3) {
          const { key: s2, computed: i2 } = t3.node, o2 = t3.node.value || t3.scope.buildUndefinedNode();
          return inheritPropComments(n.types.expressionStatement(n.types.callExpression(r3.addHelper("defineProperty"), [e3, i2 || n.types.isLiteral(s2) ? s2 : n.types.stringLiteral(s2.name), o2])), t3);
        }
        function buildPrivateStaticMethodInitLoose(e3, t3, r3, s2) {
          const i2 = s2.get(t3.node.key.id.name), { id: o2, methodId: a2, getId: l2, setId: p2, initAdded: c2 } = i2;
          if (c2) return;
          return l2 || p2 ? (s2.set(t3.node.key.id.name, Object.assign({}, i2, { initAdded: true })), inheritPropComments(n.template.statement.ast`
        Object.defineProperty(${e3}, ${o2}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          get: ${l2 ? l2.name : t3.scope.buildUndefinedNode()},
          set: ${p2 ? p2.name : t3.scope.buildUndefinedNode()}
        })
      `, t3)) : inheritPropComments(n.template.statement.ast`
      Object.defineProperty(${e3}, ${o2}, {
        // configurable is false by default
        // enumerable is false by default
        // writable is false by default
        value: ${a2.name}
      });
    `, t3);
        }
        function buildPrivateMethodDeclaration(e3, t3, r3, s2 = false) {
          const i2 = r3.get(t3.node.key.id.name), { id: o2, methodId: a2, getId: l2, setId: p2, getterDeclared: c2, setterDeclared: u2, static: d2 } = i2, { params: h2, body: m2, generator: y2, async: b } = t3.node, g = l2 && 0 === h2.length, x = p2 && h2.length > 0;
          if (g && c2 || x && u2) return r3.set(t3.node.key.id.name, Object.assign({}, i2, { initAdded: true })), null;
          if (newHelpers(e3) && (g || x) && !s2) {
            const e4 = t3.get("body").scope, r4 = e4.generateUidIdentifier("this"), s3 = { thisRef: r4, argumentsPath: [] };
            if (t3.traverse(f, s3), s3.argumentsPath.length) {
              const t4 = e4.generateUidIdentifier("arguments");
              e4.push({ id: t4, init: n.template.expression.ast`[].slice.call(arguments, 1)` });
              for (const e5 of s3.argumentsPath) e5.replaceWith(n.types.cloneNode(t4));
            }
            h2.unshift(n.types.cloneNode(r4));
          }
          let v = a2;
          return g ? (r3.set(t3.node.key.id.name, Object.assign({}, i2, { getterDeclared: true, initAdded: true })), v = l2) : x ? (r3.set(t3.node.key.id.name, Object.assign({}, i2, { setterDeclared: true, initAdded: true })), v = p2) : d2 && !s2 && (v = o2), inheritPropComments(n.types.functionDeclaration(n.types.cloneNode(v), h2, m2, y2, b), t3);
        }
        const f = s.visitors.environmentVisitor({ Identifier(e3, t3) {
          t3.argumentsPath && "arguments" === e3.node.name && t3.argumentsPath.push(e3);
        }, UnaryExpression(e3) {
          const { node: t3 } = e3;
          if ("delete" === t3.operator) {
            const r3 = (0, p.skipTransparentExprWrapperNodes)(t3.argument);
            n.types.isThisExpression(r3) && e3.replaceWith(n.types.booleanLiteral(true));
          }
        }, ThisExpression(e3, t3) {
          t3.needsClassRef = true, e3.replaceWith(n.types.cloneNode(t3.thisRef));
        }, MetaProperty(e3) {
          const { node: t3, scope: r3 } = e3;
          "new" === t3.meta.name && "target" === t3.property.name && e3.replaceWith(r3.buildUndefinedNode());
        } }), y = { ReferencedIdentifier(e3, t3) {
          e3.scope.bindingIdentifierEquals(e3.node.name, t3.innerBinding) && (t3.needsClassRef = true, e3.node.name = t3.thisRef.name);
        } };
        function replaceThisContext(e3, t3, r3) {
          var n2;
          const s2 = { thisRef: t3, needsClassRef: false, innerBinding: r3 };
          return e3.isMethod() || e3.traverse(f, s2), null != r3 && null != (n2 = s2.thisRef) && n2.name && s2.thisRef.name !== r3.name && e3.traverse(y, s2), s2.needsClassRef;
        }
        function isNameOrLength({ key: e3, computed: t3 }) {
          return "Identifier" === e3.type ? !t3 && ("name" === e3.name || "length" === e3.name) : "StringLiteral" === e3.type && ("name" === e3.value || "length" === e3.value);
        }
        function inheritPropComments(e3, t3) {
          return n.types.inheritLeadingComments(e3, t3.node), n.types.inheritInnerComments(e3, t3.node), e3;
        }
        function inheritLoc(e3, t3) {
          return e3.start = t3.start, e3.end = t3.end, e3.loc = t3.loc, e3;
        }
      }, "./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.28.3_@babel+core@7.28.4/node_modules/@babel/helper-create-class-features-plugin/lib/index.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), Object.defineProperty(t2, "FEATURES", { enumerable: true, get: function() {
          return p.FEATURES;
        } }), Object.defineProperty(t2, "buildCheckInRHS", { enumerable: true, get: function() {
          return i.buildCheckInRHS;
        } }), Object.defineProperty(t2, "buildNamedEvaluationVisitor", { enumerable: true, get: function() {
          return o.buildNamedEvaluationVisitor;
        } }), t2.createClassFeaturePlugin = function({ name: e3, feature: t3, loose: d, manipulateOptions: h, api: m, inherits: f, decoratorVersion: y }) {
          var b;
          if (t3 & p.FEATURES.decorators && ("2023-11" === y || "2023-05" === y || "2023-01" === y || "2022-03" === y || "2021-12" === y)) return (0, o.default)(m, { loose: d }, y, f);
          null != m || (m = { assumption: () => {
          } });
          const g = m.assumption("setPublicClassFields"), x = m.assumption("privateFieldsAsSymbols"), v = m.assumption("privateFieldsAsProperties"), E = null != (b = m.assumption("noUninitializedPrivateFieldAccess")) && b, T = m.assumption("constantSuper"), S = m.assumption("noDocumentAll");
          if (v && x) throw new Error('Cannot enable both the "privateFieldsAsProperties" and "privateFieldsAsSymbols" assumptions as the same time.');
          const P = v || x;
          if (true === d) {
            const t4 = [];
            void 0 !== g && t4.push('"setPublicClassFields"'), void 0 !== v && t4.push('"privateFieldsAsProperties"'), void 0 !== x && t4.push('"privateFieldsAsSymbols"'), 0 !== t4.length && console.warn(`[${e3}]: You are using the "loose: true" option and you are explicitly setting a value for the ${t4.join(" and ")} assumption${t4.length > 1 ? "s" : ""}. The "loose" option can cause incompatibilities with the other class features plugins, so it's recommended that you replace it with the following top-level option:
	"assumptions": {
		"setPublicClassFields": true,
		"privateFieldsAsSymbols": true
	}`);
          }
          return { name: e3, manipulateOptions: h, inherits: f, pre(e4) {
            (0, p.enableFeature)(e4, t3, d), "number" != typeof e4.get(u) && e4.get(u) && !s.lt(e4.get(u), "7.28.3") || e4.set(u, "7.28.3");
          }, visitor: { Class(e4, { file: s2 }) {
            if ("7.28.3" !== s2.get(u)) return;
            if (!(0, p.shouldTransform)(e4, s2)) return;
            const d2 = e4.isClassDeclaration();
            d2 && (0, c.assertFieldTransformed)(e4);
            const h2 = (0, p.isLoose)(s2, t3);
            let m2;
            const f2 = (0, o.hasDecorators)(e4.node), y2 = [], b2 = [], _ = [], A = /* @__PURE__ */ new Set(), C = e4.get("body");
            for (const e5 of C.get("body")) {
              if ((e5.isClassProperty() || e5.isClassMethod()) && e5.node.computed && _.push(e5), e5.isPrivate()) {
                const { name: t4 } = e5.node.key.id, r3 = `get ${t4}`, n2 = `set ${t4}`;
                if (e5.isClassPrivateMethod()) {
                  if ("get" === e5.node.kind) {
                    if (A.has(r3) || A.has(t4) && !A.has(n2)) throw e5.buildCodeFrameError("Duplicate private field");
                    A.add(r3).add(t4);
                  } else if ("set" === e5.node.kind) {
                    if (A.has(n2) || A.has(t4) && !A.has(r3)) throw e5.buildCodeFrameError("Duplicate private field");
                    A.add(n2).add(t4);
                  }
                } else {
                  if (A.has(t4) && !A.has(r3) && !A.has(n2) || A.has(t4) && (A.has(r3) || A.has(n2))) throw e5.buildCodeFrameError("Duplicate private field");
                  A.add(t4);
                }
              }
              e5.isClassMethod({ kind: "constructor" }) ? m2 = e5 : (b2.push(e5), (e5.isProperty() || e5.isPrivate() || null != e5.isStaticBlock && e5.isStaticBlock()) && y2.push(e5));
            }
            if (!y2.length && !f2) return;
            const w = e4.node.id;
            let I;
            w && d2 || (null != e4.ensureFunctionName || (e4.ensureFunctionName = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/index.js").NodePath.prototype.ensureFunctionName), e4.ensureFunctionName(false), I = e4.scope.generateUidIdentifier((null == w ? void 0 : w.name) || "Class"));
            const D = null != I ? I : n.types.cloneNode(w), k = (0, i.buildPrivateNamesMap)(D.name, null != P ? P : h2, y2, s2), N = (0, i.buildPrivateNamesNodes)(k, null != v ? v : h2, null != x && x, s2);
            let O, j, F, L, M, B, R;
            (0, i.transformPrivateNamesUsage)(D, e4, k, { privateFieldsAsProperties: null != P ? P : h2, noUninitializedPrivateFieldAccess: E, noDocumentAll: S, innerBinding: w }, s2), f2 ? (j = M = O = [], { instanceNodes: F, wrapClass: R } = (0, a.buildDecoratedClass)(D, e4, b2, s2)) : (O = (0, l.extractComputedKeys)(e4, _, s2), { staticNodes: j, pureStaticNodes: M, instanceNodes: F, lastInstanceNodeReturnsThis: L, classBindingNode: B, wrapClass: R } = (0, i.buildFieldsInitNodes)(I, e4.node.superClass, y2, k, s2, null != g ? g : h2, null != P ? P : h2, E, null != T ? T : h2, w)), F.length > 0 && (0, l.injectInitialization)(e4, m2, F, (e5, t4) => {
              if (!f2) for (const r3 of y2) null != n.types.isStaticBlock && n.types.isStaticBlock(r3.node) || r3.node.static || r3.traverse(e5, t4);
            }, L);
            const U = R(e4);
            U.insertBefore([...N, ...O]), j.length > 0 && U.insertAfter(j), M.length > 0 && U.find((e5) => e5.isStatement() || e5.isDeclaration()).insertAfter(M), null != B && d2 && U.insertAfter(B);
          }, ExportDefaultDeclaration(e4, { file: t4 }) {
            {
              if ("7.28.3" !== t4.get(u)) return;
              const n2 = e4.get("declaration");
              if (n2.isClassDeclaration() && (0, o.hasDecorators)(n2.node)) if (n2.node.id) null != e4.splitExportDeclaration || (e4.splitExportDeclaration = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/index.js").NodePath.prototype.splitExportDeclaration), e4.splitExportDeclaration();
              else n2.node.type = "ClassExpression";
            }
          } } };
        }, Object.defineProperty(t2, "enableFeature", { enumerable: true, get: function() {
          return p.enableFeature;
        } }), Object.defineProperty(t2, "injectInitialization", { enumerable: true, get: function() {
          return l.injectInitialization;
        } });
        var n = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/index.js"), s = r2("./node_modules/.pnpm/semver@6.3.1/node_modules/semver/semver.js"), i = r2("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.28.3_@babel+core@7.28.4/node_modules/@babel/helper-create-class-features-plugin/lib/fields.js"), o = r2("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.28.3_@babel+core@7.28.4/node_modules/@babel/helper-create-class-features-plugin/lib/decorators.js"), a = r2("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.28.3_@babel+core@7.28.4/node_modules/@babel/helper-create-class-features-plugin/lib/decorators-2018-09.js"), l = r2("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.28.3_@babel+core@7.28.4/node_modules/@babel/helper-create-class-features-plugin/lib/misc.js"), p = r2("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.28.3_@babel+core@7.28.4/node_modules/@babel/helper-create-class-features-plugin/lib/features.js"), c = r2("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.28.3_@babel+core@7.28.4/node_modules/@babel/helper-create-class-features-plugin/lib/typescript.js");
        const u = "@babel/plugin-class-features/version";
      }, "./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.28.3_@babel+core@7.28.4/node_modules/@babel/helper-create-class-features-plugin/lib/misc.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.extractComputedKeys = function(e3, t3, r3) {
          const { scope: s2 } = e3, i2 = [], a = { classBinding: e3.node.id && s2.getBinding(e3.node.id.name), file: r3 };
          for (const e4 of t3) {
            const t4 = e4.get("key");
            t4.isReferencedIdentifier() ? handleClassTDZ(t4, a) : t4.traverse(o, a);
            const r4 = e4.node;
            if (!t4.isConstantExpression()) {
              const e5 = memoiseComputedKey(t4.node, s2, s2.generateUidBasedOnNode(t4.node));
              e5 && (i2.push(n.types.expressionStatement(e5)), r4.key = n.types.cloneNode(e5.left));
            }
          }
          return i2;
        }, t2.injectInitialization = function(e3, t3, r3, o2, a) {
          if (!r3.length) return;
          const l = !!e3.node.superClass;
          if (!t3) {
            const r4 = n.types.classMethod("constructor", n.types.identifier("constructor"), [], n.types.blockStatement([]));
            l && (r4.params = [n.types.restElement(n.types.identifier("args"))], r4.body.body.push(n.template.statement.ast`super(...args)`)), [t3] = e3.get("body").unshiftContainer("body", r4);
          }
          o2 && o2(i, { scope: t3.scope });
          if (l) {
            const e4 = [];
            t3.traverse(s, e4);
            let i2 = true;
            for (const t4 of e4) if (i2 ? i2 = false : r3 = r3.map((e5) => n.types.cloneNode(e5)), t4.parentPath.isExpressionStatement()) t4.insertAfter(r3);
            else {
              const e5 = [t4.node, ...r3.map((e6) => n.types.toExpression(e6))];
              a || e5.push(n.types.thisExpression()), t4.replaceWith(n.types.sequenceExpression(e5));
            }
          } else t3.get("body").unshiftContainer("body", r3);
        }, t2.memoiseComputedKey = memoiseComputedKey;
        var n = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/index.js");
        const s = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/index.js").visitors.environmentVisitor({ Super(e3) {
          const { node: t3, parentPath: r3 } = e3;
          r3.isCallExpression({ callee: t3 }) && this.push(r3);
        } }), i = { "TSTypeAnnotation|TypeAnnotation"(e3) {
          e3.skip();
        }, ReferencedIdentifier(e3, { scope: t3 }) {
          t3.hasOwnBinding(e3.node.name) && (t3.rename(e3.node.name), e3.skip());
        } };
        function handleClassTDZ(e3, t3) {
          if (t3.classBinding && t3.classBinding === e3.scope.getBinding(e3.node.name)) {
            const r3 = t3.file.addHelper("classNameTDZError"), s2 = n.types.callExpression(r3, [n.types.stringLiteral(e3.node.name)]);
            e3.replaceWith(n.types.sequenceExpression([s2, e3.node])), e3.skip();
          }
        }
        const o = { ReferencedIdentifier: handleClassTDZ, "TSTypeAnnotation|TypeAnnotation"(e3) {
          e3.skip();
        } };
        function memoiseComputedKey(e3, t3, r3) {
          if (n.types.isIdentifier(e3) && t3.hasUid(e3.name)) return;
          if (n.types.isAssignmentExpression(e3, { operator: "=" }) && n.types.isIdentifier(e3.left) && t3.hasUid(e3.left.name)) return n.types.cloneNode(e3);
          {
            const s2 = n.types.identifier(r3);
            return t3.push({ id: s2, kind: "let" }), n.types.assignmentExpression("=", n.types.cloneNode(s2), e3);
          }
        }
      }, "./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.28.3_@babel+core@7.28.4/node_modules/@babel/helper-create-class-features-plugin/lib/typescript.js": function(e2, t2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.assertFieldTransformed = function(e3) {
          if (e3.node.declare) throw e3.buildCodeFrameError("TypeScript 'declare' fields must first be transformed by @babel/plugin-transform-typescript.\nIf you have already enabled that plugin (or '@babel/preset-typescript'), make sure that it runs before any plugin related to additional class features:\n - @babel/plugin-transform-class-properties\n - @babel/plugin-transform-private-methods\n - @babel/plugin-proposal-decorators");
        };
      }, "./node_modules/.pnpm/@babel+helper-member-expression-to-functions@7.27.1/node_modules/@babel/helper-member-expression-to-functions/lib/index.js": function(e2, t2, r2) {
        "use strict";
        function _interopNamespace(e3) {
          if (e3 && e3.__esModule) return e3;
          var t3 = /* @__PURE__ */ Object.create(null);
          return e3 && Object.keys(e3).forEach(function(r3) {
            if ("default" !== r3) {
              var n2 = Object.getOwnPropertyDescriptor(e3, r3);
              Object.defineProperty(t3, r3, n2.get ? n2 : { enumerable: true, get: function() {
                return e3[r3];
              } });
            }
          }), t3.default = e3, Object.freeze(t3);
        }
        Object.defineProperty(t2, "__esModule", { value: true });
        var n = _interopNamespace(r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/index.js"));
        function willPathCastToBoolean(e3) {
          const t3 = e3, { node: r3, parentPath: n2 } = t3;
          if (n2.isLogicalExpression()) {
            const { operator: e4, right: t4 } = n2.node;
            if ("&&" === e4 || "||" === e4 || "??" === e4 && r3 === t4) return willPathCastToBoolean(n2);
          }
          if (n2.isSequenceExpression()) {
            const { expressions: e4 } = n2.node;
            return e4[e4.length - 1] !== r3 || willPathCastToBoolean(n2);
          }
          return n2.isConditional({ test: r3 }) || n2.isUnaryExpression({ operator: "!" }) || n2.isLoop({ test: r3 });
        }
        const { LOGICAL_OPERATORS: s, arrowFunctionExpression: i, assignmentExpression: o, binaryExpression: a, booleanLiteral: l, callExpression: p, cloneNode: c, conditionalExpression: u, identifier: d, isMemberExpression: h, isOptionalCallExpression: m, isOptionalMemberExpression: f, isUpdateExpression: y, logicalExpression: b, memberExpression: g, nullLiteral: x, optionalCallExpression: v, optionalMemberExpression: E, sequenceExpression: T, updateExpression: S } = n;
        class AssignmentMemoiser {
          constructor() {
            this._map = void 0, this._map = /* @__PURE__ */ new WeakMap();
          }
          has(e3) {
            return this._map.has(e3);
          }
          get(e3) {
            if (!this.has(e3)) return;
            const t3 = this._map.get(e3), { value: r3 } = t3;
            return t3.count--, 0 === t3.count ? o("=", r3, e3) : r3;
          }
          set(e3, t3, r3) {
            return this._map.set(e3, { count: r3, value: t3 });
          }
        }
        function toNonOptional(e3, t3) {
          const { node: r3 } = e3;
          if (f(r3)) return g(t3, r3.property, r3.computed);
          if (e3.isOptionalCallExpression()) {
            const r4 = e3.get("callee");
            if (e3.node.optional && r4.isOptionalMemberExpression()) {
              const n2 = r4.node.object, s2 = e3.scope.maybeGenerateMemoised(n2);
              return r4.get("object").replaceWith(o("=", s2, n2)), p(g(t3, d("call")), [s2, ...e3.node.arguments]);
            }
            return p(t3, e3.node.arguments);
          }
          return e3.node;
        }
        const P = { memoise() {
        }, handle(e3, t3) {
          const { node: r3, parent: n2, parentPath: s2, scope: g2 } = e3;
          if (e3.isOptionalMemberExpression()) {
            if ((function(e4) {
              for (; e4 && !e4.isProgram(); ) {
                const { parentPath: t4, container: r4, listKey: n3 } = e4, s3 = t4.node;
                if (n3) {
                  if (r4 !== s3[n3]) return true;
                } else if (r4 !== s3) return true;
                e4 = t4;
              }
              return false;
            })(e3)) return;
            const y2 = e3.find(({ node: t4, parent: r4 }) => f(r4) ? r4.optional || r4.object !== t4 : !m(r4) || (t4 !== e3.node && r4.optional || r4.callee !== t4));
            if (g2.path.isPattern()) return void y2.replaceWith(p(i([], y2.node), []));
            const T2 = willPathCastToBoolean(y2), S2 = y2.parentPath;
            if (S2.isUpdateExpression({ argument: r3 })) throw e3.buildCodeFrameError("can't handle update expression");
            const P2 = S2.isAssignmentExpression({ left: y2.node }), _ = S2.isUnaryExpression({ operator: "delete" });
            if (_ && y2.isOptionalMemberExpression() && y2.get("property").isPrivateName()) throw e3.buildCodeFrameError("can't delete a private class element");
            let A = e3;
            for (; ; ) if (A.isOptionalMemberExpression()) {
              if (A.node.optional) break;
              A = A.get("object");
            } else {
              if (!A.isOptionalCallExpression()) throw new Error(`Internal error: unexpected ${A.node.type}`);
              if (A.node.optional) break;
              A = A.get("callee");
            }
            const C = A.isOptionalMemberExpression() ? A.node.object : A.node.callee, w = g2.maybeGenerateMemoised(C), I = null != w ? w : C, D = s2.isOptionalCallExpression({ callee: r3 }), isOptionalCall = (e4) => D, k = s2.isCallExpression({ callee: r3 });
            A.replaceWith(toNonOptional(A, I)), isOptionalCall() ? n2.optional ? s2.replaceWith(this.optionalCall(e3, n2.arguments)) : s2.replaceWith(this.call(e3, n2.arguments)) : k ? e3.replaceWith(this.boundGet(e3)) : this.delete && s2.isUnaryExpression({ operator: "delete" }) ? s2.replaceWith(this.delete(e3)) : s2.isAssignmentExpression() ? handleAssignment(this, e3, s2) : e3.replaceWith(this.get(e3));
            let N, O = e3.node;
            for (let t4 = e3; t4 !== y2; ) {
              const e4 = t4.parentPath;
              if (e4 === y2 && isOptionalCall() && n2.optional) {
                O = e4.node;
                break;
              }
              O = toNonOptional(e4, O), t4 = e4;
            }
            const j = y2.parentPath;
            if (h(O) && j.isOptionalCallExpression({ callee: y2.node, optional: true })) {
              const { object: t4 } = O;
              N = e3.scope.maybeGenerateMemoised(t4), N && (O.object = o("=", N, t4));
            }
            let F = y2;
            (_ || P2) && (F = j, O = j.node);
            const L = w ? o("=", c(I), c(C)) : c(I);
            if (T2) {
              let e4;
              e4 = t3 ? a("!=", L, x()) : b("&&", a("!==", L, x()), a("!==", c(I), g2.buildUndefinedNode())), F.replaceWith(b("&&", e4, O));
            } else {
              let e4;
              e4 = t3 ? a("==", L, x()) : b("||", a("===", L, x()), a("===", c(I), g2.buildUndefinedNode())), F.replaceWith(u(e4, _ ? l(true) : g2.buildUndefinedNode(), O));
            }
            if (N) {
              const e4 = j.node;
              j.replaceWith(v(E(e4.callee, d("call"), false, true), [c(N), ...e4.arguments], false));
            }
            return;
          }
          if (y(n2, { argument: r3 })) {
            if (this.simpleSet) return void e3.replaceWith(this.simpleSet(e3));
            const { operator: t4, prefix: i2 } = n2;
            this.memoise(e3, 2);
            const a2 = g2.generateUidIdentifierBasedOnNode(r3);
            g2.push({ id: a2 });
            const l2 = [o("=", c(a2), this.get(e3))];
            if (i2) {
              l2.push(S(t4, c(a2), i2));
              const r4 = T(l2);
              return void s2.replaceWith(this.set(e3, r4));
            }
            {
              const n3 = g2.generateUidIdentifierBasedOnNode(r3);
              g2.push({ id: n3 }), l2.push(o("=", c(n3), S(t4, c(a2), i2)), c(a2));
              const p2 = T(l2);
              return void s2.replaceWith(T([this.set(e3, p2), c(n3)]));
            }
          }
          if (s2.isAssignmentExpression({ left: r3 })) handleAssignment(this, e3, s2);
          else {
            if (!s2.isCallExpression({ callee: r3 })) return s2.isOptionalCallExpression({ callee: r3 }) ? g2.path.isPattern() ? void s2.replaceWith(p(i([], s2.node), [])) : void s2.replaceWith(this.optionalCall(e3, s2.node.arguments)) : void (this.delete && s2.isUnaryExpression({ operator: "delete" }) ? s2.replaceWith(this.delete(e3)) : s2.isForXStatement({ left: r3 }) || s2.isObjectProperty({ value: r3 }) && s2.parentPath.isObjectPattern() || s2.isAssignmentPattern({ left: r3 }) && s2.parentPath.isObjectProperty({ value: n2 }) && s2.parentPath.parentPath.isObjectPattern() || s2.isArrayPattern() || s2.isAssignmentPattern({ left: r3 }) && s2.parentPath.isArrayPattern() || s2.isRestElement() ? e3.replaceWith(this.destructureSet(e3)) : s2.isTaggedTemplateExpression() ? e3.replaceWith(this.boundGet(e3)) : e3.replaceWith(this.get(e3)));
            s2.replaceWith(this.call(e3, s2.node.arguments));
          }
        } };
        function handleAssignment(e3, t3, r3) {
          if (e3.simpleSet) return void t3.replaceWith(e3.simpleSet(t3));
          const { operator: n2, right: i2 } = r3.node;
          if ("=" === n2) r3.replaceWith(e3.set(t3, i2));
          else {
            const o2 = n2.slice(0, -1);
            s.includes(o2) ? (e3.memoise(t3, 1), r3.replaceWith(b(o2, e3.get(t3), e3.set(t3, i2)))) : (e3.memoise(t3, 2), r3.replaceWith(e3.set(t3, a(o2, e3.get(t3), i2))));
          }
        }
        t2.default = function(e3, t3, r3) {
          e3.traverse(t3, Object.assign({}, P, r3, { memoiser: new AssignmentMemoiser() }));
        };
      }, "./node_modules/.pnpm/@babel+helper-module-imports@7.27.1/node_modules/@babel/helper-module-imports/lib/import-builder.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var n = r2("assert"), s = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/index.js");
        const { callExpression: i, cloneNode: o, expressionStatement: a, identifier: l, importDeclaration: p, importDefaultSpecifier: c, importNamespaceSpecifier: u, importSpecifier: d, memberExpression: h, stringLiteral: m, variableDeclaration: f, variableDeclarator: y } = s;
        t2.default = class {
          constructor(e3, t3, r3) {
            this._statements = [], this._resultName = null, this._importedSource = void 0, this._scope = t3, this._hub = r3, this._importedSource = e3;
          }
          done() {
            return { statements: this._statements, resultName: this._resultName };
          }
          import() {
            return this._statements.push(p([], m(this._importedSource))), this;
          }
          require() {
            return this._statements.push(a(i(l("require"), [m(this._importedSource)]))), this;
          }
          namespace(e3 = "namespace") {
            const t3 = this._scope.generateUidIdentifier(e3), r3 = this._statements[this._statements.length - 1];
            return n("ImportDeclaration" === r3.type), n(0 === r3.specifiers.length), r3.specifiers = [u(t3)], this._resultName = o(t3), this;
          }
          default(e3) {
            const t3 = this._scope.generateUidIdentifier(e3), r3 = this._statements[this._statements.length - 1];
            return n("ImportDeclaration" === r3.type), n(0 === r3.specifiers.length), r3.specifiers = [c(t3)], this._resultName = o(t3), this;
          }
          named(e3, t3) {
            if ("default" === t3) return this.default(e3);
            const r3 = this._scope.generateUidIdentifier(e3), s2 = this._statements[this._statements.length - 1];
            return n("ImportDeclaration" === s2.type), n(0 === s2.specifiers.length), s2.specifiers = [d(r3, l(t3))], this._resultName = o(r3), this;
          }
          var(e3) {
            const t3 = this._scope.generateUidIdentifier(e3);
            let r3 = this._statements[this._statements.length - 1];
            return "ExpressionStatement" !== r3.type && (n(this._resultName), r3 = a(this._resultName), this._statements.push(r3)), this._statements[this._statements.length - 1] = f("var", [y(t3, r3.expression)]), this._resultName = o(t3), this;
          }
          defaultInterop() {
            return this._interop(this._hub.addHelper("interopRequireDefault"));
          }
          wildcardInterop() {
            return this._interop(this._hub.addHelper("interopRequireWildcard"));
          }
          _interop(e3) {
            const t3 = this._statements[this._statements.length - 1];
            return "ExpressionStatement" === t3.type ? t3.expression = i(e3, [t3.expression]) : "VariableDeclaration" === t3.type ? (n(1 === t3.declarations.length), t3.declarations[0].init = i(e3, [t3.declarations[0].init])) : n.fail("Unexpected type."), this;
          }
          prop(e3) {
            const t3 = this._statements[this._statements.length - 1];
            return "ExpressionStatement" === t3.type ? t3.expression = h(t3.expression, l(e3)) : "VariableDeclaration" === t3.type ? (n(1 === t3.declarations.length), t3.declarations[0].init = h(t3.declarations[0].init, l(e3))) : n.fail("Unexpected type:" + t3.type), this;
          }
          read(e3) {
            this._resultName = h(this._resultName, l(e3));
          }
        };
      }, "./node_modules/.pnpm/@babel+helper-module-imports@7.27.1/node_modules/@babel/helper-module-imports/lib/import-injector.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var n = r2("assert"), s = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/index.js"), i = r2("./node_modules/.pnpm/@babel+helper-module-imports@7.27.1/node_modules/@babel/helper-module-imports/lib/import-builder.js"), o = r2("./node_modules/.pnpm/@babel+helper-module-imports@7.27.1/node_modules/@babel/helper-module-imports/lib/is-module.js");
        const { identifier: a, importSpecifier: l, numericLiteral: p, sequenceExpression: c, isImportDeclaration: u } = s;
        function isValueImport(e3) {
          return "type" !== e3.importKind && "typeof" !== e3.importKind;
        }
        function hasNamespaceImport(e3) {
          return 1 === e3.specifiers.length && "ImportNamespaceSpecifier" === e3.specifiers[0].type || 2 === e3.specifiers.length && "ImportNamespaceSpecifier" === e3.specifiers[1].type;
        }
        function hasDefaultImport(e3) {
          return e3.specifiers.length > 0 && "ImportDefaultSpecifier" === e3.specifiers[0].type;
        }
        function maybeAppendImportSpecifiers(e3, t3) {
          return e3.specifiers.length ? !t3.specifiers.length || !hasNamespaceImport(e3) && !hasNamespaceImport(t3) && (hasDefaultImport(t3) && (hasDefaultImport(e3) ? t3.specifiers[0] = l(t3.specifiers[0].local, a("default")) : e3.specifiers.unshift(t3.specifiers.shift())), e3.specifiers.push(...t3.specifiers), true) : (e3.specifiers = t3.specifiers, true);
        }
        t2.default = class {
          constructor(e3, t3, r3) {
            this._defaultOpts = { importedSource: null, importedType: "commonjs", importedInterop: "babel", importingInterop: "babel", ensureLiveReference: false, ensureNoContext: false, importPosition: "before" };
            const n2 = e3.find((e4) => e4.isProgram());
            this._programPath = n2, this._programScope = n2.scope, this._hub = n2.hub, this._defaultOpts = this._applyDefaults(t3, r3, true);
          }
          addDefault(e3, t3) {
            return this.addNamed("default", e3, t3);
          }
          addNamed(e3, t3, r3) {
            return n("string" == typeof e3), this._generateImport(this._applyDefaults(t3, r3), e3);
          }
          addNamespace(e3, t3) {
            return this._generateImport(this._applyDefaults(e3, t3), null);
          }
          addSideEffect(e3, t3) {
            return this._generateImport(this._applyDefaults(e3, t3), void 0);
          }
          _applyDefaults(e3, t3, r3 = false) {
            let s2;
            return "string" == typeof e3 ? s2 = Object.assign({}, this._defaultOpts, { importedSource: e3 }, t3) : (n(!t3, "Unexpected secondary arguments."), s2 = Object.assign({}, this._defaultOpts, e3)), !r3 && t3 && (void 0 !== t3.nameHint && (s2.nameHint = t3.nameHint), void 0 !== t3.blockHoist && (s2.blockHoist = t3.blockHoist)), s2;
          }
          _generateImport(e3, t3) {
            const r3 = "default" === t3, n2 = !!t3 && !r3, s2 = null === t3, { importedSource: a2, importedType: l2, importedInterop: u2, importingInterop: d, ensureLiveReference: h, ensureNoContext: m, nameHint: f, importPosition: y, blockHoist: b } = e3;
            let g = f || t3;
            const x = (0, o.default)(this._programPath), v = x && "node" === d, E = x && "babel" === d;
            if ("after" === y && !x) throw new Error('"importPosition": "after" is only supported in modules');
            const T = new i.default(a2, this._programScope, this._hub);
            if ("es6" === l2) {
              if (!v && !E) throw new Error("Cannot import an ES6 module from CommonJS");
              T.import(), s2 ? T.namespace(f || a2) : (r3 || n2) && T.named(g, t3);
            } else {
              if ("commonjs" !== l2) throw new Error(`Unexpected interopType "${l2}"`);
              if ("babel" === u2) if (v) {
                g = "default" !== g ? g : a2;
                const e4 = `${a2}$es6Default`;
                T.import(), s2 ? T.default(e4).var(g || a2).wildcardInterop() : r3 ? h ? T.default(e4).var(g || a2).defaultInterop().read("default") : T.default(e4).var(g).defaultInterop().prop(t3) : n2 && T.default(e4).read(t3);
              } else E ? (T.import(), s2 ? T.namespace(g || a2) : (r3 || n2) && T.named(g, t3)) : (T.require(), s2 ? T.var(g || a2).wildcardInterop() : (r3 || n2) && h ? r3 ? (g = "default" !== g ? g : a2, T.var(g).read(t3), T.defaultInterop()) : T.var(a2).read(t3) : r3 ? T.var(g).defaultInterop().prop(t3) : n2 && T.var(g).prop(t3));
              else if ("compiled" === u2) v ? (T.import(), s2 ? T.default(g || a2) : (r3 || n2) && T.default(a2).read(g)) : E ? (T.import(), s2 ? T.namespace(g || a2) : (r3 || n2) && T.named(g, t3)) : (T.require(), s2 ? T.var(g || a2) : (r3 || n2) && (h ? T.var(a2).read(g) : T.prop(t3).var(g)));
              else {
                if ("uncompiled" !== u2) throw new Error(`Unknown importedInterop "${u2}".`);
                if (r3 && h) throw new Error("No live reference for commonjs default");
                v ? (T.import(), s2 ? T.default(g || a2) : r3 ? T.default(g) : n2 && T.default(a2).read(g)) : E ? (T.import(), s2 ? T.default(g || a2) : r3 ? T.default(g) : n2 && T.named(g, t3)) : (T.require(), s2 ? T.var(g || a2) : r3 ? T.var(g) : n2 && (h ? T.var(a2).read(g) : T.var(g).prop(t3)));
              }
            }
            const { statements: S, resultName: P } = T.done();
            return this._insertStatements(S, y, b), (r3 || n2) && m && "Identifier" !== P.type ? c([p(0), P]) : P;
          }
          _insertStatements(e3, t3 = "before", r3 = 3) {
            if ("after" === t3) {
              if (this._insertStatementsAfter(e3)) return;
            } else if (this._insertStatementsBefore(e3, r3)) return;
            this._programPath.unshiftContainer("body", e3);
          }
          _insertStatementsBefore(e3, t3) {
            if (1 === e3.length && u(e3[0]) && isValueImport(e3[0])) {
              const t4 = this._programPath.get("body").find((e4) => e4.isImportDeclaration() && isValueImport(e4.node));
              if ((null == t4 ? void 0 : t4.node.source.value) === e3[0].source.value && maybeAppendImportSpecifiers(t4.node, e3[0])) return true;
            }
            e3.forEach((e4) => {
              e4._blockHoist = t3;
            });
            const r3 = this._programPath.get("body").find((e4) => {
              const t4 = e4.node._blockHoist;
              return Number.isFinite(t4) && t4 < 4;
            });
            return !!r3 && (r3.insertBefore(e3), true);
          }
          _insertStatementsAfter(e3) {
            const t3 = new Set(e3), r3 = /* @__PURE__ */ new Map();
            for (const t4 of e3) if (u(t4) && isValueImport(t4)) {
              const e4 = t4.source.value;
              r3.has(e4) || r3.set(e4, []), r3.get(e4).push(t4);
            }
            let n2 = null;
            for (const e4 of this._programPath.get("body")) if (e4.isImportDeclaration() && isValueImport(e4.node)) {
              n2 = e4;
              const s2 = e4.node.source.value, i2 = r3.get(s2);
              if (!i2) continue;
              for (const r4 of i2) t3.has(r4) && maybeAppendImportSpecifiers(e4.node, r4) && t3.delete(r4);
            }
            return 0 === t3.size || (n2 && n2.insertAfter(Array.from(t3)), !!n2);
          }
        };
      }, "./node_modules/.pnpm/@babel+helper-module-imports@7.27.1/node_modules/@babel/helper-module-imports/lib/index.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), Object.defineProperty(t2, "ImportInjector", { enumerable: true, get: function() {
          return n.default;
        } }), t2.addDefault = function(e3, t3, r3) {
          return new n.default(e3).addDefault(t3, r3);
        }, t2.addNamed = function(e3, t3, r3, s2) {
          return new n.default(e3).addNamed(t3, r3, s2);
        }, t2.addNamespace = function(e3, t3, r3) {
          return new n.default(e3).addNamespace(t3, r3);
        }, t2.addSideEffect = function(e3, t3, r3) {
          return new n.default(e3).addSideEffect(t3, r3);
        }, Object.defineProperty(t2, "isModule", { enumerable: true, get: function() {
          return s.default;
        } });
        var n = r2("./node_modules/.pnpm/@babel+helper-module-imports@7.27.1/node_modules/@babel/helper-module-imports/lib/import-injector.js"), s = r2("./node_modules/.pnpm/@babel+helper-module-imports@7.27.1/node_modules/@babel/helper-module-imports/lib/is-module.js");
      }, "./node_modules/.pnpm/@babel+helper-module-imports@7.27.1/node_modules/@babel/helper-module-imports/lib/is-module.js": function(e2, t2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
          return "module" === e3.node.sourceType;
        };
      }, "./node_modules/.pnpm/@babel+helper-module-transforms@7.28.3_@babel+core@7.28.4/node_modules/@babel/helper-module-transforms/lib/dynamic-import.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.buildDynamicImport = function(e3, t3, r3, s) {
          const i = n.types.isCallExpression(e3) ? e3.arguments[0] : e3.source;
          if (n.types.isStringLiteral(i) || n.types.isTemplateLiteral(i) && 0 === i.quasis.length) return t3 ? n.template.expression.ast`
        Promise.resolve().then(() => ${s(i)})
      ` : s(i);
          const o = n.types.isTemplateLiteral(i) ? n.types.identifier("specifier") : n.types.templateLiteral([n.types.templateElement({ raw: "" }), n.types.templateElement({ raw: "" })], [n.types.identifier("specifier")]);
          return t3 ? n.template.expression.ast`
      (specifier =>
        new Promise(r => r(${o}))
          .then(s => ${s(n.types.identifier("s"))})
      )(${i})
    ` : r3 ? n.template.expression.ast`
      (specifier =>
        new Promise(r => r(${s(o)}))
      )(${i})
    ` : n.template.expression.ast`
      (specifier => ${s(o)})(${i})
    `;
        };
        var n = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/index.js");
        t2.getDynamicImportSource = function(e3) {
          const [t3] = e3.arguments;
          return n.types.isStringLiteral(t3) || n.types.isTemplateLiteral(t3) ? t3 : n.template.expression.ast`\`\${${t3}}\``;
        };
      }, "./node_modules/.pnpm/@babel+helper-module-transforms@7.28.3_@babel+core@7.28.4/node_modules/@babel/helper-module-transforms/lib/get-module-name.js": function(e2, t2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = getModuleName;
        {
          const e3 = getModuleName;
          t2.default = getModuleName = function(t3, r2) {
            var n, s, i, o;
            return e3(t3, { moduleId: null != (n = r2.moduleId) ? n : t3.moduleId, moduleIds: null != (s = r2.moduleIds) ? s : t3.moduleIds, getModuleId: null != (i = r2.getModuleId) ? i : t3.getModuleId, moduleRoot: null != (o = r2.moduleRoot) ? o : t3.moduleRoot });
          };
        }
        function getModuleName(e3, t3) {
          const { filename: r2, filenameRelative: n = r2, sourceRoot: s = t3.moduleRoot } = e3, { moduleId: i, moduleIds: o = !!i, getModuleId: a, moduleRoot: l = s } = t3;
          if (!o) return null;
          if (null != i && !a) return i;
          let p = null != l ? l + "/" : "";
          if (n) {
            const e4 = null != s ? new RegExp("^" + s + "/?") : "";
            p += n.replace(e4, "").replace(/\.\w*$/, "");
          }
          return p = p.replace(/\\/g, "/"), a && a(p) || p;
        }
      }, "./node_modules/.pnpm/@babel+helper-module-transforms@7.28.3_@babel+core@7.28.4/node_modules/@babel/helper-module-transforms/lib/index.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), Object.defineProperty(t2, "buildDynamicImport", { enumerable: true, get: function() {
          return c.buildDynamicImport;
        } }), t2.buildNamespaceInitStatements = function(e3, t3, r3 = false, n2 = p.wrapReference) {
          var i2;
          const o2 = [], a2 = s.types.identifier(t3.name);
          for (const e4 of t3.importsNamespace) e4 !== t3.name && o2.push(s.template.statement`var NAME = SOURCE;`({ NAME: e4, SOURCE: s.types.cloneNode(a2) }));
          const l2 = null != (i2 = n2(a2, t3.wrap)) ? i2 : a2;
          r3 && o2.push(...buildReexportsFromMeta(e3, t3, true, n2));
          for (const r4 of t3.reexportNamespace) o2.push((s.types.isIdentifier(l2) ? s.template.statement`EXPORTS.NAME = NAMESPACE;` : s.template.statement`
            Object.defineProperty(EXPORTS, "NAME", {
              enumerable: true,
              get: function() {
                return NAMESPACE;
              }
            });
          `)({ EXPORTS: e3.exportName, NAME: r4, NAMESPACE: s.types.cloneNode(l2) }));
          if (t3.reexportAll) {
            const n3 = (function(e4, t4, r4) {
              return (r4 ? s.template.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

          EXPORTS[key] = NAMESPACE[key];
        });
      ` : s.template.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

          Object.defineProperty(EXPORTS, key, {
            enumerable: true,
            get: function() {
              return NAMESPACE[key];
            },
          });
        });
    `)({ NAMESPACE: t4, EXPORTS: e4.exportName, VERIFY_NAME_LIST: e4.exportNameListName ? s.template`
            if (Object.prototype.hasOwnProperty.call(EXPORTS_LIST, key)) return;
          `({ EXPORTS_LIST: e4.exportNameListName }) : null });
            })(e3, s.types.cloneNode(l2), r3);
            n3.loc = t3.reexportAll.loc, o2.push(n3);
          }
          return o2;
        }, t2.ensureStatementsHoisted = function(e3) {
          e3.forEach((e4) => {
            e4._blockHoist = 3;
          });
        }, Object.defineProperty(t2, "getModuleName", { enumerable: true, get: function() {
          return u.default;
        } }), Object.defineProperty(t2, "hasExports", { enumerable: true, get: function() {
          return l.hasExports;
        } }), Object.defineProperty(t2, "isModule", { enumerable: true, get: function() {
          return i.isModule;
        } }), Object.defineProperty(t2, "isSideEffectImport", { enumerable: true, get: function() {
          return l.isSideEffectImport;
        } }), t2.rewriteModuleStatementsAndPrepareHeader = function(e3, { exportName: t3, strict: r3, allowTopLevelThis: c2, strictMode: u2, noInterop: d2, importInterop: h2 = d2 ? "none" : "babel", lazy: m, getWrapperPayload: f = p.toGetWrapperPayload(null != m && m), wrapReference: y = p.wrapReference, esNamespaceOnly: b, filename: g, constantReexports: x = arguments[1].loose, enumerableModuleMeta: v = arguments[1].loose, noIncompleteNsImportDetection: E }) {
          (0, l.validateImportInteropOption)(h2), n((0, i.isModule)(e3), "Cannot process module statements in a script"), e3.node.sourceType = "script";
          const T = (0, l.default)(e3, t3, { importInterop: h2, initializeReexports: x, getWrapperPayload: f, esNamespaceOnly: b, filename: g });
          c2 || (0, o.default)(e3);
          if ((0, a.default)(e3, T, y), false !== u2) {
            e3.node.directives.some((e4) => "use strict" === e4.value.value) || e3.unshiftContainer("directives", s.types.directive(s.types.directiveLiteral("use strict")));
          }
          const S = [];
          (0, l.hasExports)(T) && !r3 && S.push((function(e4, t4 = false) {
            return (t4 ? s.template.statement`
        EXPORTS.__esModule = true;
      ` : s.template.statement`
        Object.defineProperty(EXPORTS, "__esModule", {
          value: true,
        });
      `)({ EXPORTS: e4.exportName });
          })(T, v));
          const P = (function(e4, t4) {
            const r4 = /* @__PURE__ */ Object.create(null);
            for (const e5 of t4.local.values()) for (const t5 of e5.names) r4[t5] = true;
            let n2 = false;
            for (const e5 of t4.source.values()) {
              for (const t5 of e5.reexports.keys()) r4[t5] = true;
              for (const t5 of e5.reexportNamespace) r4[t5] = true;
              n2 = n2 || !!e5.reexportAll;
            }
            if (!n2 || 0 === Object.keys(r4).length) return null;
            const i2 = e4.scope.generateUidIdentifier("exportNames");
            return delete r4.default, { name: i2.name, statement: s.types.variableDeclaration("var", [s.types.variableDeclarator(i2, s.types.valueToNode(r4))]) };
          })(e3, T);
          P && (T.exportNameListName = P.name, S.push(P.statement));
          return S.push(...(function(e4, t4, r4, n2 = false, i2 = false) {
            const o2 = [];
            for (const [e5, r5] of t4.local) if ("import" === r5.kind) ;
            else if ("hoisted" === r5.kind) o2.push([r5.names[0], buildInitStatement(t4, r5.names, s.types.identifier(e5))]);
            else if (!i2) for (const e6 of r5.names) o2.push([e6, null]);
            for (const e5 of t4.source.values()) {
              if (!n2) {
                const n3 = buildReexportsFromMeta(t4, e5, false, r4), s2 = [...e5.reexports.keys()];
                for (let e6 = 0; e6 < n3.length; e6++) o2.push([s2[e6], n3[e6]]);
              }
              if (!i2) for (const t5 of e5.reexportNamespace) o2.push([t5, null]);
            }
            o2.sort(([e5], [t5]) => e5 < t5 ? -1 : t5 < e5 ? 1 : 0);
            const a2 = [];
            if (i2) for (const [, e5] of o2) a2.push(e5);
            else {
              const r5 = 100;
              for (let n3 = 0; n3 < o2.length; n3 += r5) {
                let s2 = [];
                for (let i3 = 0; i3 < r5 && n3 + i3 < o2.length; i3++) {
                  const [r6, l2] = o2[n3 + i3];
                  null !== l2 ? (s2.length > 0 && (a2.push(buildInitStatement(t4, s2, e4.scope.buildUndefinedNode())), s2 = []), a2.push(l2)) : s2.push(r6);
                }
                s2.length > 0 && a2.push(buildInitStatement(t4, s2, e4.scope.buildUndefinedNode()));
              }
            }
            return a2;
          })(e3, T, y, x, E)), { meta: T, headers: S };
        }, Object.defineProperty(t2, "rewriteThis", { enumerable: true, get: function() {
          return o.default;
        } }), t2.wrapInterop = function(e3, t3, r3) {
          if ("none" === r3) return null;
          if ("node-namespace" === r3) return s.types.callExpression(e3.hub.addHelper("interopRequireWildcard"), [t3, s.types.booleanLiteral(true)]);
          if ("node-default" === r3) return null;
          let n2;
          if ("default" === r3) n2 = "interopRequireDefault";
          else {
            if ("namespace" !== r3) throw new Error(`Unknown interop: ${r3}`);
            n2 = "interopRequireWildcard";
          }
          return s.types.callExpression(e3.hub.addHelper(n2), [t3]);
        };
        var n = r2("assert"), s = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/index.js"), i = r2("./node_modules/.pnpm/@babel+helper-module-imports@7.27.1/node_modules/@babel/helper-module-imports/lib/index.js"), o = r2("./node_modules/.pnpm/@babel+helper-module-transforms@7.28.3_@babel+core@7.28.4/node_modules/@babel/helper-module-transforms/lib/rewrite-this.js"), a = r2("./node_modules/.pnpm/@babel+helper-module-transforms@7.28.3_@babel+core@7.28.4/node_modules/@babel/helper-module-transforms/lib/rewrite-live-references.js"), l = r2("./node_modules/.pnpm/@babel+helper-module-transforms@7.28.3_@babel+core@7.28.4/node_modules/@babel/helper-module-transforms/lib/normalize-and-load-metadata.js"), p = r2("./node_modules/.pnpm/@babel+helper-module-transforms@7.28.3_@babel+core@7.28.4/node_modules/@babel/helper-module-transforms/lib/lazy-modules.js"), c = r2("./node_modules/.pnpm/@babel+helper-module-transforms@7.28.3_@babel+core@7.28.4/node_modules/@babel/helper-module-transforms/lib/dynamic-import.js"), u = r2("./node_modules/.pnpm/@babel+helper-module-transforms@7.28.3_@babel+core@7.28.4/node_modules/@babel/helper-module-transforms/lib/get-module-name.js");
        t2.getDynamicImportSource = r2("./node_modules/.pnpm/@babel+helper-module-transforms@7.28.3_@babel+core@7.28.4/node_modules/@babel/helper-module-transforms/lib/dynamic-import.js").getDynamicImportSource;
        const d = { constant: ({ exports: e3, exportName: t3, namespaceImport: r3 }) => s.template.statement.ast`
      ${e3}.${t3} = ${r3};
    `, constantComputed: ({ exports: e3, exportName: t3, namespaceImport: r3 }) => s.template.statement.ast`
      ${e3}["${t3}"] = ${r3};
    `, spec: ({ exports: e3, exportName: t3, namespaceImport: r3 }) => s.template.statement.ast`
      Object.defineProperty(${e3}, "${t3}", {
        enumerable: true,
        get: function() {
          return ${r3};
        },
      });
    ` };
        function buildReexportsFromMeta(e3, t3, r3, n2) {
          var i2;
          let o2 = s.types.identifier(t3.name);
          o2 = null != (i2 = n2(o2, t3.wrap)) ? i2 : o2;
          const { stringSpecifiers: a2 } = e3;
          return Array.from(t3.reexports, ([n3, i3]) => {
            let l2 = s.types.cloneNode(o2);
            "default" === i3 && "node-default" === t3.interop || (l2 = a2.has(i3) ? s.types.memberExpression(l2, s.types.stringLiteral(i3), true) : s.types.memberExpression(l2, s.types.identifier(i3)));
            const p2 = { exports: e3.exportName, exportName: n3, namespaceImport: l2 };
            return r3 || s.types.isIdentifier(l2) ? a2.has(n3) ? d.constantComputed(p2) : d.constant(p2) : d.spec(p2);
          });
        }
        const h = { computed: ({ exports: e3, name: t3, value: r3 }) => s.template.expression.ast`${e3}["${t3}"] = ${r3}`, default: ({ exports: e3, name: t3, value: r3 }) => s.template.expression.ast`${e3}.${t3} = ${r3}`, define: ({ exports: e3, name: t3, value: r3 }) => s.template.expression.ast`
      Object.defineProperty(${e3}, "${t3}", {
        enumerable: true,
        value: void 0,
        writable: true
      })["${t3}"] = ${r3}` };
        function buildInitStatement(e3, t3, r3) {
          const { stringSpecifiers: n2, exportName: i2 } = e3;
          return s.types.expressionStatement(t3.reduce((e4, t4) => {
            const r4 = { exports: i2, name: t4, value: e4 };
            return "__proto__" === t4 ? h.define(r4) : n2.has(t4) ? h.computed(r4) : h.default(r4);
          }, r3));
        }
      }, "./node_modules/.pnpm/@babel+helper-module-transforms@7.28.3_@babel+core@7.28.4/node_modules/@babel/helper-module-transforms/lib/lazy-modules.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.toGetWrapperPayload = function(e3) {
          return (t3, r3) => {
            if (false === e3) return null;
            if ((0, s.isSideEffectImport)(r3) || r3.reexportAll) return null;
            if (true === e3) return t3.includes(".") ? null : "lazy";
            if (Array.isArray(e3)) return e3.includes(t3) ? "lazy" : null;
            if ("function" == typeof e3) return e3(t3) ? "lazy" : null;
            throw new Error(".lazy must be a boolean, string array, or function");
          };
        }, t2.wrapReference = function(e3, t3) {
          return "lazy" === t3 ? n.types.callExpression(e3, []) : null;
        };
        var n = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/index.js"), s = r2("./node_modules/.pnpm/@babel+helper-module-transforms@7.28.3_@babel+core@7.28.4/node_modules/@babel/helper-module-transforms/lib/normalize-and-load-metadata.js");
      }, "./node_modules/.pnpm/@babel+helper-module-transforms@7.28.3_@babel+core@7.28.4/node_modules/@babel/helper-module-transforms/lib/normalize-and-load-metadata.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, { importInterop: s2, initializeReexports: i = false, getWrapperPayload: o, esNamespaceOnly: a = false, filename: l }) {
          t3 || (t3 = e3.scope.generateUidIdentifier("exports").name);
          const p = /* @__PURE__ */ new Set();
          !(function(e4) {
            e4.get("body").forEach((e5) => {
              e5.isExportDefaultDeclaration() && (null != e5.splitExportDeclaration || (e5.splitExportDeclaration = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/index.js").NodePath.prototype.splitExportDeclaration), e5.splitExportDeclaration());
            });
          })(e3);
          const { local: c, sources: u, hasExports: d } = (function(e4, { getWrapperPayload: t4, initializeReexports: r3 }, s3) {
            const i2 = (function(e5, t5, r4) {
              const n2 = /* @__PURE__ */ new Map(), s4 = e5.scope, i3 = e5.get("body");
              i3.forEach((e6) => {
                let r5;
                if (e6.isImportDeclaration()) r5 = "import";
                else {
                  if (e6.isExportDefaultDeclaration() && (e6 = e6.get("declaration")), e6.isExportNamedDeclaration()) {
                    if (e6.node.declaration) e6 = e6.get("declaration");
                    else if (t5 && e6.node.source && e6.get("source").isStringLiteral()) return void e6.get("specifiers").forEach((e7) => {
                      assertExportSpecifier(e7), n2.set(e7.get("local").node.name, "block");
                    });
                  }
                  if (e6.isFunctionDeclaration()) r5 = "hoisted";
                  else if (e6.isClassDeclaration()) r5 = "block";
                  else if (e6.isVariableDeclaration({ kind: "var" })) r5 = "var";
                  else {
                    if (!e6.isVariableDeclaration()) return;
                    r5 = "block";
                  }
                }
                Object.keys(e6.getOuterBindingIdentifiers()).forEach((e7) => {
                  n2.set(e7, r5);
                });
              });
              const o3 = /* @__PURE__ */ new Map(), getLocalMetadata = (e6) => {
                const t6 = e6.node.name;
                let r5 = o3.get(t6);
                if (!r5) {
                  var i4, a3;
                  const l3 = null != (i4 = n2.get(t6)) ? i4 : null == (a3 = s4.getBinding(t6)) ? void 0 : a3.kind;
                  if (void 0 === l3) throw e6.buildCodeFrameError(`Exporting local "${t6}", which is not declared.`);
                  r5 = { names: [], kind: l3 }, o3.set(t6, r5);
                }
                return r5;
              };
              return i3.forEach((e6) => {
                if (!e6.isExportNamedDeclaration() || !t5 && e6.node.source) {
                  if (e6.isExportDefaultDeclaration()) {
                    const t6 = e6.get("declaration");
                    if (!t6.isFunctionDeclaration() && !t6.isClassDeclaration()) throw t6.buildCodeFrameError("Unexpected default expression export.");
                    getLocalMetadata(t6.get("id")).names.push("default");
                  }
                } else if (e6.node.declaration) {
                  const t6 = e6.get("declaration"), r5 = t6.getOuterBindingIdentifierPaths();
                  Object.keys(r5).forEach((e7) => {
                    if ("__esModule" === e7) throw t6.buildCodeFrameError('Illegal export "__esModule".');
                    getLocalMetadata(r5[e7]).names.push(e7);
                  });
                } else e6.get("specifiers").forEach((e7) => {
                  const t6 = e7.get("local"), n3 = e7.get("exported"), s5 = getLocalMetadata(t6), i4 = getExportSpecifierName(n3, r4);
                  if ("__esModule" === i4) throw n3.buildCodeFrameError('Illegal export "__esModule".');
                  s5.names.push(i4);
                });
              }), o3;
            })(e4, r3, s3), o2 = /* @__PURE__ */ new Map(), a2 = /* @__PURE__ */ new Map(), getData = (t5, r4) => {
              const s4 = t5.value;
              let i3 = a2.get(s4);
              return i3 ? o2.get(s4).push(r4) : (i3 = { name: e4.scope.generateUidIdentifier((0, n.basename)(s4, (0, n.extname)(s4))).name, interop: "none", loc: null, imports: /* @__PURE__ */ new Map(), importsNamespace: /* @__PURE__ */ new Set(), reexports: /* @__PURE__ */ new Map(), reexportNamespace: /* @__PURE__ */ new Set(), reexportAll: null, wrap: null, get lazy() {
                return "lazy" === this.wrap;
              }, referenced: false }, a2.set(s4, i3), o2.set(s4, [r4])), i3;
            };
            let l2 = false;
            e4.get("body").forEach((e5) => {
              if (e5.isImportDeclaration()) {
                const t5 = getData(e5.node.source, e5.node);
                t5.loc || (t5.loc = e5.node.loc), e5.get("specifiers").forEach((e6) => {
                  if (e6.isImportDefaultSpecifier()) {
                    const r4 = e6.get("local").node.name;
                    t5.imports.set(r4, "default");
                    const n2 = i2.get(r4);
                    n2 && (i2.delete(r4), n2.names.forEach((e7) => {
                      t5.reexports.set(e7, "default");
                    }), t5.referenced = true);
                  } else if (e6.isImportNamespaceSpecifier()) {
                    const r4 = e6.get("local").node.name;
                    t5.importsNamespace.add(r4);
                    const n2 = i2.get(r4);
                    n2 && (i2.delete(r4), n2.names.forEach((e7) => {
                      t5.reexportNamespace.add(e7);
                    }), t5.referenced = true);
                  } else if (e6.isImportSpecifier()) {
                    const r4 = getExportSpecifierName(e6.get("imported"), s3), n2 = e6.get("local").node.name;
                    t5.imports.set(n2, r4);
                    const o3 = i2.get(n2);
                    o3 && (i2.delete(n2), o3.names.forEach((e7) => {
                      t5.reexports.set(e7, r4);
                    }), t5.referenced = true);
                  }
                });
              } else if (e5.isExportAllDeclaration()) {
                l2 = true;
                const t5 = getData(e5.node.source, e5.node);
                t5.loc || (t5.loc = e5.node.loc), t5.reexportAll = { loc: e5.node.loc }, t5.referenced = true;
              } else if (e5.isExportNamedDeclaration() && e5.node.source) {
                l2 = true;
                const t5 = getData(e5.node.source, e5.node);
                t5.loc || (t5.loc = e5.node.loc), e5.get("specifiers").forEach((e6) => {
                  assertExportSpecifier(e6);
                  const r4 = getExportSpecifierName(e6.get("local"), s3), n2 = getExportSpecifierName(e6.get("exported"), s3);
                  if (t5.reexports.set(n2, r4), t5.referenced = true, "__esModule" === n2) throw e6.get("exported").buildCodeFrameError('Illegal export "__esModule".');
                });
              } else (e5.isExportNamedDeclaration() || e5.isExportDefaultDeclaration()) && (l2 = true);
            });
            for (const e5 of a2.values()) {
              let t5 = false, r4 = false;
              e5.importsNamespace.size > 0 && (t5 = true, r4 = true), e5.reexportAll && (r4 = true);
              for (const n2 of e5.imports.values()) "default" === n2 ? t5 = true : r4 = true;
              for (const n2 of e5.reexports.values()) "default" === n2 ? t5 = true : r4 = true;
              t5 && r4 ? e5.interop = "namespace" : t5 && (e5.interop = "default");
            }
            if (t4) for (const [e5, r4] of a2) r4.wrap = t4(e5, r4, o2.get(e5));
            return { hasExports: l2, local: i2, sources: a2 };
          })(e3, { initializeReexports: i, getWrapperPayload: o }, p);
          !(function(e4) {
            e4.get("body").forEach((e5) => {
              if (e5.isImportDeclaration()) e5.remove();
              else if (e5.isExportNamedDeclaration()) e5.node.declaration ? (e5.node.declaration._blockHoist = e5.node._blockHoist, e5.replaceWith(e5.node.declaration)) : e5.remove();
              else if (e5.isExportDefaultDeclaration()) {
                const t4 = e5.get("declaration");
                if (!t4.isFunctionDeclaration() && !t4.isClassDeclaration()) throw t4.buildCodeFrameError("Unexpected default expression export.");
                t4._blockHoist = e5.node._blockHoist, e5.replaceWith(t4);
              } else e5.isExportAllDeclaration() && e5.remove();
            });
          })(e3);
          for (const [e4, t4] of u) {
            const { importsNamespace: r3, imports: n2 } = t4;
            if (r3.size > 0 && 0 === n2.size) {
              const [e5] = r3;
              t4.name = e5;
            }
            const i2 = resolveImportInterop(s2, e4, l);
            "none" === i2 ? t4.interop = "none" : "node" === i2 && "namespace" === t4.interop ? t4.interop = "node-namespace" : "node" === i2 && "default" === t4.interop ? t4.interop = "node-default" : a && "namespace" === t4.interop && (t4.interop = "default");
          }
          return { exportName: t3, exportNameListName: null, hasExports: d, local: c, source: u, stringSpecifiers: p };
        }, t2.hasExports = function(e3) {
          return e3.hasExports;
        }, t2.isSideEffectImport = function(e3) {
          return 0 === e3.imports.size && 0 === e3.importsNamespace.size && 0 === e3.reexports.size && 0 === e3.reexportNamespace.size && !e3.reexportAll;
        }, t2.validateImportInteropOption = validateImportInteropOption;
        var n = r2("path"), s = r2("./node_modules/.pnpm/@babel+helper-validator-identifier@7.27.1/node_modules/@babel/helper-validator-identifier/lib/index.js");
        function validateImportInteropOption(e3) {
          if ("function" != typeof e3 && "none" !== e3 && "babel" !== e3 && "node" !== e3) throw new Error(`.importInterop must be one of "none", "babel", "node", or a function returning one of those values (received ${e3}).`);
          return e3;
        }
        function resolveImportInterop(e3, t3, r3) {
          return "function" == typeof e3 ? validateImportInteropOption(e3(t3, r3)) : e3;
        }
        function getExportSpecifierName(e3, t3) {
          if (e3.isIdentifier()) return e3.node.name;
          if (e3.isStringLiteral()) {
            const r3 = e3.node.value;
            return (0, s.isIdentifierName)(r3) || t3.add(r3), r3;
          }
          throw new Error(`Expected export specifier to be either Identifier or StringLiteral, got ${e3.node.type}`);
        }
        function assertExportSpecifier(e3) {
          if (!e3.isExportSpecifier()) throw e3.isExportNamespaceSpecifier() ? e3.buildCodeFrameError("Export namespace should be first transformed by `@babel/plugin-transform-export-namespace-from`.") : e3.buildCodeFrameError("Unexpected export specifier type");
        }
      }, "./node_modules/.pnpm/@babel+helper-module-transforms@7.28.3_@babel+core@7.28.4/node_modules/@babel/helper-module-transforms/lib/rewrite-live-references.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3) {
          const o = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map(), requeueInParent = (t4) => {
            e3.requeue(t4);
          };
          for (const [e4, r4] of t3.source) {
            for (const [t4, n2] of r4.imports) o.set(t4, [e4, n2, null]);
            for (const t4 of r4.importsNamespace) o.set(t4, [e4, null, t4]);
          }
          for (const [e4, r4] of t3.local) {
            let t4 = a.get(e4);
            t4 || (t4 = [], a.set(e4, t4)), t4.push(...r4.names);
          }
          const l = { metadata: t3, requeueInParent, scope: e3.scope, exported: a };
          e3.traverse(s, l);
          const p = { seen: /* @__PURE__ */ new WeakSet(), metadata: t3, requeueInParent, scope: e3.scope, imported: o, exported: a, buildImportReference([e4, s2, i2], o2) {
            const a2 = t3.source.get(e4);
            if (a2.referenced = true, i2) {
              var l2;
              if (a2.wrap) o2 = null != (l2 = r3(o2, a2.wrap)) ? l2 : o2;
              return o2;
            }
            let p2 = n.types.identifier(a2.name);
            var c;
            a2.wrap && (p2 = null != (c = r3(p2, a2.wrap)) ? c : p2);
            if ("default" === s2 && "node-default" === a2.interop) return p2;
            const u = t3.stringSpecifiers.has(s2);
            return n.types.memberExpression(p2, u ? n.types.stringLiteral(s2) : n.types.identifier(s2), u);
          } };
          e3.traverse(i, p);
        };
        var n = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/index.js");
        const s = { Scope(e3) {
          e3.skip();
        }, ClassDeclaration(e3) {
          const { requeueInParent: t3, exported: r3, metadata: s2 } = this, { id: i2 } = e3.node;
          if (!i2) throw new Error("Expected class to have a name");
          const o = i2.name, a = r3.get(o) || [];
          if (a.length > 0) {
            const r4 = n.types.expressionStatement(buildBindingExportAssignmentExpression(s2, a, n.types.identifier(o), e3.scope));
            r4._blockHoist = e3.node._blockHoist, t3(e3.insertAfter(r4)[0]);
          }
        }, VariableDeclaration(e3) {
          const { requeueInParent: t3, exported: r3, metadata: s2 } = this, i2 = "var" === e3.node.kind;
          for (const o of e3.get("declarations")) {
            const { id: a } = o.node;
            let { init: l } = o.node;
            if (!n.types.isIdentifier(a) || !r3.has(a.name) || n.types.isArrowFunctionExpression(l) || n.types.isFunctionExpression(l) && !l.id || n.types.isClassExpression(l) && !l.id) {
              for (const i3 of Object.keys(o.getOuterBindingIdentifiers())) if (r3.has(i3)) {
                const o2 = n.types.expressionStatement(buildBindingExportAssignmentExpression(s2, r3.get(i3), n.types.identifier(i3), e3.scope));
                o2._blockHoist = e3.node._blockHoist, t3(e3.insertAfter(o2)[0]);
              }
            } else {
              if (!l) {
                if (i2) continue;
                l = e3.scope.buildUndefinedNode();
              }
              o.node.init = buildBindingExportAssignmentExpression(s2, r3.get(a.name), l, e3.scope), t3(o.get("init"));
            }
          }
        } }, buildBindingExportAssignmentExpression = (e3, t3, r3, s2) => {
          const i2 = e3.exportName;
          for (let e4 = s2; null != e4; e4 = e4.parent) e4.hasOwnBinding(i2) && e4.rename(i2);
          return (t3 || []).reduce((t4, r4) => {
            const { stringSpecifiers: s3 } = e3, o = s3.has(r4);
            return n.types.assignmentExpression("=", n.types.memberExpression(n.types.identifier(i2), o ? n.types.stringLiteral(r4) : n.types.identifier(r4), o), t4);
          }, r3);
        }, buildImportThrow = (e3) => n.template.expression.ast`
    (function() {
      throw new Error('"' + '${e3}' + '" is read-only.');
    })()
  `, i = { ReferencedIdentifier(e3) {
          const { seen: t3, buildImportReference: r3, scope: s2, imported: i2, requeueInParent: o } = this;
          if (t3.has(e3.node)) return;
          t3.add(e3.node);
          const a = e3.node.name, l = i2.get(a);
          if (l) {
            if ((function(e4) {
              do {
                switch (e4.parent.type) {
                  case "TSTypeAnnotation":
                  case "TSTypeAliasDeclaration":
                  case "TSTypeReference":
                  case "TypeAnnotation":
                  case "TypeAlias":
                    return true;
                  case "ExportSpecifier":
                    return "type" === e4.parentPath.parent.exportKind;
                  default:
                    if (e4.parentPath.isStatement() || e4.parentPath.isExpression()) return false;
                }
              } while (e4 = e4.parentPath);
            })(e3)) throw e3.buildCodeFrameError(`Cannot transform the imported binding "${a}" since it's also used in a type annotation. Please strip type annotations using @babel/preset-typescript or @babel/preset-flow.`);
            const t4 = e3.scope.getBinding(a);
            if (s2.getBinding(a) !== t4) return;
            const i3 = r3(l, e3.node);
            if (i3.loc = e3.node.loc, (e3.parentPath.isCallExpression({ callee: e3.node }) || e3.parentPath.isOptionalCallExpression({ callee: e3.node }) || e3.parentPath.isTaggedTemplateExpression({ tag: e3.node })) && n.types.isMemberExpression(i3)) e3.replaceWith(n.types.sequenceExpression([n.types.numericLiteral(0), i3]));
            else if (e3.isJSXIdentifier() && n.types.isMemberExpression(i3)) {
              const { object: t5, property: r4 } = i3;
              e3.replaceWith(n.types.jsxMemberExpression(n.types.jsxIdentifier(t5.name), n.types.jsxIdentifier(r4.name)));
            } else e3.replaceWith(i3);
            o(e3), e3.skip();
          }
        }, UpdateExpression(e3) {
          const { scope: t3, seen: r3, imported: s2, exported: i2, requeueInParent: o, buildImportReference: a } = this;
          if (r3.has(e3.node)) return;
          r3.add(e3.node);
          const l = e3.get("argument");
          if (l.isMemberExpression()) return;
          const p = e3.node;
          if (l.isIdentifier()) {
            const r4 = l.node.name;
            if (t3.getBinding(r4) !== e3.scope.getBinding(r4)) return;
            const o2 = i2.get(r4), c = s2.get(r4);
            if ((null == o2 ? void 0 : o2.length) > 0 || c) if (c) e3.replaceWith(n.types.assignmentExpression(p.operator[0] + "=", a(c, l.node), buildImportThrow(r4)));
            else if (p.prefix) e3.replaceWith(buildBindingExportAssignmentExpression(this.metadata, o2, n.types.cloneNode(p), e3.scope));
            else {
              const s3 = t3.generateDeclaredUidIdentifier(r4);
              e3.replaceWith(n.types.sequenceExpression([n.types.assignmentExpression("=", n.types.cloneNode(s3), n.types.cloneNode(p)), buildBindingExportAssignmentExpression(this.metadata, o2, n.types.identifier(r4), e3.scope), n.types.cloneNode(s3)]));
            }
          }
          o(e3), e3.skip();
        }, AssignmentExpression: { exit(e3) {
          const { scope: t3, seen: r3, imported: s2, exported: i2, requeueInParent: o, buildImportReference: a } = this;
          if (r3.has(e3.node)) return;
          r3.add(e3.node);
          const l = e3.get("left");
          if (!l.isMemberExpression()) if (l.isIdentifier()) {
            const r4 = l.node.name;
            if (t3.getBinding(r4) !== e3.scope.getBinding(r4)) return;
            const p = i2.get(r4), c = s2.get(r4);
            if ((null == p ? void 0 : p.length) > 0 || c) {
              const t4 = e3.node;
              c && (t4.left = a(c, l.node), t4.right = n.types.sequenceExpression([t4.right, buildImportThrow(r4)]));
              const { operator: s3 } = t4;
              let i3;
              i3 = "=" === s3 ? t4 : "&&=" === s3 || "||=" === s3 || "??=" === s3 ? n.types.assignmentExpression("=", t4.left, n.types.logicalExpression(s3.slice(0, -1), n.types.cloneNode(t4.left), t4.right)) : n.types.assignmentExpression("=", t4.left, n.types.binaryExpression(s3.slice(0, -1), n.types.cloneNode(t4.left), t4.right)), e3.replaceWith(buildBindingExportAssignmentExpression(this.metadata, p, i3, e3.scope)), o(e3), e3.skip();
            }
          } else {
            const r4 = l.getOuterBindingIdentifiers(), a2 = Object.keys(r4).filter((r5) => t3.getBinding(r5) === e3.scope.getBinding(r5)), p = a2.find((e4) => s2.has(e4));
            p && (e3.node.right = n.types.sequenceExpression([e3.node.right, buildImportThrow(p)]));
            const c = [];
            if (a2.forEach((t4) => {
              const r5 = i2.get(t4) || [];
              r5.length > 0 && c.push(buildBindingExportAssignmentExpression(this.metadata, r5, n.types.identifier(t4), e3.scope));
            }), c.length > 0) {
              let t4 = n.types.sequenceExpression(c);
              e3.parentPath.isExpressionStatement() && (t4 = n.types.expressionStatement(t4), t4._blockHoist = e3.parentPath.node._blockHoist);
              o(e3.insertAfter(t4)[0]);
            }
          }
        } }, ForXStatement(e3) {
          const { scope: t3, node: r3 } = e3, { left: s2 } = r3, { exported: i2, imported: o, scope: a } = this;
          if (!n.types.isVariableDeclaration(s2)) {
            let r4, l = false;
            const p = e3.get("body").scope;
            for (const e4 of Object.keys(n.types.getOuterBindingIdentifiers(s2))) a.getBinding(e4) === t3.getBinding(e4) && (i2.has(e4) && (l = true, p.hasOwnBinding(e4) && p.rename(e4)), o.has(e4) && !r4 && (r4 = e4));
            if (!l && !r4) return;
            e3.ensureBlock();
            const c = e3.get("body"), u = t3.generateUidIdentifierBasedOnNode(s2);
            e3.get("left").replaceWith(n.types.variableDeclaration("let", [n.types.variableDeclarator(n.types.cloneNode(u))])), t3.registerDeclaration(e3.get("left")), l && c.unshiftContainer("body", n.types.expressionStatement(n.types.assignmentExpression("=", s2, u))), r4 && c.unshiftContainer("body", n.types.expressionStatement(buildImportThrow(r4)));
          }
        } };
      }, "./node_modules/.pnpm/@babel+helper-module-transforms@7.28.3_@babel+core@7.28.4/node_modules/@babel/helper-module-transforms/lib/rewrite-this.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
          i || (i = s.visitors.environmentVisitor({ ThisExpression(e4) {
            e4.replaceWith(n.types.unaryExpression("void", n.types.numericLiteral(0), true));
          } }), i.noScope = true);
          (0, s.default)(e3.node, i);
        };
        var n = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/index.js"), s = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/index.js");
        let i;
      }, "./node_modules/.pnpm/@babel+helper-optimise-call-expression@7.27.1/node_modules/@babel/helper-optimise-call-expression/lib/index.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3, n2) {
          return 1 === r3.length && a(r3[0]) && o(r3[0].argument, { name: "arguments" }) ? n2 ? p(c(e3, i("apply"), false, true), [t3, r3[0].argument], false) : s(l(e3, i("apply")), [t3, r3[0].argument]) : n2 ? p(c(e3, i("call"), false, true), [t3, ...r3], false) : s(l(e3, i("call")), [t3, ...r3]);
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/index.js");
        const { callExpression: s, identifier: i, isIdentifier: o, isSpreadElement: a, memberExpression: l, optionalCallExpression: p, optionalMemberExpression: c } = n;
      }, "./node_modules/.pnpm/@babel+helper-plugin-utils@7.27.1/node_modules/@babel/helper-plugin-utils/lib/index.js": function(e2, t2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.declare = declare, t2.declarePreset = void 0;
        const r2 = { assertVersion: (e3) => (t3) => {
          !(function(e4, t4) {
            if ("number" == typeof e4) {
              if (!Number.isInteger(e4)) throw new Error("Expected string or integer value.");
              e4 = `^${e4}.0.0-0`;
            }
            if ("string" != typeof e4) throw new Error("Expected string or integer value.");
            const r3 = Error.stackTraceLimit;
            "number" == typeof r3 && r3 < 25 && (Error.stackTraceLimit = 25);
            let n;
            n = "7." === t4.slice(0, 2) ? new Error(`Requires Babel "^7.0.0-beta.41", but was loaded with "${t4}". You'll need to update your @babel/core version.`) : new Error(`Requires Babel "${e4}", but was loaded with "${t4}". If you are sure you have a compatible version of @babel/core, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for the first entry that doesn't mention "@babel/core" or "babel-core" to see what is calling Babel.`);
            "number" == typeof r3 && (Error.stackTraceLimit = r3);
            throw Object.assign(n, { code: "BABEL_VERSION_UNSUPPORTED", version: t4, range: e4 });
          })(t3, e3.version);
        } };
        function declare(e3) {
          return (t3, n, s) => {
            let i;
            for (const e4 of Object.keys(r2)) t3[e4] || (null != i || (i = copyApiObject(t3)), i[e4] = r2[e4](i));
            return e3(null != i ? i : t3, n || {}, s);
          };
        }
        Object.assign(r2, { targets: () => () => ({}), assumption: () => () => {
        }, addExternalDependency: () => () => {
        } });
        t2.declarePreset = declare;
        function copyApiObject(e3) {
          let t3 = null;
          return "string" == typeof e3.version && /^7\./.test(e3.version) && (t3 = Object.getPrototypeOf(e3), !t3 || hasOwnProperty.call(t3, "version") && hasOwnProperty.call(t3, "transform") && hasOwnProperty.call(t3, "template") && hasOwnProperty.call(t3, "types") || (t3 = null)), Object.assign({}, t3, e3);
        }
      }, "./node_modules/.pnpm/@babel+helper-replace-supers@7.27.1_@babel+core@7.28.4/node_modules/@babel/helper-replace-supers/lib/index.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var n = r2("./node_modules/.pnpm/@babel+helper-member-expression-to-functions@7.27.1/node_modules/@babel/helper-member-expression-to-functions/lib/index.js"), s = r2("./node_modules/.pnpm/@babel+helper-optimise-call-expression@7.27.1/node_modules/@babel/helper-optimise-call-expression/lib/index.js"), i = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/index.js"), o = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/index.js");
        const { assignmentExpression: a, callExpression: l, cloneNode: p, identifier: c, memberExpression: u, sequenceExpression: d, stringLiteral: h, thisExpression: m } = i.types;
        t2.environmentVisitor = o.visitors.environmentVisitor({}), t2.skipAllButComputedKey = function(e3) {
          e3.skip(), e3.node.computed && e3.context.maybeQueue(e3.get("key"));
        };
        const f = o.visitors.environmentVisitor({ Super(e3, t3) {
          const { node: r3, parentPath: n2 } = e3;
          n2.isMemberExpression({ object: r3 }) && t3.handle(n2);
        } }), y = o.visitors.environmentVisitor({ Scopable(e3, { refName: t3 }) {
          const r3 = e3.scope.getOwnBinding(t3);
          r3 && r3.identifier.name === t3 && e3.scope.rename(t3);
        } }), b = { memoise(e3, t3) {
          const { scope: r3, node: n2 } = e3, { computed: s2, property: i2 } = n2;
          if (!s2) return;
          const o2 = r3.maybeGenerateMemoised(i2);
          o2 && this.memoiser.set(i2, o2, t3);
        }, prop(e3) {
          const { computed: t3, property: r3 } = e3.node;
          return this.memoiser.has(r3) ? p(this.memoiser.get(r3)) : t3 ? p(r3) : h(r3.name);
        }, _getPrototypeOfExpression() {
          const e3 = p(this.getObjectRef()), t3 = this.isStatic || this.isPrivateMethod ? e3 : u(e3, c("prototype"));
          return l(this.file.addHelper("getPrototypeOf"), [t3]);
        }, get(e3) {
          const t3 = p(this.getObjectRef());
          return l(this.file.addHelper("superPropGet"), [this.isDerivedConstructor ? d([m(), t3]) : t3, this.prop(e3), m(), ...this.isStatic || this.isPrivateMethod ? [] : [i.types.numericLiteral(1)]]);
        }, _call(e3, t3, r3) {
          const n2 = p(this.getObjectRef());
          let s2;
          s2 = 1 === t3.length && i.types.isSpreadElement(t3[0]) && (i.types.isIdentifier(t3[0].argument) || i.types.isArrayExpression(t3[0].argument)) ? t3[0].argument : i.types.arrayExpression(t3);
          const o2 = i.types.callExpression(this.file.addHelper("superPropGet"), [this.isDerivedConstructor ? d([m(), n2]) : n2, this.prop(e3), m(), i.types.numericLiteral(2 | (this.isStatic || this.isPrivateMethod ? 0 : 1))]);
          return r3 ? i.types.optionalCallExpression(o2, [s2], true) : l(o2, [s2]);
        }, set(e3, t3) {
          const r3 = p(this.getObjectRef());
          return l(this.file.addHelper("superPropSet"), [this.isDerivedConstructor ? d([m(), r3]) : r3, this.prop(e3), t3, m(), i.types.numericLiteral(e3.isInStrictMode() ? 1 : 0), ...this.isStatic || this.isPrivateMethod ? [] : [i.types.numericLiteral(1)]]);
        }, destructureSet(e3) {
          throw e3.buildCodeFrameError("Destructuring to a super field is not supported yet.");
        }, call(e3, t3) {
          return this._call(e3, t3, false);
        }, optionalCall(e3, t3) {
          return this._call(e3, t3, true);
        }, delete(e3) {
          return e3.node.computed ? d([l(this.file.addHelper("toPropertyKey"), [p(e3.node.property)]), i.template.expression.ast`
          function () { throw new ReferenceError("'delete super[expr]' is invalid"); }()
        `]) : i.template.expression.ast`
        function () { throw new ReferenceError("'delete super.prop' is invalid"); }()
      `;
        } }, g = { memoise(e3, t3) {
          const { scope: r3, node: n2 } = e3, { computed: s2, property: i2 } = n2;
          if (!s2) return;
          const o2 = r3.maybeGenerateMemoised(i2);
          o2 && this.memoiser.set(i2, o2, t3);
        }, prop(e3) {
          const { computed: t3, property: r3 } = e3.node;
          return this.memoiser.has(r3) ? p(this.memoiser.get(r3)) : t3 ? p(r3) : h(r3.name);
        }, _getPrototypeOfExpression() {
          const e3 = p(this.getObjectRef()), t3 = this.isStatic || this.isPrivateMethod ? e3 : u(e3, c("prototype"));
          return l(this.file.addHelper("getPrototypeOf"), [t3]);
        }, get(e3) {
          return this._get(e3);
        }, _get(e3) {
          const t3 = this._getPrototypeOfExpression();
          return l(this.file.addHelper("get"), [this.isDerivedConstructor ? d([m(), t3]) : t3, this.prop(e3), m()]);
        }, set(e3, t3) {
          const r3 = this._getPrototypeOfExpression();
          return l(this.file.addHelper("set"), [this.isDerivedConstructor ? d([m(), r3]) : r3, this.prop(e3), t3, m(), i.types.booleanLiteral(e3.isInStrictMode())]);
        }, destructureSet(e3) {
          throw e3.buildCodeFrameError("Destructuring to a super field is not supported yet.");
        }, call(e3, t3) {
          return (0, s.default)(this._get(e3), m(), t3, false);
        }, optionalCall(e3, t3) {
          return (0, s.default)(this._get(e3), p(m()), t3, true);
        }, delete(e3) {
          return e3.node.computed ? d([l(this.file.addHelper("toPropertyKey"), [p(e3.node.property)]), i.template.expression.ast`
          function () { throw new ReferenceError("'delete super[expr]' is invalid"); }()
        `]) : i.template.expression.ast`
        function () { throw new ReferenceError("'delete super.prop' is invalid"); }()
      `;
        } }, x = Object.assign({}, b, { prop(e3) {
          const { property: t3 } = e3.node;
          return this.memoiser.has(t3) ? p(this.memoiser.get(t3)) : p(t3);
        }, get(e3) {
          const { isStatic: t3, getSuperRef: r3 } = this, { computed: n2 } = e3.node, s2 = this.prop(e3);
          let i2;
          var o2, a2;
          t3 ? i2 = null != (o2 = r3()) ? o2 : u(c("Function"), c("prototype")) : i2 = u(null != (a2 = r3()) ? a2 : c("Object"), c("prototype"));
          return u(i2, s2, n2);
        }, set(e3, t3) {
          const { computed: r3 } = e3.node, n2 = this.prop(e3);
          return a("=", u(m(), n2, r3), t3);
        }, destructureSet(e3) {
          const { computed: t3 } = e3.node, r3 = this.prop(e3);
          return u(m(), r3, t3);
        }, call(e3, t3) {
          return (0, s.default)(this.get(e3), m(), t3, false);
        }, optionalCall(e3, t3) {
          return (0, s.default)(this.get(e3), m(), t3, true);
        } });
        t2.default = class {
          constructor(e3) {
            var t3;
            const r3 = e3.methodPath;
            this.methodPath = r3, this.isDerivedConstructor = r3.isClassMethod({ kind: "constructor" }) && !!e3.superRef, this.isStatic = r3.isObjectMethod() || r3.node.static || (null == r3.isStaticBlock ? void 0 : r3.isStaticBlock()), this.isPrivateMethod = r3.isPrivate() && r3.isMethod(), this.file = e3.file, this.constantSuper = null != (t3 = e3.constantSuper) ? t3 : e3.isLoose, this.opts = e3;
          }
          getObjectRef() {
            return p(this.opts.objectRef || this.opts.getObjectRef());
          }
          getSuperRef() {
            return this.opts.superRef ? p(this.opts.superRef) : this.opts.getSuperRef ? p(this.opts.getSuperRef()) : void 0;
          }
          replace() {
            const { methodPath: e3 } = this;
            this.opts.refToPreserve && e3.traverse(y, { refName: this.opts.refToPreserve.name });
            const t3 = this.constantSuper ? x : this.file.availableHelper("superPropSet") ? b : g;
            f.shouldSkip = (t4) => {
              if (t4.parentPath === e3 && ("decorators" === t4.parentKey || "key" === t4.parentKey)) return true;
            }, (0, n.default)(e3, f, Object.assign({ file: this.file, scope: this.methodPath.scope, isDerivedConstructor: this.isDerivedConstructor, isStatic: this.isStatic, isPrivateMethod: this.isPrivateMethod, getObjectRef: this.getObjectRef.bind(this), getSuperRef: this.getSuperRef.bind(this), boundGet: t3.get }, t3));
          }
        };
      }, "./node_modules/.pnpm/@babel+helper-simple-access@7.27.1/node_modules/@babel/helper-simple-access/lib/index.js": function(e2, t2, r2) {
        "use strict";
        t2.default = function(e3, t3) {
          var r3;
          e3.traverse(h, { scope: e3.scope, bindingNames: t3, seen: /* @__PURE__ */ new WeakSet(), includeUpdateExpression: null == (r3 = arguments[2]) || r3 });
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/index.js");
        const { LOGICAL_OPERATORS: s, assignmentExpression: i, binaryExpression: o, cloneNode: a, identifier: l, logicalExpression: p, numericLiteral: c, sequenceExpression: u, unaryExpression: d } = n, h = { AssignmentExpression: { exit(e3) {
          const { scope: t3, seen: r3, bindingNames: n2 } = this;
          if ("=" === e3.node.operator) return;
          if (r3.has(e3.node)) return;
          r3.add(e3.node);
          const l2 = e3.get("left");
          if (!l2.isIdentifier()) return;
          const c2 = l2.node.name;
          if (!n2.has(c2)) return;
          if (t3.getBinding(c2) !== e3.scope.getBinding(c2)) return;
          const u2 = e3.node.operator.slice(0, -1);
          s.includes(u2) ? e3.replaceWith(p(u2, e3.node.left, i("=", a(e3.node.left), e3.node.right))) : (e3.node.right = o(u2, a(e3.node.left), e3.node.right), e3.node.operator = "=");
        } } };
        h.UpdateExpression = { exit(e3) {
          if (!this.includeUpdateExpression) return;
          const { scope: t3, bindingNames: r3 } = this, n2 = e3.get("argument");
          if (!n2.isIdentifier()) return;
          const s2 = n2.node.name;
          if (r3.has(s2) && t3.getBinding(s2) === e3.scope.getBinding(s2)) if (e3.parentPath.isExpressionStatement() && !e3.isCompletionRecord()) {
            const t4 = "++" === e3.node.operator ? "+=" : "-=";
            e3.replaceWith(i(t4, n2.node, c(1)));
          } else if (e3.node.prefix) e3.replaceWith(i("=", l(s2), o(e3.node.operator[0], d("+", n2.node), c(1))));
          else {
            const t4 = e3.scope.generateUidIdentifierBasedOnNode(n2.node, "old"), r4 = t4.name;
            e3.scope.push({ id: t4 });
            const s3 = o(e3.node.operator[0], l(r4), c(1));
            e3.replaceWith(u([i("=", l(r4), d("+", n2.node)), i("=", a(n2.node), s3), l(r4)]));
          }
        } };
      }, "./node_modules/.pnpm/@babel+helper-skip-transparent-expression-wrappers@7.27.1/node_modules/@babel/helper-skip-transparent-expression-wrappers/lib/index.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.isTransparentExprWrapper = isTransparentExprWrapper, t2.skipTransparentExprWrapperNodes = function(e3) {
          for (; isTransparentExprWrapper(e3); ) e3 = e3.expression;
          return e3;
        }, t2.skipTransparentExprWrappers = function(e3) {
          for (; isTransparentExprWrapper(e3.node); ) e3 = e3.get("expression");
          return e3;
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/index.js");
        const { isParenthesizedExpression: s, isTSAsExpression: i, isTSNonNullExpression: o, isTSSatisfiesExpression: a, isTSTypeAssertion: l, isTypeCastExpression: p } = n;
        function isTransparentExprWrapper(e3) {
          return i(e3) || a(e3) || l(e3) || o(e3) || p(e3) || s(e3);
        }
      }, "./node_modules/.pnpm/@babel+helper-string-parser@7.27.1/node_modules/@babel/helper-string-parser/lib/index.js": function(e2, t2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.readCodePoint = readCodePoint, t2.readInt = readInt, t2.readStringContents = function(e3, t3, r3, n2, s, i) {
          const o = r3, a = n2, l = s;
          let p = "", c = null, u = r3;
          const { length: d } = t3;
          for (; ; ) {
            if (r3 >= d) {
              i.unterminated(o, a, l), p += t3.slice(u, r3);
              break;
            }
            const h = t3.charCodeAt(r3);
            if (isStringEnd(e3, h, t3, r3)) {
              p += t3.slice(u, r3);
              break;
            }
            if (92 === h) {
              p += t3.slice(u, r3);
              const o2 = readEscapedChar(t3, r3, n2, s, "template" === e3, i);
              null !== o2.ch || c ? p += o2.ch : c = { pos: r3, lineStart: n2, curLine: s }, { pos: r3, lineStart: n2, curLine: s } = o2, u = r3;
            } else 8232 === h || 8233 === h ? (++s, n2 = ++r3) : 10 === h || 13 === h ? "template" === e3 ? (p += t3.slice(u, r3) + "\n", ++r3, 13 === h && 10 === t3.charCodeAt(r3) && ++r3, ++s, u = n2 = r3) : i.unterminated(o, a, l) : ++r3;
          }
          return { pos: r3, str: p, firstInvalidLoc: c, lineStart: n2, curLine: s, containsInvalid: !!c };
        };
        var _isDigit = function(e3) {
          return e3 >= 48 && e3 <= 57;
        };
        const r2 = { decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]), hex: /* @__PURE__ */ new Set([46, 88, 95, 120]) }, n = { bin: (e3) => 48 === e3 || 49 === e3, oct: (e3) => e3 >= 48 && e3 <= 55, dec: (e3) => e3 >= 48 && e3 <= 57, hex: (e3) => e3 >= 48 && e3 <= 57 || e3 >= 65 && e3 <= 70 || e3 >= 97 && e3 <= 102 };
        function isStringEnd(e3, t3, r3, n2) {
          return "template" === e3 ? 96 === t3 || 36 === t3 && 123 === r3.charCodeAt(n2 + 1) : t3 === ("double" === e3 ? 34 : 39);
        }
        function readEscapedChar(e3, t3, r3, n2, s, i) {
          const o = !s;
          t3++;
          const res = (e4) => ({ pos: t3, ch: e4, lineStart: r3, curLine: n2 }), a = e3.charCodeAt(t3++);
          switch (a) {
            case 110:
              return res("\n");
            case 114:
              return res("\r");
            case 120: {
              let s2;
              return { code: s2, pos: t3 } = readHexChar(e3, t3, r3, n2, 2, false, o, i), res(null === s2 ? null : String.fromCharCode(s2));
            }
            case 117: {
              let s2;
              return { code: s2, pos: t3 } = readCodePoint(e3, t3, r3, n2, o, i), res(null === s2 ? null : String.fromCodePoint(s2));
            }
            case 116:
              return res("	");
            case 98:
              return res("\b");
            case 118:
              return res("\v");
            case 102:
              return res("\f");
            case 13:
              10 === e3.charCodeAt(t3) && ++t3;
            case 10:
              r3 = t3, ++n2;
            case 8232:
            case 8233:
              return res("");
            case 56:
            case 57:
              if (s) return res(null);
              i.strictNumericEscape(t3 - 1, r3, n2);
            default:
              if (a >= 48 && a <= 55) {
                const o2 = t3 - 1;
                let a2 = /^[0-7]+/.exec(e3.slice(o2, t3 + 2))[0], l = parseInt(a2, 8);
                l > 255 && (a2 = a2.slice(0, -1), l = parseInt(a2, 8)), t3 += a2.length - 1;
                const p = e3.charCodeAt(t3);
                if ("0" !== a2 || 56 === p || 57 === p) {
                  if (s) return res(null);
                  i.strictNumericEscape(o2, r3, n2);
                }
                return res(String.fromCharCode(l));
              }
              return res(String.fromCharCode(a));
          }
        }
        function readHexChar(e3, t3, r3, n2, s, i, o, a) {
          const l = t3;
          let p;
          return { n: p, pos: t3 } = readInt(e3, t3, r3, n2, 16, s, i, false, a, !o), null === p && (o ? a.invalidEscapeSequence(l, r3, n2) : t3 = l - 1), { code: p, pos: t3 };
        }
        function readInt(e3, t3, s, i, o, a, l, p, c, u) {
          const d = t3, h = 16 === o ? r2.hex : r2.decBinOct, m = 16 === o ? n.hex : 10 === o ? n.dec : 8 === o ? n.oct : n.bin;
          let f = false, y = 0;
          for (let r3 = 0, n2 = null == a ? 1 / 0 : a; r3 < n2; ++r3) {
            const r4 = e3.charCodeAt(t3);
            let n3;
            if (95 === r4 && "bail" !== p) {
              const r5 = e3.charCodeAt(t3 - 1), n4 = e3.charCodeAt(t3 + 1);
              if (p) {
                if (Number.isNaN(n4) || !m(n4) || h.has(r5) || h.has(n4)) {
                  if (u) return { n: null, pos: t3 };
                  c.unexpectedNumericSeparator(t3, s, i);
                }
              } else {
                if (u) return { n: null, pos: t3 };
                c.numericSeparatorInEscapeSequence(t3, s, i);
              }
              ++t3;
              continue;
            }
            if (n3 = r4 >= 97 ? r4 - 97 + 10 : r4 >= 65 ? r4 - 65 + 10 : _isDigit(r4) ? r4 - 48 : 1 / 0, n3 >= o) {
              if (n3 <= 9 && u) return { n: null, pos: t3 };
              if (n3 <= 9 && c.invalidDigit(t3, s, i, o)) n3 = 0;
              else {
                if (!l) break;
                n3 = 0, f = true;
              }
            }
            ++t3, y = y * o + n3;
          }
          return t3 === d || null != a && t3 - d !== a || f ? { n: null, pos: t3 } : { n: y, pos: t3 };
        }
        function readCodePoint(e3, t3, r3, n2, s, i) {
          let o;
          if (123 === e3.charCodeAt(t3)) {
            if (++t3, { code: o, pos: t3 } = readHexChar(e3, t3, r3, n2, e3.indexOf("}", t3) - t3, true, s, i), ++t3, null !== o && o > 1114111) {
              if (!s) return { code: null, pos: t3 };
              i.invalidCodePoint(t3, r3, n2);
            }
          } else ({ code: o, pos: t3 } = readHexChar(e3, t3, r3, n2, 4, false, s, i));
          return { code: o, pos: t3 };
        }
      }, "./node_modules/.pnpm/@babel+helper-validator-identifier@7.27.1/node_modules/@babel/helper-validator-identifier/lib/identifier.js": function(e2, t2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.isIdentifierChar = isIdentifierChar, t2.isIdentifierName = function(e3) {
          let t3 = true;
          for (let r3 = 0; r3 < e3.length; r3++) {
            let n2 = e3.charCodeAt(r3);
            if (55296 == (64512 & n2) && r3 + 1 < e3.length) {
              const t4 = e3.charCodeAt(++r3);
              56320 == (64512 & t4) && (n2 = 65536 + ((1023 & n2) << 10) + (1023 & t4));
            }
            if (t3) {
              if (t3 = false, !isIdentifierStart(n2)) return false;
            } else if (!isIdentifierChar(n2)) return false;
          }
          return !t3;
        }, t2.isIdentifierStart = isIdentifierStart;
        let r2 = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC", n = "\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65";
        const s = new RegExp("[" + r2 + "]"), i = new RegExp("[" + r2 + n + "]");
        r2 = n = null;
        const o = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], a = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
        function isInAstralSet(e3, t3) {
          let r3 = 65536;
          for (let n2 = 0, s2 = t3.length; n2 < s2; n2 += 2) {
            if (r3 += t3[n2], r3 > e3) return false;
            if (r3 += t3[n2 + 1], r3 >= e3) return true;
          }
          return false;
        }
        function isIdentifierStart(e3) {
          return e3 < 65 ? 36 === e3 : e3 <= 90 || (e3 < 97 ? 95 === e3 : e3 <= 122 || (e3 <= 65535 ? e3 >= 170 && s.test(String.fromCharCode(e3)) : isInAstralSet(e3, o)));
        }
        function isIdentifierChar(e3) {
          return e3 < 48 ? 36 === e3 : e3 < 58 || !(e3 < 65) && (e3 <= 90 || (e3 < 97 ? 95 === e3 : e3 <= 122 || (e3 <= 65535 ? e3 >= 170 && i.test(String.fromCharCode(e3)) : isInAstralSet(e3, o) || isInAstralSet(e3, a))));
        }
      }, "./node_modules/.pnpm/@babel+helper-validator-identifier@7.27.1/node_modules/@babel/helper-validator-identifier/lib/index.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), Object.defineProperty(t2, "isIdentifierChar", { enumerable: true, get: function() {
          return n.isIdentifierChar;
        } }), Object.defineProperty(t2, "isIdentifierName", { enumerable: true, get: function() {
          return n.isIdentifierName;
        } }), Object.defineProperty(t2, "isIdentifierStart", { enumerable: true, get: function() {
          return n.isIdentifierStart;
        } }), Object.defineProperty(t2, "isKeyword", { enumerable: true, get: function() {
          return s.isKeyword;
        } }), Object.defineProperty(t2, "isReservedWord", { enumerable: true, get: function() {
          return s.isReservedWord;
        } }), Object.defineProperty(t2, "isStrictBindOnlyReservedWord", { enumerable: true, get: function() {
          return s.isStrictBindOnlyReservedWord;
        } }), Object.defineProperty(t2, "isStrictBindReservedWord", { enumerable: true, get: function() {
          return s.isStrictBindReservedWord;
        } }), Object.defineProperty(t2, "isStrictReservedWord", { enumerable: true, get: function() {
          return s.isStrictReservedWord;
        } });
        var n = r2("./node_modules/.pnpm/@babel+helper-validator-identifier@7.27.1/node_modules/@babel/helper-validator-identifier/lib/identifier.js"), s = r2("./node_modules/.pnpm/@babel+helper-validator-identifier@7.27.1/node_modules/@babel/helper-validator-identifier/lib/keyword.js");
      }, "./node_modules/.pnpm/@babel+helper-validator-identifier@7.27.1/node_modules/@babel/helper-validator-identifier/lib/keyword.js": function(e2, t2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.isKeyword = function(e3) {
          return s.has(e3);
        }, t2.isReservedWord = isReservedWord, t2.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord, t2.isStrictBindReservedWord = function(e3, t3) {
          return isStrictReservedWord(e3, t3) || isStrictBindOnlyReservedWord(e3);
        }, t2.isStrictReservedWord = isStrictReservedWord;
        const r2 = ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"], n = ["eval", "arguments"], s = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"]), i = new Set(r2), o = new Set(n);
        function isReservedWord(e3, t3) {
          return t3 && "await" === e3 || "enum" === e3;
        }
        function isStrictReservedWord(e3, t3) {
          return isReservedWord(e3, t3) || i.has(e3);
        }
        function isStrictBindOnlyReservedWord(e3) {
          return o.has(e3);
        }
      }, "./node_modules/.pnpm/@babel+helper-validator-option@7.27.1/node_modules/@babel/helper-validator-option/lib/find-suggestion.js": function(e2, t2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.findSuggestion = function(e3, t3) {
          const n = t3.map((t4) => (function(e4, t5) {
            let n2, s, i = [], o = [];
            const a = e4.length, l = t5.length;
            if (!a) return l;
            if (!l) return a;
            for (s = 0; s <= l; s++) i[s] = s;
            for (n2 = 1; n2 <= a; n2++) {
              for (o = [n2], s = 1; s <= l; s++) o[s] = e4[n2 - 1] === t5[s - 1] ? i[s - 1] : r2(i[s - 1], i[s], o[s - 1]) + 1;
              i = o;
            }
            return o[l];
          })(t4, e3));
          return t3[n.indexOf(r2(...n))];
        };
        const { min: r2 } = Math;
      }, "./node_modules/.pnpm/@babel+helper-validator-option@7.27.1/node_modules/@babel/helper-validator-option/lib/index.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), Object.defineProperty(t2, "OptionValidator", { enumerable: true, get: function() {
          return n.OptionValidator;
        } }), Object.defineProperty(t2, "findSuggestion", { enumerable: true, get: function() {
          return s.findSuggestion;
        } });
        var n = r2("./node_modules/.pnpm/@babel+helper-validator-option@7.27.1/node_modules/@babel/helper-validator-option/lib/validator.js"), s = r2("./node_modules/.pnpm/@babel+helper-validator-option@7.27.1/node_modules/@babel/helper-validator-option/lib/find-suggestion.js");
      }, "./node_modules/.pnpm/@babel+helper-validator-option@7.27.1/node_modules/@babel/helper-validator-option/lib/validator.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.OptionValidator = void 0;
        var n = r2("./node_modules/.pnpm/@babel+helper-validator-option@7.27.1/node_modules/@babel/helper-validator-option/lib/find-suggestion.js");
        t2.OptionValidator = class {
          constructor(e3) {
            this.descriptor = e3;
          }
          validateTopLevelOptions(e3, t3) {
            const r3 = Object.keys(t3);
            for (const t4 of Object.keys(e3)) if (!r3.includes(t4)) throw new Error(this.formatMessage(`'${t4}' is not a valid top-level option.
- Did you mean '${(0, n.findSuggestion)(t4, r3)}'?`));
          }
          validateBooleanOption(e3, t3, r3) {
            return void 0 === t3 ? r3 : (this.invariant("boolean" == typeof t3, `'${e3}' option must be a boolean.`), t3);
          }
          validateStringOption(e3, t3, r3) {
            return void 0 === t3 ? r3 : (this.invariant("string" == typeof t3, `'${e3}' option must be a string.`), t3);
          }
          invariant(e3, t3) {
            if (!e3) throw new Error(this.formatMessage(t3));
          }
          formatMessage(e3) {
            return `${this.descriptor}: ${e3}`;
          }
        };
      }, "./node_modules/.pnpm/@babel+helpers@7.28.4/node_modules/@babel/helpers/lib/helpers-generated.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var n = r2("./node_modules/.pnpm/@babel+template@7.27.2/node_modules/@babel/template/lib/index.js");
        function helper(e3, t3, r3) {
          return Object.freeze({ minVersion: e3, ast: () => n.default.program.ast(t3, { preserveComments: true }), metadata: r3 });
        }
        const s = t2.default = { __proto__: null, OverloadYield: helper("7.18.14", "function _OverloadYield(e,d){this.v=e,this.k=d}", { globals: [], locals: { _OverloadYield: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_OverloadYield", dependencies: {}, internal: false }), applyDecoratedDescriptor: helper("7.0.0-beta.0", 'function _applyDecoratedDescriptor(i,e,r,n,l){var a={};return Object.keys(n).forEach(function(i){a[i]=n[i]}),a.enumerable=!!a.enumerable,a.configurable=!!a.configurable,("value"in a||a.initializer)&&(a.writable=!0),a=r.slice().reverse().reduce(function(r,n){return n(i,e,r)||r},a),l&&void 0!==a.initializer&&(a.value=a.initializer?a.initializer.call(l):void 0,a.initializer=void 0),void 0===a.initializer?(Object.defineProperty(i,e,a),null):a}', { globals: ["Object"], locals: { _applyDecoratedDescriptor: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_applyDecoratedDescriptor", dependencies: {}, internal: false }), applyDecs2311: helper("7.24.0", 'function applyDecs2311(e,t,n,r,o,i){var a,c,u,s,f,l,p,d=Symbol.metadata||Symbol.for("Symbol.metadata"),m=Object.defineProperty,h=Object.create,y=[h(null),h(null)],v=t.length;function g(t,n,r){return function(o,i){n&&(i=o,o=e);for(var a=0;a<t.length;a++)i=t[a].apply(o,r?[i]:[]);return r?i:o}}function b(e,t,n,r){if("function"!=typeof e&&(r||void 0!==e))throw new TypeError(t+" must "+(n||"be")+" a function"+(r?"":" or undefined"));return e}function applyDec(e,t,n,r,o,i,u,s,f,l,p){function d(e){if(!p(e))throw new TypeError("Attempted to access private element on non-instance")}var h=[].concat(t[0]),v=t[3],w=!u,D=1===o,S=3===o,j=4===o,E=2===o;function I(t,n,r){return function(o,i){return n&&(i=o,o=e),r&&r(o),P[t].call(o,i)}}if(!w){var P={},k=[],F=S?"get":j||D?"set":"value";if(f?(l||D?P={get:setFunctionName(function(){return v(this)},r,"get"),set:function(e){t[4](this,e)}}:P[F]=v,l||setFunctionName(P[F],r,E?"":F)):l||(P=Object.getOwnPropertyDescriptor(e,r)),!l&&!f){if((c=y[+s][r])&&7!==(c^o))throw Error("Decorating two elements with the same name ("+P[F].name+") is not supported yet");y[+s][r]=o<3?1:o}}for(var N=e,O=h.length-1;O>=0;O-=n?2:1){var T=b(h[O],"A decorator","be",!0),z=n?h[O-1]:void 0,A={},H={kind:["field","accessor","method","getter","setter","class"][o],name:r,metadata:a,addInitializer:function(e,t){if(e.v)throw new TypeError("attempted to call addInitializer after decoration was finished");b(t,"An initializer","be",!0),i.push(t)}.bind(null,A)};if(w)c=T.call(z,N,H),A.v=1,b(c,"class decorators","return")&&(N=c);else if(H.static=s,H.private=f,c=H.access={has:f?p.bind():function(e){return r in e}},j||(c.get=f?E?function(e){return d(e),P.value}:I("get",0,d):function(e){return e[r]}),E||S||(c.set=f?I("set",0,d):function(e,t){e[r]=t}),N=T.call(z,D?{get:P.get,set:P.set}:P[F],H),A.v=1,D){if("object"==typeof N&&N)(c=b(N.get,"accessor.get"))&&(P.get=c),(c=b(N.set,"accessor.set"))&&(P.set=c),(c=b(N.init,"accessor.init"))&&k.unshift(c);else if(void 0!==N)throw new TypeError("accessor decorators must return an object with get, set, or init properties or undefined")}else b(N,(l?"field":"method")+" decorators","return")&&(l?k.unshift(N):P[F]=N)}return o<2&&u.push(g(k,s,1),g(i,s,0)),l||w||(f?D?u.splice(-1,0,I("get",s),I("set",s)):u.push(E?P[F]:b.call.bind(P[F])):m(e,r,P)),N}function w(e){return m(e,d,{configurable:!0,enumerable:!0,value:a})}return void 0!==i&&(a=i[d]),a=h(null==a?null:a),f=[],l=function(e){e&&f.push(g(e))},p=function(t,r){for(var i=0;i<n.length;i++){var a=n[i],c=a[1],l=7&c;if((8&c)==t&&!l==r){var p=a[2],d=!!a[3],m=16&c;applyDec(t?e:e.prototype,a,m,d?"#"+p:toPropertyKey(p),l,l<2?[]:t?s=s||[]:u=u||[],f,!!t,d,r,t&&d?function(t){return checkInRHS(t)===e}:o)}}},p(8,0),p(0,0),p(8,1),p(0,1),l(u),l(s),c=f,v||w(e),{e:c,get c(){var n=[];return v&&[w(e=applyDec(e,[t],r,e.name,5,n)),g(n,1)]}}}', { globals: ["Symbol", "Object", "TypeError", "Error"], locals: { applyDecs2311: ["body.0.id"] }, exportBindingAssignments: [], exportName: "applyDecs2311", dependencies: { checkInRHS: ["body.0.body.body.5.argument.expressions.4.right.body.body.0.body.body.1.consequent.body.1.expression.arguments.10.consequent.body.body.0.argument.left.callee"], setFunctionName: ["body.0.body.body.3.body.body.3.consequent.body.1.test.expressions.0.consequent.expressions.0.consequent.right.properties.0.value.callee", "body.0.body.body.3.body.body.3.consequent.body.1.test.expressions.0.consequent.expressions.1.right.callee"], toPropertyKey: ["body.0.body.body.5.argument.expressions.4.right.body.body.0.body.body.1.consequent.body.1.expression.arguments.3.alternate.callee"] }, internal: false }), arrayLikeToArray: helper("7.9.0", "function _arrayLikeToArray(r,a){(null==a||a>r.length)&&(a=r.length);for(var e=0,n=Array(a);e<a;e++)n[e]=r[e];return n}", { globals: ["Array"], locals: { _arrayLikeToArray: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_arrayLikeToArray", dependencies: {}, internal: false }), arrayWithHoles: helper("7.0.0-beta.0", "function _arrayWithHoles(r){if(Array.isArray(r))return r}", { globals: ["Array"], locals: { _arrayWithHoles: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_arrayWithHoles", dependencies: {}, internal: false }), arrayWithoutHoles: helper("7.0.0-beta.0", "function _arrayWithoutHoles(r){if(Array.isArray(r))return arrayLikeToArray(r)}", { globals: ["Array"], locals: { _arrayWithoutHoles: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_arrayWithoutHoles", dependencies: { arrayLikeToArray: ["body.0.body.body.0.consequent.argument.callee"] }, internal: false }), assertClassBrand: helper("7.24.0", 'function _assertClassBrand(e,t,n){if("function"==typeof e?e===t:e.has(t))return arguments.length<3?t:n;throw new TypeError("Private element is not present on this object")}', { globals: ["TypeError"], locals: { _assertClassBrand: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_assertClassBrand", dependencies: {}, internal: false }), assertThisInitialized: helper("7.0.0-beta.0", `function _assertThisInitialized(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}`, { globals: ["ReferenceError"], locals: { _assertThisInitialized: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_assertThisInitialized", dependencies: {}, internal: false }), asyncGeneratorDelegate: helper("7.0.0-beta.0", 'function _asyncGeneratorDelegate(t){var e={},n=!1;function pump(e,r){return n=!0,r=new Promise(function(n){n(t[e](r))}),{done:!1,value:new OverloadYield(r,1)}}return e["undefined"!=typeof Symbol&&Symbol.iterator||"@@iterator"]=function(){return this},e.next=function(t){return n?(n=!1,t):pump("next",t)},"function"==typeof t.throw&&(e.throw=function(t){if(n)throw n=!1,t;return pump("throw",t)}),"function"==typeof t.return&&(e.return=function(t){return n?(n=!1,t):pump("return",t)}),e}', { globals: ["Promise", "Symbol"], locals: { _asyncGeneratorDelegate: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_asyncGeneratorDelegate", dependencies: { OverloadYield: ["body.0.body.body.1.body.body.0.argument.expressions.2.properties.1.value.callee"] }, internal: false }), asyncIterator: helper("7.15.9", 'function _asyncIterator(r){var n,t,o,e=2;for("undefined"!=typeof Symbol&&(t=Symbol.asyncIterator,o=Symbol.iterator);e--;){if(t&&null!=(n=r[t]))return n.call(r);if(o&&null!=(n=r[o]))return new AsyncFromSyncIterator(n.call(r));t="@@asyncIterator",o="@@iterator"}throw new TypeError("Object is not async iterable")}function AsyncFromSyncIterator(r){function AsyncFromSyncIteratorContinuation(r){if(Object(r)!==r)return Promise.reject(new TypeError(r+" is not an object."));var n=r.done;return Promise.resolve(r.value).then(function(r){return{value:r,done:n}})}return AsyncFromSyncIterator=function(r){this.s=r,this.n=r.next},AsyncFromSyncIterator.prototype={s:null,n:null,next:function(){return AsyncFromSyncIteratorContinuation(this.n.apply(this.s,arguments))},return:function(r){var n=this.s.return;return void 0===n?Promise.resolve({value:r,done:!0}):AsyncFromSyncIteratorContinuation(n.apply(this.s,arguments))},throw:function(r){var n=this.s.return;return void 0===n?Promise.reject(r):AsyncFromSyncIteratorContinuation(n.apply(this.s,arguments))}},new AsyncFromSyncIterator(r)}', { globals: ["Symbol", "TypeError", "Object", "Promise"], locals: { _asyncIterator: ["body.0.id"], AsyncFromSyncIterator: ["body.1.id", "body.0.body.body.1.body.body.1.consequent.argument.callee", "body.1.body.body.1.argument.expressions.1.left.object", "body.1.body.body.1.argument.expressions.2.callee", "body.1.body.body.1.argument.expressions.0.left"] }, exportBindingAssignments: [], exportName: "_asyncIterator", dependencies: {}, internal: false }), asyncToGenerator: helper("7.0.0-beta.0", 'function asyncGeneratorStep(n,t,e,r,o,a,c){try{var i=n[a](c),u=i.value}catch(n){return void e(n)}i.done?t(u):Promise.resolve(u).then(r,o)}function _asyncToGenerator(n){return function(){var t=this,e=arguments;return new Promise(function(r,o){var a=n.apply(t,e);function _next(n){asyncGeneratorStep(a,r,o,_next,_throw,"next",n)}function _throw(n){asyncGeneratorStep(a,r,o,_next,_throw,"throw",n)}_next(void 0)})}}', { globals: ["Promise"], locals: { asyncGeneratorStep: ["body.0.id", "body.1.body.body.0.argument.body.body.1.argument.arguments.0.body.body.1.body.body.0.expression.callee", "body.1.body.body.0.argument.body.body.1.argument.arguments.0.body.body.2.body.body.0.expression.callee"], _asyncToGenerator: ["body.1.id"] }, exportBindingAssignments: [], exportName: "_asyncToGenerator", dependencies: {}, internal: false }), awaitAsyncGenerator: helper("7.0.0-beta.0", "function _awaitAsyncGenerator(e){return new OverloadYield(e,0)}", { globals: [], locals: { _awaitAsyncGenerator: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_awaitAsyncGenerator", dependencies: { OverloadYield: ["body.0.body.body.0.argument.callee"] }, internal: false }), callSuper: helper("7.23.8", "function _callSuper(t,o,e){return o=getPrototypeOf(o),possibleConstructorReturn(t,isNativeReflectConstruct()?Reflect.construct(o,e||[],getPrototypeOf(t).constructor):o.apply(t,e))}", { globals: ["Reflect"], locals: { _callSuper: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_callSuper", dependencies: { getPrototypeOf: ["body.0.body.body.0.argument.expressions.0.right.callee", "body.0.body.body.0.argument.expressions.1.arguments.1.consequent.arguments.2.object.callee"], isNativeReflectConstruct: ["body.0.body.body.0.argument.expressions.1.arguments.1.test.callee"], possibleConstructorReturn: ["body.0.body.body.0.argument.expressions.1.callee"] }, internal: false }), checkInRHS: helper("7.20.5", `function _checkInRHS(e){if(Object(e)!==e)throw TypeError("right-hand side of 'in' should be an object, got "+(null!==e?typeof e:"null"));return e}`, { globals: ["Object", "TypeError"], locals: { _checkInRHS: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_checkInRHS", dependencies: {}, internal: false }), checkPrivateRedeclaration: helper("7.14.1", 'function _checkPrivateRedeclaration(e,t){if(t.has(e))throw new TypeError("Cannot initialize the same private elements twice on an object")}', { globals: ["TypeError"], locals: { _checkPrivateRedeclaration: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_checkPrivateRedeclaration", dependencies: {}, internal: false }), classCallCheck: helper("7.0.0-beta.0", 'function _classCallCheck(a,n){if(!(a instanceof n))throw new TypeError("Cannot call a class as a function")}', { globals: ["TypeError"], locals: { _classCallCheck: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classCallCheck", dependencies: {}, internal: false }), classNameTDZError: helper("7.0.0-beta.0", `function _classNameTDZError(e){throw new ReferenceError('Class "'+e+'" cannot be referenced in computed property keys.')}`, { globals: ["ReferenceError"], locals: { _classNameTDZError: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classNameTDZError", dependencies: {}, internal: false }), classPrivateFieldGet2: helper("7.24.0", "function _classPrivateFieldGet2(s,a){return s.get(assertClassBrand(s,a))}", { globals: [], locals: { _classPrivateFieldGet2: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classPrivateFieldGet2", dependencies: { assertClassBrand: ["body.0.body.body.0.argument.arguments.0.callee"] }, internal: false }), classPrivateFieldInitSpec: helper("7.14.1", "function _classPrivateFieldInitSpec(e,t,a){checkPrivateRedeclaration(e,t),t.set(e,a)}", { globals: [], locals: { _classPrivateFieldInitSpec: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classPrivateFieldInitSpec", dependencies: { checkPrivateRedeclaration: ["body.0.body.body.0.expression.expressions.0.callee"] }, internal: false }), classPrivateFieldLooseBase: helper("7.0.0-beta.0", 'function _classPrivateFieldBase(e,t){if(!{}.hasOwnProperty.call(e,t))throw new TypeError("attempted to use private field on non-instance");return e}', { globals: ["TypeError"], locals: { _classPrivateFieldBase: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classPrivateFieldBase", dependencies: {}, internal: false }), classPrivateFieldLooseKey: helper("7.0.0-beta.0", 'var id=0;function _classPrivateFieldKey(e){return"__private_"+id+++"_"+e}', { globals: [], locals: { id: ["body.0.declarations.0.id", "body.1.body.body.0.argument.left.left.right.argument", "body.1.body.body.0.argument.left.left.right.argument"], _classPrivateFieldKey: ["body.1.id"] }, exportBindingAssignments: [], exportName: "_classPrivateFieldKey", dependencies: {}, internal: false }), classPrivateFieldSet2: helper("7.24.0", "function _classPrivateFieldSet2(s,a,r){return s.set(assertClassBrand(s,a),r),r}", { globals: [], locals: { _classPrivateFieldSet2: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classPrivateFieldSet2", dependencies: { assertClassBrand: ["body.0.body.body.0.argument.expressions.0.arguments.0.callee"] }, internal: false }), classPrivateGetter: helper("7.24.0", "function _classPrivateGetter(s,r,a){return a(assertClassBrand(s,r))}", { globals: [], locals: { _classPrivateGetter: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classPrivateGetter", dependencies: { assertClassBrand: ["body.0.body.body.0.argument.arguments.0.callee"] }, internal: false }), classPrivateMethodInitSpec: helper("7.14.1", "function _classPrivateMethodInitSpec(e,a){checkPrivateRedeclaration(e,a),a.add(e)}", { globals: [], locals: { _classPrivateMethodInitSpec: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classPrivateMethodInitSpec", dependencies: { checkPrivateRedeclaration: ["body.0.body.body.0.expression.expressions.0.callee"] }, internal: false }), classPrivateSetter: helper("7.24.0", "function _classPrivateSetter(s,r,a,t){return r(assertClassBrand(s,a),t),t}", { globals: [], locals: { _classPrivateSetter: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classPrivateSetter", dependencies: { assertClassBrand: ["body.0.body.body.0.argument.expressions.0.arguments.0.callee"] }, internal: false }), classStaticPrivateMethodGet: helper("7.3.2", "function _classStaticPrivateMethodGet(s,a,t){return assertClassBrand(a,s),t}", { globals: [], locals: { _classStaticPrivateMethodGet: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classStaticPrivateMethodGet", dependencies: { assertClassBrand: ["body.0.body.body.0.argument.expressions.0.callee"] }, internal: false }), construct: helper("7.0.0-beta.0", "function _construct(t,e,r){if(isNativeReflectConstruct())return Reflect.construct.apply(null,arguments);var o=[null];o.push.apply(o,e);var p=new(t.bind.apply(t,o));return r&&setPrototypeOf(p,r.prototype),p}", { globals: ["Reflect"], locals: { _construct: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_construct", dependencies: { isNativeReflectConstruct: ["body.0.body.body.0.test.callee"], setPrototypeOf: ["body.0.body.body.4.argument.expressions.0.right.callee"] }, internal: false }), createClass: helper("7.0.0-beta.0", 'function _defineProperties(e,r){for(var t=0;t<r.length;t++){var o=r[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,toPropertyKey(o.key),o)}}function _createClass(e,r,t){return r&&_defineProperties(e.prototype,r),t&&_defineProperties(e,t),Object.defineProperty(e,"prototype",{writable:!1}),e}', { globals: ["Object"], locals: { _defineProperties: ["body.0.id", "body.1.body.body.0.argument.expressions.0.right.callee", "body.1.body.body.0.argument.expressions.1.right.callee"], _createClass: ["body.1.id"] }, exportBindingAssignments: [], exportName: "_createClass", dependencies: { toPropertyKey: ["body.0.body.body.0.body.body.1.expression.expressions.3.arguments.1.callee"] }, internal: false }), createForOfIteratorHelper: helper("7.9.0", 'function _createForOfIteratorHelper(r,e){var t="undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(!t){if(Array.isArray(r)||(t=unsupportedIterableToArray(r))||e&&r&&"number"==typeof r.length){t&&(r=t);var n=0,F=function(){};return{s:F,n:function(){return n>=r.length?{done:!0}:{done:!1,value:r[n++]}},e:function(r){throw r},f:F}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var o,a=!0,u=!1;return{s:function(){t=t.call(r)},n:function(){var r=t.next();return a=r.done,r},e:function(r){u=!0,o=r},f:function(){try{a||null==t.return||t.return()}finally{if(u)throw o}}}}', { globals: ["Symbol", "Array", "TypeError"], locals: { _createForOfIteratorHelper: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_createForOfIteratorHelper", dependencies: { unsupportedIterableToArray: ["body.0.body.body.1.consequent.body.0.test.left.right.right.callee"] }, internal: false }), createForOfIteratorHelperLoose: helper("7.9.0", 'function _createForOfIteratorHelperLoose(r,e){var t="undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(t)return(t=t.call(r)).next.bind(t);if(Array.isArray(r)||(t=unsupportedIterableToArray(r))||e&&r&&"number"==typeof r.length){t&&(r=t);var o=0;return function(){return o>=r.length?{done:!0}:{done:!1,value:r[o++]}}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}', { globals: ["Symbol", "Array", "TypeError"], locals: { _createForOfIteratorHelperLoose: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_createForOfIteratorHelperLoose", dependencies: { unsupportedIterableToArray: ["body.0.body.body.2.test.left.right.right.callee"] }, internal: false }), createSuper: helper("7.9.0", "function _createSuper(t){var r=isNativeReflectConstruct();return function(){var e,o=getPrototypeOf(t);if(r){var s=getPrototypeOf(this).constructor;e=Reflect.construct(o,arguments,s)}else e=o.apply(this,arguments);return possibleConstructorReturn(this,e)}}", { globals: ["Reflect"], locals: { _createSuper: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_createSuper", dependencies: { getPrototypeOf: ["body.0.body.body.1.argument.body.body.0.declarations.1.init.callee", "body.0.body.body.1.argument.body.body.1.consequent.body.0.declarations.0.init.object.callee"], isNativeReflectConstruct: ["body.0.body.body.0.declarations.0.init.callee"], possibleConstructorReturn: ["body.0.body.body.1.argument.body.body.2.argument.callee"] }, internal: false }), decorate: helper("7.1.5", `function _decorate(e,r,t,i){var o=_getDecoratorsApi();if(i)for(var n=0;n<i.length;n++)o=i[n](o);var s=r(function(e){o.initializeInstanceElements(e,a.elements)},t),a=o.decorateClass(_coalesceClassElements(s.d.map(_createElementDescriptor)),e);return o.initializeClassElements(s.F,a.elements),o.runClassFinishers(s.F,a.finishers)}function _getDecoratorsApi(){_getDecoratorsApi=function(){return e};var e={elementsDefinitionOrder:[["method"],["field"]],initializeInstanceElements:function(e,r){["method","field"].forEach(function(t){r.forEach(function(r){r.kind===t&&"own"===r.placement&&this.defineClassElement(e,r)},this)},this)},initializeClassElements:function(e,r){var t=e.prototype;["method","field"].forEach(function(i){r.forEach(function(r){var o=r.placement;if(r.kind===i&&("static"===o||"prototype"===o)){var n="static"===o?e:t;this.defineClassElement(n,r)}},this)},this)},defineClassElement:function(e,r){var t=r.descriptor;if("field"===r.kind){var i=r.initializer;t={enumerable:t.enumerable,writable:t.writable,configurable:t.configurable,value:void 0===i?void 0:i.call(e)}}Object.defineProperty(e,r.key,t)},decorateClass:function(e,r){var t=[],i=[],o={static:[],prototype:[],own:[]};if(e.forEach(function(e){this.addElementPlacement(e,o)},this),e.forEach(function(e){if(!_hasDecorators(e))return t.push(e);var r=this.decorateElement(e,o);t.push(r.element),t.push.apply(t,r.extras),i.push.apply(i,r.finishers)},this),!r)return{elements:t,finishers:i};var n=this.decorateConstructor(t,r);return i.push.apply(i,n.finishers),n.finishers=i,n},addElementPlacement:function(e,r,t){var i=r[e.placement];if(!t&&-1!==i.indexOf(e.key))throw new TypeError("Duplicated element ("+e.key+")");i.push(e.key)},decorateElement:function(e,r){for(var t=[],i=[],o=e.decorators,n=o.length-1;n>=0;n--){var s=r[e.placement];s.splice(s.indexOf(e.key),1);var a=this.fromElementDescriptor(e),l=this.toElementFinisherExtras((0,o[n])(a)||a);e=l.element,this.addElementPlacement(e,r),l.finisher&&i.push(l.finisher);var c=l.extras;if(c){for(var p=0;p<c.length;p++)this.addElementPlacement(c[p],r);t.push.apply(t,c)}}return{element:e,finishers:i,extras:t}},decorateConstructor:function(e,r){for(var t=[],i=r.length-1;i>=0;i--){var o=this.fromClassDescriptor(e),n=this.toClassDescriptor((0,r[i])(o)||o);if(void 0!==n.finisher&&t.push(n.finisher),void 0!==n.elements){e=n.elements;for(var s=0;s<e.length-1;s++)for(var a=s+1;a<e.length;a++)if(e[s].key===e[a].key&&e[s].placement===e[a].placement)throw new TypeError("Duplicated element ("+e[s].key+")")}}return{elements:e,finishers:t}},fromElementDescriptor:function(e){var r={kind:e.kind,key:e.key,placement:e.placement,descriptor:e.descriptor};return Object.defineProperty(r,Symbol.toStringTag,{value:"Descriptor",configurable:!0}),"field"===e.kind&&(r.initializer=e.initializer),r},toElementDescriptors:function(e){if(void 0!==e)return toArray(e).map(function(e){var r=this.toElementDescriptor(e);return this.disallowProperty(e,"finisher","An element descriptor"),this.disallowProperty(e,"extras","An element descriptor"),r},this)},toElementDescriptor:function(e){var r=e.kind+"";if("method"!==r&&"field"!==r)throw new TypeError('An element descriptor\\'s .kind property must be either "method" or "field", but a decorator created an element descriptor with .kind "'+r+'"');var t=toPropertyKey(e.key),i=e.placement+"";if("static"!==i&&"prototype"!==i&&"own"!==i)throw new TypeError('An element descriptor\\'s .placement property must be one of "static", "prototype" or "own", but a decorator created an element descriptor with .placement "'+i+'"');var o=e.descriptor;this.disallowProperty(e,"elements","An element descriptor");var n={kind:r,key:t,placement:i,descriptor:Object.assign({},o)};return"field"!==r?this.disallowProperty(e,"initializer","A method descriptor"):(this.disallowProperty(o,"get","The property descriptor of a field descriptor"),this.disallowProperty(o,"set","The property descriptor of a field descriptor"),this.disallowProperty(o,"value","The property descriptor of a field descriptor"),n.initializer=e.initializer),n},toElementFinisherExtras:function(e){return{element:this.toElementDescriptor(e),finisher:_optionalCallableProperty(e,"finisher"),extras:this.toElementDescriptors(e.extras)}},fromClassDescriptor:function(e){var r={kind:"class",elements:e.map(this.fromElementDescriptor,this)};return Object.defineProperty(r,Symbol.toStringTag,{value:"Descriptor",configurable:!0}),r},toClassDescriptor:function(e){var r=e.kind+"";if("class"!==r)throw new TypeError('A class descriptor\\'s .kind property must be "class", but a decorator created a class descriptor with .kind "'+r+'"');this.disallowProperty(e,"key","A class descriptor"),this.disallowProperty(e,"placement","A class descriptor"),this.disallowProperty(e,"descriptor","A class descriptor"),this.disallowProperty(e,"initializer","A class descriptor"),this.disallowProperty(e,"extras","A class descriptor");var t=_optionalCallableProperty(e,"finisher");return{elements:this.toElementDescriptors(e.elements),finisher:t}},runClassFinishers:function(e,r){for(var t=0;t<r.length;t++){var i=(0,r[t])(e);if(void 0!==i){if("function"!=typeof i)throw new TypeError("Finishers must return a constructor.");e=i}}return e},disallowProperty:function(e,r,t){if(void 0!==e[r])throw new TypeError(t+" can't have a ."+r+" property.")}};return e}function _createElementDescriptor(e){var r,t=toPropertyKey(e.key);"method"===e.kind?r={value:e.value,writable:!0,configurable:!0,enumerable:!1}:"get"===e.kind?r={get:e.value,configurable:!0,enumerable:!1}:"set"===e.kind?r={set:e.value,configurable:!0,enumerable:!1}:"field"===e.kind&&(r={configurable:!0,writable:!0,enumerable:!0});var i={kind:"field"===e.kind?"field":"method",key:t,placement:e.static?"static":"field"===e.kind?"own":"prototype",descriptor:r};return e.decorators&&(i.decorators=e.decorators),"field"===e.kind&&(i.initializer=e.value),i}function _coalesceGetterSetter(e,r){void 0!==e.descriptor.get?r.descriptor.get=e.descriptor.get:r.descriptor.set=e.descriptor.set}function _coalesceClassElements(e){for(var r=[],isSameElement=function(e){return"method"===e.kind&&e.key===o.key&&e.placement===o.placement},t=0;t<e.length;t++){var i,o=e[t];if("method"===o.kind&&(i=r.find(isSameElement)))if(_isDataDescriptor(o.descriptor)||_isDataDescriptor(i.descriptor)){if(_hasDecorators(o)||_hasDecorators(i))throw new ReferenceError("Duplicated methods ("+o.key+") can't be decorated.");i.descriptor=o.descriptor}else{if(_hasDecorators(o)){if(_hasDecorators(i))throw new ReferenceError("Decorators can't be placed on different accessors with for the same property ("+o.key+").");i.decorators=o.decorators}_coalesceGetterSetter(o,i)}else r.push(o)}return r}function _hasDecorators(e){return e.decorators&&e.decorators.length}function _isDataDescriptor(e){return void 0!==e&&!(void 0===e.value&&void 0===e.writable)}function _optionalCallableProperty(e,r){var t=e[r];if(void 0!==t&&"function"!=typeof t)throw new TypeError("Expected '"+r+"' to be a function");return t}`, { globals: ["Object", "TypeError", "Symbol", "ReferenceError"], locals: { _decorate: ["body.0.id"], _getDecoratorsApi: ["body.1.id", "body.0.body.body.0.declarations.0.init.callee", "body.1.body.body.0.expression.left"], _createElementDescriptor: ["body.2.id", "body.0.body.body.2.declarations.1.init.arguments.0.arguments.0.arguments.0"], _coalesceGetterSetter: ["body.3.id", "body.4.body.body.0.body.body.1.consequent.alternate.body.1.expression.callee"], _coalesceClassElements: ["body.4.id", "body.0.body.body.2.declarations.1.init.arguments.0.callee"], _hasDecorators: ["body.5.id", "body.1.body.body.1.declarations.0.init.properties.4.value.body.body.1.test.expressions.1.arguments.0.body.body.0.test.argument.callee", "body.4.body.body.0.body.body.1.consequent.consequent.body.0.test.left.callee", "body.4.body.body.0.body.body.1.consequent.consequent.body.0.test.right.callee", "body.4.body.body.0.body.body.1.consequent.alternate.body.0.test.callee", "body.4.body.body.0.body.body.1.consequent.alternate.body.0.consequent.body.0.test.callee"], _isDataDescriptor: ["body.6.id", "body.4.body.body.0.body.body.1.consequent.test.left.callee", "body.4.body.body.0.body.body.1.consequent.test.right.callee"], _optionalCallableProperty: ["body.7.id", "body.1.body.body.1.declarations.0.init.properties.11.value.body.body.0.argument.properties.1.value.callee", "body.1.body.body.1.declarations.0.init.properties.13.value.body.body.3.declarations.0.init.callee"] }, exportBindingAssignments: [], exportName: "_decorate", dependencies: { toArray: ["body.1.body.body.1.declarations.0.init.properties.9.value.body.body.0.consequent.argument.callee.object.callee"], toPropertyKey: ["body.1.body.body.1.declarations.0.init.properties.10.value.body.body.2.declarations.0.init.callee", "body.2.body.body.0.declarations.1.init.callee"] }, internal: false }), defaults: helper("7.0.0-beta.0", "function _defaults(e,r){for(var t=Object.getOwnPropertyNames(r),o=0;o<t.length;o++){var n=t[o],a=Object.getOwnPropertyDescriptor(r,n);a&&a.configurable&&void 0===e[n]&&Object.defineProperty(e,n,a)}return e}", { globals: ["Object"], locals: { _defaults: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_defaults", dependencies: {}, internal: false }), defineAccessor: helper("7.20.7", "function _defineAccessor(e,r,n,t){var c={configurable:!0,enumerable:!0};return c[e]=t,Object.defineProperty(r,n,c)}", { globals: ["Object"], locals: { _defineAccessor: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_defineAccessor", dependencies: {}, internal: false }), defineProperty: helper("7.0.0-beta.0", "function _defineProperty(e,r,t){return(r=toPropertyKey(r))in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}", { globals: ["Object"], locals: { _defineProperty: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_defineProperty", dependencies: { toPropertyKey: ["body.0.body.body.0.argument.expressions.0.test.left.right.callee"] }, internal: false }), extends: helper("7.0.0-beta.0", "function _extends(){return _extends=Object.assign?Object.assign.bind():function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var r in t)({}).hasOwnProperty.call(t,r)&&(n[r]=t[r])}return n},_extends.apply(null,arguments)}", { globals: ["Object"], locals: { _extends: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee.object", "body.0.body.body.0.argument.expressions.0.left"] }, exportBindingAssignments: ["body.0.body.body.0.argument.expressions.0"], exportName: "_extends", dependencies: {}, internal: false }), get: helper("7.0.0-beta.0", 'function _get(){return _get="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(e,t,r){var p=superPropBase(e,t);if(p){var n=Object.getOwnPropertyDescriptor(p,t);return n.get?n.get.call(arguments.length<3?e:r):n.value}},_get.apply(null,arguments)}', { globals: ["Reflect", "Object"], locals: { _get: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee.object", "body.0.body.body.0.argument.expressions.0.left"] }, exportBindingAssignments: ["body.0.body.body.0.argument.expressions.0"], exportName: "_get", dependencies: { superPropBase: ["body.0.body.body.0.argument.expressions.0.right.alternate.body.body.0.declarations.0.init.callee"] }, internal: false }), getPrototypeOf: helper("7.0.0-beta.0", "function _getPrototypeOf(t){return _getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},_getPrototypeOf(t)}", { globals: ["Object"], locals: { _getPrototypeOf: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee", "body.0.body.body.0.argument.expressions.0.left"] }, exportBindingAssignments: ["body.0.body.body.0.argument.expressions.0"], exportName: "_getPrototypeOf", dependencies: {}, internal: false }), identity: helper("7.17.0", "function _identity(t){return t}", { globals: [], locals: { _identity: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_identity", dependencies: {}, internal: false }), importDeferProxy: helper("7.23.0", "function _importDeferProxy(e){var t=null,constValue=function(e){return function(){return e}},proxy=function(r){return function(n,o,f){return null===t&&(t=e()),r(t,o,f)}};return new Proxy({},{defineProperty:constValue(!1),deleteProperty:constValue(!1),get:proxy(Reflect.get),getOwnPropertyDescriptor:proxy(Reflect.getOwnPropertyDescriptor),getPrototypeOf:constValue(null),isExtensible:constValue(!1),has:proxy(Reflect.has),ownKeys:proxy(Reflect.ownKeys),preventExtensions:constValue(!0),set:constValue(!1),setPrototypeOf:constValue(!1)})}", { globals: ["Proxy", "Reflect"], locals: { _importDeferProxy: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_importDeferProxy", dependencies: {}, internal: false }), inherits: helper("7.0.0-beta.0", 'function _inherits(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&setPrototypeOf(t,e)}', { globals: ["TypeError", "Object"], locals: { _inherits: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_inherits", dependencies: { setPrototypeOf: ["body.0.body.body.1.expression.expressions.2.right.callee"] }, internal: false }), inheritsLoose: helper("7.0.0-beta.0", "function _inheritsLoose(t,o){t.prototype=Object.create(o.prototype),t.prototype.constructor=t,setPrototypeOf(t,o)}", { globals: ["Object"], locals: { _inheritsLoose: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_inheritsLoose", dependencies: { setPrototypeOf: ["body.0.body.body.0.expression.expressions.2.callee"] }, internal: false }), initializerDefineProperty: helper("7.0.0-beta.0", "function _initializerDefineProperty(e,i,r,l){r&&Object.defineProperty(e,i,{enumerable:r.enumerable,configurable:r.configurable,writable:r.writable,value:r.initializer?r.initializer.call(l):void 0})}", { globals: ["Object"], locals: { _initializerDefineProperty: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_initializerDefineProperty", dependencies: {}, internal: false }), initializerWarningHelper: helper("7.0.0-beta.0", 'function _initializerWarningHelper(r,e){throw Error("Decorating class property failed. Please ensure that transform-class-properties is enabled and runs after the decorators transform.")}', { globals: ["Error"], locals: { _initializerWarningHelper: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_initializerWarningHelper", dependencies: {}, internal: false }), instanceof: helper("7.0.0-beta.0", 'function _instanceof(n,e){return null!=e&&"undefined"!=typeof Symbol&&e[Symbol.hasInstance]?!!e[Symbol.hasInstance](n):n instanceof e}', { globals: ["Symbol"], locals: { _instanceof: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_instanceof", dependencies: {}, internal: false }), interopRequireDefault: helper("7.0.0-beta.0", "function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}", { globals: [], locals: { _interopRequireDefault: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_interopRequireDefault", dependencies: {}, internal: false }), interopRequireWildcard: helper("7.14.0", 'function _interopRequireWildcard(e,t){if("function"==typeof WeakMap)var r=new WeakMap,n=new WeakMap;return(_interopRequireWildcard=function(e,t){if(!t&&e&&e.__esModule)return e;var o,i,f={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return f;if(o=t?n:r){if(o.has(e))return o.get(e);o.set(e,f)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((i=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(i.get||i.set)?o(f,t,i):f[t]=e[t]);return f})(e,t)}', { globals: ["WeakMap", "Object"], locals: { _interopRequireWildcard: ["body.0.id", "body.0.body.body.1.argument.callee.left"] }, exportBindingAssignments: ["body.0.body.body.1.argument.callee"], exportName: "_interopRequireWildcard", dependencies: {}, internal: false }), isNativeFunction: helper("7.0.0-beta.0", 'function _isNativeFunction(t){try{return-1!==Function.toString.call(t).indexOf("[native code]")}catch(n){return"function"==typeof t}}', { globals: ["Function"], locals: { _isNativeFunction: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_isNativeFunction", dependencies: {}, internal: false }), isNativeReflectConstruct: helper("7.9.0", "function _isNativeReflectConstruct(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){}))}catch(t){}return(_isNativeReflectConstruct=function(){return!!t})()}", { globals: ["Boolean", "Reflect"], locals: { _isNativeReflectConstruct: ["body.0.id", "body.0.body.body.1.argument.callee.left"] }, exportBindingAssignments: ["body.0.body.body.1.argument.callee"], exportName: "_isNativeReflectConstruct", dependencies: {}, internal: false }), iterableToArray: helper("7.0.0-beta.0", 'function _iterableToArray(r){if("undefined"!=typeof Symbol&&null!=r[Symbol.iterator]||null!=r["@@iterator"])return Array.from(r)}', { globals: ["Symbol", "Array"], locals: { _iterableToArray: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_iterableToArray", dependencies: {}, internal: false }), iterableToArrayLimit: helper("7.0.0-beta.0", 'function _iterableToArrayLimit(r,l){var t=null==r?null:"undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(null!=t){var e,n,i,u,a=[],f=!0,o=!1;try{if(i=(t=t.call(r)).next,0===l){if(Object(t)!==t)return;f=!1}else for(;!(f=(e=i.call(t)).done)&&(a.push(e.value),a.length!==l);f=!0);}catch(r){o=!0,n=r}finally{try{if(!f&&null!=t.return&&(u=t.return(),Object(u)!==u))return}finally{if(o)throw n}}return a}}', { globals: ["Symbol", "Object"], locals: { _iterableToArrayLimit: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_iterableToArrayLimit", dependencies: {}, internal: false }), jsx: helper("7.0.0-beta.0", 'var REACT_ELEMENT_TYPE;function _createRawReactElement(e,r,E,l){REACT_ELEMENT_TYPE||(REACT_ELEMENT_TYPE="function"==typeof Symbol&&Symbol.for&&Symbol.for("react.element")||60103);var o=e&&e.defaultProps,n=arguments.length-3;if(r||0===n||(r={children:void 0}),1===n)r.children=l;else if(n>1){for(var t=Array(n),f=0;f<n;f++)t[f]=arguments[f+3];r.children=t}if(r&&o)for(var i in o)void 0===r[i]&&(r[i]=o[i]);else r||(r=o||{});return{$$typeof:REACT_ELEMENT_TYPE,type:e,key:void 0===E?null:""+E,ref:null,props:r,_owner:null}}', { globals: ["Symbol", "Array"], locals: { REACT_ELEMENT_TYPE: ["body.0.declarations.0.id", "body.1.body.body.0.expression.left", "body.1.body.body.4.argument.properties.0.value", "body.1.body.body.0.expression.right.left"], _createRawReactElement: ["body.1.id"] }, exportBindingAssignments: [], exportName: "_createRawReactElement", dependencies: {}, internal: false }), maybeArrayLike: helper("7.9.0", 'function _maybeArrayLike(r,a,e){if(a&&!Array.isArray(a)&&"number"==typeof a.length){var y=a.length;return arrayLikeToArray(a,void 0!==e&&e<y?e:y)}return r(a,e)}', { globals: ["Array"], locals: { _maybeArrayLike: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_maybeArrayLike", dependencies: { arrayLikeToArray: ["body.0.body.body.0.consequent.body.1.argument.callee"] }, internal: false }), newArrowCheck: helper("7.0.0-beta.0", 'function _newArrowCheck(n,r){if(n!==r)throw new TypeError("Cannot instantiate an arrow function")}', { globals: ["TypeError"], locals: { _newArrowCheck: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_newArrowCheck", dependencies: {}, internal: false }), nonIterableRest: helper("7.0.0-beta.0", 'function _nonIterableRest(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}', { globals: ["TypeError"], locals: { _nonIterableRest: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_nonIterableRest", dependencies: {}, internal: false }), nonIterableSpread: helper("7.0.0-beta.0", 'function _nonIterableSpread(){throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}', { globals: ["TypeError"], locals: { _nonIterableSpread: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_nonIterableSpread", dependencies: {}, internal: false }), nullishReceiverError: helper("7.22.6", 'function _nullishReceiverError(r){throw new TypeError("Cannot set property of null or undefined.")}', { globals: ["TypeError"], locals: { _nullishReceiverError: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_nullishReceiverError", dependencies: {}, internal: false }), objectDestructuringEmpty: helper("7.0.0-beta.0", 'function _objectDestructuringEmpty(t){if(null==t)throw new TypeError("Cannot destructure "+t)}', { globals: ["TypeError"], locals: { _objectDestructuringEmpty: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_objectDestructuringEmpty", dependencies: {}, internal: false }), objectSpread2: helper("7.5.0", "function ownKeys(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);r&&(o=o.filter(function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable})),t.push.apply(t,o)}return t}function _objectSpread2(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?ownKeys(Object(t),!0).forEach(function(r){defineProperty(e,r,t[r])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):ownKeys(Object(t)).forEach(function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))})}return e}", { globals: ["Object"], locals: { ownKeys: ["body.0.id", "body.1.body.body.0.body.body.1.expression.consequent.callee.object.callee", "body.1.body.body.0.body.body.1.expression.alternate.alternate.callee.object.callee"], _objectSpread2: ["body.1.id"] }, exportBindingAssignments: [], exportName: "_objectSpread2", dependencies: { defineProperty: ["body.1.body.body.0.body.body.1.expression.consequent.arguments.0.body.body.0.expression.callee"] }, internal: false }), objectWithoutProperties: helper("7.0.0-beta.0", "function _objectWithoutProperties(e,t){if(null==e)return{};var o,r,i=objectWithoutPropertiesLoose(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(r=0;r<n.length;r++)o=n[r],-1===t.indexOf(o)&&{}.propertyIsEnumerable.call(e,o)&&(i[o]=e[o])}return i}", { globals: ["Object"], locals: { _objectWithoutProperties: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_objectWithoutProperties", dependencies: { objectWithoutPropertiesLoose: ["body.0.body.body.1.declarations.2.init.callee"] }, internal: false }), objectWithoutPropertiesLoose: helper("7.0.0-beta.0", "function _objectWithoutPropertiesLoose(r,e){if(null==r)return{};var t={};for(var n in r)if({}.hasOwnProperty.call(r,n)){if(-1!==e.indexOf(n))continue;t[n]=r[n]}return t}", { globals: [], locals: { _objectWithoutPropertiesLoose: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_objectWithoutPropertiesLoose", dependencies: {}, internal: false }), possibleConstructorReturn: helper("7.0.0-beta.0", 'function _possibleConstructorReturn(t,e){if(e&&("object"==typeof e||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return assertThisInitialized(t)}', { globals: ["TypeError"], locals: { _possibleConstructorReturn: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_possibleConstructorReturn", dependencies: { assertThisInitialized: ["body.0.body.body.2.argument.callee"] }, internal: false }), readOnlyError: helper("7.0.0-beta.0", `function _readOnlyError(r){throw new TypeError('"'+r+'" is read-only')}`, { globals: ["TypeError"], locals: { _readOnlyError: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_readOnlyError", dependencies: {}, internal: false }), regenerator: helper("7.27.0", `function _regenerator(){
/*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */
var e,t,r="function"==typeof Symbol?Symbol:{},n=r.iterator||"@@iterator",o=r.toStringTag||"@@toStringTag";function i(r,n,o,i){var c=n&&n.prototype instanceof Generator?n:Generator,u=Object.create(c.prototype);return define(u,"_invoke",function(r,n,o){var i,c,u,f=0,p=o||[],y=!1,G={p:0,n:0,v:e,a:d,f:d.bind(e,4),d:function(t,r){return i=t,c=0,u=e,G.n=r,a}};function d(r,n){for(c=r,u=n,t=0;!y&&f&&!o&&t<p.length;t++){var o,i=p[t],d=G.p,l=i[2];r>3?(o=l===n)&&(u=i[(c=i[4])?5:(c=3,3)],i[4]=i[5]=e):i[0]<=d&&((o=r<2&&d<i[1])?(c=0,G.v=n,G.n=i[1]):d<l&&(o=r<3||i[0]>n||n>l)&&(i[4]=r,i[5]=n,G.n=l,c=0))}if(o||r>1)return a;throw y=!0,n}return function(o,p,l){if(f>1)throw TypeError("Generator is already running");for(y&&1===p&&d(p,l),c=p,u=l;(t=c<2?e:u)||!y;){i||(c?c<3?(c>1&&(G.n=-1),d(c,u)):G.n=u:G.v=u);try{if(f=2,i){if(c||(o="next"),t=i[o]){if(!(t=t.call(i,u)))throw TypeError("iterator result is not an object");if(!t.done)return t;u=t.value,c<2&&(c=0)}else 1===c&&(t=i.return)&&t.call(i),c<2&&(u=TypeError("The iterator does not provide a '"+o+"' method"),c=1);i=e}else if((t=(y=G.n<0)?u:r.call(n,G))!==a)break}catch(t){i=e,c=1,u=t}finally{f=1}}return{value:t,done:y}}}(r,o,i),!0),u}var a={};function Generator(){}function GeneratorFunction(){}function GeneratorFunctionPrototype(){}t=Object.getPrototypeOf;var c=[][n]?t(t([][n]())):(define(t={},n,function(){return this}),t),u=GeneratorFunctionPrototype.prototype=Generator.prototype=Object.create(c);function f(e){return Object.setPrototypeOf?Object.setPrototypeOf(e,GeneratorFunctionPrototype):(e.__proto__=GeneratorFunctionPrototype,define(e,o,"GeneratorFunction")),e.prototype=Object.create(u),e}return GeneratorFunction.prototype=GeneratorFunctionPrototype,define(u,"constructor",GeneratorFunctionPrototype),define(GeneratorFunctionPrototype,"constructor",GeneratorFunction),GeneratorFunction.displayName="GeneratorFunction",define(GeneratorFunctionPrototype,o,"GeneratorFunction"),define(u),define(u,o,"Generator"),define(u,n,function(){return this}),define(u,"toString",function(){return"[object Generator]"}),(_regenerator=function(){return{w:i,m:f}})()}`, { globals: ["Symbol", "Object", "TypeError"], locals: { _regenerator: ["body.0.id", "body.0.body.body.9.argument.expressions.9.callee.left"] }, exportBindingAssignments: ["body.0.body.body.9.argument.expressions.9.callee"], exportName: "_regenerator", dependencies: { regeneratorDefine: ["body.0.body.body.1.body.body.1.argument.expressions.0.callee", "body.0.body.body.7.declarations.0.init.alternate.expressions.0.callee", "body.0.body.body.8.body.body.0.argument.expressions.0.alternate.expressions.1.callee", "body.0.body.body.9.argument.expressions.1.callee", "body.0.body.body.9.argument.expressions.2.callee", "body.0.body.body.9.argument.expressions.4.callee", "body.0.body.body.9.argument.expressions.5.callee", "body.0.body.body.9.argument.expressions.6.callee", "body.0.body.body.9.argument.expressions.7.callee", "body.0.body.body.9.argument.expressions.8.callee"] }, internal: false }), regeneratorAsync: helper("7.27.0", "function _regeneratorAsync(n,e,r,t,o){var a=asyncGen(n,e,r,t,o);return a.next().then(function(n){return n.done?n.value:a.next()})}", { globals: [], locals: { _regeneratorAsync: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_regeneratorAsync", dependencies: { regeneratorAsyncGen: ["body.0.body.body.0.declarations.0.init.callee"] }, internal: false }), regeneratorAsyncGen: helper("7.27.0", "function _regeneratorAsyncGen(r,e,t,o,n){return new regeneratorAsyncIterator(regenerator().w(r,e,t,o),n||Promise)}", { globals: ["Promise"], locals: { _regeneratorAsyncGen: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_regeneratorAsyncGen", dependencies: { regenerator: ["body.0.body.body.0.argument.arguments.0.callee.object.callee"], regeneratorAsyncIterator: ["body.0.body.body.0.argument.callee"] }, internal: false }), regeneratorAsyncIterator: helper("7.27.0", 'function AsyncIterator(t,e){function n(r,o,i,f){try{var c=t[r](o),u=c.value;return u instanceof OverloadYield?e.resolve(u.v).then(function(t){n("next",t,i,f)},function(t){n("throw",t,i,f)}):e.resolve(u).then(function(t){c.value=t,i(c)},function(t){return n("throw",t,i,f)})}catch(t){f(t)}}var r;this.next||(define(AsyncIterator.prototype),define(AsyncIterator.prototype,"function"==typeof Symbol&&Symbol.asyncIterator||"@asyncIterator",function(){return this})),define(this,"_invoke",function(t,o,i){function f(){return new e(function(e,r){n(t,i,e,r)})}return r=r?r.then(f,f):f()},!0)}', { globals: ["Symbol"], locals: { AsyncIterator: ["body.0.id", "body.0.body.body.2.expression.expressions.0.right.expressions.0.arguments.0.object", "body.0.body.body.2.expression.expressions.0.right.expressions.1.arguments.0.object"] }, exportBindingAssignments: [], exportName: "AsyncIterator", dependencies: { OverloadYield: ["body.0.body.body.0.body.body.0.block.body.1.argument.test.right"], regeneratorDefine: ["body.0.body.body.2.expression.expressions.0.right.expressions.0.callee", "body.0.body.body.2.expression.expressions.0.right.expressions.1.callee", "body.0.body.body.2.expression.expressions.1.callee"] }, internal: true }), regeneratorDefine: helper("7.27.0", 'function regeneratorDefine(e,r,n,t){var i=Object.defineProperty;try{i({},"",{})}catch(e){i=0}regeneratorDefine=function(e,r,n,t){function o(r,n){regeneratorDefine(e,r,function(e){return this._invoke(r,n,e)})}r?i?i(e,r,{value:n,enumerable:!t,configurable:!t,writable:!t}):e[r]=n:(o("next",0),o("throw",1),o("return",2))},regeneratorDefine(e,r,n,t)}', { globals: ["Object"], locals: { regeneratorDefine: ["body.0.id", "body.0.body.body.2.expression.expressions.0.right.body.body.0.body.body.0.expression.callee", "body.0.body.body.2.expression.expressions.1.callee", "body.0.body.body.2.expression.expressions.0.left"] }, exportBindingAssignments: ["body.0.body.body.2.expression.expressions.0"], exportName: "regeneratorDefine", dependencies: {}, internal: true }), regeneratorKeys: helper("7.27.0", "function _regeneratorKeys(e){var n=Object(e),r=[];for(var t in n)r.unshift(t);return function e(){for(;r.length;)if((t=r.pop())in n)return e.value=t,e.done=!1,e;return e.done=!0,e}}", { globals: ["Object"], locals: { _regeneratorKeys: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_regeneratorKeys", dependencies: {}, internal: false }), regeneratorValues: helper("7.18.0", 'function _regeneratorValues(e){if(null!=e){var t=e["function"==typeof Symbol&&Symbol.iterator||"@@iterator"],r=0;if(t)return t.call(e);if("function"==typeof e.next)return e;if(!isNaN(e.length))return{next:function(){return e&&r>=e.length&&(e=void 0),{value:e&&e[r++],done:!e}}}}throw new TypeError(typeof e+" is not iterable")}', { globals: ["Symbol", "isNaN", "TypeError"], locals: { _regeneratorValues: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_regeneratorValues", dependencies: {}, internal: false }), set: helper("7.0.0-beta.0", 'function set(e,r,t,o){return set="undefined"!=typeof Reflect&&Reflect.set?Reflect.set:function(e,r,t,o){var f,i=superPropBase(e,r);if(i){if((f=Object.getOwnPropertyDescriptor(i,r)).set)return f.set.call(o,t),!0;if(!f.writable)return!1}if(f=Object.getOwnPropertyDescriptor(o,r)){if(!f.writable)return!1;f.value=t,Object.defineProperty(o,r,f)}else defineProperty(o,r,t);return!0},set(e,r,t,o)}function _set(e,r,t,o,f){if(!set(e,r,t,o||e)&&f)throw new TypeError("failed to set property");return t}', { globals: ["Reflect", "Object", "TypeError"], locals: { set: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee", "body.1.body.body.0.test.left.argument.callee", "body.0.body.body.0.argument.expressions.0.left"], _set: ["body.1.id"] }, exportBindingAssignments: [], exportName: "_set", dependencies: { superPropBase: ["body.0.body.body.0.argument.expressions.0.right.alternate.body.body.0.declarations.1.init.callee"], defineProperty: ["body.0.body.body.0.argument.expressions.0.right.alternate.body.body.2.alternate.expression.callee"] }, internal: false }), setFunctionName: helper("7.23.6", 'function setFunctionName(e,t,n){"symbol"==typeof t&&(t=(t=t.description)?"["+t+"]":"");try{Object.defineProperty(e,"name",{configurable:!0,value:n?n+" "+t:t})}catch(e){}return e}', { globals: ["Object"], locals: { setFunctionName: ["body.0.id"] }, exportBindingAssignments: [], exportName: "setFunctionName", dependencies: {}, internal: false }), setPrototypeOf: helper("7.0.0-beta.0", "function _setPrototypeOf(t,e){return _setPrototypeOf=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},_setPrototypeOf(t,e)}", { globals: ["Object"], locals: { _setPrototypeOf: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee", "body.0.body.body.0.argument.expressions.0.left"] }, exportBindingAssignments: ["body.0.body.body.0.argument.expressions.0"], exportName: "_setPrototypeOf", dependencies: {}, internal: false }), skipFirstGeneratorNext: helper("7.0.0-beta.0", "function _skipFirstGeneratorNext(t){return function(){var r=t.apply(this,arguments);return r.next(),r}}", { globals: [], locals: { _skipFirstGeneratorNext: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_skipFirstGeneratorNext", dependencies: {}, internal: false }), slicedToArray: helper("7.0.0-beta.0", "function _slicedToArray(r,e){return arrayWithHoles(r)||iterableToArrayLimit(r,e)||unsupportedIterableToArray(r,e)||nonIterableRest()}", { globals: [], locals: { _slicedToArray: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_slicedToArray", dependencies: { arrayWithHoles: ["body.0.body.body.0.argument.left.left.left.callee"], iterableToArrayLimit: ["body.0.body.body.0.argument.left.left.right.callee"], unsupportedIterableToArray: ["body.0.body.body.0.argument.left.right.callee"], nonIterableRest: ["body.0.body.body.0.argument.right.callee"] }, internal: false }), superPropBase: helper("7.0.0-beta.0", "function _superPropBase(t,o){for(;!{}.hasOwnProperty.call(t,o)&&null!==(t=getPrototypeOf(t)););return t}", { globals: [], locals: { _superPropBase: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_superPropBase", dependencies: { getPrototypeOf: ["body.0.body.body.0.test.right.right.right.callee"] }, internal: false }), superPropGet: helper("7.25.0", 'function _superPropGet(t,o,e,r){var p=get(getPrototypeOf(1&r?t.prototype:t),o,e);return 2&r&&"function"==typeof p?function(t){return p.apply(e,t)}:p}', { globals: [], locals: { _superPropGet: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_superPropGet", dependencies: { get: ["body.0.body.body.0.declarations.0.init.callee"], getPrototypeOf: ["body.0.body.body.0.declarations.0.init.arguments.0.callee"] }, internal: false }), superPropSet: helper("7.25.0", "function _superPropSet(t,e,o,r,p,f){return set(getPrototypeOf(f?t.prototype:t),e,o,r,p)}", { globals: [], locals: { _superPropSet: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_superPropSet", dependencies: { set: ["body.0.body.body.0.argument.callee"], getPrototypeOf: ["body.0.body.body.0.argument.arguments.0.callee"] }, internal: false }), taggedTemplateLiteral: helper("7.0.0-beta.0", "function _taggedTemplateLiteral(e,t){return t||(t=e.slice(0)),Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(t)}}))}", { globals: ["Object"], locals: { _taggedTemplateLiteral: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_taggedTemplateLiteral", dependencies: {}, internal: false }), taggedTemplateLiteralLoose: helper("7.0.0-beta.0", "function _taggedTemplateLiteralLoose(e,t){return t||(t=e.slice(0)),e.raw=t,e}", { globals: [], locals: { _taggedTemplateLiteralLoose: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_taggedTemplateLiteralLoose", dependencies: {}, internal: false }), tdz: helper("7.5.5", 'function _tdzError(e){throw new ReferenceError(e+" is not defined - temporal dead zone")}', { globals: ["ReferenceError"], locals: { _tdzError: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_tdzError", dependencies: {}, internal: false }), temporalRef: helper("7.0.0-beta.0", "function _temporalRef(r,e){return r===undef?err(e):r}", { globals: [], locals: { _temporalRef: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_temporalRef", dependencies: { temporalUndefined: ["body.0.body.body.0.argument.test.right"], tdz: ["body.0.body.body.0.argument.consequent.callee"] }, internal: false }), temporalUndefined: helper("7.0.0-beta.0", "function _temporalUndefined(){}", { globals: [], locals: { _temporalUndefined: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_temporalUndefined", dependencies: {}, internal: false }), toArray: helper("7.0.0-beta.0", "function _toArray(r){return arrayWithHoles(r)||iterableToArray(r)||unsupportedIterableToArray(r)||nonIterableRest()}", { globals: [], locals: { _toArray: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_toArray", dependencies: { arrayWithHoles: ["body.0.body.body.0.argument.left.left.left.callee"], iterableToArray: ["body.0.body.body.0.argument.left.left.right.callee"], unsupportedIterableToArray: ["body.0.body.body.0.argument.left.right.callee"], nonIterableRest: ["body.0.body.body.0.argument.right.callee"] }, internal: false }), toConsumableArray: helper("7.0.0-beta.0", "function _toConsumableArray(r){return arrayWithoutHoles(r)||iterableToArray(r)||unsupportedIterableToArray(r)||nonIterableSpread()}", { globals: [], locals: { _toConsumableArray: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_toConsumableArray", dependencies: { arrayWithoutHoles: ["body.0.body.body.0.argument.left.left.left.callee"], iterableToArray: ["body.0.body.body.0.argument.left.left.right.callee"], unsupportedIterableToArray: ["body.0.body.body.0.argument.left.right.callee"], nonIterableSpread: ["body.0.body.body.0.argument.right.callee"] }, internal: false }), toPrimitive: helper("7.1.5", 'function toPrimitive(t,r){if("object"!=typeof t||!t)return t;var e=t[Symbol.toPrimitive];if(void 0!==e){var i=e.call(t,r||"default");if("object"!=typeof i)return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===r?String:Number)(t)}', { globals: ["Symbol", "TypeError", "String", "Number"], locals: { toPrimitive: ["body.0.id"] }, exportBindingAssignments: [], exportName: "toPrimitive", dependencies: {}, internal: false }), toPropertyKey: helper("7.1.5", 'function toPropertyKey(t){var i=toPrimitive(t,"string");return"symbol"==typeof i?i:i+""}', { globals: [], locals: { toPropertyKey: ["body.0.id"] }, exportBindingAssignments: [], exportName: "toPropertyKey", dependencies: { toPrimitive: ["body.0.body.body.0.declarations.0.init.callee"] }, internal: false }), toSetter: helper("7.24.0", 'function _toSetter(t,e,n){e||(e=[]);var r=e.length++;return Object.defineProperty({},"_",{set:function(o){e[r]=o,t.apply(n,e)}})}', { globals: ["Object"], locals: { _toSetter: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_toSetter", dependencies: {}, internal: false }), tsRewriteRelativeImportExtensions: helper("7.27.0", 'function tsRewriteRelativeImportExtensions(t,e){return"string"==typeof t&&/^\\.\\.?\\//.test(t)?t.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+)?)\\.([cm]?)ts$/i,function(t,s,r,n,o){return s?e?".jsx":".js":!r||n&&o?r+n+"."+o.toLowerCase()+"js":t}):t}', { globals: [], locals: { tsRewriteRelativeImportExtensions: ["body.0.id"] }, exportBindingAssignments: [], exportName: "tsRewriteRelativeImportExtensions", dependencies: {}, internal: false }), typeof: helper("7.0.0-beta.0", 'function _typeof(o){"@babel/helpers - typeof";return _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(o){return typeof o}:function(o){return o&&"function"==typeof Symbol&&o.constructor===Symbol&&o!==Symbol.prototype?"symbol":typeof o},_typeof(o)}', { globals: ["Symbol"], locals: { _typeof: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee", "body.0.body.body.0.argument.expressions.0.left"] }, exportBindingAssignments: ["body.0.body.body.0.argument.expressions.0"], exportName: "_typeof", dependencies: {}, internal: false }), unsupportedIterableToArray: helper("7.9.0", 'function _unsupportedIterableToArray(r,a){if(r){if("string"==typeof r)return arrayLikeToArray(r,a);var t={}.toString.call(r).slice(8,-1);return"Object"===t&&r.constructor&&(t=r.constructor.name),"Map"===t||"Set"===t?Array.from(r):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?arrayLikeToArray(r,a):void 0}}', { globals: ["Array"], locals: { _unsupportedIterableToArray: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_unsupportedIterableToArray", dependencies: { arrayLikeToArray: ["body.0.body.body.0.consequent.body.0.consequent.argument.callee", "body.0.body.body.0.consequent.body.2.argument.expressions.1.alternate.consequent.callee"] }, internal: false }), usingCtx: helper("7.23.9", 'function _usingCtx(){var r="function"==typeof SuppressedError?SuppressedError:function(r,e){var n=Error();return n.name="SuppressedError",n.error=r,n.suppressed=e,n},e={},n=[];function using(r,e){if(null!=e){if(Object(e)!==e)throw new TypeError("using declarations can only be used with objects, functions, null, or undefined.");if(r)var o=e[Symbol.asyncDispose||Symbol.for("Symbol.asyncDispose")];if(void 0===o&&(o=e[Symbol.dispose||Symbol.for("Symbol.dispose")],r))var t=o;if("function"!=typeof o)throw new TypeError("Object is not disposable.");t&&(o=function(){try{t.call(e)}catch(r){return Promise.reject(r)}}),n.push({v:e,d:o,a:r})}else r&&n.push({d:e,a:r});return e}return{e:e,u:using.bind(null,!1),a:using.bind(null,!0),d:function(){var o,t=this.e,s=0;function next(){for(;o=n.pop();)try{if(!o.a&&1===s)return s=0,n.push(o),Promise.resolve().then(next);if(o.d){var r=o.d.call(o.v);if(o.a)return s|=2,Promise.resolve(r).then(next,err)}else s|=1}catch(r){return err(r)}if(1===s)return t!==e?Promise.reject(t):Promise.resolve();if(t!==e)throw t}function err(n){return t=t!==e?new r(n,t):n,next()}return next()}}}', { globals: ["SuppressedError", "Error", "Object", "TypeError", "Symbol", "Promise"], locals: { _usingCtx: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_usingCtx", dependencies: {}, internal: false }), wrapAsyncGenerator: helper("7.0.0-beta.0", 'function _wrapAsyncGenerator(e){return function(){return new AsyncGenerator(e.apply(this,arguments))}}function AsyncGenerator(e){var r,t;function resume(r,t){try{var n=e[r](t),o=n.value,u=o instanceof OverloadYield;Promise.resolve(u?o.v:o).then(function(t){if(u){var i="return"===r?"return":"next";if(!o.k||t.done)return resume(i,t);t=e[i](t).value}settle(n.done?"return":"normal",t)},function(e){resume("throw",e)})}catch(e){settle("throw",e)}}function settle(e,n){switch(e){case"return":r.resolve({value:n,done:!0});break;case"throw":r.reject(n);break;default:r.resolve({value:n,done:!1})}(r=r.next)?resume(r.key,r.arg):t=null}this._invoke=function(e,n){return new Promise(function(o,u){var i={key:e,arg:n,resolve:o,reject:u,next:null};t?t=t.next=i:(r=t=i,resume(e,n))})},"function"!=typeof e.return&&(this.return=void 0)}AsyncGenerator.prototype["function"==typeof Symbol&&Symbol.asyncIterator||"@@asyncIterator"]=function(){return this},AsyncGenerator.prototype.next=function(e){return this._invoke("next",e)},AsyncGenerator.prototype.throw=function(e){return this._invoke("throw",e)},AsyncGenerator.prototype.return=function(e){return this._invoke("return",e)};', { globals: ["Promise", "Symbol"], locals: { _wrapAsyncGenerator: ["body.0.id"], AsyncGenerator: ["body.1.id", "body.0.body.body.0.argument.body.body.0.argument.callee", "body.2.expression.expressions.0.left.object.object", "body.2.expression.expressions.1.left.object.object", "body.2.expression.expressions.2.left.object.object", "body.2.expression.expressions.3.left.object.object"] }, exportBindingAssignments: [], exportName: "_wrapAsyncGenerator", dependencies: { OverloadYield: ["body.1.body.body.1.body.body.0.block.body.0.declarations.2.init.right"] }, internal: false }), wrapNativeSuper: helper("7.0.0-beta.0", 'function _wrapNativeSuper(t){var r="function"==typeof Map?new Map:void 0;return _wrapNativeSuper=function(t){if(null===t||!isNativeFunction(t))return t;if("function"!=typeof t)throw new TypeError("Super expression must either be null or a function");if(void 0!==r){if(r.has(t))return r.get(t);r.set(t,Wrapper)}function Wrapper(){return construct(t,arguments,getPrototypeOf(this).constructor)}return Wrapper.prototype=Object.create(t.prototype,{constructor:{value:Wrapper,enumerable:!1,writable:!0,configurable:!0}}),setPrototypeOf(Wrapper,t)},_wrapNativeSuper(t)}', { globals: ["Map", "TypeError", "Object"], locals: { _wrapNativeSuper: ["body.0.id", "body.0.body.body.1.argument.expressions.1.callee", "body.0.body.body.1.argument.expressions.0.left"] }, exportBindingAssignments: ["body.0.body.body.1.argument.expressions.0"], exportName: "_wrapNativeSuper", dependencies: { getPrototypeOf: ["body.0.body.body.1.argument.expressions.0.right.body.body.3.body.body.0.argument.arguments.2.object.callee"], setPrototypeOf: ["body.0.body.body.1.argument.expressions.0.right.body.body.4.argument.expressions.1.callee"], isNativeFunction: ["body.0.body.body.1.argument.expressions.0.right.body.body.0.test.right.argument.callee"], construct: ["body.0.body.body.1.argument.expressions.0.right.body.body.3.body.body.0.argument.callee"] }, internal: false }), wrapRegExp: helper("7.19.0", 'function _wrapRegExp(){_wrapRegExp=function(e,r){return new BabelRegExp(e,void 0,r)};var e=RegExp.prototype,r=new WeakMap;function BabelRegExp(e,t,p){var o=RegExp(e,t);return r.set(o,p||r.get(e)),setPrototypeOf(o,BabelRegExp.prototype)}function buildGroups(e,t){var p=r.get(t);return Object.keys(p).reduce(function(r,t){var o=p[t];if("number"==typeof o)r[t]=e[o];else{for(var i=0;void 0===e[o[i]]&&i+1<o.length;)i++;r[t]=e[o[i]]}return r},Object.create(null))}return inherits(BabelRegExp,RegExp),BabelRegExp.prototype.exec=function(r){var t=e.exec.call(this,r);if(t){t.groups=buildGroups(t,this);var p=t.indices;p&&(p.groups=buildGroups(p,this))}return t},BabelRegExp.prototype[Symbol.replace]=function(t,p){if("string"==typeof p){var o=r.get(this);return e[Symbol.replace].call(this,t,p.replace(/\\$<([^>]+)(>|$)/g,function(e,r,t){if(""===t)return e;var p=o[r];return Array.isArray(p)?"$"+p.join("$"):"number"==typeof p?"$"+p:""}))}if("function"==typeof p){var i=this;return e[Symbol.replace].call(this,t,function(){var e=arguments;return"object"!=typeof e[e.length-1]&&(e=[].slice.call(e)).push(buildGroups(e,i)),p.apply(this,e)})}return e[Symbol.replace].call(this,t,p)},_wrapRegExp.apply(this,arguments)}', { globals: ["RegExp", "WeakMap", "Object", "Symbol", "Array"], locals: { _wrapRegExp: ["body.0.id", "body.0.body.body.4.argument.expressions.3.callee.object", "body.0.body.body.0.expression.left"] }, exportBindingAssignments: ["body.0.body.body.0.expression"], exportName: "_wrapRegExp", dependencies: { setPrototypeOf: ["body.0.body.body.2.body.body.1.argument.expressions.1.callee"], inherits: ["body.0.body.body.4.argument.expressions.0.callee"] }, internal: false }), writeOnlyError: helper("7.12.13", `function _writeOnlyError(r){throw new TypeError('"'+r+'" is write-only')}`, { globals: ["TypeError"], locals: { _writeOnlyError: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_writeOnlyError", dependencies: {}, internal: false }) };
        Object.assign(s, { AwaitValue: helper("7.0.0-beta.0", "function _AwaitValue(t){this.wrapped=t}", { globals: [], locals: { _AwaitValue: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_AwaitValue", dependencies: {}, internal: false }), applyDecs: helper("7.17.8", 'function old_createMetadataMethodsForProperty(e,t,a,r){return{getMetadata:function(o){old_assertNotFinished(r,"getMetadata"),old_assertMetadataKey(o);var i=e[o];if(void 0!==i)if(1===t){var n=i.public;if(void 0!==n)return n[a]}else if(2===t){var l=i.private;if(void 0!==l)return l.get(a)}else if(Object.hasOwnProperty.call(i,"constructor"))return i.constructor},setMetadata:function(o,i){old_assertNotFinished(r,"setMetadata"),old_assertMetadataKey(o);var n=e[o];if(void 0===n&&(n=e[o]={}),1===t){var l=n.public;void 0===l&&(l=n.public={}),l[a]=i}else if(2===t){var s=n.priv;void 0===s&&(s=n.private=new Map),s.set(a,i)}else n.constructor=i}}}function old_convertMetadataMapToFinal(e,t){var a=e[Symbol.metadata||Symbol.for("Symbol.metadata")],r=Object.getOwnPropertySymbols(t);if(0!==r.length){for(var o=0;o<r.length;o++){var i=r[o],n=t[i],l=a?a[i]:null,s=n.public,c=l?l.public:null;s&&c&&Object.setPrototypeOf(s,c);var d=n.private;if(d){var u=Array.from(d.values()),f=l?l.private:null;f&&(u=u.concat(f)),n.private=u}l&&Object.setPrototypeOf(n,l)}a&&Object.setPrototypeOf(t,a),e[Symbol.metadata||Symbol.for("Symbol.metadata")]=t}}function old_createAddInitializerMethod(e,t){return function(a){old_assertNotFinished(t,"addInitializer"),old_assertCallable(a,"An initializer"),e.push(a)}}function old_memberDec(e,t,a,r,o,i,n,l,s){var c;switch(i){case 1:c="accessor";break;case 2:c="method";break;case 3:c="getter";break;case 4:c="setter";break;default:c="field"}var d,u,f={kind:c,name:l?"#"+t:toPropertyKey(t),isStatic:n,isPrivate:l},p={v:!1};if(0!==i&&(f.addInitializer=old_createAddInitializerMethod(o,p)),l){d=2,u=Symbol(t);var v={};0===i?(v.get=a.get,v.set=a.set):2===i?v.get=function(){return a.value}:(1!==i&&3!==i||(v.get=function(){return a.get.call(this)}),1!==i&&4!==i||(v.set=function(e){a.set.call(this,e)})),f.access=v}else d=1,u=t;try{return e(s,Object.assign(f,old_createMetadataMethodsForProperty(r,d,u,p)))}finally{p.v=!0}}function old_assertNotFinished(e,t){if(e.v)throw Error("attempted to call "+t+" after decoration was finished")}function old_assertMetadataKey(e){if("symbol"!=typeof e)throw new TypeError("Metadata keys must be symbols, received: "+e)}function old_assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function old_assertValidReturnValue(e,t){var a=typeof t;if(1===e){if("object"!==a||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&old_assertCallable(t.get,"accessor.get"),void 0!==t.set&&old_assertCallable(t.set,"accessor.set"),void 0!==t.init&&old_assertCallable(t.init,"accessor.init"),void 0!==t.initializer&&old_assertCallable(t.initializer,"accessor.initializer")}else if("function"!==a)throw new TypeError((0===e?"field":10===e?"class":"method")+" decorators must return a function or void 0")}function old_getInit(e){var t;return null==(t=e.init)&&(t=e.initializer)&&void 0!==console&&console.warn(".initializer has been renamed to .init as of March 2022"),t}function old_applyMemberDec(e,t,a,r,o,i,n,l,s){var c,d,u,f,p,v,y,h=a[0];if(n?(0===o||1===o?(c={get:a[3],set:a[4]},u="get"):3===o?(c={get:a[3]},u="get"):4===o?(c={set:a[3]},u="set"):c={value:a[3]},0!==o&&(1===o&&setFunctionName(a[4],"#"+r,"set"),setFunctionName(a[3],"#"+r,u))):0!==o&&(c=Object.getOwnPropertyDescriptor(t,r)),1===o?f={get:c.get,set:c.set}:2===o?f=c.value:3===o?f=c.get:4===o&&(f=c.set),"function"==typeof h)void 0!==(p=old_memberDec(h,r,c,l,s,o,i,n,f))&&(old_assertValidReturnValue(o,p),0===o?d=p:1===o?(d=old_getInit(p),v=p.get||f.get,y=p.set||f.set,f={get:v,set:y}):f=p);else for(var m=h.length-1;m>=0;m--){var b;void 0!==(p=old_memberDec(h[m],r,c,l,s,o,i,n,f))&&(old_assertValidReturnValue(o,p),0===o?b=p:1===o?(b=old_getInit(p),v=p.get||f.get,y=p.set||f.set,f={get:v,set:y}):f=p,void 0!==b&&(void 0===d?d=b:"function"==typeof d?d=[d,b]:d.push(b)))}if(0===o||1===o){if(void 0===d)d=function(e,t){return t};else if("function"!=typeof d){var g=d;d=function(e,t){for(var a=t,r=0;r<g.length;r++)a=g[r].call(e,a);return a}}else{var _=d;d=function(e,t){return _.call(e,t)}}e.push(d)}0!==o&&(1===o?(c.get=f.get,c.set=f.set):2===o?c.value=f:3===o?c.get=f:4===o&&(c.set=f),n?1===o?(e.push(function(e,t){return f.get.call(e,t)}),e.push(function(e,t){return f.set.call(e,t)})):2===o?e.push(f):e.push(function(e,t){return f.call(e,t)}):Object.defineProperty(t,r,c))}function old_applyMemberDecs(e,t,a,r,o){for(var i,n,l=new Map,s=new Map,c=0;c<o.length;c++){var d=o[c];if(Array.isArray(d)){var u,f,p,v=d[1],y=d[2],h=d.length>3,m=v>=5;if(m?(u=t,f=r,0!=(v-=5)&&(p=n=n||[])):(u=t.prototype,f=a,0!==v&&(p=i=i||[])),0!==v&&!h){var b=m?s:l,g=b.get(y)||0;if(!0===g||3===g&&4!==v||4===g&&3!==v)throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+y);!g&&v>2?b.set(y,v):b.set(y,!0)}old_applyMemberDec(e,u,d,y,v,m,h,f,p)}}old_pushInitializers(e,i),old_pushInitializers(e,n)}function old_pushInitializers(e,t){t&&e.push(function(e){for(var a=0;a<t.length;a++)t[a].call(e);return e})}function old_applyClassDecs(e,t,a,r){if(r.length>0){for(var o=[],i=t,n=t.name,l=r.length-1;l>=0;l--){var s={v:!1};try{var c=Object.assign({kind:"class",name:n,addInitializer:old_createAddInitializerMethod(o,s)},old_createMetadataMethodsForProperty(a,0,n,s)),d=r[l](i,c)}finally{s.v=!0}void 0!==d&&(old_assertValidReturnValue(10,d),i=d)}e.push(i,function(){for(var e=0;e<o.length;e++)o[e].call(i)})}}function applyDecs(e,t,a){var r=[],o={},i={};return old_applyMemberDecs(r,e,i,o,t),old_convertMetadataMapToFinal(e.prototype,i),old_applyClassDecs(r,e,o,a),old_convertMetadataMapToFinal(e,o),r}', { globals: ["Object", "Map", "Symbol", "Array", "Error", "TypeError", "console"], locals: { old_createMetadataMethodsForProperty: ["body.0.id", "body.3.body.body.4.block.body.0.argument.arguments.1.arguments.1.callee", "body.12.body.body.0.consequent.body.0.body.body.1.block.body.0.declarations.0.init.arguments.1.callee"], old_convertMetadataMapToFinal: ["body.1.id", "body.13.body.body.1.argument.expressions.1.callee", "body.13.body.body.1.argument.expressions.3.callee"], old_createAddInitializerMethod: ["body.2.id", "body.3.body.body.3.test.expressions.0.right.right.callee", "body.12.body.body.0.consequent.body.0.body.body.1.block.body.0.declarations.0.init.arguments.0.properties.2.value.callee"], old_memberDec: ["body.3.id", "body.9.body.body.1.consequent.expression.left.right.right.callee", "body.9.body.body.1.alternate.body.body.1.expression.left.right.right.callee"], old_assertNotFinished: ["body.4.id", "body.0.body.body.0.argument.properties.0.value.body.body.0.expression.expressions.0.callee", "body.0.body.body.0.argument.properties.1.value.body.body.0.expression.expressions.0.callee", "body.2.body.body.0.argument.body.body.0.expression.expressions.0.callee"], old_assertMetadataKey: ["body.5.id", "body.0.body.body.0.argument.properties.0.value.body.body.0.expression.expressions.1.callee", "body.0.body.body.0.argument.properties.1.value.body.body.0.expression.expressions.1.callee"], old_assertCallable: ["body.6.id", "body.2.body.body.0.argument.body.body.0.expression.expressions.1.callee", "body.7.body.body.1.consequent.body.1.expression.expressions.0.right.callee", "body.7.body.body.1.consequent.body.1.expression.expressions.1.right.callee", "body.7.body.body.1.consequent.body.1.expression.expressions.2.right.callee", "body.7.body.body.1.consequent.body.1.expression.expressions.3.right.callee"], old_assertValidReturnValue: ["body.7.id", "body.9.body.body.1.consequent.expression.right.expressions.0.callee", "body.9.body.body.1.alternate.body.body.1.expression.right.expressions.0.callee", "body.12.body.body.0.consequent.body.0.body.body.2.expression.right.expressions.0.callee"], old_getInit: ["body.8.id", "body.9.body.body.1.consequent.expression.right.expressions.1.alternate.consequent.expressions.0.right.callee", "body.9.body.body.1.alternate.body.body.1.expression.right.expressions.1.alternate.consequent.expressions.0.right.callee"], old_applyMemberDec: ["body.9.id", "body.10.body.body.0.body.body.1.consequent.body.2.expression.callee"], old_applyMemberDecs: ["body.10.id", "body.13.body.body.1.argument.expressions.0.callee"], old_pushInitializers: ["body.11.id", "body.10.body.body.1.expression.expressions.0.callee", "body.10.body.body.1.expression.expressions.1.callee"], old_applyClassDecs: ["body.12.id", "body.13.body.body.1.argument.expressions.2.callee"], applyDecs: ["body.13.id"] }, exportBindingAssignments: [], exportName: "applyDecs", dependencies: { setFunctionName: ["body.9.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.0.right.callee", "body.9.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.1.callee"], toPropertyKey: ["body.3.body.body.2.declarations.2.init.properties.1.value.alternate.callee"] }, internal: false }), applyDecs2203: helper("7.19.0", 'function applyDecs2203Factory(){function createAddInitializerMethod(e,t){return function(r){!function(e){if(e.v)throw Error("attempted to call addInitializer after decoration was finished")}(t),assertCallable(r,"An initializer"),e.push(r)}}function memberDec(e,t,r,a,n,i,s,o){var c;switch(n){case 1:c="accessor";break;case 2:c="method";break;case 3:c="getter";break;case 4:c="setter";break;default:c="field"}var l,u,f={kind:c,name:s?"#"+t:t,static:i,private:s},p={v:!1};0!==n&&(f.addInitializer=createAddInitializerMethod(a,p)),0===n?s?(l=r.get,u=r.set):(l=function(){return this[t]},u=function(e){this[t]=e}):2===n?l=function(){return r.value}:(1!==n&&3!==n||(l=function(){return r.get.call(this)}),1!==n&&4!==n||(u=function(e){r.set.call(this,e)})),f.access=l&&u?{get:l,set:u}:l?{get:l}:{set:u};try{return e(o,f)}finally{p.v=!0}}function assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertValidReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor.set"),void 0!==t.init&&assertCallable(t.init,"accessor.init")}else if("function"!==r)throw new TypeError((0===e?"field":10===e?"class":"method")+" decorators must return a function or void 0")}function applyMemberDec(e,t,r,a,n,i,s,o){var c,l,u,f,p,d,h=r[0];if(s?c=0===n||1===n?{get:r[3],set:r[4]}:3===n?{get:r[3]}:4===n?{set:r[3]}:{value:r[3]}:0!==n&&(c=Object.getOwnPropertyDescriptor(t,a)),1===n?u={get:c.get,set:c.set}:2===n?u=c.value:3===n?u=c.get:4===n&&(u=c.set),"function"==typeof h)void 0!==(f=memberDec(h,a,c,o,n,i,s,u))&&(assertValidReturnValue(n,f),0===n?l=f:1===n?(l=f.init,p=f.get||u.get,d=f.set||u.set,u={get:p,set:d}):u=f);else for(var v=h.length-1;v>=0;v--){var g;void 0!==(f=memberDec(h[v],a,c,o,n,i,s,u))&&(assertValidReturnValue(n,f),0===n?g=f:1===n?(g=f.init,p=f.get||u.get,d=f.set||u.set,u={get:p,set:d}):u=f,void 0!==g&&(void 0===l?l=g:"function"==typeof l?l=[l,g]:l.push(g)))}if(0===n||1===n){if(void 0===l)l=function(e,t){return t};else if("function"!=typeof l){var y=l;l=function(e,t){for(var r=t,a=0;a<y.length;a++)r=y[a].call(e,r);return r}}else{var m=l;l=function(e,t){return m.call(e,t)}}e.push(l)}0!==n&&(1===n?(c.get=u.get,c.set=u.set):2===n?c.value=u:3===n?c.get=u:4===n&&(c.set=u),s?1===n?(e.push(function(e,t){return u.get.call(e,t)}),e.push(function(e,t){return u.set.call(e,t)})):2===n?e.push(u):e.push(function(e,t){return u.call(e,t)}):Object.defineProperty(t,a,c))}function pushInitializers(e,t){t&&e.push(function(e){for(var r=0;r<t.length;r++)t[r].call(e);return e})}return function(e,t,r){var a=[];return function(e,t,r){for(var a,n,i=new Map,s=new Map,o=0;o<r.length;o++){var c=r[o];if(Array.isArray(c)){var l,u,f=c[1],p=c[2],d=c.length>3,h=f>=5;if(h?(l=t,0!=(f-=5)&&(u=n=n||[])):(l=t.prototype,0!==f&&(u=a=a||[])),0!==f&&!d){var v=h?s:i,g=v.get(p)||0;if(!0===g||3===g&&4!==f||4===g&&3!==f)throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+p);!g&&f>2?v.set(p,f):v.set(p,!0)}applyMemberDec(e,l,c,p,f,h,d,u)}}pushInitializers(e,a),pushInitializers(e,n)}(a,e,t),function(e,t,r){if(r.length>0){for(var a=[],n=t,i=t.name,s=r.length-1;s>=0;s--){var o={v:!1};try{var c=r[s](n,{kind:"class",name:i,addInitializer:createAddInitializerMethod(a,o)})}finally{o.v=!0}void 0!==c&&(assertValidReturnValue(10,c),n=c)}e.push(n,function(){for(var e=0;e<a.length;e++)a[e].call(n)})}}(a,e,r),a}}var applyDecs2203Impl;function applyDecs2203(e,t,r){return(applyDecs2203Impl=applyDecs2203Impl||applyDecs2203Factory())(e,t,r)}', { globals: ["Error", "TypeError", "Object", "Map", "Array"], locals: { applyDecs2203Factory: ["body.0.id", "body.2.body.body.0.argument.callee.right.right.callee"], applyDecs2203Impl: ["body.1.declarations.0.id", "body.2.body.body.0.argument.callee.right.left", "body.2.body.body.0.argument.callee.left"], applyDecs2203: ["body.2.id"] }, exportBindingAssignments: [], exportName: "applyDecs2203", dependencies: {}, internal: false }), applyDecs2203R: helper("7.20.0", 'function applyDecs2203RFactory(){function createAddInitializerMethod(e,t){return function(r){!function(e){if(e.v)throw Error("attempted to call addInitializer after decoration was finished")}(t),assertCallable(r,"An initializer"),e.push(r)}}function memberDec(e,t,r,n,a,i,o,s){var c;switch(a){case 1:c="accessor";break;case 2:c="method";break;case 3:c="getter";break;case 4:c="setter";break;default:c="field"}var l,u,f={kind:c,name:o?"#"+t:toPropertyKey(t),static:i,private:o},p={v:!1};0!==a&&(f.addInitializer=createAddInitializerMethod(n,p)),0===a?o?(l=r.get,u=r.set):(l=function(){return this[t]},u=function(e){this[t]=e}):2===a?l=function(){return r.value}:(1!==a&&3!==a||(l=function(){return r.get.call(this)}),1!==a&&4!==a||(u=function(e){r.set.call(this,e)})),f.access=l&&u?{get:l,set:u}:l?{get:l}:{set:u};try{return e(s,f)}finally{p.v=!0}}function assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertValidReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor.set"),void 0!==t.init&&assertCallable(t.init,"accessor.init")}else if("function"!==r)throw new TypeError((0===e?"field":10===e?"class":"method")+" decorators must return a function or void 0")}function applyMemberDec(e,t,r,n,a,i,o,s){var c,l,u,f,p,d,h,v=r[0];if(o?(0===a||1===a?(c={get:r[3],set:r[4]},u="get"):3===a?(c={get:r[3]},u="get"):4===a?(c={set:r[3]},u="set"):c={value:r[3]},0!==a&&(1===a&&setFunctionName(r[4],"#"+n,"set"),setFunctionName(r[3],"#"+n,u))):0!==a&&(c=Object.getOwnPropertyDescriptor(t,n)),1===a?f={get:c.get,set:c.set}:2===a?f=c.value:3===a?f=c.get:4===a&&(f=c.set),"function"==typeof v)void 0!==(p=memberDec(v,n,c,s,a,i,o,f))&&(assertValidReturnValue(a,p),0===a?l=p:1===a?(l=p.init,d=p.get||f.get,h=p.set||f.set,f={get:d,set:h}):f=p);else for(var g=v.length-1;g>=0;g--){var y;void 0!==(p=memberDec(v[g],n,c,s,a,i,o,f))&&(assertValidReturnValue(a,p),0===a?y=p:1===a?(y=p.init,d=p.get||f.get,h=p.set||f.set,f={get:d,set:h}):f=p,void 0!==y&&(void 0===l?l=y:"function"==typeof l?l=[l,y]:l.push(y)))}if(0===a||1===a){if(void 0===l)l=function(e,t){return t};else if("function"!=typeof l){var m=l;l=function(e,t){for(var r=t,n=0;n<m.length;n++)r=m[n].call(e,r);return r}}else{var b=l;l=function(e,t){return b.call(e,t)}}e.push(l)}0!==a&&(1===a?(c.get=f.get,c.set=f.set):2===a?c.value=f:3===a?c.get=f:4===a&&(c.set=f),o?1===a?(e.push(function(e,t){return f.get.call(e,t)}),e.push(function(e,t){return f.set.call(e,t)})):2===a?e.push(f):e.push(function(e,t){return f.call(e,t)}):Object.defineProperty(t,n,c))}function applyMemberDecs(e,t){for(var r,n,a=[],i=new Map,o=new Map,s=0;s<t.length;s++){var c=t[s];if(Array.isArray(c)){var l,u,f=c[1],p=c[2],d=c.length>3,h=f>=5;if(h?(l=e,0!=(f-=5)&&(u=n=n||[])):(l=e.prototype,0!==f&&(u=r=r||[])),0!==f&&!d){var v=h?o:i,g=v.get(p)||0;if(!0===g||3===g&&4!==f||4===g&&3!==f)throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+p);!g&&f>2?v.set(p,f):v.set(p,!0)}applyMemberDec(a,l,c,p,f,h,d,u)}}return pushInitializers(a,r),pushInitializers(a,n),a}function pushInitializers(e,t){t&&e.push(function(e){for(var r=0;r<t.length;r++)t[r].call(e);return e})}return function(e,t,r){return{e:applyMemberDecs(e,t),get c(){return function(e,t){if(t.length>0){for(var r=[],n=e,a=e.name,i=t.length-1;i>=0;i--){var o={v:!1};try{var s=t[i](n,{kind:"class",name:a,addInitializer:createAddInitializerMethod(r,o)})}finally{o.v=!0}void 0!==s&&(assertValidReturnValue(10,s),n=s)}return[n,function(){for(var e=0;e<r.length;e++)r[e].call(n)}]}}(e,r)}}}}function applyDecs2203R(e,t,r){return(applyDecs2203R=applyDecs2203RFactory())(e,t,r)}', { globals: ["Error", "TypeError", "Object", "Map", "Array"], locals: { applyDecs2203RFactory: ["body.0.id", "body.1.body.body.0.argument.callee.right.callee"], applyDecs2203R: ["body.1.id", "body.1.body.body.0.argument.callee.left"] }, exportBindingAssignments: ["body.1.body.body.0.argument.callee"], exportName: "applyDecs2203R", dependencies: { setFunctionName: ["body.0.body.body.4.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.0.right.callee", "body.0.body.body.4.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.1.callee"], toPropertyKey: ["body.0.body.body.1.body.body.2.declarations.2.init.properties.1.value.alternate.callee"] }, internal: false }), applyDecs2301: helper("7.21.0", 'function applyDecs2301Factory(){function createAddInitializerMethod(e,t){return function(r){!function(e){if(e.v)throw Error("attempted to call addInitializer after decoration was finished")}(t),assertCallable(r,"An initializer"),e.push(r)}}function assertInstanceIfPrivate(e,t){if(!e(t))throw new TypeError("Attempted to access private element on non-instance")}function memberDec(e,t,r,n,a,i,s,o,c){var u;switch(a){case 1:u="accessor";break;case 2:u="method";break;case 3:u="getter";break;case 4:u="setter";break;default:u="field"}var l,f,p={kind:u,name:s?"#"+t:toPropertyKey(t),static:i,private:s},d={v:!1};if(0!==a&&(p.addInitializer=createAddInitializerMethod(n,d)),s||0!==a&&2!==a)if(2===a)l=function(e){return assertInstanceIfPrivate(c,e),r.value};else{var h=0===a||1===a;(h||3===a)&&(l=s?function(e){return assertInstanceIfPrivate(c,e),r.get.call(e)}:function(e){return r.get.call(e)}),(h||4===a)&&(f=s?function(e,t){assertInstanceIfPrivate(c,e),r.set.call(e,t)}:function(e,t){r.set.call(e,t)})}else l=function(e){return e[t]},0===a&&(f=function(e,r){e[t]=r});var v=s?c.bind():function(e){return t in e};p.access=l&&f?{get:l,set:f,has:v}:l?{get:l,has:v}:{set:f,has:v};try{return e(o,p)}finally{d.v=!0}}function assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertValidReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor.set"),void 0!==t.init&&assertCallable(t.init,"accessor.init")}else if("function"!==r)throw new TypeError((0===e?"field":10===e?"class":"method")+" decorators must return a function or void 0")}function curryThis2(e){return function(t){e(this,t)}}function applyMemberDec(e,t,r,n,a,i,s,o,c){var u,l,f,p,d,h,v,y,g=r[0];if(s?(0===a||1===a?(u={get:(d=r[3],function(){return d(this)}),set:curryThis2(r[4])},f="get"):3===a?(u={get:r[3]},f="get"):4===a?(u={set:r[3]},f="set"):u={value:r[3]},0!==a&&(1===a&&setFunctionName(u.set,"#"+n,"set"),setFunctionName(u[f||"value"],"#"+n,f))):0!==a&&(u=Object.getOwnPropertyDescriptor(t,n)),1===a?p={get:u.get,set:u.set}:2===a?p=u.value:3===a?p=u.get:4===a&&(p=u.set),"function"==typeof g)void 0!==(h=memberDec(g,n,u,o,a,i,s,p,c))&&(assertValidReturnValue(a,h),0===a?l=h:1===a?(l=h.init,v=h.get||p.get,y=h.set||p.set,p={get:v,set:y}):p=h);else for(var m=g.length-1;m>=0;m--){var b;void 0!==(h=memberDec(g[m],n,u,o,a,i,s,p,c))&&(assertValidReturnValue(a,h),0===a?b=h:1===a?(b=h.init,v=h.get||p.get,y=h.set||p.set,p={get:v,set:y}):p=h,void 0!==b&&(void 0===l?l=b:"function"==typeof l?l=[l,b]:l.push(b)))}if(0===a||1===a){if(void 0===l)l=function(e,t){return t};else if("function"!=typeof l){var I=l;l=function(e,t){for(var r=t,n=0;n<I.length;n++)r=I[n].call(e,r);return r}}else{var w=l;l=function(e,t){return w.call(e,t)}}e.push(l)}0!==a&&(1===a?(u.get=p.get,u.set=p.set):2===a?u.value=p:3===a?u.get=p:4===a&&(u.set=p),s?1===a?(e.push(function(e,t){return p.get.call(e,t)}),e.push(function(e,t){return p.set.call(e,t)})):2===a?e.push(p):e.push(function(e,t){return p.call(e,t)}):Object.defineProperty(t,n,u))}function applyMemberDecs(e,t,r){for(var n,a,i,s=[],o=new Map,c=new Map,u=0;u<t.length;u++){var l=t[u];if(Array.isArray(l)){var f,p,d=l[1],h=l[2],v=l.length>3,y=d>=5,g=r;if(y?(f=e,0!=(d-=5)&&(p=a=a||[]),v&&!i&&(i=function(t){return checkInRHS(t)===e}),g=i):(f=e.prototype,0!==d&&(p=n=n||[])),0!==d&&!v){var m=y?c:o,b=m.get(h)||0;if(!0===b||3===b&&4!==d||4===b&&3!==d)throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+h);!b&&d>2?m.set(h,d):m.set(h,!0)}applyMemberDec(s,f,l,h,d,y,v,p,g)}}return pushInitializers(s,n),pushInitializers(s,a),s}function pushInitializers(e,t){t&&e.push(function(e){for(var r=0;r<t.length;r++)t[r].call(e);return e})}return function(e,t,r,n){return{e:applyMemberDecs(e,t,n),get c(){return function(e,t){if(t.length>0){for(var r=[],n=e,a=e.name,i=t.length-1;i>=0;i--){var s={v:!1};try{var o=t[i](n,{kind:"class",name:a,addInitializer:createAddInitializerMethod(r,s)})}finally{s.v=!0}void 0!==o&&(assertValidReturnValue(10,o),n=o)}return[n,function(){for(var e=0;e<r.length;e++)r[e].call(n)}]}}(e,r)}}}}function applyDecs2301(e,t,r,n){return(applyDecs2301=applyDecs2301Factory())(e,t,r,n)}', { globals: ["Error", "TypeError", "Object", "Map", "Array"], locals: { applyDecs2301Factory: ["body.0.id", "body.1.body.body.0.argument.callee.right.callee"], applyDecs2301: ["body.1.id", "body.1.body.body.0.argument.callee.left"] }, exportBindingAssignments: ["body.1.body.body.0.argument.callee"], exportName: "applyDecs2301", dependencies: { checkInRHS: ["body.0.body.body.7.body.body.0.body.body.1.consequent.body.1.test.expressions.0.consequent.expressions.2.right.right.body.body.0.argument.left.callee"], setFunctionName: ["body.0.body.body.6.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.0.right.callee", "body.0.body.body.6.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.1.callee"], toPropertyKey: ["body.0.body.body.2.body.body.2.declarations.2.init.properties.1.value.alternate.callee"] }, internal: false }), applyDecs2305: helper("7.21.0", 'function applyDecs2305(e,t,r,n,o,a){function i(e,t,r){return function(n,o){return r&&r(n),e[t].call(n,o)}}function c(e,t){for(var r=0;r<e.length;r++)e[r].call(t);return t}function s(e,t,r,n){if("function"!=typeof e&&(n||void 0!==e))throw new TypeError(t+" must "+(r||"be")+" a function"+(n?"":" or undefined"));return e}function applyDec(e,t,r,n,o,a,c,u,l,f,p,d,h){function m(e){if(!h(e))throw new TypeError("Attempted to access private element on non-instance")}var y,v=t[0],g=t[3],b=!u;if(!b){r||Array.isArray(v)||(v=[v]);var w={},S=[],A=3===o?"get":4===o||d?"set":"value";f?(p||d?w={get:setFunctionName(function(){return g(this)},n,"get"),set:function(e){t[4](this,e)}}:w[A]=g,p||setFunctionName(w[A],n,2===o?"":A)):p||(w=Object.getOwnPropertyDescriptor(e,n))}for(var P=e,j=v.length-1;j>=0;j-=r?2:1){var D=v[j],E=r?v[j-1]:void 0,I={},O={kind:["field","accessor","method","getter","setter","class"][o],name:n,metadata:a,addInitializer:function(e,t){if(e.v)throw Error("attempted to call addInitializer after decoration was finished");s(t,"An initializer","be",!0),c.push(t)}.bind(null,I)};try{if(b)(y=s(D.call(E,P,O),"class decorators","return"))&&(P=y);else{var k,F;O.static=l,O.private=f,f?2===o?k=function(e){return m(e),w.value}:(o<4&&(k=i(w,"get",m)),3!==o&&(F=i(w,"set",m))):(k=function(e){return e[n]},(o<2||4===o)&&(F=function(e,t){e[n]=t}));var N=O.access={has:f?h.bind():function(e){return n in e}};if(k&&(N.get=k),F&&(N.set=F),P=D.call(E,d?{get:w.get,set:w.set}:w[A],O),d){if("object"==typeof P&&P)(y=s(P.get,"accessor.get"))&&(w.get=y),(y=s(P.set,"accessor.set"))&&(w.set=y),(y=s(P.init,"accessor.init"))&&S.push(y);else if(void 0!==P)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0")}else s(P,(p?"field":"method")+" decorators","return")&&(p?S.push(P):w[A]=P)}}finally{I.v=!0}}return(p||d)&&u.push(function(e,t){for(var r=S.length-1;r>=0;r--)t=S[r].call(e,t);return t}),p||b||(f?d?u.push(i(w,"get"),i(w,"set")):u.push(2===o?w[A]:i.call.bind(w[A])):Object.defineProperty(e,n,w)),P}function u(e,t){return Object.defineProperty(e,Symbol.metadata||Symbol.for("Symbol.metadata"),{configurable:!0,enumerable:!0,value:t})}if(arguments.length>=6)var l=a[Symbol.metadata||Symbol.for("Symbol.metadata")];var f=Object.create(null==l?null:l),p=function(e,t,r,n){var o,a,i=[],s=function(t){return checkInRHS(t)===e},u=new Map;function l(e){e&&i.push(c.bind(null,e))}for(var f=0;f<t.length;f++){var p=t[f];if(Array.isArray(p)){var d=p[1],h=p[2],m=p.length>3,y=16&d,v=!!(8&d),g=0==(d&=7),b=h+"/"+v;if(!g&&!m){var w=u.get(b);if(!0===w||3===w&&4!==d||4===w&&3!==d)throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+h);u.set(b,!(d>2)||d)}applyDec(v?e:e.prototype,p,y,m?"#"+h:toPropertyKey(h),d,n,v?a=a||[]:o=o||[],i,v,m,g,1===d,v&&m?s:r)}}return l(o),l(a),i}(e,t,o,f);return r.length||u(e,f),{e:p,get c(){var t=[];return r.length&&[u(applyDec(e,[r],n,e.name,5,f,t),f),c.bind(null,t,e)]}}}', { globals: ["TypeError", "Array", "Object", "Error", "Symbol", "Map"], locals: { applyDecs2305: ["body.0.id"] }, exportBindingAssignments: [], exportName: "applyDecs2305", dependencies: { checkInRHS: ["body.0.body.body.6.declarations.1.init.callee.body.body.0.declarations.3.init.body.body.0.argument.left.callee"], setFunctionName: ["body.0.body.body.3.body.body.2.consequent.body.2.expression.consequent.expressions.0.consequent.right.properties.0.value.callee", "body.0.body.body.3.body.body.2.consequent.body.2.expression.consequent.expressions.1.right.callee"], toPropertyKey: ["body.0.body.body.6.declarations.1.init.callee.body.body.2.body.body.1.consequent.body.2.expression.arguments.3.alternate.callee"] }, internal: false }), classApplyDescriptorDestructureSet: helper("7.13.10", 'function _classApplyDescriptorDestructureSet(e,t){if(t.set)return"__destrObj"in t||(t.__destrObj={set value(r){t.set.call(e,r)}}),t.__destrObj;if(!t.writable)throw new TypeError("attempted to set read only private field");return t}', { globals: ["TypeError"], locals: { _classApplyDescriptorDestructureSet: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classApplyDescriptorDestructureSet", dependencies: {}, internal: false }), classApplyDescriptorGet: helper("7.13.10", "function _classApplyDescriptorGet(e,t){return t.get?t.get.call(e):t.value}", { globals: [], locals: { _classApplyDescriptorGet: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classApplyDescriptorGet", dependencies: {}, internal: false }), classApplyDescriptorSet: helper("7.13.10", 'function _classApplyDescriptorSet(e,t,l){if(t.set)t.set.call(e,l);else{if(!t.writable)throw new TypeError("attempted to set read only private field");t.value=l}}', { globals: ["TypeError"], locals: { _classApplyDescriptorSet: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classApplyDescriptorSet", dependencies: {}, internal: false }), classCheckPrivateStaticAccess: helper("7.13.10", "function _classCheckPrivateStaticAccess(s,a,r){return assertClassBrand(a,s,r)}", { globals: [], locals: { _classCheckPrivateStaticAccess: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classCheckPrivateStaticAccess", dependencies: { assertClassBrand: ["body.0.body.body.0.argument.callee"] }, internal: false }), classCheckPrivateStaticFieldDescriptor: helper("7.13.10", 'function _classCheckPrivateStaticFieldDescriptor(t,e){if(void 0===t)throw new TypeError("attempted to "+e+" private static field before its declaration")}', { globals: ["TypeError"], locals: { _classCheckPrivateStaticFieldDescriptor: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classCheckPrivateStaticFieldDescriptor", dependencies: {}, internal: false }), classExtractFieldDescriptor: helper("7.13.10", "function _classExtractFieldDescriptor(e,t){return classPrivateFieldGet2(t,e)}", { globals: [], locals: { _classExtractFieldDescriptor: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classExtractFieldDescriptor", dependencies: { classPrivateFieldGet2: ["body.0.body.body.0.argument.callee"] }, internal: false }), classPrivateFieldDestructureSet: helper("7.4.4", "function _classPrivateFieldDestructureSet(e,t){var r=classPrivateFieldGet2(t,e);return classApplyDescriptorDestructureSet(e,r)}", { globals: [], locals: { _classPrivateFieldDestructureSet: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classPrivateFieldDestructureSet", dependencies: { classApplyDescriptorDestructureSet: ["body.0.body.body.1.argument.callee"], classPrivateFieldGet2: ["body.0.body.body.0.declarations.0.init.callee"] }, internal: false }), classPrivateFieldGet: helper("7.0.0-beta.0", "function _classPrivateFieldGet(e,t){var r=classPrivateFieldGet2(t,e);return classApplyDescriptorGet(e,r)}", { globals: [], locals: { _classPrivateFieldGet: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classPrivateFieldGet", dependencies: { classApplyDescriptorGet: ["body.0.body.body.1.argument.callee"], classPrivateFieldGet2: ["body.0.body.body.0.declarations.0.init.callee"] }, internal: false }), classPrivateFieldSet: helper("7.0.0-beta.0", "function _classPrivateFieldSet(e,t,r){var s=classPrivateFieldGet2(t,e);return classApplyDescriptorSet(e,s,r),r}", { globals: [], locals: { _classPrivateFieldSet: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classPrivateFieldSet", dependencies: { classApplyDescriptorSet: ["body.0.body.body.1.argument.expressions.0.callee"], classPrivateFieldGet2: ["body.0.body.body.0.declarations.0.init.callee"] }, internal: false }), classPrivateMethodGet: helper("7.1.6", "function _classPrivateMethodGet(s,a,r){return assertClassBrand(a,s),r}", { globals: [], locals: { _classPrivateMethodGet: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classPrivateMethodGet", dependencies: { assertClassBrand: ["body.0.body.body.0.argument.expressions.0.callee"] }, internal: false }), classPrivateMethodSet: helper("7.1.6", 'function _classPrivateMethodSet(){throw new TypeError("attempted to reassign private method")}', { globals: ["TypeError"], locals: { _classPrivateMethodSet: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classPrivateMethodSet", dependencies: {}, internal: false }), classStaticPrivateFieldDestructureSet: helper("7.13.10", 'function _classStaticPrivateFieldDestructureSet(t,r,s){return assertClassBrand(r,t),classCheckPrivateStaticFieldDescriptor(s,"set"),classApplyDescriptorDestructureSet(t,s)}', { globals: [], locals: { _classStaticPrivateFieldDestructureSet: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classStaticPrivateFieldDestructureSet", dependencies: { classApplyDescriptorDestructureSet: ["body.0.body.body.0.argument.expressions.2.callee"], assertClassBrand: ["body.0.body.body.0.argument.expressions.0.callee"], classCheckPrivateStaticFieldDescriptor: ["body.0.body.body.0.argument.expressions.1.callee"] }, internal: false }), classStaticPrivateFieldSpecGet: helper("7.0.2", 'function _classStaticPrivateFieldSpecGet(t,s,r){return assertClassBrand(s,t),classCheckPrivateStaticFieldDescriptor(r,"get"),classApplyDescriptorGet(t,r)}', { globals: [], locals: { _classStaticPrivateFieldSpecGet: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classStaticPrivateFieldSpecGet", dependencies: { classApplyDescriptorGet: ["body.0.body.body.0.argument.expressions.2.callee"], assertClassBrand: ["body.0.body.body.0.argument.expressions.0.callee"], classCheckPrivateStaticFieldDescriptor: ["body.0.body.body.0.argument.expressions.1.callee"] }, internal: false }), classStaticPrivateFieldSpecSet: helper("7.0.2", 'function _classStaticPrivateFieldSpecSet(s,t,r,e){return assertClassBrand(t,s),classCheckPrivateStaticFieldDescriptor(r,"set"),classApplyDescriptorSet(s,r,e),e}', { globals: [], locals: { _classStaticPrivateFieldSpecSet: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classStaticPrivateFieldSpecSet", dependencies: { classApplyDescriptorSet: ["body.0.body.body.0.argument.expressions.2.callee"], assertClassBrand: ["body.0.body.body.0.argument.expressions.0.callee"], classCheckPrivateStaticFieldDescriptor: ["body.0.body.body.0.argument.expressions.1.callee"] }, internal: false }), classStaticPrivateMethodSet: helper("7.3.2", 'function _classStaticPrivateMethodSet(){throw new TypeError("attempted to set read only static private field")}', { globals: ["TypeError"], locals: { _classStaticPrivateMethodSet: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_classStaticPrivateMethodSet", dependencies: {}, internal: false }), defineEnumerableProperties: helper("7.0.0-beta.0", 'function _defineEnumerableProperties(e,r){for(var t in r){var n=r[t];n.configurable=n.enumerable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,t,n)}if(Object.getOwnPropertySymbols)for(var a=Object.getOwnPropertySymbols(r),b=0;b<a.length;b++){var i=a[b];(n=r[i]).configurable=n.enumerable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,i,n)}return e}', { globals: ["Object"], locals: { _defineEnumerableProperties: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_defineEnumerableProperties", dependencies: {}, internal: false }), dispose: helper("7.22.0", 'function dispose_SuppressedError(r,e){return"undefined"!=typeof SuppressedError?dispose_SuppressedError=SuppressedError:(dispose_SuppressedError=function(r,e){this.suppressed=e,this.error=r,this.stack=Error().stack},dispose_SuppressedError.prototype=Object.create(Error.prototype,{constructor:{value:dispose_SuppressedError,writable:!0,configurable:!0}})),new dispose_SuppressedError(r,e)}function _dispose(r,e,s){function next(){for(;r.length>0;)try{var o=r.pop(),p=o.d.call(o.v);if(o.a)return Promise.resolve(p).then(next,err)}catch(r){return err(r)}if(s)throw e}function err(r){return e=s?new dispose_SuppressedError(e,r):r,s=!0,next()}return next()}', { globals: ["SuppressedError", "Error", "Object", "Promise"], locals: { dispose_SuppressedError: ["body.0.id", "body.0.body.body.0.argument.expressions.0.alternate.expressions.1.left.object", "body.0.body.body.0.argument.expressions.0.alternate.expressions.1.right.arguments.1.properties.0.value.properties.0.value", "body.0.body.body.0.argument.expressions.1.callee", "body.1.body.body.1.body.body.0.argument.expressions.0.right.consequent.callee", "body.0.body.body.0.argument.expressions.0.consequent.left", "body.0.body.body.0.argument.expressions.0.alternate.expressions.0.left"], _dispose: ["body.1.id"] }, exportBindingAssignments: [], exportName: "_dispose", dependencies: {}, internal: false }), objectSpread: helper("7.0.0-beta.0", 'function _objectSpread(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?Object(arguments[r]):{},o=Object.keys(t);"function"==typeof Object.getOwnPropertySymbols&&o.push.apply(o,Object.getOwnPropertySymbols(t).filter(function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable})),o.forEach(function(r){defineProperty(e,r,t[r])})}return e}', { globals: ["Object"], locals: { _objectSpread: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_objectSpread", dependencies: { defineProperty: ["body.0.body.body.0.body.body.1.expression.expressions.1.arguments.0.body.body.0.expression.callee"] }, internal: false }), regeneratorRuntime: helper("7.18.0", 'function _regeneratorRuntime(){"use strict";var r=regenerator(),e=r.m(_regeneratorRuntime),t=(Object.getPrototypeOf?Object.getPrototypeOf(e):e.__proto__).constructor;function n(r){var e="function"==typeof r&&r.constructor;return!!e&&(e===t||"GeneratorFunction"===(e.displayName||e.name))}var o={throw:1,return:2,break:3,continue:3};function a(r){var e,t;return function(n){e||(e={stop:function(){return t(n.a,2)},catch:function(){return n.v},abrupt:function(r,e){return t(n.a,o[r],e)},delegateYield:function(r,o,a){return e.resultName=o,t(n.d,values(r),a)},finish:function(r){return t(n.f,r)}},t=function(r,t,o){n.p=e.prev,n.n=e.next;try{return r(t,o)}finally{e.next=n.n}}),e.resultName&&(e[e.resultName]=n.v,e.resultName=void 0),e.sent=n.v,e.next=n.n;try{return r.call(this,e)}finally{n.p=e.prev,n.n=e.next}}}return(_regeneratorRuntime=function(){return{wrap:function(e,t,n,o){return r.w(a(e),t,n,o&&o.reverse())},isGeneratorFunction:n,mark:r.m,awrap:function(r,e){return new OverloadYield(r,e)},AsyncIterator:AsyncIterator,async:function(r,e,t,o,u){return(n(e)?asyncGen:async)(a(r),e,t,o,u)},keys:keys,values:values}})()}', { globals: ["Object"], locals: { _regeneratorRuntime: ["body.0.id", "body.0.body.body.0.declarations.1.init.arguments.0", "body.0.body.body.4.argument.callee.left"] }, exportBindingAssignments: ["body.0.body.body.4.argument.callee"], exportName: "_regeneratorRuntime", dependencies: { OverloadYield: ["body.0.body.body.4.argument.callee.right.body.body.0.argument.properties.3.value.body.body.0.argument.callee"], regenerator: ["body.0.body.body.0.declarations.0.init.callee"], regeneratorAsync: ["body.0.body.body.4.argument.callee.right.body.body.0.argument.properties.5.value.body.body.0.argument.callee.alternate"], regeneratorAsyncGen: ["body.0.body.body.4.argument.callee.right.body.body.0.argument.properties.5.value.body.body.0.argument.callee.consequent"], regeneratorAsyncIterator: ["body.0.body.body.4.argument.callee.right.body.body.0.argument.properties.4.value"], regeneratorKeys: ["body.0.body.body.4.argument.callee.right.body.body.0.argument.properties.6.value"], regeneratorValues: ["body.0.body.body.3.body.body.1.argument.body.body.0.expression.expressions.0.right.expressions.0.right.properties.3.value.body.body.0.argument.expressions.1.arguments.1.callee", "body.0.body.body.4.argument.callee.right.body.body.0.argument.properties.7.value"] }, internal: false }), using: helper("7.22.0", 'function _using(o,n,e){if(null==n)return n;if(Object(n)!==n)throw new TypeError("using declarations can only be used with objects, functions, null, or undefined.");if(e)var r=n[Symbol.asyncDispose||Symbol.for("Symbol.asyncDispose")];if(null==r&&(r=n[Symbol.dispose||Symbol.for("Symbol.dispose")]),"function"!=typeof r)throw new TypeError("Property [Symbol.dispose] is not a function.");return o.push({v:n,d:r,a:e}),n}', { globals: ["Object", "TypeError", "Symbol"], locals: { _using: ["body.0.id"] }, exportBindingAssignments: [], exportName: "_using", dependencies: {}, internal: false }) });
      }, "./node_modules/.pnpm/@babel+helpers@7.28.4/node_modules/@babel/helpers/lib/index.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0, t2.get = get, t2.getDependencies = function(e3) {
          return loadHelper(e3).getDependencies();
        }, t2.isInternal = function(e3) {
          var t3;
          return null == (t3 = s.default[e3]) ? void 0 : t3.metadata.internal;
        }, t2.list = void 0, t2.minVersion = function(e3) {
          return loadHelper(e3).minVersion;
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/index.js"), s = r2("./node_modules/.pnpm/@babel+helpers@7.28.4/node_modules/@babel/helpers/lib/helpers-generated.js");
        const { cloneNode: i, identifier: o } = n;
        function deep(e3, t3, r3) {
          try {
            const n2 = t3.split(".");
            let s2 = n2.shift();
            for (; n2.length > 0; ) e3 = e3[s2], s2 = n2.shift();
            if (!(arguments.length > 2)) return e3[s2];
            e3[s2] = r3;
          } catch (e4) {
            throw e4.message += ` (when accessing ${t3})`, e4;
          }
        }
        const a = /* @__PURE__ */ Object.create(null);
        function loadHelper(e3) {
          if (!a[e3]) {
            const t3 = s.default[e3];
            if (!t3) throw Object.assign(new ReferenceError(`Unknown helper ${e3}`), { code: "BABEL_HELPER_UNKNOWN", helper: e3 });
            a[e3] = { minVersion: t3.minVersion, build(e4, r3, n2, s2) {
              const a2 = t3.ast();
              return (function(e5, t4, r4, n3, s3, a3) {
                const { locals: l, dependencies: p, exportBindingAssignments: c, exportName: u } = t4, d = new Set(n3 || []);
                r4 && d.add(r4);
                for (const [t5, n4] of (Object.entries || ((e6) => Object.keys(e6).map((t6) => [t6, e6[t6]])))(l)) {
                  let s4 = t5;
                  if (r4 && t5 === u) s4 = r4;
                  else for (; d.has(s4); ) s4 = "_" + s4;
                  if (s4 !== t5) for (const t6 of n4) deep(e5, t6, o(s4));
                }
                for (const [t5, r5] of (Object.entries || ((e6) => Object.keys(e6).map((t6) => [t6, e6[t6]])))(p)) {
                  const n4 = "function" == typeof s3 && s3(t5) || o(t5);
                  for (const t6 of r5) deep(e5, t6, i(n4));
                }
                null == a3 || a3(e5, u, (t5) => {
                  c.forEach((r5) => deep(e5, r5, t5(deep(e5, r5))));
                });
              })(a2, t3.metadata, r3, n2, e4, s2), { nodes: a2.body, globals: t3.metadata.globals };
            }, getDependencies: () => Object.keys(t3.metadata.dependencies) };
          }
          return a[e3];
        }
        function get(e3, t3, r3, n2, s2) {
          if ("object" == typeof r3) {
            const e4 = r3;
            r3 = "Identifier" === (null == e4 ? void 0 : e4.type) ? e4.name : void 0;
          }
          return loadHelper(e3).build(t3, r3, n2, s2);
        }
        t2.ensure = (e3) => {
          loadHelper(e3);
        };
        t2.list = Object.keys(s.default).map((e3) => e3.replace(/^_/, ""));
        t2.default = get;
      }, "./node_modules/.pnpm/@babel+parser@7.28.4/node_modules/@babel/parser/lib/index.js": function(e2, t2) {
        "use strict";
        function _objectWithoutPropertiesLoose(e3, t3) {
          if (null == e3) return {};
          var r3 = {};
          for (var n2 in e3) if ({}.hasOwnProperty.call(e3, n2)) {
            if (-1 !== t3.indexOf(n2)) continue;
            r3[n2] = e3[n2];
          }
          return r3;
        }
        Object.defineProperty(t2, "__esModule", { value: true });
        class Position {
          constructor(e3, t3, r3) {
            this.line = void 0, this.column = void 0, this.index = void 0, this.line = e3, this.column = t3, this.index = r3;
          }
        }
        class SourceLocation {
          constructor(e3, t3) {
            this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = e3, this.end = t3;
          }
        }
        function createPositionWithColumnOffset(e3, t3) {
          const { line: r3, column: n2, index: s2 } = e3;
          return new Position(r3, n2 + t3, s2 + t3);
        }
        const r2 = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED";
        var n = { ImportMetaOutsideModule: { message: `import.meta may appear only with 'sourceType: "module"'`, code: r2 }, ImportOutsideModule: { message: `'import' and 'export' may appear only with 'sourceType: "module"'`, code: r2 } };
        const s = { ArrayPattern: "array destructuring pattern", AssignmentExpression: "assignment expression", AssignmentPattern: "assignment expression", ArrowFunctionExpression: "arrow function expression", ConditionalExpression: "conditional expression", CatchClause: "catch clause", ForOfStatement: "for-of statement", ForInStatement: "for-in statement", ForStatement: "for-loop", FormalParameters: "function parameter list", Identifier: "identifier", ImportSpecifier: "import specifier", ImportDefaultSpecifier: "import default specifier", ImportNamespaceSpecifier: "import namespace specifier", ObjectPattern: "object destructuring pattern", ParenthesizedExpression: "parenthesized expression", RestElement: "rest element", UpdateExpression: { true: "prefix operation", false: "postfix operation" }, VariableDeclarator: "variable declaration", YieldExpression: "yield expression" }, toNodeDescription = (e3) => "UpdateExpression" === e3.type ? s.UpdateExpression[`${e3.prefix}`] : s[e3.type];
        var i = { AccessorIsGenerator: ({ kind: e3 }) => `A ${e3}ter cannot be a generator.`, ArgumentsInClass: "'arguments' is only allowed in functions and class methods.", AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.", AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.", AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.", AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.", AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.", BadGetterArity: "A 'get' accessor must not have any formal parameters.", BadSetterArity: "A 'set' accessor must have exactly one formal parameter.", BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.", ConstructorClassField: "Classes may not have a field named 'constructor'.", ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.", ConstructorIsAccessor: "Class constructor may not be an accessor.", ConstructorIsAsync: "Constructor can't be an async function.", ConstructorIsGenerator: "Constructor can't be a generator.", DeclarationMissingInitializer: ({ kind: e3 }) => `Missing initializer in ${e3} declaration.`, DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.", DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.", DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.", DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?", DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.", DecoratorSemicolon: "Decorators must not be followed by a semicolon.", DecoratorStaticBlock: "Decorators can't be used with a static block.", DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.', DeletePrivateField: "Deleting a private field is not allowed.", DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.", DuplicateConstructor: "Duplicate constructor in the same class.", DuplicateDefaultExport: "Only one default export allowed per module.", DuplicateExport: ({ exportName: e3 }) => `\`${e3}\` has already been exported. Exported identifiers must be unique.`, DuplicateProto: "Redefinition of __proto__ property.", DuplicateRegExpFlags: "Duplicate regular expression flag.", ElementAfterRest: "Rest element must be last element.", EscapedCharNotAnIdentifier: "Invalid Unicode escape.", ExportBindingIsString: ({ localName: e3, exportName: t3 }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${e3}' as '${t3}' } from 'some-module'\`?`, ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.", ForInOfLoopInitializer: ({ type: e3 }) => `'${"ForInStatement" === e3 ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`, ForInUsing: "For-in loop may not start with 'using' declaration.", ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.", ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.", GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.", IllegalBreakContinue: ({ type: e3 }) => `Unsyntactic ${"BreakStatement" === e3 ? "break" : "continue"}.`, IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.", IllegalReturn: "'return' outside of function.", ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedImportAssert` parser plugin to suppress this error.", ImportBindingIsString: ({ importName: e3 }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${e3}" as foo }\`?`, ImportCallArity: "`import()` requires exactly one or two arguments.", ImportCallNotNewExpression: "Cannot use new with import(...).", ImportCallSpreadArgument: "`...` is not allowed in `import()`.", ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.", ImportReflectionHasAssertion: "`import module x` cannot have assertions.", ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.', IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.", InvalidBigIntLiteral: "Invalid BigIntLiteral.", InvalidCodePoint: "Code point out of bounds.", InvalidCoverDiscardElement: "'void' must be followed by an expression when not used in a binding position.", InvalidCoverInitializedName: "Invalid shorthand property initializer.", InvalidDecimal: "Invalid decimal.", InvalidDigit: ({ radix: e3 }) => `Expected number in radix ${e3}.`, InvalidEscapeSequence: "Bad character escape sequence.", InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.", InvalidEscapedReservedWord: ({ reservedWord: e3 }) => `Escape sequence in keyword ${e3}.`, InvalidIdentifier: ({ identifierName: e3 }) => `Invalid identifier ${e3}.`, InvalidLhs: ({ ancestor: e3 }) => `Invalid left-hand side in ${toNodeDescription(e3)}.`, InvalidLhsBinding: ({ ancestor: e3 }) => `Binding invalid left-hand side in ${toNodeDescription(e3)}.`, InvalidLhsOptionalChaining: ({ ancestor: e3 }) => `Invalid optional chaining in the left-hand side of ${toNodeDescription(e3)}.`, InvalidNumber: "Invalid number.", InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.", InvalidOrUnexpectedToken: ({ unexpected: e3 }) => `Unexpected character '${e3}'.`, InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.", InvalidPrivateFieldResolution: ({ identifierName: e3 }) => `Private name #${e3} is not defined.`, InvalidPropertyBindingPattern: "Binding member expression.", InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.", InvalidRestAssignmentPattern: "Invalid rest operator's argument.", LabelRedeclaration: ({ labelName: e3 }) => `Label '${e3}' is already declared.`, LetInLexicalBinding: "'let' is disallowed as a lexically bound name.", LineTerminatorBeforeArrow: "No line break is allowed before '=>'.", MalformedRegExpFlags: "Invalid regular expression flag.", MissingClassName: "A class name is required.", MissingEqInAssignment: "Only '=' operator can be used for specifying default value.", MissingSemicolon: "Missing semicolon.", MissingPlugin: ({ missingPlugin: e3 }) => `This experimental syntax requires enabling the parser plugin: ${e3.map((e4) => JSON.stringify(e4)).join(", ")}.`, MissingOneOfPlugins: ({ missingPlugin: e3 }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${e3.map((e4) => JSON.stringify(e4)).join(", ")}.`, MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.", MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.", ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.", ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.", ModuleAttributesWithDuplicateKeys: ({ key: e3 }) => `Duplicate key "${e3}" is not allowed in module attributes.`, ModuleExportNameHasLoneSurrogate: ({ surrogateCharCode: e3 }) => `An export name cannot include a lone surrogate, found '\\u${e3.toString(16)}'.`, ModuleExportUndefined: ({ localName: e3 }) => `Export '${e3}' is not defined.`, MultipleDefaultsInSwitch: "Multiple default clauses.", NewlineAfterThrow: "Illegal newline after throw.", NoCatchOrFinally: "Missing catch or finally clause.", NumberIdentifier: "Identifier directly after number.", NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.", ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.", OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.", OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.", OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.", ParamDupe: "Argument name clash.", PatternHasAccessor: "Object pattern can't contain getter or setter.", PatternHasMethod: "Object pattern can't contain methods.", PrivateInExpectedIn: ({ identifierName: e3 }) => `Private names are only allowed in property accesses (\`obj.#${e3}\`) or in \`in\` expressions (\`#${e3} in obj\`).`, PrivateNameRedeclaration: ({ identifierName: e3 }) => `Duplicate private name #${e3}.`, RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", RecordNoProto: "'__proto__' is not allowed in Record expressions.", RestTrailingComma: "Unexpected trailing comma after rest element.", SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.", SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.", SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.', StaticPrototype: "Classes may not have static property named prototype.", SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?", SuperPrivateField: "Private fields can't be accessed on super.", TrailingDecorator: "Decorators must be attached to a class element.", TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.", UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.', UnexpectedDigitAfterHash: "Unexpected digit after hash token.", UnexpectedImportExport: "'import' and 'export' may only appear at the top level.", UnexpectedKeyword: ({ keyword: e3 }) => `Unexpected keyword '${e3}'.`, UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.", UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.", UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.", UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.", UnexpectedPrivateField: "Unexpected private name.", UnexpectedReservedWord: ({ reservedWord: e3 }) => `Unexpected reserved word '${e3}'.`, UnexpectedSuper: "'super' is only allowed in object methods and classes.", UnexpectedToken: ({ expected: e3, unexpected: t3 }) => `Unexpected token${t3 ? ` '${t3}'.` : ""}${e3 ? `, expected "${e3}"` : ""}`, UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.", UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script` or in the bare case statement.", UnexpectedVoidPattern: "Unexpected void binding.", UnsupportedBind: "Binding should be performed on object property.", UnsupportedDecoratorExport: "A decorated export must export a class declaration.", UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.", UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.", UnsupportedMetaProperty: ({ target: e3, onlyValidPropertyName: t3 }) => `The only valid meta property for ${e3} is ${e3}.${t3}.`, UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.", UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.", UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).", UnterminatedComment: "Unterminated comment.", UnterminatedRegExp: "Unterminated regular expression.", UnterminatedString: "Unterminated string constant.", UnterminatedTemplate: "Unterminated template.", UsingDeclarationExport: "Using declaration cannot be exported.", UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.", VarRedeclaration: ({ identifierName: e3 }) => `Identifier '${e3}' has already been declared.`, VoidPatternCatchClauseParam: "A void binding can not be the catch clause parameter. Use `try { ... } catch { ... }` if you want to discard the caught error.", VoidPatternInitializer: "A void binding may not have an initializer.", YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.", YieldInParameter: "Yield expression is not allowed in formal parameters.", YieldNotInGeneratorFunction: "'yield' is only allowed within generator functions.", ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0." }, o = { ParseExpressionEmptyInput: "Unexpected parseExpression() input: The input is empty or contains only comments.", ParseExpressionExpectsEOF: ({ unexpected: e3 }) => `Unexpected parseExpression() input: The input should contain exactly one expression, but the first expression is followed by the unexpected character \`${String.fromCodePoint(e3)}\`.` };
        const a = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]);
        var l = Object.assign({ PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.", PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.', PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.", PipeTopicUnconfiguredToken: ({ token: e3 }) => `Invalid topic token ${e3}. In order to use ${e3} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${e3}" }.`, PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.", PipeUnparenthesizedBody: ({ type: e3 }) => `Hack-style pipe body cannot be an unparenthesized ${toNodeDescription({ type: e3 })}; please wrap it in parentheses.` }, { PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.', PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.", PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.", PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.", PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.", PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.' });
        const p = ["message"];
        function defineHidden(e3, t3, r3) {
          Object.defineProperty(e3, t3, { enumerable: false, configurable: true, value: r3 });
        }
        function toParseErrorConstructor({ toMessage: e3, code: t3, reasonCode: r3, syntaxPlugin: n2 }) {
          const s2 = "MissingPlugin" === r3 || "MissingOneOfPlugins" === r3;
          {
            const e4 = { AccessorCannotDeclareThisParameter: "AccesorCannotDeclareThisParameter", AccessorCannotHaveTypeParameters: "AccesorCannotHaveTypeParameters", ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference", SetAccessorCannotHaveOptionalParameter: "SetAccesorCannotHaveOptionalParameter", SetAccessorCannotHaveRestParameter: "SetAccesorCannotHaveRestParameter", SetAccessorCannotHaveReturnType: "SetAccesorCannotHaveReturnType" };
            e4[r3] && (r3 = e4[r3]);
          }
          return function constructor(i2, o2) {
            const a2 = new SyntaxError();
            return a2.code = t3, a2.reasonCode = r3, a2.loc = i2, a2.pos = i2.index, a2.syntaxPlugin = n2, s2 && (a2.missingPlugin = o2.missingPlugin), defineHidden(a2, "clone", function(e4 = {}) {
              var t4;
              const { line: r4, column: n3, index: s3 } = null != (t4 = e4.loc) ? t4 : i2;
              return constructor(new Position(r4, n3, s3), Object.assign({}, o2, e4.details));
            }), defineHidden(a2, "details", o2), Object.defineProperty(a2, "message", { configurable: true, get() {
              const t4 = `${e3(o2)} (${i2.line}:${i2.column})`;
              return this.message = t4, t4;
            }, set(e4) {
              Object.defineProperty(this, "message", { value: e4, writable: true });
            } }), a2;
          };
        }
        function ParseErrorEnum(e3, t3) {
          if (Array.isArray(e3)) return (t4) => ParseErrorEnum(t4, e3[0]);
          const r3 = {};
          for (const n2 of Object.keys(e3)) {
            const s2 = e3[n2], i2 = "string" == typeof s2 ? { message: () => s2 } : "function" == typeof s2 ? { message: s2 } : s2, { message: o2 } = i2, a2 = _objectWithoutPropertiesLoose(i2, p), l2 = "string" == typeof o2 ? () => o2 : o2;
            r3[n2] = toParseErrorConstructor(Object.assign({ code: "BABEL_PARSER_SYNTAX_ERROR", reasonCode: n2, toMessage: l2 }, t3 ? { syntaxPlugin: t3 } : {}, a2));
          }
          return r3;
        }
        const c = Object.assign({}, ParseErrorEnum(n), ParseErrorEnum(i), ParseErrorEnum({ StrictDelete: "Deleting local variable in strict mode.", StrictEvalArguments: ({ referenceName: e3 }) => `Assigning to '${e3}' in strict mode.`, StrictEvalArgumentsBinding: ({ bindingName: e3 }) => `Binding '${e3}' in strict mode.`, StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.", StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.", StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.", StrictWith: "'with' in strict mode." }), ParseErrorEnum(o), ParseErrorEnum`pipelineOperator`(l));
        const { defineProperty: u } = Object, toUnenumerable = (e3, t3) => {
          e3 && u(e3, t3, { enumerable: false, value: e3[t3] });
        };
        function toESTreeLocation(e3) {
          return toUnenumerable(e3.loc.start, "index"), toUnenumerable(e3.loc.end, "index"), e3;
        }
        class TokContext {
          constructor(e3, t3) {
            this.token = void 0, this.preserveSpace = void 0, this.token = e3, this.preserveSpace = !!t3;
          }
        }
        const d = { brace: new TokContext("{"), j_oTag: new TokContext("<tag"), j_cTag: new TokContext("</tag"), j_expr: new TokContext("<tag>...</tag>", true) };
        d.template = new TokContext("`", true);
        const h = true, m = true, f = true, y = true, b = true;
        class ExportedTokenType {
          constructor(e3, t3 = {}) {
            this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop = void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = e3, this.keyword = t3.keyword, this.beforeExpr = !!t3.beforeExpr, this.startsExpr = !!t3.startsExpr, this.rightAssociative = !!t3.rightAssociative, this.isLoop = !!t3.isLoop, this.isAssign = !!t3.isAssign, this.prefix = !!t3.prefix, this.postfix = !!t3.postfix, this.binop = null != t3.binop ? t3.binop : null, this.updateContext = null;
          }
        }
        const g = /* @__PURE__ */ new Map();
        function createKeyword(e3, t3 = {}) {
          t3.keyword = e3;
          const r3 = createToken(e3, t3);
          return g.set(e3, r3), r3;
        }
        function createBinop(e3, t3) {
          return createToken(e3, { beforeExpr: h, binop: t3 });
        }
        let x = -1;
        const v = [], E = [], T = [], S = [], P = [], _ = [];
        function createToken(e3, t3 = {}) {
          var r3, n2, s2, i2;
          return ++x, E.push(e3), T.push(null != (r3 = t3.binop) ? r3 : -1), S.push(null != (n2 = t3.beforeExpr) && n2), P.push(null != (s2 = t3.startsExpr) && s2), _.push(null != (i2 = t3.prefix) && i2), v.push(new ExportedTokenType(e3, t3)), x;
        }
        function createKeywordLike(e3, t3 = {}) {
          var r3, n2, s2, i2;
          return ++x, g.set(e3, x), E.push(e3), T.push(null != (r3 = t3.binop) ? r3 : -1), S.push(null != (n2 = t3.beforeExpr) && n2), P.push(null != (s2 = t3.startsExpr) && s2), _.push(null != (i2 = t3.prefix) && i2), v.push(new ExportedTokenType("name", t3)), x;
        }
        const A = { bracketL: createToken("[", { beforeExpr: h, startsExpr: m }), bracketHashL: createToken("#[", { beforeExpr: h, startsExpr: m }), bracketBarL: createToken("[|", { beforeExpr: h, startsExpr: m }), bracketR: createToken("]"), bracketBarR: createToken("|]"), braceL: createToken("{", { beforeExpr: h, startsExpr: m }), braceBarL: createToken("{|", { beforeExpr: h, startsExpr: m }), braceHashL: createToken("#{", { beforeExpr: h, startsExpr: m }), braceR: createToken("}"), braceBarR: createToken("|}"), parenL: createToken("(", { beforeExpr: h, startsExpr: m }), parenR: createToken(")"), comma: createToken(",", { beforeExpr: h }), semi: createToken(";", { beforeExpr: h }), colon: createToken(":", { beforeExpr: h }), doubleColon: createToken("::", { beforeExpr: h }), dot: createToken("."), question: createToken("?", { beforeExpr: h }), questionDot: createToken("?."), arrow: createToken("=>", { beforeExpr: h }), template: createToken("template"), ellipsis: createToken("...", { beforeExpr: h }), backQuote: createToken("`", { startsExpr: m }), dollarBraceL: createToken("${", { beforeExpr: h, startsExpr: m }), templateTail: createToken("...`", { startsExpr: m }), templateNonTail: createToken("...${", { beforeExpr: h, startsExpr: m }), at: createToken("@"), hash: createToken("#", { startsExpr: m }), interpreterDirective: createToken("#!..."), eq: createToken("=", { beforeExpr: h, isAssign: y }), assign: createToken("_=", { beforeExpr: h, isAssign: y }), slashAssign: createToken("_=", { beforeExpr: h, isAssign: y }), xorAssign: createToken("_=", { beforeExpr: h, isAssign: y }), moduloAssign: createToken("_=", { beforeExpr: h, isAssign: y }), incDec: createToken("++/--", { prefix: b, postfix: true, startsExpr: m }), bang: createToken("!", { beforeExpr: h, prefix: b, startsExpr: m }), tilde: createToken("~", { beforeExpr: h, prefix: b, startsExpr: m }), doubleCaret: createToken("^^", { startsExpr: m }), doubleAt: createToken("@@", { startsExpr: m }), pipeline: createBinop("|>", 0), nullishCoalescing: createBinop("??", 1), logicalOR: createBinop("||", 1), logicalAND: createBinop("&&", 2), bitwiseOR: createBinop("|", 3), bitwiseXOR: createBinop("^", 4), bitwiseAND: createBinop("&", 5), equality: createBinop("==/!=/===/!==", 6), lt: createBinop("</>/<=/>=", 7), gt: createBinop("</>/<=/>=", 7), relational: createBinop("</>/<=/>=", 7), bitShift: createBinop("<</>>/>>>", 8), bitShiftL: createBinop("<</>>/>>>", 8), bitShiftR: createBinop("<</>>/>>>", 8), plusMin: createToken("+/-", { beforeExpr: h, binop: 9, prefix: b, startsExpr: m }), modulo: createToken("%", { binop: 10, startsExpr: m }), star: createToken("*", { binop: 10 }), slash: createBinop("/", 10), exponent: createToken("**", { beforeExpr: h, binop: 11, rightAssociative: true }), _in: createKeyword("in", { beforeExpr: h, binop: 7 }), _instanceof: createKeyword("instanceof", { beforeExpr: h, binop: 7 }), _break: createKeyword("break"), _case: createKeyword("case", { beforeExpr: h }), _catch: createKeyword("catch"), _continue: createKeyword("continue"), _debugger: createKeyword("debugger"), _default: createKeyword("default", { beforeExpr: h }), _else: createKeyword("else", { beforeExpr: h }), _finally: createKeyword("finally"), _function: createKeyword("function", { startsExpr: m }), _if: createKeyword("if"), _return: createKeyword("return", { beforeExpr: h }), _switch: createKeyword("switch"), _throw: createKeyword("throw", { beforeExpr: h, prefix: b, startsExpr: m }), _try: createKeyword("try"), _var: createKeyword("var"), _const: createKeyword("const"), _with: createKeyword("with"), _new: createKeyword("new", { beforeExpr: h, startsExpr: m }), _this: createKeyword("this", { startsExpr: m }), _super: createKeyword("super", { startsExpr: m }), _class: createKeyword("class", { startsExpr: m }), _extends: createKeyword("extends", { beforeExpr: h }), _export: createKeyword("export"), _import: createKeyword("import", { startsExpr: m }), _null: createKeyword("null", { startsExpr: m }), _true: createKeyword("true", { startsExpr: m }), _false: createKeyword("false", { startsExpr: m }), _typeof: createKeyword("typeof", { beforeExpr: h, prefix: b, startsExpr: m }), _void: createKeyword("void", { beforeExpr: h, prefix: b, startsExpr: m }), _delete: createKeyword("delete", { beforeExpr: h, prefix: b, startsExpr: m }), _do: createKeyword("do", { isLoop: f, beforeExpr: h }), _for: createKeyword("for", { isLoop: f }), _while: createKeyword("while", { isLoop: f }), _as: createKeywordLike("as", { startsExpr: m }), _assert: createKeywordLike("assert", { startsExpr: m }), _async: createKeywordLike("async", { startsExpr: m }), _await: createKeywordLike("await", { startsExpr: m }), _defer: createKeywordLike("defer", { startsExpr: m }), _from: createKeywordLike("from", { startsExpr: m }), _get: createKeywordLike("get", { startsExpr: m }), _let: createKeywordLike("let", { startsExpr: m }), _meta: createKeywordLike("meta", { startsExpr: m }), _of: createKeywordLike("of", { startsExpr: m }), _sent: createKeywordLike("sent", { startsExpr: m }), _set: createKeywordLike("set", { startsExpr: m }), _source: createKeywordLike("source", { startsExpr: m }), _static: createKeywordLike("static", { startsExpr: m }), _using: createKeywordLike("using", { startsExpr: m }), _yield: createKeywordLike("yield", { startsExpr: m }), _asserts: createKeywordLike("asserts", { startsExpr: m }), _checks: createKeywordLike("checks", { startsExpr: m }), _exports: createKeywordLike("exports", { startsExpr: m }), _global: createKeywordLike("global", { startsExpr: m }), _implements: createKeywordLike("implements", { startsExpr: m }), _intrinsic: createKeywordLike("intrinsic", { startsExpr: m }), _infer: createKeywordLike("infer", { startsExpr: m }), _is: createKeywordLike("is", { startsExpr: m }), _mixins: createKeywordLike("mixins", { startsExpr: m }), _proto: createKeywordLike("proto", { startsExpr: m }), _require: createKeywordLike("require", { startsExpr: m }), _satisfies: createKeywordLike("satisfies", { startsExpr: m }), _keyof: createKeywordLike("keyof", { startsExpr: m }), _readonly: createKeywordLike("readonly", { startsExpr: m }), _unique: createKeywordLike("unique", { startsExpr: m }), _abstract: createKeywordLike("abstract", { startsExpr: m }), _declare: createKeywordLike("declare", { startsExpr: m }), _enum: createKeywordLike("enum", { startsExpr: m }), _module: createKeywordLike("module", { startsExpr: m }), _namespace: createKeywordLike("namespace", { startsExpr: m }), _interface: createKeywordLike("interface", { startsExpr: m }), _type: createKeywordLike("type", { startsExpr: m }), _opaque: createKeywordLike("opaque", { startsExpr: m }), name: createToken("name", { startsExpr: m }), placeholder: createToken("%%", { startsExpr: m }), string: createToken("string", { startsExpr: m }), num: createToken("num", { startsExpr: m }), bigint: createToken("bigint", { startsExpr: m }), decimal: createToken("decimal", { startsExpr: m }), regexp: createToken("regexp", { startsExpr: m }), privateName: createToken("#name", { startsExpr: m }), eof: createToken("eof"), jsxName: createToken("jsxName"), jsxText: createToken("jsxText", { beforeExpr: h }), jsxTagStart: createToken("jsxTagStart", { startsExpr: m }), jsxTagEnd: createToken("jsxTagEnd") };
        function tokenIsIdentifier(e3) {
          return e3 >= 93 && e3 <= 133;
        }
        function tokenIsKeywordOrIdentifier(e3) {
          return e3 >= 58 && e3 <= 133;
        }
        function tokenIsLiteralPropertyName(e3) {
          return e3 >= 58 && e3 <= 137;
        }
        function tokenCanStartExpression(e3) {
          return P[e3];
        }
        function tokenIsFlowInterfaceOrTypeOrOpaque(e3) {
          return e3 >= 129 && e3 <= 131;
        }
        function tokenIsKeyword(e3) {
          return e3 >= 58 && e3 <= 92;
        }
        function tokenIsPostfix(e3) {
          return 34 === e3;
        }
        function tokenLabelName(e3) {
          return E[e3];
        }
        function tokenOperatorPrecedence(e3) {
          return T[e3];
        }
        function tokenIsTemplate(e3) {
          return e3 >= 24 && e3 <= 25;
        }
        function getExportedToken(e3) {
          return v[e3];
        }
        v[8].updateContext = (e3) => {
          e3.pop();
        }, v[5].updateContext = v[7].updateContext = v[23].updateContext = (e3) => {
          e3.push(d.brace);
        }, v[22].updateContext = (e3) => {
          e3[e3.length - 1] === d.template ? e3.pop() : e3.push(d.template);
        }, v[143].updateContext = (e3) => {
          e3.push(d.j_expr, d.j_oTag);
        };
        let C = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC", w = "\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65";
        const I = new RegExp("[" + C + "]"), D = new RegExp("[" + C + w + "]");
        C = w = null;
        const k = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], N = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
        function isInAstralSet(e3, t3) {
          let r3 = 65536;
          for (let n2 = 0, s2 = t3.length; n2 < s2; n2 += 2) {
            if (r3 += t3[n2], r3 > e3) return false;
            if (r3 += t3[n2 + 1], r3 >= e3) return true;
          }
          return false;
        }
        function isIdentifierStart(e3) {
          return e3 < 65 ? 36 === e3 : e3 <= 90 || (e3 < 97 ? 95 === e3 : e3 <= 122 || (e3 <= 65535 ? e3 >= 170 && I.test(String.fromCharCode(e3)) : isInAstralSet(e3, k)));
        }
        function isIdentifierChar(e3) {
          return e3 < 48 ? 36 === e3 : e3 < 58 || !(e3 < 65) && (e3 <= 90 || (e3 < 97 ? 95 === e3 : e3 <= 122 || (e3 <= 65535 ? e3 >= 170 && D.test(String.fromCharCode(e3)) : isInAstralSet(e3, k) || isInAstralSet(e3, N))));
        }
        const O = ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"], j = ["eval", "arguments"], F = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"]), L = new Set(O), M = new Set(j);
        function isReservedWord(e3, t3) {
          return t3 && "await" === e3 || "enum" === e3;
        }
        function isStrictReservedWord(e3, t3) {
          return isReservedWord(e3, t3) || L.has(e3);
        }
        function isStrictBindOnlyReservedWord(e3) {
          return M.has(e3);
        }
        function isStrictBindReservedWord(e3, t3) {
          return isStrictReservedWord(e3, t3) || isStrictBindOnlyReservedWord(e3);
        }
        const B = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
        class Scope {
          constructor(e3) {
            this.flags = 0, this.names = /* @__PURE__ */ new Map(), this.firstLexicalName = "", this.flags = e3;
          }
        }
        class ScopeHandler {
          constructor(e3, t3) {
            this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = e3, this.inModule = t3;
          }
          get inTopLevel() {
            return (1 & this.currentScope().flags) > 0;
          }
          get inFunction() {
            return (2 & this.currentVarScopeFlags()) > 0;
          }
          get allowSuper() {
            return (16 & this.currentThisScopeFlags()) > 0;
          }
          get allowDirectSuper() {
            return (32 & this.currentThisScopeFlags()) > 0;
          }
          get allowNewTarget() {
            return (512 & this.currentThisScopeFlags()) > 0;
          }
          get inClass() {
            return (64 & this.currentThisScopeFlags()) > 0;
          }
          get inClassAndNotInNonArrowFunction() {
            const e3 = this.currentThisScopeFlags();
            return (64 & e3) > 0 && !(2 & e3);
          }
          get inStaticBlock() {
            for (let e3 = this.scopeStack.length - 1; ; e3--) {
              const { flags: t3 } = this.scopeStack[e3];
              if (128 & t3) return true;
              if (1731 & t3) return false;
            }
          }
          get inNonArrowFunction() {
            return (2 & this.currentThisScopeFlags()) > 0;
          }
          get inBareCaseStatement() {
            return (256 & this.currentScope().flags) > 0;
          }
          get treatFunctionsAsVar() {
            return this.treatFunctionsAsVarInScope(this.currentScope());
          }
          createScope(e3) {
            return new Scope(e3);
          }
          enter(e3) {
            this.scopeStack.push(this.createScope(e3));
          }
          exit() {
            return this.scopeStack.pop().flags;
          }
          treatFunctionsAsVarInScope(e3) {
            return !!(130 & e3.flags || !this.parser.inModule && 1 & e3.flags);
          }
          declareName(e3, t3, r3) {
            let n2 = this.currentScope();
            if (8 & t3 || 16 & t3) {
              this.checkRedeclarationInScope(n2, e3, t3, r3);
              let s2 = n2.names.get(e3) || 0;
              16 & t3 ? s2 |= 4 : (n2.firstLexicalName || (n2.firstLexicalName = e3), s2 |= 2), n2.names.set(e3, s2), 8 & t3 && this.maybeExportDefined(n2, e3);
            } else if (4 & t3) for (let s2 = this.scopeStack.length - 1; s2 >= 0 && (n2 = this.scopeStack[s2], this.checkRedeclarationInScope(n2, e3, t3, r3), n2.names.set(e3, 1 | (n2.names.get(e3) || 0)), this.maybeExportDefined(n2, e3), !(1667 & n2.flags)); --s2) ;
            this.parser.inModule && 1 & n2.flags && this.undefinedExports.delete(e3);
          }
          maybeExportDefined(e3, t3) {
            this.parser.inModule && 1 & e3.flags && this.undefinedExports.delete(t3);
          }
          checkRedeclarationInScope(e3, t3, r3, n2) {
            this.isRedeclaredInScope(e3, t3, r3) && this.parser.raise(c.VarRedeclaration, n2, { identifierName: t3 });
          }
          isRedeclaredInScope(e3, t3, r3) {
            if (!(1 & r3)) return false;
            if (8 & r3) return e3.names.has(t3);
            const n2 = e3.names.get(t3);
            return 16 & r3 ? (2 & n2) > 0 || !this.treatFunctionsAsVarInScope(e3) && (1 & n2) > 0 : (2 & n2) > 0 && !(8 & e3.flags && e3.firstLexicalName === t3) || !this.treatFunctionsAsVarInScope(e3) && (4 & n2) > 0;
          }
          checkLocalExport(e3) {
            const { name: t3 } = e3;
            this.scopeStack[0].names.has(t3) || this.undefinedExports.set(t3, e3.loc.start);
          }
          currentScope() {
            return this.scopeStack[this.scopeStack.length - 1];
          }
          currentVarScopeFlags() {
            for (let e3 = this.scopeStack.length - 1; ; e3--) {
              const { flags: t3 } = this.scopeStack[e3];
              if (1667 & t3) return t3;
            }
          }
          currentThisScopeFlags() {
            for (let e3 = this.scopeStack.length - 1; ; e3--) {
              const { flags: t3 } = this.scopeStack[e3];
              if (1731 & t3 && !(4 & t3)) return t3;
            }
          }
        }
        class FlowScope extends Scope {
          constructor(...e3) {
            super(...e3), this.declareFunctions = /* @__PURE__ */ new Set();
          }
        }
        class FlowScopeHandler extends ScopeHandler {
          createScope(e3) {
            return new FlowScope(e3);
          }
          declareName(e3, t3, r3) {
            const n2 = this.currentScope();
            if (2048 & t3) return this.checkRedeclarationInScope(n2, e3, t3, r3), this.maybeExportDefined(n2, e3), void n2.declareFunctions.add(e3);
            super.declareName(e3, t3, r3);
          }
          isRedeclaredInScope(e3, t3, r3) {
            if (super.isRedeclaredInScope(e3, t3, r3)) return true;
            if (2048 & r3 && !e3.declareFunctions.has(t3)) {
              const r4 = e3.names.get(t3);
              return (4 & r4) > 0 || (2 & r4) > 0;
            }
            return false;
          }
          checkLocalExport(e3) {
            this.scopeStack[0].declareFunctions.has(e3.name) || super.checkLocalExport(e3);
          }
        }
        const R = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]), U = ParseErrorEnum`flow`({ AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.", AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.", AssignReservedType: ({ reservedType: e3 }) => `Cannot overwrite reserved type ${e3}.`, DeclareClassElement: "The `declare` modifier can only appear on class fields.", DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.", DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.", EnumBooleanMemberNotInitialized: ({ memberName: e3, enumName: t3 }) => `Boolean enum members need to be initialized. Use either \`${e3} = true,\` or \`${e3} = false,\` in enum \`${t3}\`.`, EnumDuplicateMemberName: ({ memberName: e3, enumName: t3 }) => `Enum member names need to be unique, but the name \`${e3}\` has already been used before in enum \`${t3}\`.`, EnumInconsistentMemberValues: ({ enumName: e3 }) => `Enum \`${e3}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`, EnumInvalidExplicitType: ({ invalidEnumType: e3, enumName: t3 }) => `Enum type \`${e3}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${t3}\`.`, EnumInvalidExplicitTypeUnknownSupplied: ({ enumName: e3 }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${e3}\`.`, EnumInvalidMemberInitializerPrimaryType: ({ enumName: e3, memberName: t3, explicitType: r3 }) => `Enum \`${e3}\` has type \`${r3}\`, so the initializer of \`${t3}\` needs to be a ${r3} literal.`, EnumInvalidMemberInitializerSymbolType: ({ enumName: e3, memberName: t3 }) => `Symbol enum members cannot be initialized. Use \`${t3},\` in enum \`${e3}\`.`, EnumInvalidMemberInitializerUnknownType: ({ enumName: e3, memberName: t3 }) => `The enum member initializer for \`${t3}\` needs to be a literal (either a boolean, number, or string) in enum \`${e3}\`.`, EnumInvalidMemberName: ({ enumName: e3, memberName: t3, suggestion: r3 }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${t3}\`, consider using \`${r3}\`, in enum \`${e3}\`.`, EnumNumberMemberNotInitialized: ({ enumName: e3, memberName: t3 }) => `Number enum members need to be initialized, e.g. \`${t3} = 1\` in enum \`${e3}\`.`, EnumStringMemberInconsistentlyInitialized: ({ enumName: e3 }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${e3}\`.`, GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.", ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.", ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.", InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.", InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.", InexactVariance: "Explicit inexact syntax cannot have variance.", InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.", MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.", NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.", NestedFlowComment: "Cannot have a flow comment inside another flow comment.", PatternIsOptional: Object.assign({ message: "A binding pattern parameter cannot be optional in an implementation signature." }, { reasonCode: "OptionalBindingPattern" }), SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.", SpreadVariance: "Spread properties cannot have variance.", ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.", ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.", ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.", ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.", ThisParamNoDefault: "The `this` parameter may not have a default value.", TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.", UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.", UnexpectedReservedType: ({ reservedType: e3 }) => `Unexpected reserved type ${e3}.`, UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.", UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.", UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.", UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".', UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.", UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.", UnsupportedDeclareExportKind: ({ unsupportedExportKind: e3, suggestion: t3 }) => `\`declare export ${e3}\` is not supported. Use \`${t3}\` instead.`, UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.", UnterminatedFlowComment: "Unterminated flow-comment." });
        function hasTypeImportKind(e3) {
          return "type" === e3.importKind || "typeof" === e3.importKind;
        }
        const V = { const: "declare export var", let: "declare export var", type: "export type", interface: "export interface" };
        const $ = /\*?\s*@((?:no)?flow)\b/;
        const K = { __proto__: null, quot: '"', amp: "&", apos: "'", lt: "<", gt: ">", nbsp: "\xA0", iexcl: "\xA1", cent: "\xA2", pound: "\xA3", curren: "\xA4", yen: "\xA5", brvbar: "\xA6", sect: "\xA7", uml: "\xA8", copy: "\xA9", ordf: "\xAA", laquo: "\xAB", not: "\xAC", shy: "\xAD", reg: "\xAE", macr: "\xAF", deg: "\xB0", plusmn: "\xB1", sup2: "\xB2", sup3: "\xB3", acute: "\xB4", micro: "\xB5", para: "\xB6", middot: "\xB7", cedil: "\xB8", sup1: "\xB9", ordm: "\xBA", raquo: "\xBB", frac14: "\xBC", frac12: "\xBD", frac34: "\xBE", iquest: "\xBF", Agrave: "\xC0", Aacute: "\xC1", Acirc: "\xC2", Atilde: "\xC3", Auml: "\xC4", Aring: "\xC5", AElig: "\xC6", Ccedil: "\xC7", Egrave: "\xC8", Eacute: "\xC9", Ecirc: "\xCA", Euml: "\xCB", Igrave: "\xCC", Iacute: "\xCD", Icirc: "\xCE", Iuml: "\xCF", ETH: "\xD0", Ntilde: "\xD1", Ograve: "\xD2", Oacute: "\xD3", Ocirc: "\xD4", Otilde: "\xD5", Ouml: "\xD6", times: "\xD7", Oslash: "\xD8", Ugrave: "\xD9", Uacute: "\xDA", Ucirc: "\xDB", Uuml: "\xDC", Yacute: "\xDD", THORN: "\xDE", szlig: "\xDF", agrave: "\xE0", aacute: "\xE1", acirc: "\xE2", atilde: "\xE3", auml: "\xE4", aring: "\xE5", aelig: "\xE6", ccedil: "\xE7", egrave: "\xE8", eacute: "\xE9", ecirc: "\xEA", euml: "\xEB", igrave: "\xEC", iacute: "\xED", icirc: "\xEE", iuml: "\xEF", eth: "\xF0", ntilde: "\xF1", ograve: "\xF2", oacute: "\xF3", ocirc: "\xF4", otilde: "\xF5", ouml: "\xF6", divide: "\xF7", oslash: "\xF8", ugrave: "\xF9", uacute: "\xFA", ucirc: "\xFB", uuml: "\xFC", yacute: "\xFD", thorn: "\xFE", yuml: "\xFF", OElig: "\u0152", oelig: "\u0153", Scaron: "\u0160", scaron: "\u0161", Yuml: "\u0178", fnof: "\u0192", circ: "\u02C6", tilde: "\u02DC", Alpha: "\u0391", Beta: "\u0392", Gamma: "\u0393", Delta: "\u0394", Epsilon: "\u0395", Zeta: "\u0396", Eta: "\u0397", Theta: "\u0398", Iota: "\u0399", Kappa: "\u039A", Lambda: "\u039B", Mu: "\u039C", Nu: "\u039D", Xi: "\u039E", Omicron: "\u039F", Pi: "\u03A0", Rho: "\u03A1", Sigma: "\u03A3", Tau: "\u03A4", Upsilon: "\u03A5", Phi: "\u03A6", Chi: "\u03A7", Psi: "\u03A8", Omega: "\u03A9", alpha: "\u03B1", beta: "\u03B2", gamma: "\u03B3", delta: "\u03B4", epsilon: "\u03B5", zeta: "\u03B6", eta: "\u03B7", theta: "\u03B8", iota: "\u03B9", kappa: "\u03BA", lambda: "\u03BB", mu: "\u03BC", nu: "\u03BD", xi: "\u03BE", omicron: "\u03BF", pi: "\u03C0", rho: "\u03C1", sigmaf: "\u03C2", sigma: "\u03C3", tau: "\u03C4", upsilon: "\u03C5", phi: "\u03C6", chi: "\u03C7", psi: "\u03C8", omega: "\u03C9", thetasym: "\u03D1", upsih: "\u03D2", piv: "\u03D6", ensp: "\u2002", emsp: "\u2003", thinsp: "\u2009", zwnj: "\u200C", zwj: "\u200D", lrm: "\u200E", rlm: "\u200F", ndash: "\u2013", mdash: "\u2014", lsquo: "\u2018", rsquo: "\u2019", sbquo: "\u201A", ldquo: "\u201C", rdquo: "\u201D", bdquo: "\u201E", dagger: "\u2020", Dagger: "\u2021", bull: "\u2022", hellip: "\u2026", permil: "\u2030", prime: "\u2032", Prime: "\u2033", lsaquo: "\u2039", rsaquo: "\u203A", oline: "\u203E", frasl: "\u2044", euro: "\u20AC", image: "\u2111", weierp: "\u2118", real: "\u211C", trade: "\u2122", alefsym: "\u2135", larr: "\u2190", uarr: "\u2191", rarr: "\u2192", darr: "\u2193", harr: "\u2194", crarr: "\u21B5", lArr: "\u21D0", uArr: "\u21D1", rArr: "\u21D2", dArr: "\u21D3", hArr: "\u21D4", forall: "\u2200", part: "\u2202", exist: "\u2203", empty: "\u2205", nabla: "\u2207", isin: "\u2208", notin: "\u2209", ni: "\u220B", prod: "\u220F", sum: "\u2211", minus: "\u2212", lowast: "\u2217", radic: "\u221A", prop: "\u221D", infin: "\u221E", ang: "\u2220", and: "\u2227", or: "\u2228", cap: "\u2229", cup: "\u222A", int: "\u222B", there4: "\u2234", sim: "\u223C", cong: "\u2245", asymp: "\u2248", ne: "\u2260", equiv: "\u2261", le: "\u2264", ge: "\u2265", sub: "\u2282", sup: "\u2283", nsub: "\u2284", sube: "\u2286", supe: "\u2287", oplus: "\u2295", otimes: "\u2297", perp: "\u22A5", sdot: "\u22C5", lceil: "\u2308", rceil: "\u2309", lfloor: "\u230A", rfloor: "\u230B", lang: "\u2329", rang: "\u232A", loz: "\u25CA", spades: "\u2660", clubs: "\u2663", hearts: "\u2665", diams: "\u2666" }, W = new RegExp(/\r\n|[\r\n\u2028\u2029]/.source, "g");
        function isNewLine(e3) {
          switch (e3) {
            case 10:
            case 13:
            case 8232:
            case 8233:
              return true;
            default:
              return false;
          }
        }
        function hasNewLine(e3, t3, r3) {
          for (let n2 = t3; n2 < r3; n2++) if (isNewLine(e3.charCodeAt(n2))) return true;
          return false;
        }
        const q = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, H = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g;
        function isWhitespace(e3) {
          switch (e3) {
            case 9:
            case 11:
            case 12:
            case 32:
            case 160:
            case 5760:
            case 8192:
            case 8193:
            case 8194:
            case 8195:
            case 8196:
            case 8197:
            case 8198:
            case 8199:
            case 8200:
            case 8201:
            case 8202:
            case 8239:
            case 8287:
            case 12288:
            case 65279:
              return true;
            default:
              return false;
          }
        }
        const z = ParseErrorEnum`jsx`({ AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.", MissingClosingTagElement: ({ openingTagName: e3 }) => `Expected corresponding JSX closing tag for <${e3}>.`, MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.", UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?", UnexpectedToken: ({ unexpected: e3, HTMLEntity: t3 }) => `Unexpected token \`${e3}\`. Did you mean \`${t3}\` or \`{'${e3}'}\`?`, UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.", UnterminatedJsxContent: "Unterminated JSX contents.", UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?" });
        function isFragment(e3) {
          return !!e3 && ("JSXOpeningFragment" === e3.type || "JSXClosingFragment" === e3.type);
        }
        function getQualifiedJSXName(e3) {
          if ("JSXIdentifier" === e3.type) return e3.name;
          if ("JSXNamespacedName" === e3.type) return e3.namespace.name + ":" + e3.name.name;
          if ("JSXMemberExpression" === e3.type) return getQualifiedJSXName(e3.object) + "." + getQualifiedJSXName(e3.property);
          throw new Error("Node had unexpected type: " + e3.type);
        }
        class TypeScriptScope extends Scope {
          constructor(...e3) {
            super(...e3), this.tsNames = /* @__PURE__ */ new Map();
          }
        }
        class TypeScriptScopeHandler extends ScopeHandler {
          constructor(...e3) {
            super(...e3), this.importsStack = [];
          }
          createScope(e3) {
            return this.importsStack.push(/* @__PURE__ */ new Set()), new TypeScriptScope(e3);
          }
          enter(e3) {
            1024 === e3 && this.importsStack.push(/* @__PURE__ */ new Set()), super.enter(e3);
          }
          exit() {
            const e3 = super.exit();
            return 1024 === e3 && this.importsStack.pop(), e3;
          }
          hasImport(e3, t3) {
            const r3 = this.importsStack.length;
            if (this.importsStack[r3 - 1].has(e3)) return true;
            if (!t3 && r3 > 1) {
              for (let t4 = 0; t4 < r3 - 1; t4++) if (this.importsStack[t4].has(e3)) return true;
            }
            return false;
          }
          declareName(e3, t3, r3) {
            if (4096 & t3) return this.hasImport(e3, true) && this.parser.raise(c.VarRedeclaration, r3, { identifierName: e3 }), void this.importsStack[this.importsStack.length - 1].add(e3);
            const n2 = this.currentScope();
            let s2 = n2.tsNames.get(e3) || 0;
            if (1024 & t3) return this.maybeExportDefined(n2, e3), void n2.tsNames.set(e3, 16 | s2);
            super.declareName(e3, t3, r3), 2 & t3 && (1 & t3 || (this.checkRedeclarationInScope(n2, e3, t3, r3), this.maybeExportDefined(n2, e3)), s2 |= 1), 256 & t3 && (s2 |= 2), 512 & t3 && (s2 |= 4), 128 & t3 && (s2 |= 8), s2 && n2.tsNames.set(e3, s2);
          }
          isRedeclaredInScope(e3, t3, r3) {
            const n2 = e3.tsNames.get(t3);
            if ((2 & n2) > 0) {
              if (256 & r3) {
                return !!(512 & r3) !== (4 & n2) > 0;
              }
              return true;
            }
            return 128 & r3 && (8 & n2) > 0 ? !!(2 & e3.names.get(t3)) && !!(1 & r3) : !!(2 & r3 && (1 & n2) > 0) || super.isRedeclaredInScope(e3, t3, r3);
          }
          checkLocalExport(e3) {
            const { name: t3 } = e3;
            if (this.hasImport(t3)) return;
            for (let e4 = this.scopeStack.length - 1; e4 >= 0; e4--) {
              const r3 = this.scopeStack[e4].tsNames.get(t3);
              if ((1 & r3) > 0 || (16 & r3) > 0) return;
            }
            super.checkLocalExport(e3);
          }
        }
        class ProductionParameterHandler {
          constructor() {
            this.stacks = [];
          }
          enter(e3) {
            this.stacks.push(e3);
          }
          exit() {
            this.stacks.pop();
          }
          currentFlags() {
            return this.stacks[this.stacks.length - 1];
          }
          get hasAwait() {
            return (2 & this.currentFlags()) > 0;
          }
          get hasYield() {
            return (1 & this.currentFlags()) > 0;
          }
          get hasReturn() {
            return (4 & this.currentFlags()) > 0;
          }
          get hasIn() {
            return (8 & this.currentFlags()) > 0;
          }
        }
        function functionFlags(e3, t3) {
          return (e3 ? 2 : 0) | (t3 ? 1 : 0);
        }
        class BaseParser {
          constructor() {
            this.sawUnambiguousESM = false, this.ambiguousScriptDifferentAst = false;
          }
          sourceToOffsetPos(e3) {
            return e3 + this.startIndex;
          }
          offsetToSourcePos(e3) {
            return e3 - this.startIndex;
          }
          hasPlugin(e3) {
            if ("string" == typeof e3) return this.plugins.has(e3);
            {
              const [t3, r3] = e3;
              if (!this.hasPlugin(t3)) return false;
              const n2 = this.plugins.get(t3);
              for (const e4 of Object.keys(r3)) if ((null == n2 ? void 0 : n2[e4]) !== r3[e4]) return false;
              return true;
            }
          }
          getPluginOption(e3, t3) {
            var r3;
            return null == (r3 = this.plugins.get(e3)) ? void 0 : r3[t3];
          }
        }
        function setTrailingComments(e3, t3) {
          void 0 === e3.trailingComments ? e3.trailingComments = t3 : e3.trailingComments.unshift(...t3);
        }
        function setInnerComments(e3, t3) {
          void 0 === e3.innerComments ? e3.innerComments = t3 : e3.innerComments.unshift(...t3);
        }
        function adjustInnerComments(e3, t3, r3) {
          let n2 = null, s2 = t3.length;
          for (; null === n2 && s2 > 0; ) n2 = t3[--s2];
          null === n2 || n2.start > r3.start ? setInnerComments(e3, r3.comments) : setTrailingComments(n2, r3.comments);
        }
        class CommentsParser extends BaseParser {
          addComment(e3) {
            this.filename && (e3.loc.filename = this.filename);
            const { commentsLen: t3 } = this.state;
            this.comments.length !== t3 && (this.comments.length = t3), this.comments.push(e3), this.state.commentsLen++;
          }
          processComment(e3) {
            const { commentStack: t3 } = this.state, r3 = t3.length;
            if (0 === r3) return;
            let n2 = r3 - 1;
            const s2 = t3[n2];
            s2.start === e3.end && (s2.leadingNode = e3, n2--);
            const { start: i2 } = e3;
            for (; n2 >= 0; n2--) {
              const r4 = t3[n2], s3 = r4.end;
              if (!(s3 > i2)) {
                s3 === i2 && (r4.trailingNode = e3);
                break;
              }
              r4.containingNode = e3, this.finalizeComment(r4), t3.splice(n2, 1);
            }
          }
          finalizeComment(e3) {
            var t3;
            const { comments: r3 } = e3;
            if (null !== e3.leadingNode || null !== e3.trailingNode) null !== e3.leadingNode && setTrailingComments(e3.leadingNode, r3), null !== e3.trailingNode && (function(e4, t4) {
              void 0 === e4.leadingComments ? e4.leadingComments = t4 : e4.leadingComments.unshift(...t4);
            })(e3.trailingNode, r3);
            else {
              const { containingNode: n2, start: s2 } = e3;
              if (44 === this.input.charCodeAt(this.offsetToSourcePos(s2) - 1)) switch (n2.type) {
                case "ObjectExpression":
                case "ObjectPattern":
                case "RecordExpression":
                  adjustInnerComments(n2, n2.properties, e3);
                  break;
                case "CallExpression":
                case "OptionalCallExpression":
                  adjustInnerComments(n2, n2.arguments, e3);
                  break;
                case "ImportExpression":
                  adjustInnerComments(n2, [n2.source, null != (t3 = n2.options) ? t3 : null], e3);
                  break;
                case "FunctionDeclaration":
                case "FunctionExpression":
                case "ArrowFunctionExpression":
                case "ObjectMethod":
                case "ClassMethod":
                case "ClassPrivateMethod":
                  adjustInnerComments(n2, n2.params, e3);
                  break;
                case "ArrayExpression":
                case "ArrayPattern":
                case "TupleExpression":
                  adjustInnerComments(n2, n2.elements, e3);
                  break;
                case "ExportNamedDeclaration":
                case "ImportDeclaration":
                  adjustInnerComments(n2, n2.specifiers, e3);
                  break;
                case "TSEnumDeclaration":
                case "TSEnumBody":
                  adjustInnerComments(n2, n2.members, e3);
                  break;
                default:
                  setInnerComments(n2, r3);
              }
              else setInnerComments(n2, r3);
            }
          }
          finalizeRemainingComments() {
            const { commentStack: e3 } = this.state;
            for (let t3 = e3.length - 1; t3 >= 0; t3--) this.finalizeComment(e3[t3]);
            this.state.commentStack = [];
          }
          resetPreviousNodeTrailingComments(e3) {
            const { commentStack: t3 } = this.state, { length: r3 } = t3;
            if (0 === r3) return;
            const n2 = t3[r3 - 1];
            n2.leadingNode === e3 && (n2.leadingNode = null);
          }
          takeSurroundingComments(e3, t3, r3) {
            const { commentStack: n2 } = this.state, s2 = n2.length;
            if (0 === s2) return;
            let i2 = s2 - 1;
            for (; i2 >= 0; i2--) {
              const s3 = n2[i2], o2 = s3.end;
              if (s3.start === r3) s3.leadingNode = e3;
              else if (o2 === t3) s3.trailingNode = e3;
              else if (o2 < t3) break;
            }
          }
        }
        class State {
          constructor() {
            this.flags = 1024, this.startIndex = void 0, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null }, this.labels = [], this.commentsLen = 0, this.commentStack = [], this.pos = 0, this.type = 140, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.context = [d.brace], this.firstInvalidTemplateEscapePos = null, this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
          }
          get strict() {
            return (1 & this.flags) > 0;
          }
          set strict(e3) {
            e3 ? this.flags |= 1 : this.flags &= -2;
          }
          init({ strictMode: e3, sourceType: t3, startIndex: r3, startLine: n2, startColumn: s2 }) {
            this.strict = false !== e3 && (true === e3 || "module" === t3), this.startIndex = r3, this.curLine = n2, this.lineStart = -s2, this.startLoc = this.endLoc = new Position(n2, s2, r3);
          }
          get maybeInArrowParameters() {
            return (2 & this.flags) > 0;
          }
          set maybeInArrowParameters(e3) {
            e3 ? this.flags |= 2 : this.flags &= -3;
          }
          get inType() {
            return (4 & this.flags) > 0;
          }
          set inType(e3) {
            e3 ? this.flags |= 4 : this.flags &= -5;
          }
          get noAnonFunctionType() {
            return (8 & this.flags) > 0;
          }
          set noAnonFunctionType(e3) {
            e3 ? this.flags |= 8 : this.flags &= -9;
          }
          get hasFlowComment() {
            return (16 & this.flags) > 0;
          }
          set hasFlowComment(e3) {
            e3 ? this.flags |= 16 : this.flags &= -17;
          }
          get isAmbientContext() {
            return (32 & this.flags) > 0;
          }
          set isAmbientContext(e3) {
            e3 ? this.flags |= 32 : this.flags &= -33;
          }
          get inAbstractClass() {
            return (64 & this.flags) > 0;
          }
          set inAbstractClass(e3) {
            e3 ? this.flags |= 64 : this.flags &= -65;
          }
          get inDisallowConditionalTypesContext() {
            return (128 & this.flags) > 0;
          }
          set inDisallowConditionalTypesContext(e3) {
            e3 ? this.flags |= 128 : this.flags &= -129;
          }
          get soloAwait() {
            return (256 & this.flags) > 0;
          }
          set soloAwait(e3) {
            e3 ? this.flags |= 256 : this.flags &= -257;
          }
          get inFSharpPipelineDirectBody() {
            return (512 & this.flags) > 0;
          }
          set inFSharpPipelineDirectBody(e3) {
            e3 ? this.flags |= 512 : this.flags &= -513;
          }
          get canStartJSXElement() {
            return (1024 & this.flags) > 0;
          }
          set canStartJSXElement(e3) {
            e3 ? this.flags |= 1024 : this.flags &= -1025;
          }
          get containsEsc() {
            return (2048 & this.flags) > 0;
          }
          set containsEsc(e3) {
            e3 ? this.flags |= 2048 : this.flags &= -2049;
          }
          get hasTopLevelAwait() {
            return (4096 & this.flags) > 0;
          }
          set hasTopLevelAwait(e3) {
            e3 ? this.flags |= 4096 : this.flags &= -4097;
          }
          curPosition() {
            return new Position(this.curLine, this.pos - this.lineStart, this.pos + this.startIndex);
          }
          clone() {
            const e3 = new State();
            return e3.flags = this.flags, e3.startIndex = this.startIndex, e3.curLine = this.curLine, e3.lineStart = this.lineStart, e3.startLoc = this.startLoc, e3.endLoc = this.endLoc, e3.errors = this.errors.slice(), e3.potentialArrowAt = this.potentialArrowAt, e3.noArrowAt = this.noArrowAt.slice(), e3.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice(), e3.topicContext = this.topicContext, e3.labels = this.labels.slice(), e3.commentsLen = this.commentsLen, e3.commentStack = this.commentStack.slice(), e3.pos = this.pos, e3.type = this.type, e3.value = this.value, e3.start = this.start, e3.end = this.end, e3.lastTokEndLoc = this.lastTokEndLoc, e3.lastTokStartLoc = this.lastTokStartLoc, e3.context = this.context.slice(), e3.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos, e3.strictErrors = this.strictErrors, e3.tokensLength = this.tokensLength, e3;
          }
        }
        var _isDigit = function(e3) {
          return e3 >= 48 && e3 <= 57;
        };
        const G = { decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]), hex: /* @__PURE__ */ new Set([46, 88, 95, 120]) }, X = { bin: (e3) => 48 === e3 || 49 === e3, oct: (e3) => e3 >= 48 && e3 <= 55, dec: (e3) => e3 >= 48 && e3 <= 57, hex: (e3) => e3 >= 48 && e3 <= 57 || e3 >= 65 && e3 <= 70 || e3 >= 97 && e3 <= 102 };
        function readStringContents(e3, t3, r3, n2, s2, i2) {
          const o2 = r3, a2 = n2, l2 = s2;
          let p2 = "", c2 = null, u2 = r3;
          const { length: d2 } = t3;
          for (; ; ) {
            if (r3 >= d2) {
              i2.unterminated(o2, a2, l2), p2 += t3.slice(u2, r3);
              break;
            }
            const h2 = t3.charCodeAt(r3);
            if (isStringEnd(e3, h2, t3, r3)) {
              p2 += t3.slice(u2, r3);
              break;
            }
            if (92 === h2) {
              p2 += t3.slice(u2, r3);
              const o3 = readEscapedChar(t3, r3, n2, s2, "template" === e3, i2);
              null !== o3.ch || c2 ? p2 += o3.ch : c2 = { pos: r3, lineStart: n2, curLine: s2 }, { pos: r3, lineStart: n2, curLine: s2 } = o3, u2 = r3;
            } else 8232 === h2 || 8233 === h2 ? (++s2, n2 = ++r3) : 10 === h2 || 13 === h2 ? "template" === e3 ? (p2 += t3.slice(u2, r3) + "\n", ++r3, 13 === h2 && 10 === t3.charCodeAt(r3) && ++r3, ++s2, u2 = n2 = r3) : i2.unterminated(o2, a2, l2) : ++r3;
          }
          return { pos: r3, str: p2, firstInvalidLoc: c2, lineStart: n2, curLine: s2, containsInvalid: !!c2 };
        }
        function isStringEnd(e3, t3, r3, n2) {
          return "template" === e3 ? 96 === t3 || 36 === t3 && 123 === r3.charCodeAt(n2 + 1) : t3 === ("double" === e3 ? 34 : 39);
        }
        function readEscapedChar(e3, t3, r3, n2, s2, i2) {
          const o2 = !s2;
          t3++;
          const res = (e4) => ({ pos: t3, ch: e4, lineStart: r3, curLine: n2 }), a2 = e3.charCodeAt(t3++);
          switch (a2) {
            case 110:
              return res("\n");
            case 114:
              return res("\r");
            case 120: {
              let s3;
              return { code: s3, pos: t3 } = readHexChar(e3, t3, r3, n2, 2, false, o2, i2), res(null === s3 ? null : String.fromCharCode(s3));
            }
            case 117: {
              let s3;
              return { code: s3, pos: t3 } = readCodePoint(e3, t3, r3, n2, o2, i2), res(null === s3 ? null : String.fromCodePoint(s3));
            }
            case 116:
              return res("	");
            case 98:
              return res("\b");
            case 118:
              return res("\v");
            case 102:
              return res("\f");
            case 13:
              10 === e3.charCodeAt(t3) && ++t3;
            case 10:
              r3 = t3, ++n2;
            case 8232:
            case 8233:
              return res("");
            case 56:
            case 57:
              if (s2) return res(null);
              i2.strictNumericEscape(t3 - 1, r3, n2);
            default:
              if (a2 >= 48 && a2 <= 55) {
                const o3 = t3 - 1;
                let a3 = /^[0-7]+/.exec(e3.slice(o3, t3 + 2))[0], l2 = parseInt(a3, 8);
                l2 > 255 && (a3 = a3.slice(0, -1), l2 = parseInt(a3, 8)), t3 += a3.length - 1;
                const p2 = e3.charCodeAt(t3);
                if ("0" !== a3 || 56 === p2 || 57 === p2) {
                  if (s2) return res(null);
                  i2.strictNumericEscape(o3, r3, n2);
                }
                return res(String.fromCharCode(l2));
              }
              return res(String.fromCharCode(a2));
          }
        }
        function readHexChar(e3, t3, r3, n2, s2, i2, o2, a2) {
          const l2 = t3;
          let p2;
          return { n: p2, pos: t3 } = readInt(e3, t3, r3, n2, 16, s2, i2, false, a2, !o2), null === p2 && (o2 ? a2.invalidEscapeSequence(l2, r3, n2) : t3 = l2 - 1), { code: p2, pos: t3 };
        }
        function readInt(e3, t3, r3, n2, s2, i2, o2, a2, l2, p2) {
          const c2 = t3, u2 = 16 === s2 ? G.hex : G.decBinOct, d2 = 16 === s2 ? X.hex : 10 === s2 ? X.dec : 8 === s2 ? X.oct : X.bin;
          let h2 = false, m2 = 0;
          for (let c3 = 0, f2 = null == i2 ? 1 / 0 : i2; c3 < f2; ++c3) {
            const i3 = e3.charCodeAt(t3);
            let c4;
            if (95 === i3 && "bail" !== a2) {
              const s3 = e3.charCodeAt(t3 - 1), i4 = e3.charCodeAt(t3 + 1);
              if (a2) {
                if (Number.isNaN(i4) || !d2(i4) || u2.has(s3) || u2.has(i4)) {
                  if (p2) return { n: null, pos: t3 };
                  l2.unexpectedNumericSeparator(t3, r3, n2);
                }
              } else {
                if (p2) return { n: null, pos: t3 };
                l2.numericSeparatorInEscapeSequence(t3, r3, n2);
              }
              ++t3;
              continue;
            }
            if (c4 = i3 >= 97 ? i3 - 97 + 10 : i3 >= 65 ? i3 - 65 + 10 : _isDigit(i3) ? i3 - 48 : 1 / 0, c4 >= s2) {
              if (c4 <= 9 && p2) return { n: null, pos: t3 };
              if (c4 <= 9 && l2.invalidDigit(t3, r3, n2, s2)) c4 = 0;
              else {
                if (!o2) break;
                c4 = 0, h2 = true;
              }
            }
            ++t3, m2 = m2 * s2 + c4;
          }
          return t3 === c2 || null != i2 && t3 - c2 !== i2 || h2 ? { n: null, pos: t3 } : { n: m2, pos: t3 };
        }
        function readCodePoint(e3, t3, r3, n2, s2, i2) {
          let o2;
          if (123 === e3.charCodeAt(t3)) {
            if (++t3, { code: o2, pos: t3 } = readHexChar(e3, t3, r3, n2, e3.indexOf("}", t3) - t3, true, s2, i2), ++t3, null !== o2 && o2 > 1114111) {
              if (!s2) return { code: null, pos: t3 };
              i2.invalidCodePoint(t3, r3, n2);
            }
          } else ({ code: o2, pos: t3 } = readHexChar(e3, t3, r3, n2, 4, false, s2, i2));
          return { code: o2, pos: t3 };
        }
        function buildPosition(e3, t3, r3) {
          return new Position(r3, e3 - t3, e3);
        }
        const J = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]);
        class Token {
          constructor(e3) {
            const t3 = e3.startIndex || 0;
            this.type = e3.type, this.value = e3.value, this.start = t3 + e3.start, this.end = t3 + e3.end, this.loc = new SourceLocation(e3.startLoc, e3.endLoc);
          }
        }
        class Tokenizer extends CommentsParser {
          constructor(e3, t3) {
            super(), this.isLookahead = void 0, this.tokens = [], this.errorHandlers_readInt = { invalidDigit: (e4, t4, r3, n2) => !!(2048 & this.optionFlags) && (this.raise(c.InvalidDigit, buildPosition(e4, t4, r3), { radix: n2 }), true), numericSeparatorInEscapeSequence: this.errorBuilder(c.NumericSeparatorInEscapeSequence), unexpectedNumericSeparator: this.errorBuilder(c.UnexpectedNumericSeparator) }, this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, { invalidEscapeSequence: this.errorBuilder(c.InvalidEscapeSequence), invalidCodePoint: this.errorBuilder(c.InvalidCodePoint) }), this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, { strictNumericEscape: (e4, t4, r3) => {
              this.recordStrictModeErrors(c.StrictNumericEscape, buildPosition(e4, t4, r3));
            }, unterminated: (e4, t4, r3) => {
              throw this.raise(c.UnterminatedString, buildPosition(e4 - 1, t4, r3));
            } }), this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, { strictNumericEscape: this.errorBuilder(c.StrictNumericEscape), unterminated: (e4, t4, r3) => {
              throw this.raise(c.UnterminatedTemplate, buildPosition(e4, t4, r3));
            } }), this.state = new State(), this.state.init(e3), this.input = t3, this.length = t3.length, this.comments = [], this.isLookahead = false;
          }
          pushToken(e3) {
            this.tokens.length = this.state.tokensLength, this.tokens.push(e3), ++this.state.tokensLength;
          }
          next() {
            this.checkKeywordEscapes(), 256 & this.optionFlags && this.pushToken(new Token(this.state)), this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
          }
          eat(e3) {
            return !!this.match(e3) && (this.next(), true);
          }
          match(e3) {
            return this.state.type === e3;
          }
          createLookaheadState(e3) {
            return { pos: e3.pos, value: null, type: e3.type, start: e3.start, end: e3.end, context: [this.curContext()], inType: e3.inType, startLoc: e3.startLoc, lastTokEndLoc: e3.lastTokEndLoc, curLine: e3.curLine, lineStart: e3.lineStart, curPosition: e3.curPosition };
          }
          lookahead() {
            const e3 = this.state;
            this.state = this.createLookaheadState(e3), this.isLookahead = true, this.nextToken(), this.isLookahead = false;
            const t3 = this.state;
            return this.state = e3, t3;
          }
          nextTokenStart() {
            return this.nextTokenStartSince(this.state.pos);
          }
          nextTokenStartSince(e3) {
            return q.lastIndex = e3, q.test(this.input) ? q.lastIndex : e3;
          }
          lookaheadCharCode() {
            return this.lookaheadCharCodeSince(this.state.pos);
          }
          lookaheadCharCodeSince(e3) {
            return this.input.charCodeAt(this.nextTokenStartSince(e3));
          }
          nextTokenInLineStart() {
            return this.nextTokenInLineStartSince(this.state.pos);
          }
          nextTokenInLineStartSince(e3) {
            return H.lastIndex = e3, H.test(this.input) ? H.lastIndex : e3;
          }
          lookaheadInLineCharCode() {
            return this.input.charCodeAt(this.nextTokenInLineStart());
          }
          codePointAtPos(e3) {
            let t3 = this.input.charCodeAt(e3);
            if (55296 == (64512 & t3) && ++e3 < this.input.length) {
              const r3 = this.input.charCodeAt(e3);
              56320 == (64512 & r3) && (t3 = 65536 + ((1023 & t3) << 10) + (1023 & r3));
            }
            return t3;
          }
          setStrict(e3) {
            this.state.strict = e3, e3 && (this.state.strictErrors.forEach(([e4, t3]) => this.raise(e4, t3)), this.state.strictErrors.clear());
          }
          curContext() {
            return this.state.context[this.state.context.length - 1];
          }
          nextToken() {
            this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.pos >= this.length ? this.finishToken(140) : this.getTokenFromCode(this.codePointAtPos(this.state.pos));
          }
          skipBlockComment(e3) {
            let t3;
            this.isLookahead || (t3 = this.state.curPosition());
            const r3 = this.state.pos, n2 = this.input.indexOf(e3, r3 + 2);
            if (-1 === n2) throw this.raise(c.UnterminatedComment, this.state.curPosition());
            for (this.state.pos = n2 + e3.length, W.lastIndex = r3 + 2; W.test(this.input) && W.lastIndex <= n2; ) ++this.state.curLine, this.state.lineStart = W.lastIndex;
            if (this.isLookahead) return;
            const s2 = { type: "CommentBlock", value: this.input.slice(r3 + 2, n2), start: this.sourceToOffsetPos(r3), end: this.sourceToOffsetPos(n2 + e3.length), loc: new SourceLocation(t3, this.state.curPosition()) };
            return 256 & this.optionFlags && this.pushToken(s2), s2;
          }
          skipLineComment(e3) {
            const t3 = this.state.pos;
            let r3;
            this.isLookahead || (r3 = this.state.curPosition());
            let n2 = this.input.charCodeAt(this.state.pos += e3);
            if (this.state.pos < this.length) for (; !isNewLine(n2) && ++this.state.pos < this.length; ) n2 = this.input.charCodeAt(this.state.pos);
            if (this.isLookahead) return;
            const s2 = this.state.pos, i2 = { type: "CommentLine", value: this.input.slice(t3 + e3, s2), start: this.sourceToOffsetPos(t3), end: this.sourceToOffsetPos(s2), loc: new SourceLocation(r3, this.state.curPosition()) };
            return 256 & this.optionFlags && this.pushToken(i2), i2;
          }
          skipSpace() {
            const e3 = this.state.pos, t3 = 4096 & this.optionFlags ? [] : null;
            e: for (; this.state.pos < this.length; ) {
              const r3 = this.input.charCodeAt(this.state.pos);
              switch (r3) {
                case 32:
                case 160:
                case 9:
                  ++this.state.pos;
                  break;
                case 13:
                  10 === this.input.charCodeAt(this.state.pos + 1) && ++this.state.pos;
                case 10:
                case 8232:
                case 8233:
                  ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
                  break;
                case 47:
                  switch (this.input.charCodeAt(this.state.pos + 1)) {
                    case 42: {
                      const e4 = this.skipBlockComment("*/");
                      void 0 !== e4 && (this.addComment(e4), null == t3 || t3.push(e4));
                      break;
                    }
                    case 47: {
                      const e4 = this.skipLineComment(2);
                      void 0 !== e4 && (this.addComment(e4), null == t3 || t3.push(e4));
                      break;
                    }
                    default:
                      break e;
                  }
                  break;
                default:
                  if (isWhitespace(r3)) ++this.state.pos;
                  else if (45 === r3 && !this.inModule && 8192 & this.optionFlags) {
                    const r4 = this.state.pos;
                    if (45 !== this.input.charCodeAt(r4 + 1) || 62 !== this.input.charCodeAt(r4 + 2) || !(0 === e3 || this.state.lineStart > e3)) break e;
                    {
                      const e4 = this.skipLineComment(3);
                      void 0 !== e4 && (this.addComment(e4), null == t3 || t3.push(e4));
                    }
                  } else {
                    if (60 !== r3 || this.inModule || !(8192 & this.optionFlags)) break e;
                    {
                      const e4 = this.state.pos;
                      if (33 !== this.input.charCodeAt(e4 + 1) || 45 !== this.input.charCodeAt(e4 + 2) || 45 !== this.input.charCodeAt(e4 + 3)) break e;
                      {
                        const e5 = this.skipLineComment(4);
                        void 0 !== e5 && (this.addComment(e5), null == t3 || t3.push(e5));
                      }
                    }
                  }
              }
            }
            if ((null == t3 ? void 0 : t3.length) > 0) {
              const r3 = this.state.pos, n2 = { start: this.sourceToOffsetPos(e3), end: this.sourceToOffsetPos(r3), comments: t3, leadingNode: null, trailingNode: null, containingNode: null };
              this.state.commentStack.push(n2);
            }
          }
          finishToken(e3, t3) {
            this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
            const r3 = this.state.type;
            this.state.type = e3, this.state.value = t3, this.isLookahead || this.updateContext(r3);
          }
          replaceToken(e3) {
            this.state.type = e3, this.updateContext();
          }
          readToken_numberSign() {
            if (0 === this.state.pos && this.readToken_interpreter()) return;
            const e3 = this.state.pos + 1, t3 = this.codePointAtPos(e3);
            if (t3 >= 48 && t3 <= 57) throw this.raise(c.UnexpectedDigitAfterHash, this.state.curPosition());
            if (123 === t3 || 91 === t3 && this.hasPlugin("recordAndTuple")) {
              if (this.expectPlugin("recordAndTuple"), "bar" === this.getPluginOption("recordAndTuple", "syntaxType")) throw this.raise(123 === t3 ? c.RecordExpressionHashIncorrectStartSyntaxType : c.TupleExpressionHashIncorrectStartSyntaxType, this.state.curPosition());
              this.state.pos += 2, 123 === t3 ? this.finishToken(7) : this.finishToken(1);
            } else isIdentifierStart(t3) ? (++this.state.pos, this.finishToken(139, this.readWord1(t3))) : 92 === t3 ? (++this.state.pos, this.finishToken(139, this.readWord1())) : this.finishOp(27, 1);
          }
          readToken_dot() {
            const e3 = this.input.charCodeAt(this.state.pos + 1);
            e3 >= 48 && e3 <= 57 ? this.readNumber(true) : 46 === e3 && 46 === this.input.charCodeAt(this.state.pos + 2) ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(16));
          }
          readToken_slash() {
            61 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(31, 2) : this.finishOp(56, 1);
          }
          readToken_interpreter() {
            if (0 !== this.state.pos || this.length < 2) return false;
            let e3 = this.input.charCodeAt(this.state.pos + 1);
            if (33 !== e3) return false;
            const t3 = this.state.pos;
            for (this.state.pos += 1; !isNewLine(e3) && ++this.state.pos < this.length; ) e3 = this.input.charCodeAt(this.state.pos);
            const r3 = this.input.slice(t3 + 2, this.state.pos);
            return this.finishToken(28, r3), true;
          }
          readToken_mult_modulo(e3) {
            let t3 = 42 === e3 ? 55 : 54, r3 = 1, n2 = this.input.charCodeAt(this.state.pos + 1);
            42 === e3 && 42 === n2 && (r3++, n2 = this.input.charCodeAt(this.state.pos + 2), t3 = 57), 61 !== n2 || this.state.inType || (r3++, t3 = 37 === e3 ? 33 : 30), this.finishOp(t3, r3);
          }
          readToken_pipe_amp(e3) {
            const t3 = this.input.charCodeAt(this.state.pos + 1);
            if (t3 !== e3) {
              if (124 === e3) {
                if (62 === t3) return void this.finishOp(39, 2);
                if (this.hasPlugin("recordAndTuple") && 125 === t3) {
                  if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType")) throw this.raise(c.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
                  return this.state.pos += 2, void this.finishToken(9);
                }
                if (this.hasPlugin("recordAndTuple") && 93 === t3) {
                  if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType")) throw this.raise(c.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
                  return this.state.pos += 2, void this.finishToken(4);
                }
              }
              61 !== t3 ? this.finishOp(124 === e3 ? 43 : 45, 1) : this.finishOp(30, 2);
            } else 61 === this.input.charCodeAt(this.state.pos + 2) ? this.finishOp(30, 3) : this.finishOp(124 === e3 ? 41 : 42, 2);
          }
          readToken_caret() {
            const e3 = this.input.charCodeAt(this.state.pos + 1);
            if (61 !== e3 || this.state.inType) if (94 === e3 && this.hasPlugin(["pipelineOperator", { proposal: "hack", topicToken: "^^" }])) {
              this.finishOp(37, 2);
              94 === this.input.codePointAt(this.state.pos) && this.unexpected();
            } else this.finishOp(44, 1);
            else this.finishOp(32, 2);
          }
          readToken_atSign() {
            64 === this.input.charCodeAt(this.state.pos + 1) && this.hasPlugin(["pipelineOperator", { proposal: "hack", topicToken: "@@" }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
          }
          readToken_plus_min(e3) {
            const t3 = this.input.charCodeAt(this.state.pos + 1);
            t3 !== e3 ? 61 === t3 ? this.finishOp(30, 2) : this.finishOp(53, 1) : this.finishOp(34, 2);
          }
          readToken_lt() {
            const { pos: e3 } = this.state, t3 = this.input.charCodeAt(e3 + 1);
            if (60 === t3) return 61 === this.input.charCodeAt(e3 + 2) ? void this.finishOp(30, 3) : void this.finishOp(51, 2);
            61 !== t3 ? this.finishOp(47, 1) : this.finishOp(49, 2);
          }
          readToken_gt() {
            const { pos: e3 } = this.state, t3 = this.input.charCodeAt(e3 + 1);
            if (62 === t3) {
              const t4 = 62 === this.input.charCodeAt(e3 + 2) ? 3 : 2;
              return 61 === this.input.charCodeAt(e3 + t4) ? void this.finishOp(30, t4 + 1) : void this.finishOp(52, t4);
            }
            61 !== t3 ? this.finishOp(48, 1) : this.finishOp(49, 2);
          }
          readToken_eq_excl(e3) {
            const t3 = this.input.charCodeAt(this.state.pos + 1);
            if (61 !== t3) return 61 === e3 && 62 === t3 ? (this.state.pos += 2, void this.finishToken(19)) : void this.finishOp(61 === e3 ? 29 : 35, 1);
            this.finishOp(46, 61 === this.input.charCodeAt(this.state.pos + 2) ? 3 : 2);
          }
          readToken_question() {
            const e3 = this.input.charCodeAt(this.state.pos + 1), t3 = this.input.charCodeAt(this.state.pos + 2);
            63 === e3 ? 61 === t3 ? this.finishOp(30, 3) : this.finishOp(40, 2) : 46 !== e3 || t3 >= 48 && t3 <= 57 ? (++this.state.pos, this.finishToken(17)) : (this.state.pos += 2, this.finishToken(18));
          }
          getTokenFromCode(e3) {
            switch (e3) {
              case 46:
                return void this.readToken_dot();
              case 40:
                return ++this.state.pos, void this.finishToken(10);
              case 41:
                return ++this.state.pos, void this.finishToken(11);
              case 59:
                return ++this.state.pos, void this.finishToken(13);
              case 44:
                return ++this.state.pos, void this.finishToken(12);
              case 91:
                if (this.hasPlugin("recordAndTuple") && 124 === this.input.charCodeAt(this.state.pos + 1)) {
                  if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType")) throw this.raise(c.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
                  this.state.pos += 2, this.finishToken(2);
                } else ++this.state.pos, this.finishToken(0);
                return;
              case 93:
                return ++this.state.pos, void this.finishToken(3);
              case 123:
                if (this.hasPlugin("recordAndTuple") && 124 === this.input.charCodeAt(this.state.pos + 1)) {
                  if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType")) throw this.raise(c.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
                  this.state.pos += 2, this.finishToken(6);
                } else ++this.state.pos, this.finishToken(5);
                return;
              case 125:
                return ++this.state.pos, void this.finishToken(8);
              case 58:
                return void (this.hasPlugin("functionBind") && 58 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(15, 2) : (++this.state.pos, this.finishToken(14)));
              case 63:
                return void this.readToken_question();
              case 96:
                return void this.readTemplateToken();
              case 48: {
                const e4 = this.input.charCodeAt(this.state.pos + 1);
                if (120 === e4 || 88 === e4) return void this.readRadixNumber(16);
                if (111 === e4 || 79 === e4) return void this.readRadixNumber(8);
                if (98 === e4 || 66 === e4) return void this.readRadixNumber(2);
              }
              case 49:
              case 50:
              case 51:
              case 52:
              case 53:
              case 54:
              case 55:
              case 56:
              case 57:
                return void this.readNumber(false);
              case 34:
              case 39:
                return void this.readString(e3);
              case 47:
                return void this.readToken_slash();
              case 37:
              case 42:
                return void this.readToken_mult_modulo(e3);
              case 124:
              case 38:
                return void this.readToken_pipe_amp(e3);
              case 94:
                return void this.readToken_caret();
              case 43:
              case 45:
                return void this.readToken_plus_min(e3);
              case 60:
                return void this.readToken_lt();
              case 62:
                return void this.readToken_gt();
              case 61:
              case 33:
                return void this.readToken_eq_excl(e3);
              case 126:
                return void this.finishOp(36, 1);
              case 64:
                return void this.readToken_atSign();
              case 35:
                return void this.readToken_numberSign();
              case 92:
                return void this.readWord();
              default:
                if (isIdentifierStart(e3)) return void this.readWord(e3);
            }
            throw this.raise(c.InvalidOrUnexpectedToken, this.state.curPosition(), { unexpected: String.fromCodePoint(e3) });
          }
          finishOp(e3, t3) {
            const r3 = this.input.slice(this.state.pos, this.state.pos + t3);
            this.state.pos += t3, this.finishToken(e3, r3);
          }
          readRegexp() {
            const e3 = this.state.startLoc, t3 = this.state.start + 1;
            let r3, n2, { pos: s2 } = this.state;
            for (; ; ++s2) {
              if (s2 >= this.length) throw this.raise(c.UnterminatedRegExp, createPositionWithColumnOffset(e3, 1));
              const t4 = this.input.charCodeAt(s2);
              if (isNewLine(t4)) throw this.raise(c.UnterminatedRegExp, createPositionWithColumnOffset(e3, 1));
              if (r3) r3 = false;
              else {
                if (91 === t4) n2 = true;
                else if (93 === t4 && n2) n2 = false;
                else if (47 === t4 && !n2) break;
                r3 = 92 === t4;
              }
            }
            const i2 = this.input.slice(t3, s2);
            ++s2;
            let o2 = "";
            const nextPos = () => createPositionWithColumnOffset(e3, s2 + 2 - t3);
            for (; s2 < this.length; ) {
              const e4 = this.codePointAtPos(s2), t4 = String.fromCharCode(e4);
              if (J.has(e4)) 118 === e4 ? o2.includes("u") && this.raise(c.IncompatibleRegExpUVFlags, nextPos()) : 117 === e4 && o2.includes("v") && this.raise(c.IncompatibleRegExpUVFlags, nextPos()), o2.includes(t4) && this.raise(c.DuplicateRegExpFlags, nextPos());
              else {
                if (!isIdentifierChar(e4) && 92 !== e4) break;
                this.raise(c.MalformedRegExpFlags, nextPos());
              }
              ++s2, o2 += t4;
            }
            this.state.pos = s2, this.finishToken(138, { pattern: i2, flags: o2 });
          }
          readInt(e3, t3, r3 = false, n2 = true) {
            const { n: s2, pos: i2 } = readInt(this.input, this.state.pos, this.state.lineStart, this.state.curLine, e3, t3, r3, n2, this.errorHandlers_readInt, false);
            return this.state.pos = i2, s2;
          }
          readRadixNumber(e3) {
            const t3 = this.state.pos, r3 = this.state.curPosition();
            let n2 = false;
            this.state.pos += 2;
            const s2 = this.readInt(e3);
            null == s2 && this.raise(c.InvalidDigit, createPositionWithColumnOffset(r3, 2), { radix: e3 });
            const i2 = this.input.charCodeAt(this.state.pos);
            if (110 === i2) ++this.state.pos, n2 = true;
            else if (109 === i2) throw this.raise(c.InvalidDecimal, r3);
            if (isIdentifierStart(this.codePointAtPos(this.state.pos))) throw this.raise(c.NumberIdentifier, this.state.curPosition());
            if (n2) {
              const e4 = this.input.slice(t3, this.state.pos).replace(/[_n]/g, "");
              return void this.finishToken(136, e4);
            }
            this.finishToken(135, s2);
          }
          readNumber(e3) {
            const t3 = this.state.pos, r3 = this.state.curPosition();
            let n2 = false, s2 = false, i2 = false, o2 = false;
            e3 || null !== this.readInt(10) || this.raise(c.InvalidNumber, this.state.curPosition());
            const a2 = this.state.pos - t3 >= 2 && 48 === this.input.charCodeAt(t3);
            if (a2) {
              const e4 = this.input.slice(t3, this.state.pos);
              if (this.recordStrictModeErrors(c.StrictOctalLiteral, r3), !this.state.strict) {
                const t4 = e4.indexOf("_");
                t4 > 0 && this.raise(c.ZeroDigitNumericSeparator, createPositionWithColumnOffset(r3, t4));
              }
              o2 = a2 && !/[89]/.test(e4);
            }
            let l2 = this.input.charCodeAt(this.state.pos);
            if (46 !== l2 || o2 || (++this.state.pos, this.readInt(10), n2 = true, l2 = this.input.charCodeAt(this.state.pos)), 69 !== l2 && 101 !== l2 || o2 || (l2 = this.input.charCodeAt(++this.state.pos), 43 !== l2 && 45 !== l2 || ++this.state.pos, null === this.readInt(10) && this.raise(c.InvalidOrMissingExponent, r3), n2 = true, i2 = true, l2 = this.input.charCodeAt(this.state.pos)), 110 === l2 && ((n2 || a2) && this.raise(c.InvalidBigIntLiteral, r3), ++this.state.pos, s2 = true), 109 === l2) {
              this.expectPlugin("decimal", this.state.curPosition()), (i2 || a2) && this.raise(c.InvalidDecimal, r3), ++this.state.pos;
              var p2 = true;
            }
            if (isIdentifierStart(this.codePointAtPos(this.state.pos))) throw this.raise(c.NumberIdentifier, this.state.curPosition());
            const u2 = this.input.slice(t3, this.state.pos).replace(/[_mn]/g, "");
            if (s2) return void this.finishToken(136, u2);
            if (p2) return void this.finishToken(137, u2);
            const d2 = o2 ? parseInt(u2, 8) : parseFloat(u2);
            this.finishToken(135, d2);
          }
          readCodePoint(e3) {
            const { code: t3, pos: r3 } = readCodePoint(this.input, this.state.pos, this.state.lineStart, this.state.curLine, e3, this.errorHandlers_readCodePoint);
            return this.state.pos = r3, t3;
          }
          readString(e3) {
            const { str: t3, pos: r3, curLine: n2, lineStart: s2 } = readStringContents(34 === e3 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
            this.state.pos = r3 + 1, this.state.lineStart = s2, this.state.curLine = n2, this.finishToken(134, t3);
          }
          readTemplateContinuation() {
            this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
          }
          readTemplateToken() {
            const e3 = this.input[this.state.pos], { str: t3, firstInvalidLoc: r3, pos: n2, curLine: s2, lineStart: i2 } = readStringContents("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
            this.state.pos = n2 + 1, this.state.lineStart = i2, this.state.curLine = s2, r3 && (this.state.firstInvalidTemplateEscapePos = new Position(r3.curLine, r3.pos - r3.lineStart, this.sourceToOffsetPos(r3.pos))), 96 === this.input.codePointAt(n2) ? this.finishToken(24, r3 ? null : e3 + t3 + "`") : (this.state.pos++, this.finishToken(25, r3 ? null : e3 + t3 + "${"));
          }
          recordStrictModeErrors(e3, t3) {
            const r3 = t3.index;
            this.state.strict && !this.state.strictErrors.has(r3) ? this.raise(e3, t3) : this.state.strictErrors.set(r3, [e3, t3]);
          }
          readWord1(e3) {
            this.state.containsEsc = false;
            let t3 = "";
            const r3 = this.state.pos;
            let n2 = this.state.pos;
            for (void 0 !== e3 && (this.state.pos += e3 <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
              const e4 = this.codePointAtPos(this.state.pos);
              if (isIdentifierChar(e4)) this.state.pos += e4 <= 65535 ? 1 : 2;
              else {
                if (92 !== e4) break;
                {
                  this.state.containsEsc = true, t3 += this.input.slice(n2, this.state.pos);
                  const e5 = this.state.curPosition(), s2 = this.state.pos === r3 ? isIdentifierStart : isIdentifierChar;
                  if (117 !== this.input.charCodeAt(++this.state.pos)) {
                    this.raise(c.MissingUnicodeEscape, this.state.curPosition()), n2 = this.state.pos - 1;
                    continue;
                  }
                  ++this.state.pos;
                  const i2 = this.readCodePoint(true);
                  null !== i2 && (s2(i2) || this.raise(c.EscapedCharNotAnIdentifier, e5), t3 += String.fromCodePoint(i2)), n2 = this.state.pos;
                }
              }
            }
            return t3 + this.input.slice(n2, this.state.pos);
          }
          readWord(e3) {
            const t3 = this.readWord1(e3), r3 = g.get(t3);
            void 0 !== r3 ? this.finishToken(r3, tokenLabelName(r3)) : this.finishToken(132, t3);
          }
          checkKeywordEscapes() {
            const { type: e3 } = this.state;
            tokenIsKeyword(e3) && this.state.containsEsc && this.raise(c.InvalidEscapedReservedWord, this.state.startLoc, { reservedWord: tokenLabelName(e3) });
          }
          raise(e3, t3, r3 = {}) {
            const n2 = e3(t3 instanceof Position ? t3 : t3.loc.start, r3);
            if (!(2048 & this.optionFlags)) throw n2;
            return this.isLookahead || this.state.errors.push(n2), n2;
          }
          raiseOverwrite(e3, t3, r3 = {}) {
            const n2 = t3 instanceof Position ? t3 : t3.loc.start, s2 = n2.index, i2 = this.state.errors;
            for (let t4 = i2.length - 1; t4 >= 0; t4--) {
              const o2 = i2[t4];
              if (o2.loc.index === s2) return i2[t4] = e3(n2, r3);
              if (o2.loc.index < s2) break;
            }
            return this.raise(e3, t3, r3);
          }
          updateContext(e3) {
          }
          unexpected(e3, t3) {
            throw this.raise(c.UnexpectedToken, null != e3 ? e3 : this.state.startLoc, { expected: t3 ? tokenLabelName(t3) : null });
          }
          expectPlugin(e3, t3) {
            if (this.hasPlugin(e3)) return true;
            throw this.raise(c.MissingPlugin, null != t3 ? t3 : this.state.startLoc, { missingPlugin: [e3] });
          }
          expectOnePlugin(e3) {
            if (!e3.some((e4) => this.hasPlugin(e4))) throw this.raise(c.MissingOneOfPlugins, this.state.startLoc, { missingPlugin: e3 });
          }
          errorBuilder(e3) {
            return (t3, r3, n2) => {
              this.raise(e3, buildPosition(t3, r3, n2));
            };
          }
        }
        class ClassScope {
          constructor() {
            this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
          }
        }
        class ClassScopeHandler {
          constructor(e3) {
            this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = e3;
          }
          current() {
            return this.stack[this.stack.length - 1];
          }
          enter() {
            this.stack.push(new ClassScope());
          }
          exit() {
            const e3 = this.stack.pop(), t3 = this.current();
            for (const [r3, n2] of Array.from(e3.undefinedPrivateNames)) t3 ? t3.undefinedPrivateNames.has(r3) || t3.undefinedPrivateNames.set(r3, n2) : this.parser.raise(c.InvalidPrivateFieldResolution, n2, { identifierName: r3 });
          }
          declarePrivateName(e3, t3, r3) {
            const { privateNames: n2, loneAccessors: s2, undefinedPrivateNames: i2 } = this.current();
            let o2 = n2.has(e3);
            if (3 & t3) {
              const r4 = o2 && s2.get(e3);
              if (r4) {
                o2 = (3 & r4) === (3 & t3) || (4 & r4) !== (4 & t3), o2 || s2.delete(e3);
              } else o2 || s2.set(e3, t3);
            }
            o2 && this.parser.raise(c.PrivateNameRedeclaration, r3, { identifierName: e3 }), n2.add(e3), i2.delete(e3);
          }
          usePrivateName(e3, t3) {
            let r3;
            for (r3 of this.stack) if (r3.privateNames.has(e3)) return;
            r3 ? r3.undefinedPrivateNames.set(e3, t3) : this.parser.raise(c.InvalidPrivateFieldResolution, t3, { identifierName: e3 });
          }
        }
        class ExpressionScope {
          constructor(e3 = 0) {
            this.type = e3;
          }
          canBeArrowParameterDeclaration() {
            return 2 === this.type || 1 === this.type;
          }
          isCertainlyParameterDeclaration() {
            return 3 === this.type;
          }
        }
        class ArrowHeadParsingScope extends ExpressionScope {
          constructor(e3) {
            super(e3), this.declarationErrors = /* @__PURE__ */ new Map();
          }
          recordDeclarationError(e3, t3) {
            const r3 = t3.index;
            this.declarationErrors.set(r3, [e3, t3]);
          }
          clearDeclarationError(e3) {
            this.declarationErrors.delete(e3);
          }
          iterateErrors(e3) {
            this.declarationErrors.forEach(e3);
          }
        }
        class ExpressionScopeHandler {
          constructor(e3) {
            this.parser = void 0, this.stack = [new ExpressionScope()], this.parser = e3;
          }
          enter(e3) {
            this.stack.push(e3);
          }
          exit() {
            this.stack.pop();
          }
          recordParameterInitializerError(e3, t3) {
            const r3 = t3.loc.start, { stack: n2 } = this;
            let s2 = n2.length - 1, i2 = n2[s2];
            for (; !i2.isCertainlyParameterDeclaration(); ) {
              if (!i2.canBeArrowParameterDeclaration()) return;
              i2.recordDeclarationError(e3, r3), i2 = n2[--s2];
            }
            this.parser.raise(e3, r3);
          }
          recordArrowParameterBindingError(e3, t3) {
            const { stack: r3 } = this, n2 = r3[r3.length - 1], s2 = t3.loc.start;
            if (n2.isCertainlyParameterDeclaration()) this.parser.raise(e3, s2);
            else {
              if (!n2.canBeArrowParameterDeclaration()) return;
              n2.recordDeclarationError(e3, s2);
            }
          }
          recordAsyncArrowParametersError(e3) {
            const { stack: t3 } = this;
            let r3 = t3.length - 1, n2 = t3[r3];
            for (; n2.canBeArrowParameterDeclaration(); ) 2 === n2.type && n2.recordDeclarationError(c.AwaitBindingIdentifier, e3), n2 = t3[--r3];
          }
          validateAsPattern() {
            const { stack: e3 } = this, t3 = e3[e3.length - 1];
            t3.canBeArrowParameterDeclaration() && t3.iterateErrors(([t4, r3]) => {
              this.parser.raise(t4, r3);
              let n2 = e3.length - 2, s2 = e3[n2];
              for (; s2.canBeArrowParameterDeclaration(); ) s2.clearDeclarationError(r3.index), s2 = e3[--n2];
            });
          }
        }
        function newExpressionScope() {
          return new ExpressionScope();
        }
        class UtilParser extends Tokenizer {
          addExtra(e3, t3, r3, n2 = true) {
            if (!e3) return;
            let { extra: s2 } = e3;
            null == s2 && (s2 = {}, e3.extra = s2), n2 ? s2[t3] = r3 : Object.defineProperty(s2, t3, { enumerable: n2, value: r3 });
          }
          isContextual(e3) {
            return this.state.type === e3 && !this.state.containsEsc;
          }
          isUnparsedContextual(e3, t3) {
            if (this.input.startsWith(t3, e3)) {
              const r3 = this.input.charCodeAt(e3 + t3.length);
              return !(isIdentifierChar(r3) || 55296 == (64512 & r3));
            }
            return false;
          }
          isLookaheadContextual(e3) {
            const t3 = this.nextTokenStart();
            return this.isUnparsedContextual(t3, e3);
          }
          eatContextual(e3) {
            return !!this.isContextual(e3) && (this.next(), true);
          }
          expectContextual(e3, t3) {
            if (!this.eatContextual(e3)) {
              if (null != t3) throw this.raise(t3, this.state.startLoc);
              this.unexpected(null, e3);
            }
          }
          canInsertSemicolon() {
            return this.match(140) || this.match(8) || this.hasPrecedingLineBreak();
          }
          hasPrecedingLineBreak() {
            return hasNewLine(this.input, this.offsetToSourcePos(this.state.lastTokEndLoc.index), this.state.start);
          }
          hasFollowingLineBreak() {
            return hasNewLine(this.input, this.state.end, this.nextTokenStart());
          }
          isLineTerminator() {
            return this.eat(13) || this.canInsertSemicolon();
          }
          semicolon(e3 = true) {
            (e3 ? this.isLineTerminator() : this.eat(13)) || this.raise(c.MissingSemicolon, this.state.lastTokEndLoc);
          }
          expect(e3, t3) {
            this.eat(e3) || this.unexpected(t3, e3);
          }
          tryParse(e3, t3 = this.state.clone()) {
            const r3 = { node: null };
            try {
              const n2 = e3((e4 = null) => {
                throw r3.node = e4, r3;
              });
              if (this.state.errors.length > t3.errors.length) {
                const e4 = this.state;
                return this.state = t3, this.state.tokensLength = e4.tokensLength, { node: n2, error: e4.errors[t3.errors.length], thrown: false, aborted: false, failState: e4 };
              }
              return { node: n2, error: null, thrown: false, aborted: false, failState: null };
            } catch (e4) {
              const n2 = this.state;
              if (this.state = t3, e4 instanceof SyntaxError) return { node: null, error: e4, thrown: true, aborted: false, failState: n2 };
              if (e4 === r3) return { node: r3.node, error: null, thrown: false, aborted: true, failState: n2 };
              throw e4;
            }
          }
          checkExpressionErrors(e3, t3) {
            if (!e3) return false;
            const { shorthandAssignLoc: r3, doubleProtoLoc: n2, privateKeyLoc: s2, optionalParametersLoc: i2, voidPatternLoc: o2 } = e3;
            if (!t3) return !!(r3 || n2 || i2 || s2 || o2);
            null != r3 && this.raise(c.InvalidCoverInitializedName, r3), null != n2 && this.raise(c.DuplicateProto, n2), null != s2 && this.raise(c.UnexpectedPrivateField, s2), null != i2 && this.unexpected(i2), null != o2 && this.raise(c.InvalidCoverDiscardElement, o2);
          }
          isLiteralPropertyName() {
            return tokenIsLiteralPropertyName(this.state.type);
          }
          isPrivateName(e3) {
            return "PrivateName" === e3.type;
          }
          getPrivateNameSV(e3) {
            return e3.id.name;
          }
          hasPropertyAsPrivateName(e3) {
            return ("MemberExpression" === e3.type || "OptionalMemberExpression" === e3.type) && this.isPrivateName(e3.property);
          }
          isObjectProperty(e3) {
            return "ObjectProperty" === e3.type;
          }
          isObjectMethod(e3) {
            return "ObjectMethod" === e3.type;
          }
          initializeScopes(e3 = "module" === this.options.sourceType) {
            const t3 = this.state.labels;
            this.state.labels = [];
            const r3 = this.exportedIdentifiers;
            this.exportedIdentifiers = /* @__PURE__ */ new Set();
            const n2 = this.inModule;
            this.inModule = e3;
            const s2 = this.scope, i2 = this.getScopeHandler();
            this.scope = new i2(this, e3);
            const o2 = this.prodParam;
            this.prodParam = new ProductionParameterHandler();
            const a2 = this.classScope;
            this.classScope = new ClassScopeHandler(this);
            const l2 = this.expressionScope;
            return this.expressionScope = new ExpressionScopeHandler(this), () => {
              this.state.labels = t3, this.exportedIdentifiers = r3, this.inModule = n2, this.scope = s2, this.prodParam = o2, this.classScope = a2, this.expressionScope = l2;
            };
          }
          enterInitialScopes() {
            let e3 = 0;
            (this.inModule || 1 & this.optionFlags) && (e3 |= 2), 32 & this.optionFlags && (e3 |= 1);
            const t3 = !this.inModule && "commonjs" === this.options.sourceType;
            (t3 || 2 & this.optionFlags) && (e3 |= 4), this.prodParam.enter(e3);
            let r3 = t3 ? 514 : 1;
            4 & this.optionFlags && (r3 |= 512), this.scope.enter(r3);
          }
          checkDestructuringPrivate(e3) {
            const { privateKeyLoc: t3 } = e3;
            null !== t3 && this.expectPlugin("destructuringPrivate", t3);
          }
        }
        class ExpressionErrors {
          constructor() {
            this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null, this.voidPatternLoc = null;
          }
        }
        class Node {
          constructor(e3, t3, r3) {
            this.type = "", this.start = t3, this.end = 0, this.loc = new SourceLocation(r3), 128 & (null == e3 ? void 0 : e3.optionFlags) && (this.range = [t3, 0]), null != e3 && e3.filename && (this.loc.filename = e3.filename);
          }
        }
        const Y = Node.prototype;
        Y.__clone = function() {
          const e3 = new Node(void 0, this.start, this.loc.start), t3 = Object.keys(this);
          for (let r3 = 0, n2 = t3.length; r3 < n2; r3++) {
            const n3 = t3[r3];
            "leadingComments" !== n3 && "trailingComments" !== n3 && "innerComments" !== n3 && (e3[n3] = this[n3]);
          }
          return e3;
        };
        class NodeUtils extends UtilParser {
          startNode() {
            const e3 = this.state.startLoc;
            return new Node(this, e3.index, e3);
          }
          startNodeAt(e3) {
            return new Node(this, e3.index, e3);
          }
          startNodeAtNode(e3) {
            return this.startNodeAt(e3.loc.start);
          }
          finishNode(e3, t3) {
            return this.finishNodeAt(e3, t3, this.state.lastTokEndLoc);
          }
          finishNodeAt(e3, t3, r3) {
            return e3.type = t3, e3.end = r3.index, e3.loc.end = r3, 128 & this.optionFlags && (e3.range[1] = r3.index), 4096 & this.optionFlags && this.processComment(e3), e3;
          }
          resetStartLocation(e3, t3) {
            e3.start = t3.index, e3.loc.start = t3, 128 & this.optionFlags && (e3.range[0] = t3.index);
          }
          resetEndLocation(e3, t3 = this.state.lastTokEndLoc) {
            e3.end = t3.index, e3.loc.end = t3, 128 & this.optionFlags && (e3.range[1] = t3.index);
          }
          resetStartLocationFromNode(e3, t3) {
            this.resetStartLocation(e3, t3.loc.start);
          }
          castNodeTo(e3, t3) {
            return e3.type = t3, e3;
          }
          cloneIdentifier(e3) {
            const { type: t3, start: r3, end: n2, loc: s2, range: i2, name: o2 } = e3, a2 = Object.create(Y);
            return a2.type = t3, a2.start = r3, a2.end = n2, a2.loc = s2, a2.range = i2, a2.name = o2, e3.extra && (a2.extra = e3.extra), a2;
          }
          cloneStringLiteral(e3) {
            const { type: t3, start: r3, end: n2, loc: s2, range: i2, extra: o2 } = e3, a2 = Object.create(Y);
            return a2.type = t3, a2.start = r3, a2.end = n2, a2.loc = s2, a2.range = i2, a2.extra = o2, a2.value = e3.value, a2;
          }
        }
        const unwrapParenthesizedExpression = (e3) => "ParenthesizedExpression" === e3.type ? unwrapParenthesizedExpression(e3.expression) : e3;
        class LValParser extends NodeUtils {
          toAssignable(e3, t3 = false) {
            var r3, n2;
            let s2;
            switch (("ParenthesizedExpression" === e3.type || null != (r3 = e3.extra) && r3.parenthesized) && (s2 = unwrapParenthesizedExpression(e3), t3 ? "Identifier" === s2.type ? this.expressionScope.recordArrowParameterBindingError(c.InvalidParenthesizedAssignment, e3) : "MemberExpression" === s2.type || this.isOptionalMemberExpression(s2) || this.raise(c.InvalidParenthesizedAssignment, e3) : this.raise(c.InvalidParenthesizedAssignment, e3)), e3.type) {
              case "Identifier":
              case "ObjectPattern":
              case "ArrayPattern":
              case "AssignmentPattern":
              case "RestElement":
              case "VoidPattern":
                break;
              case "ObjectExpression":
                this.castNodeTo(e3, "ObjectPattern");
                for (let r4 = 0, n3 = e3.properties.length, s3 = n3 - 1; r4 < n3; r4++) {
                  var i2;
                  const n4 = e3.properties[r4], o2 = r4 === s3;
                  this.toAssignableObjectExpressionProp(n4, o2, t3), o2 && "RestElement" === n4.type && null != (i2 = e3.extra) && i2.trailingCommaLoc && this.raise(c.RestTrailingComma, e3.extra.trailingCommaLoc);
                }
                break;
              case "ObjectProperty": {
                const { key: r4, value: n3 } = e3;
                this.isPrivateName(r4) && this.classScope.usePrivateName(this.getPrivateNameSV(r4), r4.loc.start), this.toAssignable(n3, t3);
                break;
              }
              case "SpreadElement":
                throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
              case "ArrayExpression":
                this.castNodeTo(e3, "ArrayPattern"), this.toAssignableList(e3.elements, null == (n2 = e3.extra) ? void 0 : n2.trailingCommaLoc, t3);
                break;
              case "AssignmentExpression":
                "=" !== e3.operator && this.raise(c.MissingEqInAssignment, e3.left.loc.end), this.castNodeTo(e3, "AssignmentPattern"), delete e3.operator, "VoidPattern" === e3.left.type && this.raise(c.VoidPatternInitializer, e3.left), this.toAssignable(e3.left, t3);
                break;
              case "ParenthesizedExpression":
                this.toAssignable(s2, t3);
            }
          }
          toAssignableObjectExpressionProp(e3, t3, r3) {
            if ("ObjectMethod" === e3.type) this.raise("get" === e3.kind || "set" === e3.kind ? c.PatternHasAccessor : c.PatternHasMethod, e3.key);
            else if ("SpreadElement" === e3.type) {
              this.castNodeTo(e3, "RestElement");
              const n2 = e3.argument;
              this.checkToRestConversion(n2, false), this.toAssignable(n2, r3), t3 || this.raise(c.RestTrailingComma, e3);
            } else this.toAssignable(e3, r3);
          }
          toAssignableList(e3, t3, r3) {
            const n2 = e3.length - 1;
            for (let s2 = 0; s2 <= n2; s2++) {
              const i2 = e3[s2];
              i2 && (this.toAssignableListItem(e3, s2, r3), "RestElement" === i2.type && (s2 < n2 ? this.raise(c.RestTrailingComma, i2) : t3 && this.raise(c.RestTrailingComma, t3)));
            }
          }
          toAssignableListItem(e3, t3, r3) {
            const n2 = e3[t3];
            if ("SpreadElement" === n2.type) {
              this.castNodeTo(n2, "RestElement");
              const e4 = n2.argument;
              this.checkToRestConversion(e4, true), this.toAssignable(e4, r3);
            } else this.toAssignable(n2, r3);
          }
          isAssignable(e3, t3) {
            switch (e3.type) {
              case "Identifier":
              case "ObjectPattern":
              case "ArrayPattern":
              case "AssignmentPattern":
              case "RestElement":
              case "VoidPattern":
                return true;
              case "ObjectExpression": {
                const t4 = e3.properties.length - 1;
                return e3.properties.every((e4, r3) => "ObjectMethod" !== e4.type && (r3 === t4 || "SpreadElement" !== e4.type) && this.isAssignable(e4));
              }
              case "ObjectProperty":
                return this.isAssignable(e3.value);
              case "SpreadElement":
                return this.isAssignable(e3.argument);
              case "ArrayExpression":
                return e3.elements.every((e4) => null === e4 || this.isAssignable(e4));
              case "AssignmentExpression":
                return "=" === e3.operator;
              case "ParenthesizedExpression":
                return this.isAssignable(e3.expression);
              case "MemberExpression":
              case "OptionalMemberExpression":
                return !t3;
              default:
                return false;
            }
          }
          toReferencedList(e3, t3) {
            return e3;
          }
          toReferencedListDeep(e3, t3) {
            this.toReferencedList(e3, t3);
            for (const t4 of e3) "ArrayExpression" === (null == t4 ? void 0 : t4.type) && this.toReferencedListDeep(t4.elements);
          }
          parseSpread(e3) {
            const t3 = this.startNode();
            return this.next(), t3.argument = this.parseMaybeAssignAllowIn(e3, void 0), this.finishNode(t3, "SpreadElement");
          }
          parseRestBinding() {
            const e3 = this.startNode();
            this.next();
            const t3 = this.parseBindingAtom();
            return "VoidPattern" === t3.type && this.raise(c.UnexpectedVoidPattern, t3), e3.argument = t3, this.finishNode(e3, "RestElement");
          }
          parseBindingAtom() {
            switch (this.state.type) {
              case 0: {
                const e3 = this.startNode();
                return this.next(), e3.elements = this.parseBindingList(3, 93, 1), this.finishNode(e3, "ArrayPattern");
              }
              case 5:
                return this.parseObjectLike(8, true);
              case 88:
                return this.parseVoidPattern(null);
            }
            return this.parseIdentifier();
          }
          parseBindingList(e3, t3, r3) {
            const n2 = 1 & r3, s2 = [];
            let i2 = true;
            for (; !this.eat(e3); ) if (i2 ? i2 = false : this.expect(12), n2 && this.match(12)) s2.push(null);
            else {
              if (this.eat(e3)) break;
              if (this.match(21)) {
                let n3 = this.parseRestBinding();
                if ((this.hasPlugin("flow") || 2 & r3) && (n3 = this.parseFunctionParamType(n3)), s2.push(n3), !this.checkCommaAfterRest(t3)) {
                  this.expect(e3);
                  break;
                }
              } else {
                const e4 = [];
                if (2 & r3) for (this.match(26) && this.hasPlugin("decorators") && this.raise(c.UnsupportedParameterDecorator, this.state.startLoc); this.match(26); ) e4.push(this.parseDecorator());
                s2.push(this.parseBindingElement(r3, e4));
              }
            }
            return s2;
          }
          parseBindingRestProperty(e3) {
            return this.next(), this.hasPlugin("discardBinding") && this.match(88) ? (e3.argument = this.parseVoidPattern(null), this.raise(c.UnexpectedVoidPattern, e3.argument)) : e3.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(e3, "RestElement");
          }
          parseBindingProperty() {
            const { type: e3, startLoc: t3 } = this.state;
            if (21 === e3) return this.parseBindingRestProperty(this.startNode());
            const r3 = this.startNode();
            return 139 === e3 ? (this.expectPlugin("destructuringPrivate", t3), this.classScope.usePrivateName(this.state.value, t3), r3.key = this.parsePrivateName()) : this.parsePropertyName(r3), r3.method = false, this.parseObjPropValue(r3, t3, false, false, true, false);
          }
          parseBindingElement(e3, t3) {
            const r3 = this.parseMaybeDefault();
            (this.hasPlugin("flow") || 2 & e3) && this.parseFunctionParamType(r3), t3.length && (r3.decorators = t3, this.resetStartLocationFromNode(r3, t3[0]));
            return this.parseMaybeDefault(r3.loc.start, r3);
          }
          parseFunctionParamType(e3) {
            return e3;
          }
          parseMaybeDefault(e3, t3) {
            if (null != e3 || (e3 = this.state.startLoc), t3 = null != t3 ? t3 : this.parseBindingAtom(), !this.eat(29)) return t3;
            const r3 = this.startNodeAt(e3);
            return "VoidPattern" === t3.type && this.raise(c.VoidPatternInitializer, t3), r3.left = t3, r3.right = this.parseMaybeAssignAllowIn(), this.finishNode(r3, "AssignmentPattern");
          }
          isValidLVal(e3, t3, r3) {
            switch (e3) {
              case "AssignmentPattern":
                return "left";
              case "RestElement":
                return "argument";
              case "ObjectProperty":
                return "value";
              case "ParenthesizedExpression":
                return "expression";
              case "ArrayPattern":
                return "elements";
              case "ObjectPattern":
                return "properties";
              case "VoidPattern":
                return true;
            }
            return false;
          }
          isOptionalMemberExpression(e3) {
            return "OptionalMemberExpression" === e3.type;
          }
          checkLVal(e3, t3, r3 = 64, n2 = false, s2 = false, i2 = false) {
            var o2;
            const a2 = e3.type;
            if (this.isObjectMethod(e3)) return;
            const l2 = this.isOptionalMemberExpression(e3);
            if (l2 || "MemberExpression" === a2) return l2 && (this.expectPlugin("optionalChainingAssign", e3.loc.start), "AssignmentExpression" !== t3.type && this.raise(c.InvalidLhsOptionalChaining, e3, { ancestor: t3 })), void (64 !== r3 && this.raise(c.InvalidPropertyBindingPattern, e3));
            if ("Identifier" === a2) {
              this.checkIdentifier(e3, r3, s2);
              const { name: t4 } = e3;
              return void (n2 && (n2.has(t4) ? this.raise(c.ParamDupe, e3) : n2.add(t4)));
            }
            "VoidPattern" === a2 && "CatchClause" === t3.type && this.raise(c.VoidPatternCatchClauseParam, e3);
            const p2 = this.isValidLVal(a2, !(i2 || null != (o2 = e3.extra) && o2.parenthesized) && "AssignmentExpression" === t3.type, r3);
            if (true === p2) return;
            if (false === p2) {
              const n3 = 64 === r3 ? c.InvalidLhs : c.InvalidLhsBinding;
              return void this.raise(n3, e3, { ancestor: t3 });
            }
            let u2, d2;
            "string" == typeof p2 ? (u2 = p2, d2 = "ParenthesizedExpression" === a2) : [u2, d2] = p2;
            const h2 = "ArrayPattern" === a2 || "ObjectPattern" === a2 ? { type: a2 } : t3, m2 = e3[u2];
            if (Array.isArray(m2)) for (const e4 of m2) e4 && this.checkLVal(e4, h2, r3, n2, s2, d2);
            else m2 && this.checkLVal(m2, h2, r3, n2, s2, d2);
          }
          checkIdentifier(e3, t3, r3 = false) {
            this.state.strict && (r3 ? isStrictBindReservedWord(e3.name, this.inModule) : isStrictBindOnlyReservedWord(e3.name)) && (64 === t3 ? this.raise(c.StrictEvalArguments, e3, { referenceName: e3.name }) : this.raise(c.StrictEvalArgumentsBinding, e3, { bindingName: e3.name })), 8192 & t3 && "let" === e3.name && this.raise(c.LetInLexicalBinding, e3), 64 & t3 || this.declareNameFromIdentifier(e3, t3);
          }
          declareNameFromIdentifier(e3, t3) {
            this.scope.declareName(e3.name, t3, e3.loc.start);
          }
          checkToRestConversion(e3, t3) {
            switch (e3.type) {
              case "ParenthesizedExpression":
                this.checkToRestConversion(e3.expression, t3);
                break;
              case "Identifier":
              case "MemberExpression":
                break;
              case "ArrayExpression":
              case "ObjectExpression":
                if (t3) break;
              default:
                this.raise(c.InvalidRestAssignmentPattern, e3);
            }
          }
          checkCommaAfterRest(e3) {
            return !!this.match(12) && (this.raise(this.lookaheadCharCode() === e3 ? c.RestTrailingComma : c.ElementAfterRest, this.state.startLoc), true);
          }
        }
        function assert(e3) {
          if (!e3) throw new Error("Assert fail");
        }
        const Q = ParseErrorEnum`typescript`({ AbstractMethodHasImplementation: ({ methodName: e3 }) => `Method '${e3}' cannot have an implementation because it is marked abstract.`, AbstractPropertyHasInitializer: ({ propertyName: e3 }) => `Property '${e3}' cannot have an initializer because it is marked abstract.`, AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.", AccessorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.", AccessorCannotHaveTypeParameters: "An accessor cannot have type parameters.", ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.", ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.", ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.", ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.", DeclareAccessor: ({ kind: e3 }) => `'declare' is not allowed in ${e3}ters.`, DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.", DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.", DuplicateAccessibilityModifier: ({ modifier: e3 }) => `Accessibility modifier already seen: '${e3}'.`, DuplicateModifier: ({ modifier: e3 }) => `Duplicate modifier: '${e3}'.`, EmptyHeritageClauseType: ({ token: e3 }) => `'${e3}' list cannot be empty.`, EmptyTypeArguments: "Type argument list cannot be empty.", EmptyTypeParameters: "Type parameter list cannot be empty.", ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.", ImportAliasHasImportType: "An import alias can not use 'import type'.", ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier", IncompatibleModifiers: ({ modifiers: e3 }) => `'${e3[0]}' modifier cannot be used with '${e3[1]}' modifier.`, IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.", IndexSignatureHasAccessibility: ({ modifier: e3 }) => `Index signatures cannot have an accessibility modifier ('${e3}').`, IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.", IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.", IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.", InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.", InvalidHeritageClauseType: ({ token: e3 }) => `'${e3}' list can only include identifiers or qualified-names with optional type arguments.`, InvalidModifierOnAwaitUsingDeclaration: (e3) => `'${e3}' modifier cannot appear on an await using declaration.`, InvalidModifierOnTypeMember: ({ modifier: e3 }) => `'${e3}' modifier cannot appear on a type member.`, InvalidModifierOnTypeParameter: ({ modifier: e3 }) => `'${e3}' modifier cannot appear on a type parameter.`, InvalidModifierOnTypeParameterPositions: ({ modifier: e3 }) => `'${e3}' modifier can only appear on a type parameter of a class, interface or type alias.`, InvalidModifierOnUsingDeclaration: (e3) => `'${e3}' modifier cannot appear on a using declaration.`, InvalidModifiersOrder: ({ orderedModifiers: e3 }) => `'${e3[0]}' modifier must precede '${e3[1]}' modifier.`, InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.", InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.", MissingInterfaceName: "'interface' declarations must be followed by an identifier.", NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.", NonClassMethodPropertyHasAbstractModifier: "'abstract' modifier can only appear on a class, method, or property declaration.", OptionalTypeBeforeRequired: "A required element cannot follow an optional element.", OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.", PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.", PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.", PrivateElementHasAccessibility: ({ modifier: e3 }) => `Private elements cannot have an accessibility modifier ('${e3}').`, ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.", ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.", ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.", SetAccessorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.", SetAccessorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.", SetAccessorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.", SingleTypeParameterWithoutTrailingComma: ({ typeParameterName: e3 }) => `Single type parameter ${e3} should have a trailing comma. Example usage: <${e3},>.`, StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.", TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).", TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.", TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.", TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.", UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.", UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.", UnexpectedTypeAnnotation: "Did not expect a type annotation here.", UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.", UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.", UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.", UnsupportedSignatureParameterKind: ({ type: e3 }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${e3}.`, UsingDeclarationInAmbientContext: (e3) => `'${e3}' declarations are not allowed in ambient contexts.` });
        function tsIsAccessModifier(e3) {
          return "private" === e3 || "public" === e3 || "protected" === e3;
        }
        function tsIsVarianceAnnotations(e3) {
          return "in" === e3 || "out" === e3;
        }
        function isPossiblyLiteralEnum(e3) {
          if ("MemberExpression" !== e3.type) return false;
          const { computed: t3, property: r3 } = e3;
          return (!t3 || "StringLiteral" === r3.type || !("TemplateLiteral" !== r3.type || r3.expressions.length > 0)) && isUncomputedMemberExpressionChain(e3.object);
        }
        function isValidAmbientConstInitializer(e3, t3) {
          var r3;
          const { type: n2 } = e3;
          if (null != (r3 = e3.extra) && r3.parenthesized) return false;
          if (t3) {
            if ("Literal" === n2) {
              const { value: t4 } = e3;
              if ("string" == typeof t4 || "boolean" == typeof t4) return true;
            }
          } else if ("StringLiteral" === n2 || "BooleanLiteral" === n2) return true;
          return !(!isNumber(e3, t3) && !(function(e4, t4) {
            if ("UnaryExpression" === e4.type) {
              const { operator: r4, argument: n3 } = e4;
              if ("-" === r4 && isNumber(n3, t4)) return true;
            }
            return false;
          })(e3, t3)) || ("TemplateLiteral" === n2 && 0 === e3.expressions.length || !!isPossiblyLiteralEnum(e3));
        }
        function isNumber(e3, t3) {
          return t3 ? "Literal" === e3.type && ("number" == typeof e3.value || "bigint" in e3) : "NumericLiteral" === e3.type || "BigIntLiteral" === e3.type;
        }
        function isUncomputedMemberExpressionChain(e3) {
          return "Identifier" === e3.type || "MemberExpression" === e3.type && !e3.computed && isUncomputedMemberExpressionChain(e3.object);
        }
        const Z = ParseErrorEnum`placeholders`({ ClassNameIsRequired: "A class name is required.", UnexpectedSpace: "Unexpected space in placeholder." });
        const ee = ["minimal", "fsharp", "hack", "smart"], te = ["^^", "@@", "^", "%", "#"];
        const re = { estree: (e3) => class extends e3 {
          parse() {
            const e4 = toESTreeLocation(super.parse());
            return 256 & this.optionFlags && (e4.tokens = e4.tokens.map(toESTreeLocation)), e4;
          }
          parseRegExpLiteral({ pattern: e4, flags: t3 }) {
            let r3 = null;
            try {
              r3 = new RegExp(e4, t3);
            } catch (e5) {
            }
            const n2 = this.estreeParseLiteral(r3);
            return n2.regex = { pattern: e4, flags: t3 }, n2;
          }
          parseBigIntLiteral(e4) {
            let t3;
            try {
              t3 = BigInt(e4);
            } catch (e5) {
              t3 = null;
            }
            const r3 = this.estreeParseLiteral(t3);
            return r3.bigint = String(r3.value || e4), r3;
          }
          parseDecimalLiteral(e4) {
            const t3 = this.estreeParseLiteral(null);
            return t3.decimal = String(t3.value || e4), t3;
          }
          estreeParseLiteral(e4) {
            return this.parseLiteral(e4, "Literal");
          }
          parseStringLiteral(e4) {
            return this.estreeParseLiteral(e4);
          }
          parseNumericLiteral(e4) {
            return this.estreeParseLiteral(e4);
          }
          parseNullLiteral() {
            return this.estreeParseLiteral(null);
          }
          parseBooleanLiteral(e4) {
            return this.estreeParseLiteral(e4);
          }
          estreeParseChainExpression(e4, t3) {
            const r3 = this.startNodeAtNode(e4);
            return r3.expression = e4, this.finishNodeAt(r3, "ChainExpression", t3);
          }
          directiveToStmt(e4) {
            const t3 = e4.value;
            delete e4.value, this.castNodeTo(t3, "Literal"), t3.raw = t3.extra.raw, t3.value = t3.extra.expressionValue;
            const r3 = this.castNodeTo(e4, "ExpressionStatement");
            return r3.expression = t3, r3.directive = t3.extra.rawValue, delete t3.extra, r3;
          }
          fillOptionalPropertiesForTSESLint(e4) {
          }
          cloneEstreeStringLiteral(e4) {
            const { start: t3, end: r3, loc: n2, range: s2, raw: i2, value: o2 } = e4, a2 = Object.create(e4.constructor.prototype);
            return a2.type = "Literal", a2.start = t3, a2.end = r3, a2.loc = n2, a2.range = s2, a2.raw = i2, a2.value = o2, a2;
          }
          initFunction(e4, t3) {
            super.initFunction(e4, t3), e4.expression = false;
          }
          checkDeclaration(e4) {
            null != e4 && this.isObjectProperty(e4) ? this.checkDeclaration(e4.value) : super.checkDeclaration(e4);
          }
          getObjectOrClassMethodParams(e4) {
            return e4.value.params;
          }
          isValidDirective(e4) {
            var t3;
            return "ExpressionStatement" === e4.type && "Literal" === e4.expression.type && "string" == typeof e4.expression.value && !(null != (t3 = e4.expression.extra) && t3.parenthesized);
          }
          parseBlockBody(e4, t3, r3, n2, s2) {
            super.parseBlockBody(e4, t3, r3, n2, s2);
            const i2 = e4.directives.map((e5) => this.directiveToStmt(e5));
            e4.body = i2.concat(e4.body), delete e4.directives;
          }
          parsePrivateName() {
            const e4 = super.parsePrivateName();
            return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(e4) : e4;
          }
          convertPrivateNameToPrivateIdentifier(e4) {
            const t3 = super.getPrivateNameSV(e4);
            return delete e4.id, e4.name = t3, this.castNodeTo(e4, "PrivateIdentifier");
          }
          isPrivateName(e4) {
            return this.getPluginOption("estree", "classFeatures") ? "PrivateIdentifier" === e4.type : super.isPrivateName(e4);
          }
          getPrivateNameSV(e4) {
            return this.getPluginOption("estree", "classFeatures") ? e4.name : super.getPrivateNameSV(e4);
          }
          parseLiteral(e4, t3) {
            const r3 = super.parseLiteral(e4, t3);
            return r3.raw = r3.extra.raw, delete r3.extra, r3;
          }
          parseFunctionBody(e4, t3, r3 = false) {
            super.parseFunctionBody(e4, t3, r3), e4.expression = "BlockStatement" !== e4.body.type;
          }
          parseMethod(e4, t3, r3, n2, s2, i2, o2 = false) {
            let a2 = this.startNode();
            a2.kind = e4.kind, a2 = super.parseMethod(a2, t3, r3, n2, s2, i2, o2), delete a2.kind;
            const { typeParameters: l2 } = e4;
            l2 && (delete e4.typeParameters, a2.typeParameters = l2, this.resetStartLocationFromNode(a2, l2));
            const p2 = this.castNodeTo(a2, "FunctionExpression");
            return e4.value = p2, "ClassPrivateMethod" === i2 && (e4.computed = false), "ObjectMethod" === i2 ? ("method" === e4.kind && (e4.kind = "init"), e4.shorthand = false, this.finishNode(e4, "Property")) : this.finishNode(e4, "MethodDefinition");
          }
          nameIsConstructor(e4) {
            return "Literal" === e4.type ? "constructor" === e4.value : super.nameIsConstructor(e4);
          }
          parseClassProperty(...e4) {
            const t3 = super.parseClassProperty(...e4);
            return this.getPluginOption("estree", "classFeatures") ? (this.castNodeTo(t3, "PropertyDefinition"), t3) : t3;
          }
          parseClassPrivateProperty(...e4) {
            const t3 = super.parseClassPrivateProperty(...e4);
            return this.getPluginOption("estree", "classFeatures") ? (this.castNodeTo(t3, "PropertyDefinition"), t3.computed = false, t3) : t3;
          }
          parseClassAccessorProperty(e4) {
            const t3 = super.parseClassAccessorProperty(e4);
            return this.getPluginOption("estree", "classFeatures") ? (t3.abstract && this.hasPlugin("typescript") ? (delete t3.abstract, this.castNodeTo(t3, "TSAbstractAccessorProperty")) : this.castNodeTo(t3, "AccessorProperty"), t3) : t3;
          }
          parseObjectProperty(e4, t3, r3, n2) {
            const s2 = super.parseObjectProperty(e4, t3, r3, n2);
            return s2 && (s2.kind = "init", this.castNodeTo(s2, "Property")), s2;
          }
          finishObjectProperty(e4) {
            return e4.kind = "init", this.finishNode(e4, "Property");
          }
          isValidLVal(e4, t3, r3) {
            return "Property" === e4 ? "value" : super.isValidLVal(e4, t3, r3);
          }
          isAssignable(e4, t3) {
            return null != e4 && this.isObjectProperty(e4) ? this.isAssignable(e4.value, t3) : super.isAssignable(e4, t3);
          }
          toAssignable(e4, t3 = false) {
            if (null != e4 && this.isObjectProperty(e4)) {
              const { key: r3, value: n2 } = e4;
              this.isPrivateName(r3) && this.classScope.usePrivateName(this.getPrivateNameSV(r3), r3.loc.start), this.toAssignable(n2, t3);
            } else super.toAssignable(e4, t3);
          }
          toAssignableObjectExpressionProp(e4, t3, r3) {
            "Property" !== e4.type || "get" !== e4.kind && "set" !== e4.kind ? "Property" === e4.type && e4.method ? this.raise(c.PatternHasMethod, e4.key) : super.toAssignableObjectExpressionProp(e4, t3, r3) : this.raise(c.PatternHasAccessor, e4.key);
          }
          finishCallExpression(e4, t3) {
            const r3 = super.finishCallExpression(e4, t3);
            var n2, s2;
            "Import" === r3.callee.type ? (this.castNodeTo(r3, "ImportExpression"), r3.source = r3.arguments[0], r3.options = null != (n2 = r3.arguments[1]) ? n2 : null, r3.attributes = null != (s2 = r3.arguments[1]) ? s2 : null, delete r3.arguments, delete r3.callee) : "OptionalCallExpression" === r3.type ? this.castNodeTo(r3, "CallExpression") : r3.optional = false;
            return r3;
          }
          toReferencedArguments(e4) {
            "ImportExpression" !== e4.type && super.toReferencedArguments(e4);
          }
          parseExport(e4, t3) {
            const r3 = this.state.lastTokStartLoc, n2 = super.parseExport(e4, t3);
            switch (n2.type) {
              case "ExportAllDeclaration":
                n2.exported = null;
                break;
              case "ExportNamedDeclaration":
                1 === n2.specifiers.length && "ExportNamespaceSpecifier" === n2.specifiers[0].type && (this.castNodeTo(n2, "ExportAllDeclaration"), n2.exported = n2.specifiers[0].exported, delete n2.specifiers);
              case "ExportDefaultDeclaration": {
                var s2;
                const { declaration: e5 } = n2;
                "ClassDeclaration" === (null == e5 ? void 0 : e5.type) && (null == (s2 = e5.decorators) ? void 0 : s2.length) > 0 && e5.start === n2.start && this.resetStartLocation(n2, r3);
              }
            }
            return n2;
          }
          stopParseSubscript(e4, t3) {
            const r3 = super.stopParseSubscript(e4, t3);
            return t3.optionalChainMember ? this.estreeParseChainExpression(r3, e4.loc.end) : r3;
          }
          parseMember(e4, t3, r3, n2, s2) {
            const i2 = super.parseMember(e4, t3, r3, n2, s2);
            return "OptionalMemberExpression" === i2.type ? this.castNodeTo(i2, "MemberExpression") : i2.optional = false, i2;
          }
          isOptionalMemberExpression(e4) {
            return "ChainExpression" === e4.type ? "MemberExpression" === e4.expression.type : super.isOptionalMemberExpression(e4);
          }
          hasPropertyAsPrivateName(e4) {
            return "ChainExpression" === e4.type && (e4 = e4.expression), super.hasPropertyAsPrivateName(e4);
          }
          isObjectProperty(e4) {
            return "Property" === e4.type && "init" === e4.kind && !e4.method;
          }
          isObjectMethod(e4) {
            return "Property" === e4.type && (e4.method || "get" === e4.kind || "set" === e4.kind);
          }
          castNodeTo(e4, t3) {
            const r3 = super.castNodeTo(e4, t3);
            return this.fillOptionalPropertiesForTSESLint(r3), r3;
          }
          cloneIdentifier(e4) {
            const t3 = super.cloneIdentifier(e4);
            return this.fillOptionalPropertiesForTSESLint(t3), t3;
          }
          cloneStringLiteral(e4) {
            return "Literal" === e4.type ? this.cloneEstreeStringLiteral(e4) : super.cloneStringLiteral(e4);
          }
          finishNodeAt(e4, t3, r3) {
            return toESTreeLocation(super.finishNodeAt(e4, t3, r3));
          }
          finishNode(e4, t3) {
            const r3 = super.finishNode(e4, t3);
            return this.fillOptionalPropertiesForTSESLint(r3), r3;
          }
          resetStartLocation(e4, t3) {
            super.resetStartLocation(e4, t3), toESTreeLocation(e4);
          }
          resetEndLocation(e4, t3 = this.state.lastTokEndLoc) {
            super.resetEndLocation(e4, t3), toESTreeLocation(e4);
          }
        }, jsx: (e3) => class extends e3 {
          jsxReadToken() {
            let e4 = "", t3 = this.state.pos;
            for (; ; ) {
              if (this.state.pos >= this.length) throw this.raise(z.UnterminatedJsxContent, this.state.startLoc);
              const r3 = this.input.charCodeAt(this.state.pos);
              switch (r3) {
                case 60:
                case 123:
                  return this.state.pos === this.state.start ? void (60 === r3 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(143)) : super.getTokenFromCode(r3)) : (e4 += this.input.slice(t3, this.state.pos), void this.finishToken(142, e4));
                case 38:
                  e4 += this.input.slice(t3, this.state.pos), e4 += this.jsxReadEntity(), t3 = this.state.pos;
                  break;
                default:
                  isNewLine(r3) ? (e4 += this.input.slice(t3, this.state.pos), e4 += this.jsxReadNewLine(true), t3 = this.state.pos) : ++this.state.pos;
              }
            }
          }
          jsxReadNewLine(e4) {
            const t3 = this.input.charCodeAt(this.state.pos);
            let r3;
            return ++this.state.pos, 13 === t3 && 10 === this.input.charCodeAt(this.state.pos) ? (++this.state.pos, r3 = e4 ? "\n" : "\r\n") : r3 = String.fromCharCode(t3), ++this.state.curLine, this.state.lineStart = this.state.pos, r3;
          }
          jsxReadString(e4) {
            let t3 = "", r3 = ++this.state.pos;
            for (; ; ) {
              if (this.state.pos >= this.length) throw this.raise(c.UnterminatedString, this.state.startLoc);
              const n2 = this.input.charCodeAt(this.state.pos);
              if (n2 === e4) break;
              38 === n2 ? (t3 += this.input.slice(r3, this.state.pos), t3 += this.jsxReadEntity(), r3 = this.state.pos) : isNewLine(n2) ? (t3 += this.input.slice(r3, this.state.pos), t3 += this.jsxReadNewLine(false), r3 = this.state.pos) : ++this.state.pos;
            }
            t3 += this.input.slice(r3, this.state.pos++), this.finishToken(134, t3);
          }
          jsxReadEntity() {
            const e4 = ++this.state.pos;
            if (35 === this.codePointAtPos(this.state.pos)) {
              ++this.state.pos;
              let e5 = 10;
              120 === this.codePointAtPos(this.state.pos) && (e5 = 16, ++this.state.pos);
              const t3 = this.readInt(e5, void 0, false, "bail");
              if (null !== t3 && 59 === this.codePointAtPos(this.state.pos)) return ++this.state.pos, String.fromCodePoint(t3);
            } else {
              let t3 = 0, r3 = false;
              for (; t3++ < 10 && this.state.pos < this.length && !(r3 = 59 === this.codePointAtPos(this.state.pos)); ) ++this.state.pos;
              if (r3) {
                const t4 = this.input.slice(e4, this.state.pos), r4 = K[t4];
                if (++this.state.pos, r4) return r4;
              }
            }
            return this.state.pos = e4, "&";
          }
          jsxReadWord() {
            let e4;
            const t3 = this.state.pos;
            do {
              e4 = this.input.charCodeAt(++this.state.pos);
            } while (isIdentifierChar(e4) || 45 === e4);
            this.finishToken(141, this.input.slice(t3, this.state.pos));
          }
          jsxParseIdentifier() {
            const e4 = this.startNode();
            return this.match(141) ? e4.name = this.state.value : tokenIsKeyword(this.state.type) ? e4.name = tokenLabelName(this.state.type) : this.unexpected(), this.next(), this.finishNode(e4, "JSXIdentifier");
          }
          jsxParseNamespacedName() {
            const e4 = this.state.startLoc, t3 = this.jsxParseIdentifier();
            if (!this.eat(14)) return t3;
            const r3 = this.startNodeAt(e4);
            return r3.namespace = t3, r3.name = this.jsxParseIdentifier(), this.finishNode(r3, "JSXNamespacedName");
          }
          jsxParseElementName() {
            const e4 = this.state.startLoc;
            let t3 = this.jsxParseNamespacedName();
            if ("JSXNamespacedName" === t3.type) return t3;
            for (; this.eat(16); ) {
              const r3 = this.startNodeAt(e4);
              r3.object = t3, r3.property = this.jsxParseIdentifier(), t3 = this.finishNode(r3, "JSXMemberExpression");
            }
            return t3;
          }
          jsxParseAttributeValue() {
            let e4;
            switch (this.state.type) {
              case 5:
                return e4 = this.startNode(), this.setContext(d.brace), this.next(), e4 = this.jsxParseExpressionContainer(e4, d.j_oTag), "JSXEmptyExpression" === e4.expression.type && this.raise(z.AttributeIsEmpty, e4), e4;
              case 143:
              case 134:
                return this.parseExprAtom();
              default:
                throw this.raise(z.UnsupportedJsxValue, this.state.startLoc);
            }
          }
          jsxParseEmptyExpression() {
            const e4 = this.startNodeAt(this.state.lastTokEndLoc);
            return this.finishNodeAt(e4, "JSXEmptyExpression", this.state.startLoc);
          }
          jsxParseSpreadChild(e4) {
            return this.next(), e4.expression = this.parseExpression(), this.setContext(d.j_expr), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(e4, "JSXSpreadChild");
          }
          jsxParseExpressionContainer(e4, t3) {
            if (this.match(8)) e4.expression = this.jsxParseEmptyExpression();
            else {
              const t4 = this.parseExpression();
              e4.expression = t4;
            }
            return this.setContext(t3), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(e4, "JSXExpressionContainer");
          }
          jsxParseAttribute() {
            const e4 = this.startNode();
            return this.match(5) ? (this.setContext(d.brace), this.next(), this.expect(21), e4.argument = this.parseMaybeAssignAllowIn(), this.setContext(d.j_oTag), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(e4, "JSXSpreadAttribute")) : (e4.name = this.jsxParseNamespacedName(), e4.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(e4, "JSXAttribute"));
          }
          jsxParseOpeningElementAt(e4) {
            const t3 = this.startNodeAt(e4);
            return this.eat(144) ? this.finishNode(t3, "JSXOpeningFragment") : (t3.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(t3));
          }
          jsxParseOpeningElementAfterName(e4) {
            const t3 = [];
            for (; !this.match(56) && !this.match(144); ) t3.push(this.jsxParseAttribute());
            return e4.attributes = t3, e4.selfClosing = this.eat(56), this.expect(144), this.finishNode(e4, "JSXOpeningElement");
          }
          jsxParseClosingElementAt(e4) {
            const t3 = this.startNodeAt(e4);
            return this.eat(144) ? this.finishNode(t3, "JSXClosingFragment") : (t3.name = this.jsxParseElementName(), this.expect(144), this.finishNode(t3, "JSXClosingElement"));
          }
          jsxParseElementAt(e4) {
            const t3 = this.startNodeAt(e4), r3 = [], n2 = this.jsxParseOpeningElementAt(e4);
            let s2 = null;
            if (!n2.selfClosing) {
              e: for (; ; ) switch (this.state.type) {
                case 143:
                  if (e4 = this.state.startLoc, this.next(), this.eat(56)) {
                    s2 = this.jsxParseClosingElementAt(e4);
                    break e;
                  }
                  r3.push(this.jsxParseElementAt(e4));
                  break;
                case 142:
                  r3.push(this.parseLiteral(this.state.value, "JSXText"));
                  break;
                case 5: {
                  const e5 = this.startNode();
                  this.setContext(d.brace), this.next(), this.match(21) ? r3.push(this.jsxParseSpreadChild(e5)) : r3.push(this.jsxParseExpressionContainer(e5, d.j_expr));
                  break;
                }
                default:
                  this.unexpected();
              }
              isFragment(n2) && !isFragment(s2) && null !== s2 ? this.raise(z.MissingClosingTagFragment, s2) : !isFragment(n2) && isFragment(s2) ? this.raise(z.MissingClosingTagElement, s2, { openingTagName: getQualifiedJSXName(n2.name) }) : isFragment(n2) || isFragment(s2) || getQualifiedJSXName(s2.name) !== getQualifiedJSXName(n2.name) && this.raise(z.MissingClosingTagElement, s2, { openingTagName: getQualifiedJSXName(n2.name) });
            }
            if (isFragment(n2) ? (t3.openingFragment = n2, t3.closingFragment = s2) : (t3.openingElement = n2, t3.closingElement = s2), t3.children = r3, this.match(47)) throw this.raise(z.UnwrappedAdjacentJSXElements, this.state.startLoc);
            return isFragment(n2) ? this.finishNode(t3, "JSXFragment") : this.finishNode(t3, "JSXElement");
          }
          jsxParseElement() {
            const e4 = this.state.startLoc;
            return this.next(), this.jsxParseElementAt(e4);
          }
          setContext(e4) {
            const { context: t3 } = this.state;
            t3[t3.length - 1] = e4;
          }
          parseExprAtom(e4) {
            return this.match(143) ? this.jsxParseElement() : this.match(47) && 33 !== this.input.charCodeAt(this.state.pos) ? (this.replaceToken(143), this.jsxParseElement()) : super.parseExprAtom(e4);
          }
          skipSpace() {
            this.curContext().preserveSpace || super.skipSpace();
          }
          getTokenFromCode(e4) {
            const t3 = this.curContext();
            if (t3 !== d.j_expr) {
              if (t3 === d.j_oTag || t3 === d.j_cTag) {
                if (isIdentifierStart(e4)) return void this.jsxReadWord();
                if (62 === e4) return ++this.state.pos, void this.finishToken(144);
                if ((34 === e4 || 39 === e4) && t3 === d.j_oTag) return void this.jsxReadString(e4);
              }
              if (60 === e4 && this.state.canStartJSXElement && 33 !== this.input.charCodeAt(this.state.pos + 1)) return ++this.state.pos, void this.finishToken(143);
              super.getTokenFromCode(e4);
            } else this.jsxReadToken();
          }
          updateContext(e4) {
            const { context: t3, type: r3 } = this.state;
            if (56 === r3 && 143 === e4) t3.splice(-2, 2, d.j_cTag), this.state.canStartJSXElement = false;
            else if (143 === r3) t3.push(d.j_oTag);
            else if (144 === r3) {
              const r4 = t3[t3.length - 1];
              r4 === d.j_oTag && 56 === e4 || r4 === d.j_cTag ? (t3.pop(), this.state.canStartJSXElement = t3[t3.length - 1] === d.j_expr) : (this.setContext(d.j_expr), this.state.canStartJSXElement = true);
            } else this.state.canStartJSXElement = S[r3];
          }
        }, flow: (e3) => class extends e3 {
          constructor(...e4) {
            super(...e4), this.flowPragma = void 0;
          }
          getScopeHandler() {
            return FlowScopeHandler;
          }
          shouldParseTypes() {
            return this.getPluginOption("flow", "all") || "flow" === this.flowPragma;
          }
          finishToken(e4, t3) {
            134 !== e4 && 13 !== e4 && 28 !== e4 && void 0 === this.flowPragma && (this.flowPragma = null), super.finishToken(e4, t3);
          }
          addComment(e4) {
            if (void 0 === this.flowPragma) {
              const t3 = $.exec(e4.value);
              if (t3) if ("flow" === t3[1]) this.flowPragma = "flow";
              else {
                if ("noflow" !== t3[1]) throw new Error("Unexpected flow pragma");
                this.flowPragma = "noflow";
              }
              else ;
            }
            super.addComment(e4);
          }
          flowParseTypeInitialiser(e4) {
            const t3 = this.state.inType;
            this.state.inType = true, this.expect(e4 || 14);
            const r3 = this.flowParseType();
            return this.state.inType = t3, r3;
          }
          flowParsePredicate() {
            const e4 = this.startNode(), t3 = this.state.startLoc;
            return this.next(), this.expectContextual(110), this.state.lastTokStartLoc.index > t3.index + 1 && this.raise(U.UnexpectedSpaceBetweenModuloChecks, t3), this.eat(10) ? (e4.value = super.parseExpression(), this.expect(11), this.finishNode(e4, "DeclaredPredicate")) : this.finishNode(e4, "InferredPredicate");
          }
          flowParseTypeAndPredicateInitialiser() {
            const e4 = this.state.inType;
            this.state.inType = true, this.expect(14);
            let t3 = null, r3 = null;
            return this.match(54) ? (this.state.inType = e4, r3 = this.flowParsePredicate()) : (t3 = this.flowParseType(), this.state.inType = e4, this.match(54) && (r3 = this.flowParsePredicate())), [t3, r3];
          }
          flowParseDeclareClass(e4) {
            return this.next(), this.flowParseInterfaceish(e4, true), this.finishNode(e4, "DeclareClass");
          }
          flowParseDeclareFunction(e4) {
            this.next();
            const t3 = e4.id = this.parseIdentifier(), r3 = this.startNode(), n2 = this.startNode();
            this.match(47) ? r3.typeParameters = this.flowParseTypeParameterDeclaration() : r3.typeParameters = null, this.expect(10);
            const s2 = this.flowParseFunctionTypeParams();
            return r3.params = s2.params, r3.rest = s2.rest, r3.this = s2._this, this.expect(11), [r3.returnType, e4.predicate] = this.flowParseTypeAndPredicateInitialiser(), n2.typeAnnotation = this.finishNode(r3, "FunctionTypeAnnotation"), t3.typeAnnotation = this.finishNode(n2, "TypeAnnotation"), this.resetEndLocation(t3), this.semicolon(), this.scope.declareName(e4.id.name, 2048, e4.id.loc.start), this.finishNode(e4, "DeclareFunction");
          }
          flowParseDeclare(e4, t3) {
            return this.match(80) ? this.flowParseDeclareClass(e4) : this.match(68) ? this.flowParseDeclareFunction(e4) : this.match(74) ? this.flowParseDeclareVariable(e4) : this.eatContextual(127) ? this.match(16) ? this.flowParseDeclareModuleExports(e4) : (t3 && this.raise(U.NestedDeclareModule, this.state.lastTokStartLoc), this.flowParseDeclareModule(e4)) : this.isContextual(130) ? this.flowParseDeclareTypeAlias(e4) : this.isContextual(131) ? this.flowParseDeclareOpaqueType(e4) : this.isContextual(129) ? this.flowParseDeclareInterface(e4) : this.match(82) ? this.flowParseDeclareExportDeclaration(e4, t3) : void this.unexpected();
          }
          flowParseDeclareVariable(e4) {
            return this.next(), e4.id = this.flowParseTypeAnnotatableIdentifier(true), this.scope.declareName(e4.id.name, 5, e4.id.loc.start), this.semicolon(), this.finishNode(e4, "DeclareVariable");
          }
          flowParseDeclareModule(e4) {
            this.scope.enter(0), this.match(134) ? e4.id = super.parseExprAtom() : e4.id = this.parseIdentifier();
            const t3 = e4.body = this.startNode(), r3 = t3.body = [];
            for (this.expect(5); !this.match(8); ) {
              let e5 = this.startNode();
              this.match(83) ? (this.next(), this.isContextual(130) || this.match(87) || this.raise(U.InvalidNonTypeImportInDeclareModule, this.state.lastTokStartLoc), super.parseImport(e5)) : (this.expectContextual(125, U.UnsupportedStatementInDeclareModule), e5 = this.flowParseDeclare(e5, true)), r3.push(e5);
            }
            this.scope.exit(), this.expect(8), this.finishNode(t3, "BlockStatement");
            let n2 = null, s2 = false;
            return r3.forEach((e5) => {
              !(function(e6) {
                return "DeclareExportAllDeclaration" === e6.type || "DeclareExportDeclaration" === e6.type && (!e6.declaration || "TypeAlias" !== e6.declaration.type && "InterfaceDeclaration" !== e6.declaration.type);
              })(e5) ? "DeclareModuleExports" === e5.type && (s2 && this.raise(U.DuplicateDeclareModuleExports, e5), "ES" === n2 && this.raise(U.AmbiguousDeclareModuleKind, e5), n2 = "CommonJS", s2 = true) : ("CommonJS" === n2 && this.raise(U.AmbiguousDeclareModuleKind, e5), n2 = "ES");
            }), e4.kind = n2 || "CommonJS", this.finishNode(e4, "DeclareModule");
          }
          flowParseDeclareExportDeclaration(e4, t3) {
            if (this.expect(82), this.eat(65)) return this.match(68) || this.match(80) ? e4.declaration = this.flowParseDeclare(this.startNode()) : (e4.declaration = this.flowParseType(), this.semicolon()), e4.default = true, this.finishNode(e4, "DeclareExportDeclaration");
            if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !t3) {
              const e5 = this.state.value;
              throw this.raise(U.UnsupportedDeclareExportKind, this.state.startLoc, { unsupportedExportKind: e5, suggestion: V[e5] });
            }
            return this.match(74) || this.match(68) || this.match(80) || this.isContextual(131) ? (e4.declaration = this.flowParseDeclare(this.startNode()), e4.default = false, this.finishNode(e4, "DeclareExportDeclaration")) : this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131) ? "ExportNamedDeclaration" === (e4 = this.parseExport(e4, null)).type ? (e4.default = false, delete e4.exportKind, this.castNodeTo(e4, "DeclareExportDeclaration")) : this.castNodeTo(e4, "DeclareExportAllDeclaration") : void this.unexpected();
          }
          flowParseDeclareModuleExports(e4) {
            return this.next(), this.expectContextual(111), e4.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(e4, "DeclareModuleExports");
          }
          flowParseDeclareTypeAlias(e4) {
            this.next();
            const t3 = this.flowParseTypeAlias(e4);
            return this.castNodeTo(t3, "DeclareTypeAlias"), t3;
          }
          flowParseDeclareOpaqueType(e4) {
            this.next();
            const t3 = this.flowParseOpaqueType(e4, true);
            return this.castNodeTo(t3, "DeclareOpaqueType"), t3;
          }
          flowParseDeclareInterface(e4) {
            return this.next(), this.flowParseInterfaceish(e4, false), this.finishNode(e4, "DeclareInterface");
          }
          flowParseInterfaceish(e4, t3) {
            if (e4.id = this.flowParseRestrictedIdentifier(!t3, true), this.scope.declareName(e4.id.name, t3 ? 17 : 8201, e4.id.loc.start), this.match(47) ? e4.typeParameters = this.flowParseTypeParameterDeclaration() : e4.typeParameters = null, e4.extends = [], this.eat(81)) do {
              e4.extends.push(this.flowParseInterfaceExtends());
            } while (!t3 && this.eat(12));
            if (t3) {
              if (e4.implements = [], e4.mixins = [], this.eatContextual(117)) do {
                e4.mixins.push(this.flowParseInterfaceExtends());
              } while (this.eat(12));
              if (this.eatContextual(113)) do {
                e4.implements.push(this.flowParseInterfaceExtends());
              } while (this.eat(12));
            }
            e4.body = this.flowParseObjectType({ allowStatic: t3, allowExact: false, allowSpread: false, allowProto: t3, allowInexact: false });
          }
          flowParseInterfaceExtends() {
            const e4 = this.startNode();
            return e4.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? e4.typeParameters = this.flowParseTypeParameterInstantiation() : e4.typeParameters = null, this.finishNode(e4, "InterfaceExtends");
          }
          flowParseInterface(e4) {
            return this.flowParseInterfaceish(e4, false), this.finishNode(e4, "InterfaceDeclaration");
          }
          checkNotUnderscore(e4) {
            "_" === e4 && this.raise(U.UnexpectedReservedUnderscore, this.state.startLoc);
          }
          checkReservedType(e4, t3, r3) {
            R.has(e4) && this.raise(r3 ? U.AssignReservedType : U.UnexpectedReservedType, t3, { reservedType: e4 });
          }
          flowParseRestrictedIdentifier(e4, t3) {
            return this.checkReservedType(this.state.value, this.state.startLoc, t3), this.parseIdentifier(e4);
          }
          flowParseTypeAlias(e4) {
            return e4.id = this.flowParseRestrictedIdentifier(false, true), this.scope.declareName(e4.id.name, 8201, e4.id.loc.start), this.match(47) ? e4.typeParameters = this.flowParseTypeParameterDeclaration() : e4.typeParameters = null, e4.right = this.flowParseTypeInitialiser(29), this.semicolon(), this.finishNode(e4, "TypeAlias");
          }
          flowParseOpaqueType(e4, t3) {
            return this.expectContextual(130), e4.id = this.flowParseRestrictedIdentifier(true, true), this.scope.declareName(e4.id.name, 8201, e4.id.loc.start), this.match(47) ? e4.typeParameters = this.flowParseTypeParameterDeclaration() : e4.typeParameters = null, e4.supertype = null, this.match(14) && (e4.supertype = this.flowParseTypeInitialiser(14)), e4.impltype = null, t3 || (e4.impltype = this.flowParseTypeInitialiser(29)), this.semicolon(), this.finishNode(e4, "OpaqueType");
          }
          flowParseTypeParameter(e4 = false) {
            const t3 = this.state.startLoc, r3 = this.startNode(), n2 = this.flowParseVariance(), s2 = this.flowParseTypeAnnotatableIdentifier();
            return r3.name = s2.name, r3.variance = n2, r3.bound = s2.typeAnnotation, this.match(29) ? (this.eat(29), r3.default = this.flowParseType()) : e4 && this.raise(U.MissingTypeParamDefault, t3), this.finishNode(r3, "TypeParameter");
          }
          flowParseTypeParameterDeclaration() {
            const e4 = this.state.inType, t3 = this.startNode();
            t3.params = [], this.state.inType = true, this.match(47) || this.match(143) ? this.next() : this.unexpected();
            let r3 = false;
            do {
              const e5 = this.flowParseTypeParameter(r3);
              t3.params.push(e5), e5.default && (r3 = true), this.match(48) || this.expect(12);
            } while (!this.match(48));
            return this.expect(48), this.state.inType = e4, this.finishNode(t3, "TypeParameterDeclaration");
          }
          flowInTopLevelContext(e4) {
            if (this.curContext() === d.brace) return e4();
            {
              const t3 = this.state.context;
              this.state.context = [t3[0]];
              try {
                return e4();
              } finally {
                this.state.context = t3;
              }
            }
          }
          flowParseTypeParameterInstantiationInExpression() {
            if (47 === this.reScan_lt()) return this.flowParseTypeParameterInstantiation();
          }
          flowParseTypeParameterInstantiation() {
            const e4 = this.startNode(), t3 = this.state.inType;
            return this.state.inType = true, e4.params = [], this.flowInTopLevelContext(() => {
              this.expect(47);
              const t4 = this.state.noAnonFunctionType;
              for (this.state.noAnonFunctionType = false; !this.match(48); ) e4.params.push(this.flowParseType()), this.match(48) || this.expect(12);
              this.state.noAnonFunctionType = t4;
            }), this.state.inType = t3, this.state.inType || this.curContext() !== d.brace || this.reScan_lt_gt(), this.expect(48), this.finishNode(e4, "TypeParameterInstantiation");
          }
          flowParseTypeParameterInstantiationCallOrNew() {
            if (47 !== this.reScan_lt()) return;
            const e4 = this.startNode(), t3 = this.state.inType;
            for (e4.params = [], this.state.inType = true, this.expect(47); !this.match(48); ) e4.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
            return this.expect(48), this.state.inType = t3, this.finishNode(e4, "TypeParameterInstantiation");
          }
          flowParseInterfaceType() {
            const e4 = this.startNode();
            if (this.expectContextual(129), e4.extends = [], this.eat(81)) do {
              e4.extends.push(this.flowParseInterfaceExtends());
            } while (this.eat(12));
            return e4.body = this.flowParseObjectType({ allowStatic: false, allowExact: false, allowSpread: false, allowProto: false, allowInexact: false }), this.finishNode(e4, "InterfaceTypeAnnotation");
          }
          flowParseObjectPropertyKey() {
            return this.match(135) || this.match(134) ? super.parseExprAtom() : this.parseIdentifier(true);
          }
          flowParseObjectTypeIndexer(e4, t3, r3) {
            return e4.static = t3, 14 === this.lookahead().type ? (e4.id = this.flowParseObjectPropertyKey(), e4.key = this.flowParseTypeInitialiser()) : (e4.id = null, e4.key = this.flowParseType()), this.expect(3), e4.value = this.flowParseTypeInitialiser(), e4.variance = r3, this.finishNode(e4, "ObjectTypeIndexer");
          }
          flowParseObjectTypeInternalSlot(e4, t3) {
            return e4.static = t3, e4.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (e4.method = true, e4.optional = false, e4.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e4.loc.start))) : (e4.method = false, this.eat(17) && (e4.optional = true), e4.value = this.flowParseTypeInitialiser()), this.finishNode(e4, "ObjectTypeInternalSlot");
          }
          flowParseObjectTypeMethodish(e4) {
            for (e4.params = [], e4.rest = null, e4.typeParameters = null, e4.this = null, this.match(47) && (e4.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(10), this.match(78) && (e4.this = this.flowParseFunctionTypeParam(true), e4.this.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); ) e4.params.push(this.flowParseFunctionTypeParam(false)), this.match(11) || this.expect(12);
            return this.eat(21) && (e4.rest = this.flowParseFunctionTypeParam(false)), this.expect(11), e4.returnType = this.flowParseTypeInitialiser(), this.finishNode(e4, "FunctionTypeAnnotation");
          }
          flowParseObjectTypeCallProperty(e4, t3) {
            const r3 = this.startNode();
            return e4.static = t3, e4.value = this.flowParseObjectTypeMethodish(r3), this.finishNode(e4, "ObjectTypeCallProperty");
          }
          flowParseObjectType({ allowStatic: e4, allowExact: t3, allowSpread: r3, allowProto: n2, allowInexact: s2 }) {
            const i2 = this.state.inType;
            this.state.inType = true;
            const o2 = this.startNode();
            let a2, l2;
            o2.callProperties = [], o2.properties = [], o2.indexers = [], o2.internalSlots = [];
            let p2 = false;
            for (t3 && this.match(6) ? (this.expect(6), a2 = 9, l2 = true) : (this.expect(5), a2 = 8, l2 = false), o2.exact = l2; !this.match(a2); ) {
              let t4 = false, i3 = null, a3 = null;
              const c3 = this.startNode();
              if (n2 && this.isContextual(118)) {
                const t5 = this.lookahead();
                14 !== t5.type && 17 !== t5.type && (this.next(), i3 = this.state.startLoc, e4 = false);
              }
              if (e4 && this.isContextual(106)) {
                const e5 = this.lookahead();
                14 !== e5.type && 17 !== e5.type && (this.next(), t4 = true);
              }
              const u2 = this.flowParseVariance();
              if (this.eat(0)) null != i3 && this.unexpected(i3), this.eat(0) ? (u2 && this.unexpected(u2.loc.start), o2.internalSlots.push(this.flowParseObjectTypeInternalSlot(c3, t4))) : o2.indexers.push(this.flowParseObjectTypeIndexer(c3, t4, u2));
              else if (this.match(10) || this.match(47)) null != i3 && this.unexpected(i3), u2 && this.unexpected(u2.loc.start), o2.callProperties.push(this.flowParseObjectTypeCallProperty(c3, t4));
              else {
                let e5 = "init";
                if (this.isContextual(99) || this.isContextual(104)) {
                  tokenIsLiteralPropertyName(this.lookahead().type) && (e5 = this.state.value, this.next());
                }
                const n3 = this.flowParseObjectTypeProperty(c3, t4, i3, u2, e5, r3, null != s2 ? s2 : !l2);
                null === n3 ? (p2 = true, a3 = this.state.lastTokStartLoc) : o2.properties.push(n3);
              }
              this.flowObjectTypeSemicolon(), !a3 || this.match(8) || this.match(9) || this.raise(U.UnexpectedExplicitInexactInObject, a3);
            }
            this.expect(a2), r3 && (o2.inexact = p2);
            const c2 = this.finishNode(o2, "ObjectTypeAnnotation");
            return this.state.inType = i2, c2;
          }
          flowParseObjectTypeProperty(e4, t3, r3, n2, s2, i2, o2) {
            if (this.eat(21)) {
              return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (i2 ? o2 || this.raise(U.InexactInsideExact, this.state.lastTokStartLoc) : this.raise(U.InexactInsideNonObject, this.state.lastTokStartLoc), n2 && this.raise(U.InexactVariance, n2), null) : (i2 || this.raise(U.UnexpectedSpreadType, this.state.lastTokStartLoc), null != r3 && this.unexpected(r3), n2 && this.raise(U.SpreadVariance, n2), e4.argument = this.flowParseType(), this.finishNode(e4, "ObjectTypeSpreadProperty"));
            }
            {
              e4.key = this.flowParseObjectPropertyKey(), e4.static = t3, e4.proto = null != r3, e4.kind = s2;
              let o3 = false;
              return this.match(47) || this.match(10) ? (e4.method = true, null != r3 && this.unexpected(r3), n2 && this.unexpected(n2.loc.start), e4.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e4.loc.start)), "get" !== s2 && "set" !== s2 || this.flowCheckGetterSetterParams(e4), !i2 && "constructor" === e4.key.name && e4.value.this && this.raise(U.ThisParamBannedInConstructor, e4.value.this)) : ("init" !== s2 && this.unexpected(), e4.method = false, this.eat(17) && (o3 = true), e4.value = this.flowParseTypeInitialiser(), e4.variance = n2), e4.optional = o3, this.finishNode(e4, "ObjectTypeProperty");
            }
          }
          flowCheckGetterSetterParams(e4) {
            const t3 = "get" === e4.kind ? 0 : 1, r3 = e4.value.params.length + (e4.value.rest ? 1 : 0);
            e4.value.this && this.raise("get" === e4.kind ? U.GetterMayNotHaveThisParam : U.SetterMayNotHaveThisParam, e4.value.this), r3 !== t3 && this.raise("get" === e4.kind ? c.BadGetterArity : c.BadSetterArity, e4), "set" === e4.kind && e4.value.rest && this.raise(c.BadSetterRestParameter, e4);
          }
          flowObjectTypeSemicolon() {
            this.eat(13) || this.eat(12) || this.match(8) || this.match(9) || this.unexpected();
          }
          flowParseQualifiedTypeIdentifier(e4, t3) {
            null != e4 || (e4 = this.state.startLoc);
            let r3 = t3 || this.flowParseRestrictedIdentifier(true);
            for (; this.eat(16); ) {
              const t4 = this.startNodeAt(e4);
              t4.qualification = r3, t4.id = this.flowParseRestrictedIdentifier(true), r3 = this.finishNode(t4, "QualifiedTypeIdentifier");
            }
            return r3;
          }
          flowParseGenericType(e4, t3) {
            const r3 = this.startNodeAt(e4);
            return r3.typeParameters = null, r3.id = this.flowParseQualifiedTypeIdentifier(e4, t3), this.match(47) && (r3.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(r3, "GenericTypeAnnotation");
          }
          flowParseTypeofType() {
            const e4 = this.startNode();
            return this.expect(87), e4.argument = this.flowParsePrimaryType(), this.finishNode(e4, "TypeofTypeAnnotation");
          }
          flowParseTupleType() {
            const e4 = this.startNode();
            for (e4.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (e4.types.push(this.flowParseType()), !this.match(3)); ) this.expect(12);
            return this.expect(3), this.finishNode(e4, "TupleTypeAnnotation");
          }
          flowParseFunctionTypeParam(e4) {
            let t3 = null, r3 = false, n2 = null;
            const s2 = this.startNode(), i2 = this.lookahead(), o2 = 78 === this.state.type;
            return 14 === i2.type || 17 === i2.type ? (o2 && !e4 && this.raise(U.ThisParamMustBeFirst, s2), t3 = this.parseIdentifier(o2), this.eat(17) && (r3 = true, o2 && this.raise(U.ThisParamMayNotBeOptional, s2)), n2 = this.flowParseTypeInitialiser()) : n2 = this.flowParseType(), s2.name = t3, s2.optional = r3, s2.typeAnnotation = n2, this.finishNode(s2, "FunctionTypeParam");
          }
          reinterpretTypeAsFunctionTypeParam(e4) {
            const t3 = this.startNodeAt(e4.loc.start);
            return t3.name = null, t3.optional = false, t3.typeAnnotation = e4, this.finishNode(t3, "FunctionTypeParam");
          }
          flowParseFunctionTypeParams(e4 = []) {
            let t3 = null, r3 = null;
            for (this.match(78) && (r3 = this.flowParseFunctionTypeParam(true), r3.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); ) e4.push(this.flowParseFunctionTypeParam(false)), this.match(11) || this.expect(12);
            return this.eat(21) && (t3 = this.flowParseFunctionTypeParam(false)), { params: e4, rest: t3, _this: r3 };
          }
          flowIdentToTypeAnnotation(e4, t3, r3) {
            switch (r3.name) {
              case "any":
                return this.finishNode(t3, "AnyTypeAnnotation");
              case "bool":
              case "boolean":
                return this.finishNode(t3, "BooleanTypeAnnotation");
              case "mixed":
                return this.finishNode(t3, "MixedTypeAnnotation");
              case "empty":
                return this.finishNode(t3, "EmptyTypeAnnotation");
              case "number":
                return this.finishNode(t3, "NumberTypeAnnotation");
              case "string":
                return this.finishNode(t3, "StringTypeAnnotation");
              case "symbol":
                return this.finishNode(t3, "SymbolTypeAnnotation");
              default:
                return this.checkNotUnderscore(r3.name), this.flowParseGenericType(e4, r3);
            }
          }
          flowParsePrimaryType() {
            const e4 = this.state.startLoc, t3 = this.startNode();
            let r3, n2, s2 = false;
            const i2 = this.state.noAnonFunctionType;
            switch (this.state.type) {
              case 5:
                return this.flowParseObjectType({ allowStatic: false, allowExact: false, allowSpread: true, allowProto: false, allowInexact: true });
              case 6:
                return this.flowParseObjectType({ allowStatic: false, allowExact: true, allowSpread: true, allowProto: false, allowInexact: false });
              case 0:
                return this.state.noAnonFunctionType = false, n2 = this.flowParseTupleType(), this.state.noAnonFunctionType = i2, n2;
              case 47: {
                const e5 = this.startNode();
                return e5.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), r3 = this.flowParseFunctionTypeParams(), e5.params = r3.params, e5.rest = r3.rest, e5.this = r3._this, this.expect(11), this.expect(19), e5.returnType = this.flowParseType(), this.finishNode(e5, "FunctionTypeAnnotation");
              }
              case 10: {
                const e5 = this.startNode();
                if (this.next(), !this.match(11) && !this.match(21)) if (tokenIsIdentifier(this.state.type) || this.match(78)) {
                  const e6 = this.lookahead().type;
                  s2 = 17 !== e6 && 14 !== e6;
                } else s2 = true;
                if (s2) {
                  if (this.state.noAnonFunctionType = false, n2 = this.flowParseType(), this.state.noAnonFunctionType = i2, this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && 19 === this.lookahead().type)) return this.expect(11), n2;
                  this.eat(12);
                }
                return r3 = n2 ? this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(n2)]) : this.flowParseFunctionTypeParams(), e5.params = r3.params, e5.rest = r3.rest, e5.this = r3._this, this.expect(11), this.expect(19), e5.returnType = this.flowParseType(), e5.typeParameters = null, this.finishNode(e5, "FunctionTypeAnnotation");
              }
              case 134:
                return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
              case 85:
              case 86:
                return t3.value = this.match(85), this.next(), this.finishNode(t3, "BooleanLiteralTypeAnnotation");
              case 53:
                if ("-" === this.state.value) {
                  if (this.next(), this.match(135)) return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", t3);
                  if (this.match(136)) return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", t3);
                  throw this.raise(U.UnexpectedSubtractionOperand, this.state.startLoc);
                }
                return void this.unexpected();
              case 135:
                return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
              case 136:
                return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
              case 88:
                return this.next(), this.finishNode(t3, "VoidTypeAnnotation");
              case 84:
                return this.next(), this.finishNode(t3, "NullLiteralTypeAnnotation");
              case 78:
                return this.next(), this.finishNode(t3, "ThisTypeAnnotation");
              case 55:
                return this.next(), this.finishNode(t3, "ExistsTypeAnnotation");
              case 87:
                return this.flowParseTypeofType();
              default:
                if (tokenIsKeyword(this.state.type)) {
                  const e5 = tokenLabelName(this.state.type);
                  return this.next(), super.createIdentifier(t3, e5);
                }
                if (tokenIsIdentifier(this.state.type)) return this.isContextual(129) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(e4, t3, this.parseIdentifier());
            }
            this.unexpected();
          }
          flowParsePostfixType() {
            const e4 = this.state.startLoc;
            let t3 = this.flowParsePrimaryType(), r3 = false;
            for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
              const n2 = this.startNodeAt(e4), s2 = this.eat(18);
              r3 = r3 || s2, this.expect(0), !s2 && this.match(3) ? (n2.elementType = t3, this.next(), t3 = this.finishNode(n2, "ArrayTypeAnnotation")) : (n2.objectType = t3, n2.indexType = this.flowParseType(), this.expect(3), r3 ? (n2.optional = s2, t3 = this.finishNode(n2, "OptionalIndexedAccessType")) : t3 = this.finishNode(n2, "IndexedAccessType"));
            }
            return t3;
          }
          flowParsePrefixType() {
            const e4 = this.startNode();
            return this.eat(17) ? (e4.typeAnnotation = this.flowParsePrefixType(), this.finishNode(e4, "NullableTypeAnnotation")) : this.flowParsePostfixType();
          }
          flowParseAnonFunctionWithoutParens() {
            const e4 = this.flowParsePrefixType();
            if (!this.state.noAnonFunctionType && this.eat(19)) {
              const t3 = this.startNodeAt(e4.loc.start);
              return t3.params = [this.reinterpretTypeAsFunctionTypeParam(e4)], t3.rest = null, t3.this = null, t3.returnType = this.flowParseType(), t3.typeParameters = null, this.finishNode(t3, "FunctionTypeAnnotation");
            }
            return e4;
          }
          flowParseIntersectionType() {
            const e4 = this.startNode();
            this.eat(45);
            const t3 = this.flowParseAnonFunctionWithoutParens();
            for (e4.types = [t3]; this.eat(45); ) e4.types.push(this.flowParseAnonFunctionWithoutParens());
            return 1 === e4.types.length ? t3 : this.finishNode(e4, "IntersectionTypeAnnotation");
          }
          flowParseUnionType() {
            const e4 = this.startNode();
            this.eat(43);
            const t3 = this.flowParseIntersectionType();
            for (e4.types = [t3]; this.eat(43); ) e4.types.push(this.flowParseIntersectionType());
            return 1 === e4.types.length ? t3 : this.finishNode(e4, "UnionTypeAnnotation");
          }
          flowParseType() {
            const e4 = this.state.inType;
            this.state.inType = true;
            const t3 = this.flowParseUnionType();
            return this.state.inType = e4, t3;
          }
          flowParseTypeOrImplicitInstantiation() {
            if (132 === this.state.type && "_" === this.state.value) {
              const e4 = this.state.startLoc, t3 = this.parseIdentifier();
              return this.flowParseGenericType(e4, t3);
            }
            return this.flowParseType();
          }
          flowParseTypeAnnotation() {
            const e4 = this.startNode();
            return e4.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(e4, "TypeAnnotation");
          }
          flowParseTypeAnnotatableIdentifier(e4) {
            const t3 = e4 ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
            return this.match(14) && (t3.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(t3)), t3;
          }
          typeCastToParameter(e4) {
            return e4.expression.typeAnnotation = e4.typeAnnotation, this.resetEndLocation(e4.expression, e4.typeAnnotation.loc.end), e4.expression;
          }
          flowParseVariance() {
            let e4 = null;
            return this.match(53) ? (e4 = this.startNode(), "+" === this.state.value ? e4.kind = "plus" : e4.kind = "minus", this.next(), this.finishNode(e4, "Variance")) : e4;
          }
          parseFunctionBody(e4, t3, r3 = false) {
            t3 ? this.forwardNoArrowParamsConversionAt(e4, () => super.parseFunctionBody(e4, true, r3)) : super.parseFunctionBody(e4, false, r3);
          }
          parseFunctionBodyAndFinish(e4, t3, r3 = false) {
            if (this.match(14)) {
              const t4 = this.startNode();
              [t4.typeAnnotation, e4.predicate] = this.flowParseTypeAndPredicateInitialiser(), e4.returnType = t4.typeAnnotation ? this.finishNode(t4, "TypeAnnotation") : null;
            }
            return super.parseFunctionBodyAndFinish(e4, t3, r3);
          }
          parseStatementLike(e4) {
            if (this.state.strict && this.isContextual(129)) {
              if (tokenIsKeywordOrIdentifier(this.lookahead().type)) {
                const e5 = this.startNode();
                return this.next(), this.flowParseInterface(e5);
              }
            } else if (this.isContextual(126)) {
              const e5 = this.startNode();
              return this.next(), this.flowParseEnumDeclaration(e5);
            }
            const t3 = super.parseStatementLike(e4);
            return void 0 !== this.flowPragma || this.isValidDirective(t3) || (this.flowPragma = null), t3;
          }
          parseExpressionStatement(e4, t3, r3) {
            if ("Identifier" === t3.type) {
              if ("declare" === t3.name) {
                if (this.match(80) || tokenIsIdentifier(this.state.type) || this.match(68) || this.match(74) || this.match(82)) return this.flowParseDeclare(e4);
              } else if (tokenIsIdentifier(this.state.type)) {
                if ("interface" === t3.name) return this.flowParseInterface(e4);
                if ("type" === t3.name) return this.flowParseTypeAlias(e4);
                if ("opaque" === t3.name) return this.flowParseOpaqueType(e4, false);
              }
            }
            return super.parseExpressionStatement(e4, t3, r3);
          }
          shouldParseExportDeclaration() {
            const { type: e4 } = this.state;
            return 126 === e4 || tokenIsFlowInterfaceOrTypeOrOpaque(e4) ? !this.state.containsEsc : super.shouldParseExportDeclaration();
          }
          isExportDefaultSpecifier() {
            const { type: e4 } = this.state;
            return 126 === e4 || tokenIsFlowInterfaceOrTypeOrOpaque(e4) ? this.state.containsEsc : super.isExportDefaultSpecifier();
          }
          parseExportDefaultExpression() {
            if (this.isContextual(126)) {
              const e4 = this.startNode();
              return this.next(), this.flowParseEnumDeclaration(e4);
            }
            return super.parseExportDefaultExpression();
          }
          parseConditional(e4, t3, r3) {
            if (!this.match(17)) return e4;
            if (this.state.maybeInArrowParameters) {
              const t4 = this.lookaheadCharCode();
              if (44 === t4 || 61 === t4 || 58 === t4 || 41 === t4) return this.setOptionalParametersError(r3), e4;
            }
            this.expect(17);
            const n2 = this.state.clone(), s2 = this.state.noArrowAt, i2 = this.startNodeAt(t3);
            let { consequent: o2, failed: a2 } = this.tryParseConditionalConsequent(), [l2, p2] = this.getArrowLikeExpressions(o2);
            if (a2 || p2.length > 0) {
              const e5 = [...s2];
              if (p2.length > 0) {
                this.state = n2, this.state.noArrowAt = e5;
                for (let t4 = 0; t4 < p2.length; t4++) e5.push(p2[t4].start);
                ({ consequent: o2, failed: a2 } = this.tryParseConditionalConsequent()), [l2, p2] = this.getArrowLikeExpressions(o2);
              }
              a2 && l2.length > 1 && this.raise(U.AmbiguousConditionalArrow, n2.startLoc), a2 && 1 === l2.length && (this.state = n2, e5.push(l2[0].start), this.state.noArrowAt = e5, { consequent: o2, failed: a2 } = this.tryParseConditionalConsequent());
            }
            return this.getArrowLikeExpressions(o2, true), this.state.noArrowAt = s2, this.expect(14), i2.test = e4, i2.consequent = o2, i2.alternate = this.forwardNoArrowParamsConversionAt(i2, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(i2, "ConditionalExpression");
          }
          tryParseConditionalConsequent() {
            this.state.noArrowParamsConversionAt.push(this.state.start);
            const e4 = this.parseMaybeAssignAllowIn(), t3 = !this.match(14);
            return this.state.noArrowParamsConversionAt.pop(), { consequent: e4, failed: t3 };
          }
          getArrowLikeExpressions(e4, t3) {
            const r3 = [e4], n2 = [];
            for (; 0 !== r3.length; ) {
              const e5 = r3.pop();
              "ArrowFunctionExpression" === e5.type && "BlockStatement" !== e5.body.type ? (e5.typeParameters || !e5.returnType ? this.finishArrowValidation(e5) : n2.push(e5), r3.push(e5.body)) : "ConditionalExpression" === e5.type && (r3.push(e5.consequent), r3.push(e5.alternate));
            }
            return t3 ? (n2.forEach((e5) => this.finishArrowValidation(e5)), [n2, []]) : (function(e5, t4) {
              const r4 = [], n3 = [];
              for (let s2 = 0; s2 < e5.length; s2++) (t4(e5[s2], s2, e5) ? r4 : n3).push(e5[s2]);
              return [r4, n3];
            })(n2, (e5) => e5.params.every((e6) => this.isAssignable(e6, true)));
          }
          finishArrowValidation(e4) {
            var t3;
            this.toAssignableList(e4.params, null == (t3 = e4.extra) ? void 0 : t3.trailingCommaLoc, false), this.scope.enter(518), super.checkParams(e4, false, true), this.scope.exit();
          }
          forwardNoArrowParamsConversionAt(e4, t3) {
            let r3;
            return this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(e4.start)) ? (this.state.noArrowParamsConversionAt.push(this.state.start), r3 = t3(), this.state.noArrowParamsConversionAt.pop()) : r3 = t3(), r3;
          }
          parseParenItem(e4, t3) {
            const r3 = super.parseParenItem(e4, t3);
            if (this.eat(17) && (r3.optional = true, this.resetEndLocation(e4)), this.match(14)) {
              const e5 = this.startNodeAt(t3);
              return e5.expression = r3, e5.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(e5, "TypeCastExpression");
            }
            return r3;
          }
          assertModuleNodeAllowed(e4) {
            "ImportDeclaration" === e4.type && ("type" === e4.importKind || "typeof" === e4.importKind) || "ExportNamedDeclaration" === e4.type && "type" === e4.exportKind || "ExportAllDeclaration" === e4.type && "type" === e4.exportKind || super.assertModuleNodeAllowed(e4);
          }
          parseExportDeclaration(e4) {
            if (this.isContextual(130)) {
              e4.exportKind = "type";
              const t3 = this.startNode();
              return this.next(), this.match(5) ? (e4.specifiers = this.parseExportSpecifiers(true), super.parseExportFrom(e4), null) : this.flowParseTypeAlias(t3);
            }
            if (this.isContextual(131)) {
              e4.exportKind = "type";
              const t3 = this.startNode();
              return this.next(), this.flowParseOpaqueType(t3, false);
            }
            if (this.isContextual(129)) {
              e4.exportKind = "type";
              const t3 = this.startNode();
              return this.next(), this.flowParseInterface(t3);
            }
            if (this.isContextual(126)) {
              e4.exportKind = "value";
              const t3 = this.startNode();
              return this.next(), this.flowParseEnumDeclaration(t3);
            }
            return super.parseExportDeclaration(e4);
          }
          eatExportStar(e4) {
            return !!super.eatExportStar(e4) || !(!this.isContextual(130) || 55 !== this.lookahead().type) && (e4.exportKind = "type", this.next(), this.next(), true);
          }
          maybeParseExportNamespaceSpecifier(e4) {
            const { startLoc: t3 } = this.state, r3 = super.maybeParseExportNamespaceSpecifier(e4);
            return r3 && "type" === e4.exportKind && this.unexpected(t3), r3;
          }
          parseClassId(e4, t3, r3) {
            super.parseClassId(e4, t3, r3), this.match(47) && (e4.typeParameters = this.flowParseTypeParameterDeclaration());
          }
          parseClassMember(e4, t3, r3) {
            const { startLoc: n2 } = this.state;
            if (this.isContextual(125)) {
              if (super.parseClassMemberFromModifier(e4, t3)) return;
              t3.declare = true;
            }
            super.parseClassMember(e4, t3, r3), t3.declare && ("ClassProperty" !== t3.type && "ClassPrivateProperty" !== t3.type && "PropertyDefinition" !== t3.type ? this.raise(U.DeclareClassElement, n2) : t3.value && this.raise(U.DeclareClassFieldInitializer, t3.value));
          }
          isIterator(e4) {
            return "iterator" === e4 || "asyncIterator" === e4;
          }
          readIterator() {
            const e4 = super.readWord1(), t3 = "@@" + e4;
            this.isIterator(e4) && this.state.inType || this.raise(c.InvalidIdentifier, this.state.curPosition(), { identifierName: t3 }), this.finishToken(132, t3);
          }
          getTokenFromCode(e4) {
            const t3 = this.input.charCodeAt(this.state.pos + 1);
            123 === e4 && 124 === t3 ? this.finishOp(6, 2) : !this.state.inType || 62 !== e4 && 60 !== e4 ? this.state.inType && 63 === e4 ? 46 === t3 ? this.finishOp(18, 2) : this.finishOp(17, 1) : !(function(e5, t4, r3) {
              return 64 === e5 && 64 === t4 && isIdentifierStart(r3);
            })(e4, t3, this.input.charCodeAt(this.state.pos + 2)) ? super.getTokenFromCode(e4) : (this.state.pos += 2, this.readIterator()) : this.finishOp(62 === e4 ? 48 : 47, 1);
          }
          isAssignable(e4, t3) {
            return "TypeCastExpression" === e4.type ? this.isAssignable(e4.expression, t3) : super.isAssignable(e4, t3);
          }
          toAssignable(e4, t3 = false) {
            t3 || "AssignmentExpression" !== e4.type || "TypeCastExpression" !== e4.left.type || (e4.left = this.typeCastToParameter(e4.left)), super.toAssignable(e4, t3);
          }
          toAssignableList(e4, t3, r3) {
            for (let t4 = 0; t4 < e4.length; t4++) {
              const r4 = e4[t4];
              "TypeCastExpression" === (null == r4 ? void 0 : r4.type) && (e4[t4] = this.typeCastToParameter(r4));
            }
            super.toAssignableList(e4, t3, r3);
          }
          toReferencedList(e4, t3) {
            for (let n2 = 0; n2 < e4.length; n2++) {
              var r3;
              const s2 = e4[n2];
              !s2 || "TypeCastExpression" !== s2.type || null != (r3 = s2.extra) && r3.parenthesized || !(e4.length > 1) && t3 || this.raise(U.TypeCastInPattern, s2.typeAnnotation);
            }
            return e4;
          }
          parseArrayLike(e4, t3, r3, n2) {
            const s2 = super.parseArrayLike(e4, t3, r3, n2);
            return t3 && !this.state.maybeInArrowParameters && this.toReferencedList(s2.elements), s2;
          }
          isValidLVal(e4, t3, r3) {
            return "TypeCastExpression" === e4 || super.isValidLVal(e4, t3, r3);
          }
          parseClassProperty(e4) {
            return this.match(14) && (e4.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(e4);
          }
          parseClassPrivateProperty(e4) {
            return this.match(14) && (e4.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(e4);
          }
          isClassMethod() {
            return this.match(47) || super.isClassMethod();
          }
          isClassProperty() {
            return this.match(14) || super.isClassProperty();
          }
          isNonstaticConstructor(e4) {
            return !this.match(14) && super.isNonstaticConstructor(e4);
          }
          pushClassMethod(e4, t3, r3, n2, s2, i2) {
            if (t3.variance && this.unexpected(t3.variance.loc.start), delete t3.variance, this.match(47) && (t3.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(e4, t3, r3, n2, s2, i2), t3.params && s2) {
              const e5 = t3.params;
              e5.length > 0 && this.isThisParam(e5[0]) && this.raise(U.ThisParamBannedInConstructor, t3);
            } else if ("MethodDefinition" === t3.type && s2 && t3.value.params) {
              const e5 = t3.value.params;
              e5.length > 0 && this.isThisParam(e5[0]) && this.raise(U.ThisParamBannedInConstructor, t3);
            }
          }
          pushClassPrivateMethod(e4, t3, r3, n2) {
            t3.variance && this.unexpected(t3.variance.loc.start), delete t3.variance, this.match(47) && (t3.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(e4, t3, r3, n2);
          }
          parseClassSuper(e4) {
            if (super.parseClassSuper(e4), e4.superClass && (this.match(47) || this.match(51)) && (e4.superTypeParameters = this.flowParseTypeParameterInstantiationInExpression()), this.isContextual(113)) {
              this.next();
              const t3 = e4.implements = [];
              do {
                const e5 = this.startNode();
                e5.id = this.flowParseRestrictedIdentifier(true), this.match(47) ? e5.typeParameters = this.flowParseTypeParameterInstantiation() : e5.typeParameters = null, t3.push(this.finishNode(e5, "ClassImplements"));
              } while (this.eat(12));
            }
          }
          checkGetterSetterParams(e4) {
            super.checkGetterSetterParams(e4);
            const t3 = this.getObjectOrClassMethodParams(e4);
            if (t3.length > 0) {
              const r3 = t3[0];
              this.isThisParam(r3) && "get" === e4.kind ? this.raise(U.GetterMayNotHaveThisParam, r3) : this.isThisParam(r3) && this.raise(U.SetterMayNotHaveThisParam, r3);
            }
          }
          parsePropertyNamePrefixOperator(e4) {
            e4.variance = this.flowParseVariance();
          }
          parseObjPropValue(e4, t3, r3, n2, s2, i2, o2) {
            let a2;
            e4.variance && this.unexpected(e4.variance.loc.start), delete e4.variance, this.match(47) && !i2 && (a2 = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected());
            const l2 = super.parseObjPropValue(e4, t3, r3, n2, s2, i2, o2);
            return a2 && ((l2.value || l2).typeParameters = a2), l2;
          }
          parseFunctionParamType(e4) {
            return this.eat(17) && ("Identifier" !== e4.type && this.raise(U.PatternIsOptional, e4), this.isThisParam(e4) && this.raise(U.ThisParamMayNotBeOptional, e4), e4.optional = true), this.match(14) ? e4.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(e4) && this.raise(U.ThisParamAnnotationRequired, e4), this.match(29) && this.isThisParam(e4) && this.raise(U.ThisParamNoDefault, e4), this.resetEndLocation(e4), e4;
          }
          parseMaybeDefault(e4, t3) {
            const r3 = super.parseMaybeDefault(e4, t3);
            return "AssignmentPattern" === r3.type && r3.typeAnnotation && r3.right.start < r3.typeAnnotation.start && this.raise(U.TypeBeforeInitializer, r3.typeAnnotation), r3;
          }
          checkImportReflection(e4) {
            super.checkImportReflection(e4), e4.module && "value" !== e4.importKind && this.raise(U.ImportReflectionHasImportType, e4.specifiers[0].loc.start);
          }
          parseImportSpecifierLocal(e4, t3, r3) {
            t3.local = hasTypeImportKind(e4) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier(), e4.specifiers.push(this.finishImportSpecifier(t3, r3));
          }
          isPotentialImportPhase(e4) {
            if (super.isPotentialImportPhase(e4)) return true;
            if (this.isContextual(130)) {
              if (!e4) return true;
              const t3 = this.lookaheadCharCode();
              return 123 === t3 || 42 === t3;
            }
            return !e4 && this.isContextual(87);
          }
          applyImportPhase(e4, t3, r3, n2) {
            if (super.applyImportPhase(e4, t3, r3, n2), t3) {
              if (!r3 && this.match(65)) return;
              e4.exportKind = "type" === r3 ? r3 : "value";
            } else "type" === r3 && this.match(55) && this.unexpected(), e4.importKind = "type" === r3 || "typeof" === r3 ? r3 : "value";
          }
          parseImportSpecifier(e4, t3, r3, n2, s2) {
            const i2 = e4.imported;
            let o2 = null;
            "Identifier" === i2.type && ("type" === i2.name ? o2 = "type" : "typeof" === i2.name && (o2 = "typeof"));
            let a2 = false;
            if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
              const t4 = this.parseIdentifier(true);
              null === o2 || tokenIsKeywordOrIdentifier(this.state.type) ? (e4.imported = i2, e4.importKind = null, e4.local = this.parseIdentifier()) : (e4.imported = t4, e4.importKind = o2, e4.local = this.cloneIdentifier(t4));
            } else {
              if (null !== o2 && tokenIsKeywordOrIdentifier(this.state.type)) e4.imported = this.parseIdentifier(true), e4.importKind = o2;
              else {
                if (t3) throw this.raise(c.ImportBindingIsString, e4, { importName: i2.value });
                e4.imported = i2, e4.importKind = null;
              }
              this.eatContextual(93) ? e4.local = this.parseIdentifier() : (a2 = true, e4.local = this.cloneIdentifier(e4.imported));
            }
            const l2 = hasTypeImportKind(e4);
            return r3 && l2 && this.raise(U.ImportTypeShorthandOnlyInPureImport, e4), (r3 || l2) && this.checkReservedType(e4.local.name, e4.local.loc.start, true), !a2 || r3 || l2 || this.checkReservedWord(e4.local.name, e4.loc.start, true, true), this.finishImportSpecifier(e4, "ImportSpecifier");
          }
          parseBindingAtom() {
            return 78 === this.state.type ? this.parseIdentifier(true) : super.parseBindingAtom();
          }
          parseFunctionParams(e4, t3) {
            const r3 = e4.kind;
            "get" !== r3 && "set" !== r3 && this.match(47) && (e4.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(e4, t3);
          }
          parseVarId(e4, t3) {
            super.parseVarId(e4, t3), this.match(14) && (e4.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(e4.id));
          }
          parseAsyncArrowFromCallExpression(e4, t3) {
            if (this.match(14)) {
              const t4 = this.state.noAnonFunctionType;
              this.state.noAnonFunctionType = true, e4.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = t4;
            }
            return super.parseAsyncArrowFromCallExpression(e4, t3);
          }
          shouldParseAsyncArrow() {
            return this.match(14) || super.shouldParseAsyncArrow();
          }
          parseMaybeAssign(e4, t3) {
            var r3;
            let n2, s2 = null;
            if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
              if (s2 = this.state.clone(), n2 = this.tryParse(() => super.parseMaybeAssign(e4, t3), s2), !n2.error) return n2.node;
              const { context: r4 } = this.state, i3 = r4[r4.length - 1];
              i3 !== d.j_oTag && i3 !== d.j_expr || r4.pop();
            }
            if (null != (r3 = n2) && r3.error || this.match(47)) {
              var i2, o2;
              let r4;
              s2 = s2 || this.state.clone();
              const a2 = this.tryParse((n3) => {
                var s3;
                r4 = this.flowParseTypeParameterDeclaration();
                const i3 = this.forwardNoArrowParamsConversionAt(r4, () => {
                  const n4 = super.parseMaybeAssign(e4, t3);
                  return this.resetStartLocationFromNode(n4, r4), n4;
                });
                null != (s3 = i3.extra) && s3.parenthesized && n3();
                const o3 = this.maybeUnwrapTypeCastExpression(i3);
                return "ArrowFunctionExpression" !== o3.type && n3(), o3.typeParameters = r4, this.resetStartLocationFromNode(o3, r4), i3;
              }, s2);
              let l2 = null;
              if (a2.node && "ArrowFunctionExpression" === this.maybeUnwrapTypeCastExpression(a2.node).type) {
                if (!a2.error && !a2.aborted) return a2.node.async && this.raise(U.UnexpectedTypeParameterBeforeAsyncArrowFunction, r4), a2.node;
                l2 = a2.node;
              }
              if (null != (i2 = n2) && i2.node) return this.state = n2.failState, n2.node;
              if (l2) return this.state = a2.failState, l2;
              if (null != (o2 = n2) && o2.thrown) throw n2.error;
              if (a2.thrown) throw a2.error;
              throw this.raise(U.UnexpectedTokenAfterTypeParameter, r4);
            }
            return super.parseMaybeAssign(e4, t3);
          }
          parseArrow(e4) {
            if (this.match(14)) {
              const t3 = this.tryParse(() => {
                const t4 = this.state.noAnonFunctionType;
                this.state.noAnonFunctionType = true;
                const r3 = this.startNode();
                return [r3.typeAnnotation, e4.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = t4, this.canInsertSemicolon() && this.unexpected(), this.match(19) || this.unexpected(), r3;
              });
              if (t3.thrown) return null;
              t3.error && (this.state = t3.failState), e4.returnType = t3.node.typeAnnotation ? this.finishNode(t3.node, "TypeAnnotation") : null;
            }
            return super.parseArrow(e4);
          }
          shouldParseArrow(e4) {
            return this.match(14) || super.shouldParseArrow(e4);
          }
          setArrowFunctionParameters(e4, t3) {
            this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(e4.start)) ? e4.params = t3 : super.setArrowFunctionParameters(e4, t3);
          }
          checkParams(e4, t3, r3, n2 = true) {
            if (!r3 || !this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(e4.start))) {
              for (let t4 = 0; t4 < e4.params.length; t4++) this.isThisParam(e4.params[t4]) && t4 > 0 && this.raise(U.ThisParamMustBeFirst, e4.params[t4]);
              super.checkParams(e4, t3, r3, n2);
            }
          }
          parseParenAndDistinguishExpression(e4) {
            return super.parseParenAndDistinguishExpression(e4 && !this.state.noArrowAt.includes(this.sourceToOffsetPos(this.state.start)));
          }
          parseSubscripts(e4, t3, r3) {
            if ("Identifier" === e4.type && "async" === e4.name && this.state.noArrowAt.includes(t3.index)) {
              this.next();
              const r4 = this.startNodeAt(t3);
              r4.callee = e4, r4.arguments = super.parseCallExpressionArguments(), e4 = this.finishNode(r4, "CallExpression");
            } else if ("Identifier" === e4.type && "async" === e4.name && this.match(47)) {
              const n2 = this.state.clone(), s2 = this.tryParse((e5) => this.parseAsyncArrowWithTypeParameters(t3) || e5(), n2);
              if (!s2.error && !s2.aborted) return s2.node;
              const i2 = this.tryParse(() => super.parseSubscripts(e4, t3, r3), n2);
              if (i2.node && !i2.error) return i2.node;
              if (s2.node) return this.state = s2.failState, s2.node;
              if (i2.node) return this.state = i2.failState, i2.node;
              throw s2.error || i2.error;
            }
            return super.parseSubscripts(e4, t3, r3);
          }
          parseSubscript(e4, t3, r3, n2) {
            if (this.match(18) && this.isLookaheadToken_lt()) {
              if (n2.optionalChainMember = true, r3) return n2.stop = true, e4;
              this.next();
              const s2 = this.startNodeAt(t3);
              return s2.callee = e4, s2.typeArguments = this.flowParseTypeParameterInstantiationInExpression(), this.expect(10), s2.arguments = this.parseCallExpressionArguments(), s2.optional = true, this.finishCallExpression(s2, true);
            }
            if (!r3 && this.shouldParseTypes() && (this.match(47) || this.match(51))) {
              const r4 = this.startNodeAt(t3);
              r4.callee = e4;
              const s2 = this.tryParse(() => (r4.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), r4.arguments = super.parseCallExpressionArguments(), n2.optionalChainMember && (r4.optional = false), this.finishCallExpression(r4, n2.optionalChainMember)));
              if (s2.node) return s2.error && (this.state = s2.failState), s2.node;
            }
            return super.parseSubscript(e4, t3, r3, n2);
          }
          parseNewCallee(e4) {
            super.parseNewCallee(e4);
            let t3 = null;
            this.shouldParseTypes() && this.match(47) && (t3 = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), e4.typeArguments = t3;
          }
          parseAsyncArrowWithTypeParameters(e4) {
            const t3 = this.startNodeAt(e4);
            if (this.parseFunctionParams(t3, false), this.parseArrow(t3)) return super.parseArrowExpression(t3, void 0, true);
          }
          readToken_mult_modulo(e4) {
            const t3 = this.input.charCodeAt(this.state.pos + 1);
            if (42 === e4 && 47 === t3 && this.state.hasFlowComment) return this.state.hasFlowComment = false, this.state.pos += 2, void this.nextToken();
            super.readToken_mult_modulo(e4);
          }
          readToken_pipe_amp(e4) {
            const t3 = this.input.charCodeAt(this.state.pos + 1);
            124 !== e4 || 125 !== t3 ? super.readToken_pipe_amp(e4) : this.finishOp(9, 2);
          }
          parseTopLevel(e4, t3) {
            const r3 = super.parseTopLevel(e4, t3);
            return this.state.hasFlowComment && this.raise(U.UnterminatedFlowComment, this.state.curPosition()), r3;
          }
          skipBlockComment() {
            if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
              if (this.state.hasFlowComment) throw this.raise(U.NestedFlowComment, this.state.startLoc);
              this.hasFlowCommentCompletion();
              const e4 = this.skipFlowComment();
              return void (e4 && (this.state.pos += e4, this.state.hasFlowComment = true));
            }
            return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
          }
          skipFlowComment() {
            const { pos: e4 } = this.state;
            let t3 = 2;
            for (; [32, 9].includes(this.input.charCodeAt(e4 + t3)); ) t3++;
            const r3 = this.input.charCodeAt(t3 + e4), n2 = this.input.charCodeAt(t3 + e4 + 1);
            return 58 === r3 && 58 === n2 ? t3 + 2 : "flow-include" === this.input.slice(t3 + e4, t3 + e4 + 12) ? t3 + 12 : 58 === r3 && 58 !== n2 && t3;
          }
          hasFlowCommentCompletion() {
            if (-1 === this.input.indexOf("*/", this.state.pos)) throw this.raise(c.UnterminatedComment, this.state.curPosition());
          }
          flowEnumErrorBooleanMemberNotInitialized(e4, { enumName: t3, memberName: r3 }) {
            this.raise(U.EnumBooleanMemberNotInitialized, e4, { memberName: r3, enumName: t3 });
          }
          flowEnumErrorInvalidMemberInitializer(e4, t3) {
            return this.raise(t3.explicitType ? "symbol" === t3.explicitType ? U.EnumInvalidMemberInitializerSymbolType : U.EnumInvalidMemberInitializerPrimaryType : U.EnumInvalidMemberInitializerUnknownType, e4, t3);
          }
          flowEnumErrorNumberMemberNotInitialized(e4, t3) {
            this.raise(U.EnumNumberMemberNotInitialized, e4, t3);
          }
          flowEnumErrorStringMemberInconsistentlyInitialized(e4, t3) {
            this.raise(U.EnumStringMemberInconsistentlyInitialized, e4, t3);
          }
          flowEnumMemberInit() {
            const e4 = this.state.startLoc, endOfInit = () => this.match(12) || this.match(8);
            switch (this.state.type) {
              case 135: {
                const t3 = this.parseNumericLiteral(this.state.value);
                return endOfInit() ? { type: "number", loc: t3.loc.start, value: t3 } : { type: "invalid", loc: e4 };
              }
              case 134: {
                const t3 = this.parseStringLiteral(this.state.value);
                return endOfInit() ? { type: "string", loc: t3.loc.start, value: t3 } : { type: "invalid", loc: e4 };
              }
              case 85:
              case 86: {
                const t3 = this.parseBooleanLiteral(this.match(85));
                return endOfInit() ? { type: "boolean", loc: t3.loc.start, value: t3 } : { type: "invalid", loc: e4 };
              }
              default:
                return { type: "invalid", loc: e4 };
            }
          }
          flowEnumMemberRaw() {
            const e4 = this.state.startLoc;
            return { id: this.parseIdentifier(true), init: this.eat(29) ? this.flowEnumMemberInit() : { type: "none", loc: e4 } };
          }
          flowEnumCheckExplicitTypeMismatch(e4, t3, r3) {
            const { explicitType: n2 } = t3;
            null !== n2 && n2 !== r3 && this.flowEnumErrorInvalidMemberInitializer(e4, t3);
          }
          flowEnumMembers({ enumName: e4, explicitType: t3 }) {
            const r3 = /* @__PURE__ */ new Set(), n2 = { booleanMembers: [], numberMembers: [], stringMembers: [], defaultedMembers: [] };
            let s2 = false;
            for (; !this.match(8); ) {
              if (this.eat(21)) {
                s2 = true;
                break;
              }
              const i2 = this.startNode(), { id: o2, init: a2 } = this.flowEnumMemberRaw(), l2 = o2.name;
              if ("" === l2) continue;
              /^[a-z]/.test(l2) && this.raise(U.EnumInvalidMemberName, o2, { memberName: l2, suggestion: l2[0].toUpperCase() + l2.slice(1), enumName: e4 }), r3.has(l2) && this.raise(U.EnumDuplicateMemberName, o2, { memberName: l2, enumName: e4 }), r3.add(l2);
              const p2 = { enumName: e4, explicitType: t3, memberName: l2 };
              switch (i2.id = o2, a2.type) {
                case "boolean":
                  this.flowEnumCheckExplicitTypeMismatch(a2.loc, p2, "boolean"), i2.init = a2.value, n2.booleanMembers.push(this.finishNode(i2, "EnumBooleanMember"));
                  break;
                case "number":
                  this.flowEnumCheckExplicitTypeMismatch(a2.loc, p2, "number"), i2.init = a2.value, n2.numberMembers.push(this.finishNode(i2, "EnumNumberMember"));
                  break;
                case "string":
                  this.flowEnumCheckExplicitTypeMismatch(a2.loc, p2, "string"), i2.init = a2.value, n2.stringMembers.push(this.finishNode(i2, "EnumStringMember"));
                  break;
                case "invalid":
                  throw this.flowEnumErrorInvalidMemberInitializer(a2.loc, p2);
                case "none":
                  switch (t3) {
                    case "boolean":
                      this.flowEnumErrorBooleanMemberNotInitialized(a2.loc, p2);
                      break;
                    case "number":
                      this.flowEnumErrorNumberMemberNotInitialized(a2.loc, p2);
                      break;
                    default:
                      n2.defaultedMembers.push(this.finishNode(i2, "EnumDefaultedMember"));
                  }
              }
              this.match(8) || this.expect(12);
            }
            return { members: n2, hasUnknownMembers: s2 };
          }
          flowEnumStringMembers(e4, t3, { enumName: r3 }) {
            if (0 === e4.length) return t3;
            if (0 === t3.length) return e4;
            if (t3.length > e4.length) {
              for (const t4 of e4) this.flowEnumErrorStringMemberInconsistentlyInitialized(t4, { enumName: r3 });
              return t3;
            }
            for (const e5 of t3) this.flowEnumErrorStringMemberInconsistentlyInitialized(e5, { enumName: r3 });
            return e4;
          }
          flowEnumParseExplicitType({ enumName: e4 }) {
            if (!this.eatContextual(102)) return null;
            if (!tokenIsIdentifier(this.state.type)) throw this.raise(U.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, { enumName: e4 });
            const { value: t3 } = this.state;
            return this.next(), "boolean" !== t3 && "number" !== t3 && "string" !== t3 && "symbol" !== t3 && this.raise(U.EnumInvalidExplicitType, this.state.startLoc, { enumName: e4, invalidEnumType: t3 }), t3;
          }
          flowEnumBody(e4, t3) {
            const r3 = t3.name, n2 = t3.loc.start, s2 = this.flowEnumParseExplicitType({ enumName: r3 });
            this.expect(5);
            const { members: i2, hasUnknownMembers: o2 } = this.flowEnumMembers({ enumName: r3, explicitType: s2 });
            switch (e4.hasUnknownMembers = o2, s2) {
              case "boolean":
                return e4.explicitType = true, e4.members = i2.booleanMembers, this.expect(8), this.finishNode(e4, "EnumBooleanBody");
              case "number":
                return e4.explicitType = true, e4.members = i2.numberMembers, this.expect(8), this.finishNode(e4, "EnumNumberBody");
              case "string":
                return e4.explicitType = true, e4.members = this.flowEnumStringMembers(i2.stringMembers, i2.defaultedMembers, { enumName: r3 }), this.expect(8), this.finishNode(e4, "EnumStringBody");
              case "symbol":
                return e4.members = i2.defaultedMembers, this.expect(8), this.finishNode(e4, "EnumSymbolBody");
              default: {
                const empty = () => (e4.members = [], this.expect(8), this.finishNode(e4, "EnumStringBody"));
                e4.explicitType = false;
                const t4 = i2.booleanMembers.length, s3 = i2.numberMembers.length, o3 = i2.stringMembers.length, a2 = i2.defaultedMembers.length;
                if (t4 || s3 || o3 || a2) {
                  if (t4 || s3) {
                    if (!s3 && !o3 && t4 >= a2) {
                      for (const e5 of i2.defaultedMembers) this.flowEnumErrorBooleanMemberNotInitialized(e5.loc.start, { enumName: r3, memberName: e5.id.name });
                      return e4.members = i2.booleanMembers, this.expect(8), this.finishNode(e4, "EnumBooleanBody");
                    }
                    if (!t4 && !o3 && s3 >= a2) {
                      for (const e5 of i2.defaultedMembers) this.flowEnumErrorNumberMemberNotInitialized(e5.loc.start, { enumName: r3, memberName: e5.id.name });
                      return e4.members = i2.numberMembers, this.expect(8), this.finishNode(e4, "EnumNumberBody");
                    }
                    return this.raise(U.EnumInconsistentMemberValues, n2, { enumName: r3 }), empty();
                  }
                  return e4.members = this.flowEnumStringMembers(i2.stringMembers, i2.defaultedMembers, { enumName: r3 }), this.expect(8), this.finishNode(e4, "EnumStringBody");
                }
                return empty();
              }
            }
          }
          flowParseEnumDeclaration(e4) {
            const t3 = this.parseIdentifier();
            return e4.id = t3, e4.body = this.flowEnumBody(this.startNode(), t3), this.finishNode(e4, "EnumDeclaration");
          }
          jsxParseOpeningElementAfterName(e4) {
            return this.shouldParseTypes() && (this.match(47) || this.match(51)) && (e4.typeArguments = this.flowParseTypeParameterInstantiationInExpression()), super.jsxParseOpeningElementAfterName(e4);
          }
          isLookaheadToken_lt() {
            const e4 = this.nextTokenStart();
            if (60 === this.input.charCodeAt(e4)) {
              const t3 = this.input.charCodeAt(e4 + 1);
              return 60 !== t3 && 61 !== t3;
            }
            return false;
          }
          reScan_lt_gt() {
            const { type: e4 } = this.state;
            47 === e4 ? (this.state.pos -= 1, this.readToken_lt()) : 48 === e4 && (this.state.pos -= 1, this.readToken_gt());
          }
          reScan_lt() {
            const { type: e4 } = this.state;
            return 51 === e4 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : e4;
          }
          maybeUnwrapTypeCastExpression(e4) {
            return "TypeCastExpression" === e4.type ? e4.expression : e4;
          }
        }, typescript: (e3) => class extends e3 {
          constructor(...e4) {
            super(...e4), this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, { allowedModifiers: ["in", "out"], disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"], errorTemplate: Q.InvalidModifierOnTypeParameter }), this.tsParseConstModifier = this.tsParseModifiers.bind(this, { allowedModifiers: ["const"], disallowedModifiers: ["in", "out"], errorTemplate: Q.InvalidModifierOnTypeParameterPositions }), this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, { allowedModifiers: ["in", "out", "const"], disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"], errorTemplate: Q.InvalidModifierOnTypeParameter });
          }
          getScopeHandler() {
            return TypeScriptScopeHandler;
          }
          tsIsIdentifier() {
            return tokenIsIdentifier(this.state.type);
          }
          tsTokenCanFollowModifier() {
            return this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(139) || this.isLiteralPropertyName();
          }
          tsNextTokenOnSameLineAndCanFollowModifier() {
            return this.next(), !this.hasPrecedingLineBreak() && this.tsTokenCanFollowModifier();
          }
          tsNextTokenCanFollowModifier() {
            return this.match(106) ? (this.next(), this.tsTokenCanFollowModifier()) : this.tsNextTokenOnSameLineAndCanFollowModifier();
          }
          tsParseModifier(e4, t3, r3) {
            if (!tokenIsIdentifier(this.state.type) && 58 !== this.state.type && 75 !== this.state.type) return;
            const n2 = this.state.value;
            if (e4.includes(n2)) {
              if (r3 && this.match(106)) return;
              if (t3 && this.tsIsStartOfStaticBlocks()) return;
              if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) return n2;
            }
          }
          tsParseModifiers({ allowedModifiers: e4, disallowedModifiers: t3, stopOnStartOfClassStaticBlock: r3, errorTemplate: n2 = Q.InvalidModifierOnTypeMember }, s2) {
            const enforceOrder = (e5, t4, r4, n3) => {
              t4 === r4 && s2[n3] && this.raise(Q.InvalidModifiersOrder, e5, { orderedModifiers: [r4, n3] });
            }, incompatible = (e5, t4, r4, n3) => {
              (s2[r4] && t4 === n3 || s2[n3] && t4 === r4) && this.raise(Q.IncompatibleModifiers, e5, { modifiers: [r4, n3] });
            };
            for (; ; ) {
              const { startLoc: i2 } = this.state, o2 = this.tsParseModifier(e4.concat(null != t3 ? t3 : []), r3, s2.static);
              if (!o2) break;
              tsIsAccessModifier(o2) ? s2.accessibility ? this.raise(Q.DuplicateAccessibilityModifier, i2, { modifier: o2 }) : (enforceOrder(i2, o2, o2, "override"), enforceOrder(i2, o2, o2, "static"), enforceOrder(i2, o2, o2, "readonly"), s2.accessibility = o2) : tsIsVarianceAnnotations(o2) ? (s2[o2] && this.raise(Q.DuplicateModifier, i2, { modifier: o2 }), s2[o2] = true, enforceOrder(i2, o2, "in", "out")) : (hasOwnProperty.call(s2, o2) ? this.raise(Q.DuplicateModifier, i2, { modifier: o2 }) : (enforceOrder(i2, o2, "static", "readonly"), enforceOrder(i2, o2, "static", "override"), enforceOrder(i2, o2, "override", "readonly"), enforceOrder(i2, o2, "abstract", "override"), incompatible(i2, o2, "declare", "override"), incompatible(i2, o2, "static", "abstract")), s2[o2] = true), null != t3 && t3.includes(o2) && this.raise(n2, i2, { modifier: o2 });
            }
          }
          tsIsListTerminator(e4) {
            switch (e4) {
              case "EnumMembers":
              case "TypeMembers":
                return this.match(8);
              case "HeritageClauseElement":
                return this.match(5);
              case "TupleElementTypes":
                return this.match(3);
              case "TypeParametersOrArguments":
                return this.match(48);
            }
          }
          tsParseList(e4, t3) {
            const r3 = [];
            for (; !this.tsIsListTerminator(e4); ) r3.push(t3());
            return r3;
          }
          tsParseDelimitedList(e4, t3, r3) {
            return (function(e5) {
              if (null == e5) throw new Error(`Unexpected ${e5} value.`);
              return e5;
            })(this.tsParseDelimitedListWorker(e4, t3, true, r3));
          }
          tsParseDelimitedListWorker(e4, t3, r3, n2) {
            const s2 = [];
            let i2 = -1;
            for (; !this.tsIsListTerminator(e4); ) {
              i2 = -1;
              const n3 = t3();
              if (null == n3) return;
              if (s2.push(n3), !this.eat(12)) {
                if (this.tsIsListTerminator(e4)) break;
                return void (r3 && this.expect(12));
              }
              i2 = this.state.lastTokStartLoc.index;
            }
            return n2 && (n2.value = i2), s2;
          }
          tsParseBracketedList(e4, t3, r3, n2, s2) {
            n2 || (r3 ? this.expect(0) : this.expect(47));
            const i2 = this.tsParseDelimitedList(e4, t3, s2);
            return r3 ? this.expect(3) : this.expect(48), i2;
          }
          tsParseImportType() {
            const e4 = this.startNode();
            return this.expect(83), this.expect(10), this.match(134) ? e4.argument = this.parseStringLiteral(this.state.value) : (this.raise(Q.UnsupportedImportTypeArgument, this.state.startLoc), e4.argument = super.parseExprAtom()), this.eat(12) ? e4.options = this.tsParseImportTypeOptions() : e4.options = null, this.expect(11), this.eat(16) && (e4.qualifier = this.tsParseEntityName(3)), this.match(47) && (e4.typeParameters = this.tsParseTypeArguments()), this.finishNode(e4, "TSImportType");
          }
          tsParseImportTypeOptions() {
            const e4 = this.startNode();
            this.expect(5);
            const t3 = this.startNode();
            return this.isContextual(76) ? (t3.method = false, t3.key = this.parseIdentifier(true), t3.computed = false, t3.shorthand = false) : this.unexpected(null, 76), this.expect(14), t3.value = this.tsParseImportTypeWithPropertyValue(), e4.properties = [this.finishObjectProperty(t3)], this.eat(12), this.expect(8), this.finishNode(e4, "ObjectExpression");
          }
          tsParseImportTypeWithPropertyValue() {
            const e4 = this.startNode(), t3 = [];
            for (this.expect(5); !this.match(8); ) {
              const e5 = this.state.type;
              tokenIsIdentifier(e5) || 134 === e5 ? t3.push(super.parsePropertyDefinition(null)) : this.unexpected(), this.eat(12);
            }
            return e4.properties = t3, this.next(), this.finishNode(e4, "ObjectExpression");
          }
          tsParseEntityName(e4) {
            let t3;
            if (1 & e4 && this.match(78)) if (2 & e4) t3 = this.parseIdentifier(true);
            else {
              const e5 = this.startNode();
              this.next(), t3 = this.finishNode(e5, "ThisExpression");
            }
            else t3 = this.parseIdentifier(!!(1 & e4));
            for (; this.eat(16); ) {
              const r3 = this.startNodeAtNode(t3);
              r3.left = t3, r3.right = this.parseIdentifier(!!(1 & e4)), t3 = this.finishNode(r3, "TSQualifiedName");
            }
            return t3;
          }
          tsParseTypeReference() {
            const e4 = this.startNode();
            return e4.typeName = this.tsParseEntityName(1), !this.hasPrecedingLineBreak() && this.match(47) && (e4.typeParameters = this.tsParseTypeArguments()), this.finishNode(e4, "TSTypeReference");
          }
          tsParseThisTypePredicate(e4) {
            this.next();
            const t3 = this.startNodeAtNode(e4);
            return t3.parameterName = e4, t3.typeAnnotation = this.tsParseTypeAnnotation(false), t3.asserts = false, this.finishNode(t3, "TSTypePredicate");
          }
          tsParseThisTypeNode() {
            const e4 = this.startNode();
            return this.next(), this.finishNode(e4, "TSThisType");
          }
          tsParseTypeQuery() {
            const e4 = this.startNode();
            return this.expect(87), this.match(83) ? e4.exprName = this.tsParseImportType() : e4.exprName = this.tsParseEntityName(3), !this.hasPrecedingLineBreak() && this.match(47) && (e4.typeParameters = this.tsParseTypeArguments()), this.finishNode(e4, "TSTypeQuery");
          }
          tsParseTypeParameter(e4) {
            const t3 = this.startNode();
            return e4(t3), t3.name = this.tsParseTypeParameterName(), t3.constraint = this.tsEatThenParseType(81), t3.default = this.tsEatThenParseType(29), this.finishNode(t3, "TSTypeParameter");
          }
          tsTryParseTypeParameters(e4) {
            if (this.match(47)) return this.tsParseTypeParameters(e4);
          }
          tsParseTypeParameters(e4) {
            const t3 = this.startNode();
            this.match(47) || this.match(143) ? this.next() : this.unexpected();
            const r3 = { value: -1 };
            return t3.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, e4), false, true, r3), 0 === t3.params.length && this.raise(Q.EmptyTypeParameters, t3), -1 !== r3.value && this.addExtra(t3, "trailingComma", r3.value), this.finishNode(t3, "TSTypeParameterDeclaration");
          }
          tsFillSignature(e4, t3) {
            const r3 = 19 === e4, n2 = "typeAnnotation";
            t3.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier), this.expect(10), t3.parameters = this.tsParseBindingListForSignature(), (r3 || this.match(e4)) && (t3[n2] = this.tsParseTypeOrTypePredicateAnnotation(e4));
          }
          tsParseBindingListForSignature() {
            const e4 = super.parseBindingList(11, 41, 2);
            for (const t3 of e4) {
              const { type: e5 } = t3;
              "AssignmentPattern" !== e5 && "TSParameterProperty" !== e5 || this.raise(Q.UnsupportedSignatureParameterKind, t3, { type: e5 });
            }
            return e4;
          }
          tsParseTypeMemberSemicolon() {
            this.eat(12) || this.isLineTerminator() || this.expect(13);
          }
          tsParseSignatureMember(e4, t3) {
            return this.tsFillSignature(14, t3), this.tsParseTypeMemberSemicolon(), this.finishNode(t3, e4);
          }
          tsIsUnambiguouslyIndexSignature() {
            return this.next(), !!tokenIsIdentifier(this.state.type) && (this.next(), this.match(14));
          }
          tsTryParseIndexSignature(e4) {
            if (!this.match(0) || !this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))) return;
            this.expect(0);
            const t3 = this.parseIdentifier();
            t3.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(t3), this.expect(3), e4.parameters = [t3];
            const r3 = this.tsTryParseTypeAnnotation();
            return r3 && (e4.typeAnnotation = r3), this.tsParseTypeMemberSemicolon(), this.finishNode(e4, "TSIndexSignature");
          }
          tsParsePropertyOrMethodSignature(e4, t3) {
            if (this.eat(17) && (e4.optional = true), this.match(10) || this.match(47)) {
              t3 && this.raise(Q.ReadonlyForMethodSignature, e4);
              const r3 = e4;
              r3.kind && this.match(47) && this.raise(Q.AccessorCannotHaveTypeParameters, this.state.curPosition()), this.tsFillSignature(14, r3), this.tsParseTypeMemberSemicolon();
              const n2 = "parameters", s2 = "typeAnnotation";
              if ("get" === r3.kind) r3[n2].length > 0 && (this.raise(c.BadGetterArity, this.state.curPosition()), this.isThisParam(r3[n2][0]) && this.raise(Q.AccessorCannotDeclareThisParameter, this.state.curPosition()));
              else if ("set" === r3.kind) {
                if (1 !== r3[n2].length) this.raise(c.BadSetterArity, this.state.curPosition());
                else {
                  const e5 = r3[n2][0];
                  this.isThisParam(e5) && this.raise(Q.AccessorCannotDeclareThisParameter, this.state.curPosition()), "Identifier" === e5.type && e5.optional && this.raise(Q.SetAccessorCannotHaveOptionalParameter, this.state.curPosition()), "RestElement" === e5.type && this.raise(Q.SetAccessorCannotHaveRestParameter, this.state.curPosition());
                }
                r3[s2] && this.raise(Q.SetAccessorCannotHaveReturnType, r3[s2]);
              } else r3.kind = "method";
              return this.finishNode(r3, "TSMethodSignature");
            }
            {
              const r3 = e4;
              t3 && (r3.readonly = true);
              const n2 = this.tsTryParseTypeAnnotation();
              return n2 && (r3.typeAnnotation = n2), this.tsParseTypeMemberSemicolon(), this.finishNode(r3, "TSPropertySignature");
            }
          }
          tsParseTypeMember() {
            const e4 = this.startNode();
            if (this.match(10) || this.match(47)) return this.tsParseSignatureMember("TSCallSignatureDeclaration", e4);
            if (this.match(77)) {
              const t4 = this.startNode();
              return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", e4) : (e4.key = this.createIdentifier(t4, "new"), this.tsParsePropertyOrMethodSignature(e4, false));
            }
            this.tsParseModifiers({ allowedModifiers: ["readonly"], disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"] }, e4);
            const t3 = this.tsTryParseIndexSignature(e4);
            return t3 || (super.parsePropertyName(e4), e4.computed || "Identifier" !== e4.key.type || "get" !== e4.key.name && "set" !== e4.key.name || !this.tsTokenCanFollowModifier() || (e4.kind = e4.key.name, super.parsePropertyName(e4), this.match(10) || this.match(47) || this.unexpected(null, 10)), this.tsParsePropertyOrMethodSignature(e4, !!e4.readonly));
          }
          tsParseTypeLiteral() {
            const e4 = this.startNode();
            return e4.members = this.tsParseObjectTypeMembers(), this.finishNode(e4, "TSTypeLiteral");
          }
          tsParseObjectTypeMembers() {
            this.expect(5);
            const e4 = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
            return this.expect(8), e4;
          }
          tsIsStartOfMappedType() {
            return this.next(), this.eat(53) ? this.isContextual(122) : (this.isContextual(122) && this.next(), !!this.match(0) && (this.next(), !!this.tsIsIdentifier() && (this.next(), this.match(58))));
          }
          tsParseMappedType() {
            const e4 = this.startNode();
            this.expect(5), this.match(53) ? (e4.readonly = this.state.value, this.next(), this.expectContextual(122)) : this.eatContextual(122) && (e4.readonly = true), this.expect(0);
            {
              const t3 = this.startNode();
              t3.name = this.tsParseTypeParameterName(), t3.constraint = this.tsExpectThenParseType(58), e4.typeParameter = this.finishNode(t3, "TSTypeParameter");
            }
            return e4.nameType = this.eatContextual(93) ? this.tsParseType() : null, this.expect(3), this.match(53) ? (e4.optional = this.state.value, this.next(), this.expect(17)) : this.eat(17) && (e4.optional = true), e4.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(8), this.finishNode(e4, "TSMappedType");
          }
          tsParseTupleType() {
            const e4 = this.startNode();
            e4.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
            let t3 = false;
            return e4.elementTypes.forEach((e5) => {
              const { type: r3 } = e5;
              !t3 || "TSRestType" === r3 || "TSOptionalType" === r3 || "TSNamedTupleMember" === r3 && e5.optional || this.raise(Q.OptionalTypeBeforeRequired, e5), t3 || (t3 = "TSNamedTupleMember" === r3 && e5.optional || "TSOptionalType" === r3);
            }), this.finishNode(e4, "TSTupleType");
          }
          tsParseTupleElementType() {
            const e4 = this.state.startLoc, t3 = this.eat(21), { startLoc: r3 } = this.state;
            let n2, s2, i2, o2;
            const a2 = tokenIsKeywordOrIdentifier(this.state.type) ? this.lookaheadCharCode() : null;
            if (58 === a2) n2 = true, i2 = false, s2 = this.parseIdentifier(true), this.expect(14), o2 = this.tsParseType();
            else if (63 === a2) {
              i2 = true;
              const e5 = this.state.value, t4 = this.tsParseNonArrayType();
              58 === this.lookaheadCharCode() ? (n2 = true, s2 = this.createIdentifier(this.startNodeAt(r3), e5), this.expect(17), this.expect(14), o2 = this.tsParseType()) : (n2 = false, o2 = t4, this.expect(17));
            } else o2 = this.tsParseType(), i2 = this.eat(17), n2 = this.eat(14);
            if (n2) {
              let e5;
              s2 ? (e5 = this.startNodeAt(r3), e5.optional = i2, e5.label = s2, e5.elementType = o2, this.eat(17) && (e5.optional = true, this.raise(Q.TupleOptionalAfterType, this.state.lastTokStartLoc))) : (e5 = this.startNodeAt(r3), e5.optional = i2, this.raise(Q.InvalidTupleMemberLabel, o2), e5.label = o2, e5.elementType = this.tsParseType()), o2 = this.finishNode(e5, "TSNamedTupleMember");
            } else if (i2) {
              const e5 = this.startNodeAt(r3);
              e5.typeAnnotation = o2, o2 = this.finishNode(e5, "TSOptionalType");
            }
            if (t3) {
              const t4 = this.startNodeAt(e4);
              t4.typeAnnotation = o2, o2 = this.finishNode(t4, "TSRestType");
            }
            return o2;
          }
          tsParseParenthesizedType() {
            const e4 = this.startNode();
            return this.expect(10), e4.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(e4, "TSParenthesizedType");
          }
          tsParseFunctionOrConstructorType(e4, t3) {
            const r3 = this.startNode();
            return "TSConstructorType" === e4 && (r3.abstract = !!t3, t3 && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, r3)), this.finishNode(r3, e4);
          }
          tsParseLiteralTypeNode() {
            const e4 = this.startNode();
            switch (this.state.type) {
              case 135:
              case 136:
              case 134:
              case 85:
              case 86:
                e4.literal = super.parseExprAtom();
                break;
              default:
                this.unexpected();
            }
            return this.finishNode(e4, "TSLiteralType");
          }
          tsParseTemplateLiteralType() {
            {
              const e4 = this.startNode();
              return e4.literal = super.parseTemplate(false), this.finishNode(e4, "TSLiteralType");
            }
          }
          parseTemplateSubstitution() {
            return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
          }
          tsParseThisTypeOrThisTypePredicate() {
            const e4 = this.tsParseThisTypeNode();
            return this.isContextual(116) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(e4) : e4;
          }
          tsParseNonArrayType() {
            switch (this.state.type) {
              case 134:
              case 135:
              case 136:
              case 85:
              case 86:
                return this.tsParseLiteralTypeNode();
              case 53:
                if ("-" === this.state.value) {
                  const e4 = this.startNode(), t3 = this.lookahead();
                  return 135 !== t3.type && 136 !== t3.type && this.unexpected(), e4.literal = this.parseMaybeUnary(), this.finishNode(e4, "TSLiteralType");
                }
                break;
              case 78:
                return this.tsParseThisTypeOrThisTypePredicate();
              case 87:
                return this.tsParseTypeQuery();
              case 83:
                return this.tsParseImportType();
              case 5:
                return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
              case 0:
                return this.tsParseTupleType();
              case 10:
                return this.tsParseParenthesizedType();
              case 25:
              case 24:
                return this.tsParseTemplateLiteralType();
              default: {
                const { type: e4 } = this.state;
                if (tokenIsIdentifier(e4) || 88 === e4 || 84 === e4) {
                  const t3 = 88 === e4 ? "TSVoidKeyword" : 84 === e4 ? "TSNullKeyword" : (function(e5) {
                    switch (e5) {
                      case "any":
                        return "TSAnyKeyword";
                      case "boolean":
                        return "TSBooleanKeyword";
                      case "bigint":
                        return "TSBigIntKeyword";
                      case "never":
                        return "TSNeverKeyword";
                      case "number":
                        return "TSNumberKeyword";
                      case "object":
                        return "TSObjectKeyword";
                      case "string":
                        return "TSStringKeyword";
                      case "symbol":
                        return "TSSymbolKeyword";
                      case "undefined":
                        return "TSUndefinedKeyword";
                      case "unknown":
                        return "TSUnknownKeyword";
                      default:
                        return;
                    }
                  })(this.state.value);
                  if (void 0 !== t3 && 46 !== this.lookaheadCharCode()) {
                    const e5 = this.startNode();
                    return this.next(), this.finishNode(e5, t3);
                  }
                  return this.tsParseTypeReference();
                }
              }
            }
            this.unexpected();
          }
          tsParseArrayTypeOrHigher() {
            const { startLoc: e4 } = this.state;
            let t3 = this.tsParseNonArrayType();
            for (; !this.hasPrecedingLineBreak() && this.eat(0); ) if (this.match(3)) {
              const r3 = this.startNodeAt(e4);
              r3.elementType = t3, this.expect(3), t3 = this.finishNode(r3, "TSArrayType");
            } else {
              const r3 = this.startNodeAt(e4);
              r3.objectType = t3, r3.indexType = this.tsParseType(), this.expect(3), t3 = this.finishNode(r3, "TSIndexedAccessType");
            }
            return t3;
          }
          tsParseTypeOperator() {
            const e4 = this.startNode(), t3 = this.state.value;
            return this.next(), e4.operator = t3, e4.typeAnnotation = this.tsParseTypeOperatorOrHigher(), "readonly" === t3 && this.tsCheckTypeAnnotationForReadOnly(e4), this.finishNode(e4, "TSTypeOperator");
          }
          tsCheckTypeAnnotationForReadOnly(e4) {
            switch (e4.typeAnnotation.type) {
              case "TSTupleType":
              case "TSArrayType":
                return;
              default:
                this.raise(Q.UnexpectedReadonly, e4);
            }
          }
          tsParseInferType() {
            const e4 = this.startNode();
            this.expectContextual(115);
            const t3 = this.startNode();
            return t3.name = this.tsParseTypeParameterName(), t3.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), e4.typeParameter = this.finishNode(t3, "TSTypeParameter"), this.finishNode(e4, "TSInferType");
          }
          tsParseConstraintForInferType() {
            if (this.eat(81)) {
              const e4 = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
              if (this.state.inDisallowConditionalTypesContext || !this.match(17)) return e4;
            }
          }
          tsParseTypeOperatorOrHigher() {
            var e4;
            return (e4 = this.state.type) >= 121 && e4 <= 123 && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
          }
          tsParseUnionOrIntersectionType(e4, t3, r3) {
            const n2 = this.startNode(), s2 = this.eat(r3), i2 = [];
            do {
              i2.push(t3());
            } while (this.eat(r3));
            return 1 !== i2.length || s2 ? (n2.types = i2, this.finishNode(n2, e4)) : i2[0];
          }
          tsParseIntersectionTypeOrHigher() {
            return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
          }
          tsParseUnionTypeOrHigher() {
            return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
          }
          tsIsStartOfFunctionType() {
            return !!this.match(47) || this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
          }
          tsSkipParameterStart() {
            if (tokenIsIdentifier(this.state.type) || this.match(78)) return this.next(), true;
            if (this.match(5)) {
              const { errors: e4 } = this.state, t3 = e4.length;
              try {
                return this.parseObjectLike(8, true), e4.length === t3;
              } catch (e5) {
                return false;
              }
            }
            if (this.match(0)) {
              this.next();
              const { errors: e4 } = this.state, t3 = e4.length;
              try {
                return super.parseBindingList(3, 93, 1), e4.length === t3;
              } catch (e5) {
                return false;
              }
            }
            return false;
          }
          tsIsUnambiguouslyStartOfFunctionType() {
            if (this.next(), this.match(11) || this.match(21)) return true;
            if (this.tsSkipParameterStart()) {
              if (this.match(14) || this.match(12) || this.match(17) || this.match(29)) return true;
              if (this.match(11) && (this.next(), this.match(19))) return true;
            }
            return false;
          }
          tsParseTypeOrTypePredicateAnnotation(e4) {
            return this.tsInType(() => {
              const t3 = this.startNode();
              this.expect(e4);
              const r3 = this.startNode(), n2 = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
              if (n2 && this.match(78)) {
                let e5 = this.tsParseThisTypeOrThisTypePredicate();
                return "TSThisType" === e5.type ? (r3.parameterName = e5, r3.asserts = true, r3.typeAnnotation = null, e5 = this.finishNode(r3, "TSTypePredicate")) : (this.resetStartLocationFromNode(e5, r3), e5.asserts = true), t3.typeAnnotation = e5, this.finishNode(t3, "TSTypeAnnotation");
              }
              const s2 = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
              if (!s2) return n2 ? (r3.parameterName = this.parseIdentifier(), r3.asserts = n2, r3.typeAnnotation = null, t3.typeAnnotation = this.finishNode(r3, "TSTypePredicate"), this.finishNode(t3, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(false, t3);
              const i2 = this.tsParseTypeAnnotation(false);
              return r3.parameterName = s2, r3.typeAnnotation = i2, r3.asserts = n2, t3.typeAnnotation = this.finishNode(r3, "TSTypePredicate"), this.finishNode(t3, "TSTypeAnnotation");
            });
          }
          tsTryParseTypeOrTypePredicateAnnotation() {
            if (this.match(14)) return this.tsParseTypeOrTypePredicateAnnotation(14);
          }
          tsTryParseTypeAnnotation() {
            if (this.match(14)) return this.tsParseTypeAnnotation();
          }
          tsTryParseType() {
            return this.tsEatThenParseType(14);
          }
          tsParseTypePredicatePrefix() {
            const e4 = this.parseIdentifier();
            if (this.isContextual(116) && !this.hasPrecedingLineBreak()) return this.next(), e4;
          }
          tsParseTypePredicateAsserts() {
            if (109 !== this.state.type) return false;
            const e4 = this.state.containsEsc;
            return this.next(), !(!tokenIsIdentifier(this.state.type) && !this.match(78)) && (e4 && this.raise(c.InvalidEscapedReservedWord, this.state.lastTokStartLoc, { reservedWord: "asserts" }), true);
          }
          tsParseTypeAnnotation(e4 = true, t3 = this.startNode()) {
            return this.tsInType(() => {
              e4 && this.expect(14), t3.typeAnnotation = this.tsParseType();
            }), this.finishNode(t3, "TSTypeAnnotation");
          }
          tsParseType() {
            assert(this.state.inType);
            const e4 = this.tsParseNonConditionalType();
            if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) return e4;
            const t3 = this.startNodeAtNode(e4);
            return t3.checkType = e4, t3.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(17), t3.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), t3.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.finishNode(t3, "TSConditionalType");
          }
          isAbstractConstructorSignature() {
            return this.isContextual(124) && this.isLookaheadContextual("new");
          }
          tsParseNonConditionalType() {
            return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", true) : this.tsParseUnionTypeOrHigher();
          }
          tsParseTypeAssertion() {
            this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(Q.ReservedTypeAssertion, this.state.startLoc);
            const e4 = this.startNode();
            return e4.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType())), this.expect(48), e4.expression = this.parseMaybeUnary(), this.finishNode(e4, "TSTypeAssertion");
          }
          tsParseHeritageClause(e4) {
            const t3 = this.state.startLoc, r3 = this.tsParseDelimitedList("HeritageClauseElement", () => {
              {
                const e5 = this.startNode();
                return e5.expression = this.tsParseEntityName(3), this.match(47) && (e5.typeParameters = this.tsParseTypeArguments()), this.finishNode(e5, "TSExpressionWithTypeArguments");
              }
            });
            return r3.length || this.raise(Q.EmptyHeritageClauseType, t3, { token: e4 }), r3;
          }
          tsParseInterfaceDeclaration(e4, t3 = {}) {
            if (this.hasFollowingLineBreak()) return null;
            this.expectContextual(129), t3.declare && (e4.declare = true), tokenIsIdentifier(this.state.type) ? (e4.id = this.parseIdentifier(), this.checkIdentifier(e4.id, 130)) : (e4.id = null, this.raise(Q.MissingInterfaceName, this.state.startLoc)), e4.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers), this.eat(81) && (e4.extends = this.tsParseHeritageClause("extends"));
            const r3 = this.startNode();
            return r3.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), e4.body = this.finishNode(r3, "TSInterfaceBody"), this.finishNode(e4, "TSInterfaceDeclaration");
          }
          tsParseTypeAliasDeclaration(e4) {
            return e4.id = this.parseIdentifier(), this.checkIdentifier(e4.id, 2), e4.typeAnnotation = this.tsInType(() => {
              if (e4.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers), this.expect(29), this.isContextual(114) && 46 !== this.lookaheadCharCode()) {
                const e5 = this.startNode();
                return this.next(), this.finishNode(e5, "TSIntrinsicKeyword");
              }
              return this.tsParseType();
            }), this.semicolon(), this.finishNode(e4, "TSTypeAliasDeclaration");
          }
          tsInTopLevelContext(e4) {
            if (this.curContext() === d.brace) return e4();
            {
              const t3 = this.state.context;
              this.state.context = [t3[0]];
              try {
                return e4();
              } finally {
                this.state.context = t3;
              }
            }
          }
          tsInType(e4) {
            const t3 = this.state.inType;
            this.state.inType = true;
            try {
              return e4();
            } finally {
              this.state.inType = t3;
            }
          }
          tsInDisallowConditionalTypesContext(e4) {
            const t3 = this.state.inDisallowConditionalTypesContext;
            this.state.inDisallowConditionalTypesContext = true;
            try {
              return e4();
            } finally {
              this.state.inDisallowConditionalTypesContext = t3;
            }
          }
          tsInAllowConditionalTypesContext(e4) {
            const t3 = this.state.inDisallowConditionalTypesContext;
            this.state.inDisallowConditionalTypesContext = false;
            try {
              return e4();
            } finally {
              this.state.inDisallowConditionalTypesContext = t3;
            }
          }
          tsEatThenParseType(e4) {
            if (this.match(e4)) return this.tsNextThenParseType();
          }
          tsExpectThenParseType(e4) {
            return this.tsInType(() => (this.expect(e4), this.tsParseType()));
          }
          tsNextThenParseType() {
            return this.tsInType(() => (this.next(), this.tsParseType()));
          }
          tsParseEnumMember() {
            const e4 = this.startNode();
            return e4.id = this.match(134) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(true), this.eat(29) && (e4.initializer = super.parseMaybeAssignAllowIn()), this.finishNode(e4, "TSEnumMember");
          }
          tsParseEnumDeclaration(e4, t3 = {}) {
            return t3.const && (e4.const = true), t3.declare && (e4.declare = true), this.expectContextual(126), e4.id = this.parseIdentifier(), this.checkIdentifier(e4.id, e4.const ? 8971 : 8459), this.expect(5), e4.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(e4, "TSEnumDeclaration");
          }
          tsParseEnumBody() {
            const e4 = this.startNode();
            return this.expect(5), e4.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(e4, "TSEnumBody");
          }
          tsParseModuleBlock() {
            const e4 = this.startNode();
            return this.scope.enter(0), this.expect(5), super.parseBlockOrModuleBlockBody(e4.body = [], void 0, true, 8), this.scope.exit(), this.finishNode(e4, "TSModuleBlock");
          }
          tsParseModuleOrNamespaceDeclaration(e4, t3 = false) {
            if (e4.id = this.parseIdentifier(), t3 || this.checkIdentifier(e4.id, 1024), this.eat(16)) {
              const t4 = this.startNode();
              this.tsParseModuleOrNamespaceDeclaration(t4, true), e4.body = t4;
            } else this.scope.enter(1024), this.prodParam.enter(0), e4.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
            return this.finishNode(e4, "TSModuleDeclaration");
          }
          tsParseAmbientExternalModuleDeclaration(e4) {
            return this.isContextual(112) ? (e4.kind = "global", e4.global = true, e4.id = this.parseIdentifier()) : this.match(134) ? (e4.kind = "module", e4.id = super.parseStringLiteral(this.state.value)) : this.unexpected(), this.match(5) ? (this.scope.enter(1024), this.prodParam.enter(0), e4.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(e4, "TSModuleDeclaration");
          }
          tsParseImportEqualsDeclaration(e4, t3, r3) {
            e4.isExport = r3 || false, e4.id = t3 || this.parseIdentifier(), this.checkIdentifier(e4.id, 4096), this.expect(29);
            const n2 = this.tsParseModuleReference();
            return "type" === e4.importKind && "TSExternalModuleReference" !== n2.type && this.raise(Q.ImportAliasHasImportType, n2), e4.moduleReference = n2, this.semicolon(), this.finishNode(e4, "TSImportEqualsDeclaration");
          }
          tsIsExternalModuleReference() {
            return this.isContextual(119) && 40 === this.lookaheadCharCode();
          }
          tsParseModuleReference() {
            return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(0);
          }
          tsParseExternalModuleReference() {
            const e4 = this.startNode();
            return this.expectContextual(119), this.expect(10), this.match(134) || this.unexpected(), e4.expression = super.parseExprAtom(), this.expect(11), this.sawUnambiguousESM = true, this.finishNode(e4, "TSExternalModuleReference");
          }
          tsLookAhead(e4) {
            const t3 = this.state.clone(), r3 = e4();
            return this.state = t3, r3;
          }
          tsTryParseAndCatch(e4) {
            const t3 = this.tryParse((t4) => e4() || t4());
            if (!t3.aborted && t3.node) return t3.error && (this.state = t3.failState), t3.node;
          }
          tsTryParse(e4) {
            const t3 = this.state.clone(), r3 = e4();
            if (void 0 !== r3 && false !== r3) return r3;
            this.state = t3;
          }
          tsTryParseDeclare(e4) {
            if (this.isLineTerminator()) return;
            const t3 = this.state.type;
            return this.tsInAmbientContext(() => {
              switch (t3) {
                case 68:
                  return e4.declare = true, super.parseFunctionStatement(e4, false, false);
                case 80:
                  return e4.declare = true, this.parseClass(e4, true, false);
                case 126:
                  return this.tsParseEnumDeclaration(e4, { declare: true });
                case 112:
                  return this.tsParseAmbientExternalModuleDeclaration(e4);
                case 100:
                  if (this.state.containsEsc) return;
                case 75:
                case 74:
                  return this.match(75) && this.isLookaheadContextual("enum") ? (this.expect(75), this.tsParseEnumDeclaration(e4, { const: true, declare: true })) : (e4.declare = true, this.parseVarStatement(e4, this.state.value, true));
                case 107:
                  if (this.isUsing()) return this.raise(Q.InvalidModifierOnUsingDeclaration, this.state.startLoc, "declare"), e4.declare = true, this.parseVarStatement(e4, "using", true);
                  break;
                case 96:
                  if (this.isAwaitUsing()) return this.raise(Q.InvalidModifierOnAwaitUsingDeclaration, this.state.startLoc, "declare"), e4.declare = true, this.next(), this.parseVarStatement(e4, "await using", true);
                  break;
                case 129: {
                  const t4 = this.tsParseInterfaceDeclaration(e4, { declare: true });
                  if (t4) return t4;
                }
                default:
                  if (tokenIsIdentifier(t3)) return this.tsParseDeclaration(e4, this.state.value, true, null);
              }
            });
          }
          tsTryParseExportDeclaration() {
            return this.tsParseDeclaration(this.startNode(), this.state.value, true, null);
          }
          tsParseExpressionStatement(e4, t3, r3) {
            switch (t3.name) {
              case "declare": {
                const t4 = this.tsTryParseDeclare(e4);
                return t4 && (t4.declare = true), t4;
              }
              case "global":
                if (this.match(5)) {
                  this.scope.enter(1024), this.prodParam.enter(0);
                  const r4 = e4;
                  return r4.kind = "global", e4.global = true, r4.id = t3, r4.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(r4, "TSModuleDeclaration");
                }
                break;
              default:
                return this.tsParseDeclaration(e4, t3.name, false, r3);
            }
          }
          tsParseDeclaration(e4, t3, r3, n2) {
            switch (t3) {
              case "abstract":
                if (this.tsCheckLineTerminator(r3) && (this.match(80) || tokenIsIdentifier(this.state.type))) return this.tsParseAbstractDeclaration(e4, n2);
                break;
              case "module":
                if (this.tsCheckLineTerminator(r3)) {
                  if (this.match(134)) return this.tsParseAmbientExternalModuleDeclaration(e4);
                  if (tokenIsIdentifier(this.state.type)) return e4.kind = "module", this.tsParseModuleOrNamespaceDeclaration(e4);
                }
                break;
              case "namespace":
                if (this.tsCheckLineTerminator(r3) && tokenIsIdentifier(this.state.type)) return e4.kind = "namespace", this.tsParseModuleOrNamespaceDeclaration(e4);
                break;
              case "type":
                if (this.tsCheckLineTerminator(r3) && tokenIsIdentifier(this.state.type)) return this.tsParseTypeAliasDeclaration(e4);
            }
          }
          tsCheckLineTerminator(e4) {
            return e4 ? !this.hasFollowingLineBreak() && (this.next(), true) : !this.isLineTerminator();
          }
          tsTryParseGenericAsyncArrowFunction(e4) {
            if (!this.match(47)) return;
            const t3 = this.state.maybeInArrowParameters;
            this.state.maybeInArrowParameters = true;
            const r3 = this.tsTryParseAndCatch(() => {
              const t4 = this.startNodeAt(e4);
              return t4.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier), super.parseFunctionParams(t4), t4.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(19), t4;
            });
            return this.state.maybeInArrowParameters = t3, r3 ? super.parseArrowExpression(r3, null, true) : void 0;
          }
          tsParseTypeArgumentsInExpression() {
            if (47 === this.reScan_lt()) return this.tsParseTypeArguments();
          }
          tsParseTypeArguments() {
            const e4 = this.startNode();
            return e4.params = this.tsInType(() => this.tsInTopLevelContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))), 0 === e4.params.length ? this.raise(Q.EmptyTypeArguments, e4) : this.state.inType || this.curContext() !== d.brace || this.reScan_lt_gt(), this.expect(48), this.finishNode(e4, "TSTypeParameterInstantiation");
          }
          tsIsDeclarationStart() {
            return (e4 = this.state.type) >= 124 && e4 <= 130;
            var e4;
          }
          isExportDefaultSpecifier() {
            return !this.tsIsDeclarationStart() && super.isExportDefaultSpecifier();
          }
          parseBindingElement(e4, t3) {
            const r3 = t3.length ? t3[0].loc.start : this.state.startLoc, n2 = {};
            this.tsParseModifiers({ allowedModifiers: ["public", "private", "protected", "override", "readonly"] }, n2);
            const s2 = n2.accessibility, i2 = n2.override, o2 = n2.readonly;
            4 & e4 || !(s2 || o2 || i2) || this.raise(Q.UnexpectedParameterModifier, r3);
            const a2 = this.parseMaybeDefault();
            2 & e4 && this.parseFunctionParamType(a2);
            const l2 = this.parseMaybeDefault(a2.loc.start, a2);
            if (s2 || o2 || i2) {
              const e5 = this.startNodeAt(r3);
              return t3.length && (e5.decorators = t3), s2 && (e5.accessibility = s2), o2 && (e5.readonly = o2), i2 && (e5.override = i2), "Identifier" !== l2.type && "AssignmentPattern" !== l2.type && this.raise(Q.UnsupportedParameterPropertyKind, e5), e5.parameter = l2, this.finishNode(e5, "TSParameterProperty");
            }
            return t3.length && (a2.decorators = t3), l2;
          }
          isSimpleParameter(e4) {
            return "TSParameterProperty" === e4.type && super.isSimpleParameter(e4.parameter) || super.isSimpleParameter(e4);
          }
          tsDisallowOptionalPattern(e4) {
            for (const t3 of e4.params) "Identifier" !== t3.type && t3.optional && !this.state.isAmbientContext && this.raise(Q.PatternIsOptional, t3);
          }
          setArrowFunctionParameters(e4, t3, r3) {
            super.setArrowFunctionParameters(e4, t3, r3), this.tsDisallowOptionalPattern(e4);
          }
          parseFunctionBodyAndFinish(e4, t3, r3 = false) {
            this.match(14) && (e4.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
            const n2 = "FunctionDeclaration" === t3 ? "TSDeclareFunction" : "ClassMethod" === t3 || "ClassPrivateMethod" === t3 ? "TSDeclareMethod" : void 0;
            return n2 && !this.match(5) && this.isLineTerminator() ? this.finishNode(e4, n2) : "TSDeclareFunction" === n2 && this.state.isAmbientContext && (this.raise(Q.DeclareFunctionHasImplementation, e4), e4.declare) ? super.parseFunctionBodyAndFinish(e4, n2, r3) : (this.tsDisallowOptionalPattern(e4), super.parseFunctionBodyAndFinish(e4, t3, r3));
          }
          registerFunctionStatementId(e4) {
            !e4.body && e4.id ? this.checkIdentifier(e4.id, 1024) : super.registerFunctionStatementId(e4);
          }
          tsCheckForInvalidTypeCasts(e4) {
            e4.forEach((e5) => {
              "TSTypeCastExpression" === (null == e5 ? void 0 : e5.type) && this.raise(Q.UnexpectedTypeAnnotation, e5.typeAnnotation);
            });
          }
          toReferencedList(e4, t3) {
            return this.tsCheckForInvalidTypeCasts(e4), e4;
          }
          parseArrayLike(e4, t3, r3, n2) {
            const s2 = super.parseArrayLike(e4, t3, r3, n2);
            return "ArrayExpression" === s2.type && this.tsCheckForInvalidTypeCasts(s2.elements), s2;
          }
          parseSubscript(e4, t3, r3, n2) {
            if (!this.hasPrecedingLineBreak() && this.match(35)) {
              this.state.canStartJSXElement = false, this.next();
              const r4 = this.startNodeAt(t3);
              return r4.expression = e4, this.finishNode(r4, "TSNonNullExpression");
            }
            let s2 = false;
            if (this.match(18) && 60 === this.lookaheadCharCode()) {
              if (r3) return n2.stop = true, e4;
              n2.optionalChainMember = s2 = true, this.next();
            }
            if (this.match(47) || this.match(51)) {
              let i2;
              const o2 = this.tsTryParseAndCatch(() => {
                if (!r3 && this.atPossibleAsyncArrow(e4)) {
                  const e5 = this.tsTryParseGenericAsyncArrowFunction(t3);
                  if (e5) return n2.stop = true, e5;
                }
                const o3 = this.tsParseTypeArgumentsInExpression();
                if (!o3) return;
                if (s2 && !this.match(10)) return void (i2 = this.state.curPosition());
                if (tokenIsTemplate(this.state.type)) {
                  const r4 = super.parseTaggedTemplateExpression(e4, t3, n2);
                  return r4.typeParameters = o3, r4;
                }
                if (!r3 && this.eat(10)) {
                  const r4 = this.startNodeAt(t3);
                  return r4.callee = e4, r4.arguments = this.parseCallExpressionArguments(), this.tsCheckForInvalidTypeCasts(r4.arguments), r4.typeParameters = o3, n2.optionalChainMember && (r4.optional = s2), this.finishCallExpression(r4, n2.optionalChainMember);
                }
                const a2 = this.state.type;
                if (48 === a2 || 52 === a2 || 10 !== a2 && tokenCanStartExpression(a2) && !this.hasPrecedingLineBreak()) return;
                const l2 = this.startNodeAt(t3);
                return l2.expression = e4, l2.typeParameters = o3, this.finishNode(l2, "TSInstantiationExpression");
              });
              if (i2 && this.unexpected(i2, 10), o2) return "TSInstantiationExpression" === o2.type && ((this.match(16) || this.match(18) && 40 !== this.lookaheadCharCode()) && this.raise(Q.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc), this.match(16) || this.match(18) || (o2.expression = super.stopParseSubscript(e4, n2))), o2;
            }
            return super.parseSubscript(e4, t3, r3, n2);
          }
          parseNewCallee(e4) {
            var t3;
            super.parseNewCallee(e4);
            const { callee: r3 } = e4;
            "TSInstantiationExpression" !== r3.type || null != (t3 = r3.extra) && t3.parenthesized || (e4.typeParameters = r3.typeParameters, e4.callee = r3.expression);
          }
          parseExprOp(e4, t3, r3) {
            let n2;
            if (tokenOperatorPrecedence(58) > r3 && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (n2 = this.isContextual(120)))) {
              const s2 = this.startNodeAt(t3);
              return s2.expression = e4, s2.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (n2 && this.raise(c.UnexpectedKeyword, this.state.startLoc, { keyword: "const" }), this.tsParseTypeReference()) : this.tsParseType())), this.finishNode(s2, n2 ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(s2, t3, r3);
            }
            return super.parseExprOp(e4, t3, r3);
          }
          checkReservedWord(e4, t3, r3, n2) {
            this.state.isAmbientContext || super.checkReservedWord(e4, t3, r3, n2);
          }
          checkImportReflection(e4) {
            super.checkImportReflection(e4), e4.module && "value" !== e4.importKind && this.raise(Q.ImportReflectionHasImportType, e4.specifiers[0].loc.start);
          }
          checkDuplicateExports() {
          }
          isPotentialImportPhase(e4) {
            if (super.isPotentialImportPhase(e4)) return true;
            if (this.isContextual(130)) {
              const t3 = this.lookaheadCharCode();
              return e4 ? 123 === t3 || 42 === t3 : 61 !== t3;
            }
            return !e4 && this.isContextual(87);
          }
          applyImportPhase(e4, t3, r3, n2) {
            super.applyImportPhase(e4, t3, r3, n2), t3 ? e4.exportKind = "type" === r3 ? "type" : "value" : e4.importKind = "type" === r3 || "typeof" === r3 ? r3 : "value";
          }
          parseImport(e4) {
            if (this.match(134)) return e4.importKind = "value", super.parseImport(e4);
            let t3;
            if (tokenIsIdentifier(this.state.type) && 61 === this.lookaheadCharCode()) return e4.importKind = "value", this.tsParseImportEqualsDeclaration(e4);
            if (this.isContextual(130)) {
              const r3 = this.parseMaybeImportPhase(e4, false);
              if (61 === this.lookaheadCharCode()) return this.tsParseImportEqualsDeclaration(e4, r3);
              t3 = super.parseImportSpecifiersAndAfter(e4, r3);
            } else t3 = super.parseImport(e4);
            return "type" === t3.importKind && t3.specifiers.length > 1 && "ImportDefaultSpecifier" === t3.specifiers[0].type && this.raise(Q.TypeImportCannotSpecifyDefaultAndNamed, t3), t3;
          }
          parseExport(e4, t3) {
            if (this.match(83)) {
              const t4 = e4;
              this.next();
              let r3 = null;
              this.isContextual(130) && this.isPotentialImportPhase(false) ? r3 = this.parseMaybeImportPhase(t4, false) : t4.importKind = "value";
              return this.tsParseImportEqualsDeclaration(t4, r3, true);
            }
            if (this.eat(29)) {
              const t4 = e4;
              return t4.expression = super.parseExpression(), this.semicolon(), this.sawUnambiguousESM = true, this.finishNode(t4, "TSExportAssignment");
            }
            if (this.eatContextual(93)) {
              const t4 = e4;
              return this.expectContextual(128), t4.id = this.parseIdentifier(), this.semicolon(), this.finishNode(t4, "TSNamespaceExportDeclaration");
            }
            return super.parseExport(e4, t3);
          }
          isAbstractClass() {
            return this.isContextual(124) && this.isLookaheadContextual("class");
          }
          parseExportDefaultExpression() {
            if (this.isAbstractClass()) {
              const e4 = this.startNode();
              return this.next(), e4.abstract = true, this.parseClass(e4, true, true);
            }
            if (this.match(129)) {
              const e4 = this.tsParseInterfaceDeclaration(this.startNode());
              if (e4) return e4;
            }
            return super.parseExportDefaultExpression();
          }
          parseVarStatement(e4, t3, r3 = false) {
            const { isAmbientContext: n2 } = this.state, s2 = super.parseVarStatement(e4, t3, r3 || n2);
            if (!n2) return s2;
            if (!e4.declare && ("using" === t3 || "await using" === t3)) return this.raiseOverwrite(Q.UsingDeclarationInAmbientContext, e4, t3), s2;
            for (const { id: e5, init: r4 } of s2.declarations) r4 && ("var" === t3 || "let" === t3 || e5.typeAnnotation ? this.raise(Q.InitializerNotAllowedInAmbientContext, r4) : isValidAmbientConstInitializer(r4, this.hasPlugin("estree")) || this.raise(Q.ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference, r4));
            return s2;
          }
          parseStatementContent(e4, t3) {
            if (this.match(75) && this.isLookaheadContextual("enum")) {
              const e5 = this.startNode();
              return this.expect(75), this.tsParseEnumDeclaration(e5, { const: true });
            }
            if (this.isContextual(126)) return this.tsParseEnumDeclaration(this.startNode());
            if (this.isContextual(129)) {
              const e5 = this.tsParseInterfaceDeclaration(this.startNode());
              if (e5) return e5;
            }
            return super.parseStatementContent(e4, t3);
          }
          parseAccessModifier() {
            return this.tsParseModifier(["public", "protected", "private"]);
          }
          tsHasSomeModifiers(e4, t3) {
            return t3.some((t4) => tsIsAccessModifier(t4) ? e4.accessibility === t4 : !!e4[t4]);
          }
          tsIsStartOfStaticBlocks() {
            return this.isContextual(106) && 123 === this.lookaheadCharCode();
          }
          parseClassMember(e4, t3, r3) {
            const n2 = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
            this.tsParseModifiers({ allowedModifiers: n2, disallowedModifiers: ["in", "out"], stopOnStartOfClassStaticBlock: true, errorTemplate: Q.InvalidModifierOnTypeParameterPositions }, t3);
            const callParseClassMemberWithIsStatic = () => {
              this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(t3, n2) && this.raise(Q.StaticBlockCannotHaveModifier, this.state.curPosition()), super.parseClassStaticBlock(e4, t3)) : this.parseClassMemberWithIsStatic(e4, t3, r3, !!t3.static);
            };
            t3.declare ? this.tsInAmbientContext(callParseClassMemberWithIsStatic) : callParseClassMemberWithIsStatic();
          }
          parseClassMemberWithIsStatic(e4, t3, r3, n2) {
            const s2 = this.tsTryParseIndexSignature(t3);
            if (s2) return e4.body.push(s2), t3.abstract && this.raise(Q.IndexSignatureHasAbstract, t3), t3.accessibility && this.raise(Q.IndexSignatureHasAccessibility, t3, { modifier: t3.accessibility }), t3.declare && this.raise(Q.IndexSignatureHasDeclare, t3), void (t3.override && this.raise(Q.IndexSignatureHasOverride, t3));
            !this.state.inAbstractClass && t3.abstract && this.raise(Q.NonAbstractClassHasAbstractMethod, t3), t3.override && (r3.hadSuperClass || this.raise(Q.OverrideNotInSubClass, t3)), super.parseClassMemberWithIsStatic(e4, t3, r3, n2);
          }
          parsePostMemberNameModifiers(e4) {
            this.eat(17) && (e4.optional = true), e4.readonly && this.match(10) && this.raise(Q.ClassMethodHasReadonly, e4), e4.declare && this.match(10) && this.raise(Q.ClassMethodHasDeclare, e4);
          }
          parseExpressionStatement(e4, t3, r3) {
            return ("Identifier" === t3.type ? this.tsParseExpressionStatement(e4, t3, r3) : void 0) || super.parseExpressionStatement(e4, t3, r3);
          }
          shouldParseExportDeclaration() {
            return !!this.tsIsDeclarationStart() || super.shouldParseExportDeclaration();
          }
          parseConditional(e4, t3, r3) {
            if (!this.match(17)) return e4;
            if (this.state.maybeInArrowParameters) {
              const t4 = this.lookaheadCharCode();
              if (44 === t4 || 61 === t4 || 58 === t4 || 41 === t4) return this.setOptionalParametersError(r3), e4;
            }
            return super.parseConditional(e4, t3, r3);
          }
          parseParenItem(e4, t3) {
            const r3 = super.parseParenItem(e4, t3);
            if (this.eat(17) && (r3.optional = true, this.resetEndLocation(e4)), this.match(14)) {
              const r4 = this.startNodeAt(t3);
              return r4.expression = e4, r4.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(r4, "TSTypeCastExpression");
            }
            return e4;
          }
          parseExportDeclaration(e4) {
            if (!this.state.isAmbientContext && this.isContextual(125)) return this.tsInAmbientContext(() => this.parseExportDeclaration(e4));
            const t3 = this.state.startLoc, r3 = this.eatContextual(125);
            if (r3 && (this.isContextual(125) || !this.shouldParseExportDeclaration())) throw this.raise(Q.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
            const n2 = tokenIsIdentifier(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(e4);
            return n2 ? (("TSInterfaceDeclaration" === n2.type || "TSTypeAliasDeclaration" === n2.type || r3) && (e4.exportKind = "type"), r3 && "TSImportEqualsDeclaration" !== n2.type && (this.resetStartLocation(n2, t3), n2.declare = true), n2) : null;
          }
          parseClassId(e4, t3, r3, n2) {
            if ((!t3 || r3) && this.isContextual(113)) return;
            super.parseClassId(e4, t3, r3, e4.declare ? 1024 : 8331);
            const s2 = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
            s2 && (e4.typeParameters = s2);
          }
          parseClassPropertyAnnotation(e4) {
            e4.optional || (this.eat(35) ? e4.definite = true : this.eat(17) && (e4.optional = true));
            const t3 = this.tsTryParseTypeAnnotation();
            t3 && (e4.typeAnnotation = t3);
          }
          parseClassProperty(e4) {
            if (this.parseClassPropertyAnnotation(e4), this.state.isAmbientContext && (!e4.readonly || e4.typeAnnotation) && this.match(29) && this.raise(Q.DeclareClassFieldHasInitializer, this.state.startLoc), e4.abstract && this.match(29)) {
              const { key: t3 } = e4;
              this.raise(Q.AbstractPropertyHasInitializer, this.state.startLoc, { propertyName: "Identifier" !== t3.type || e4.computed ? `[${this.input.slice(this.offsetToSourcePos(t3.start), this.offsetToSourcePos(t3.end))}]` : t3.name });
            }
            return super.parseClassProperty(e4);
          }
          parseClassPrivateProperty(e4) {
            return e4.abstract && this.raise(Q.PrivateElementHasAbstract, e4), e4.accessibility && this.raise(Q.PrivateElementHasAccessibility, e4, { modifier: e4.accessibility }), this.parseClassPropertyAnnotation(e4), super.parseClassPrivateProperty(e4);
          }
          parseClassAccessorProperty(e4) {
            return this.parseClassPropertyAnnotation(e4), e4.optional && this.raise(Q.AccessorCannotBeOptional, e4), super.parseClassAccessorProperty(e4);
          }
          pushClassMethod(e4, t3, r3, n2, s2, i2) {
            const o2 = this.tsTryParseTypeParameters(this.tsParseConstModifier);
            o2 && s2 && this.raise(Q.ConstructorHasTypeParameters, o2);
            const { declare: a2 = false, kind: l2 } = t3;
            !a2 || "get" !== l2 && "set" !== l2 || this.raise(Q.DeclareAccessor, t3, { kind: l2 }), o2 && (t3.typeParameters = o2), super.pushClassMethod(e4, t3, r3, n2, s2, i2);
          }
          pushClassPrivateMethod(e4, t3, r3, n2) {
            const s2 = this.tsTryParseTypeParameters(this.tsParseConstModifier);
            s2 && (t3.typeParameters = s2), super.pushClassPrivateMethod(e4, t3, r3, n2);
          }
          declareClassPrivateMethodInScope(e4, t3) {
            "TSDeclareMethod" !== e4.type && ("MethodDefinition" === e4.type && null == e4.value.body || super.declareClassPrivateMethodInScope(e4, t3));
          }
          parseClassSuper(e4) {
            super.parseClassSuper(e4), e4.superClass && (this.match(47) || this.match(51)) && (e4.superTypeParameters = this.tsParseTypeArgumentsInExpression()), this.eatContextual(113) && (e4.implements = this.tsParseHeritageClause("implements"));
          }
          parseObjPropValue(e4, t3, r3, n2, s2, i2, o2) {
            const a2 = this.tsTryParseTypeParameters(this.tsParseConstModifier);
            return a2 && (e4.typeParameters = a2), super.parseObjPropValue(e4, t3, r3, n2, s2, i2, o2);
          }
          parseFunctionParams(e4, t3) {
            const r3 = this.tsTryParseTypeParameters(this.tsParseConstModifier);
            r3 && (e4.typeParameters = r3), super.parseFunctionParams(e4, t3);
          }
          parseVarId(e4, t3) {
            super.parseVarId(e4, t3), "Identifier" === e4.id.type && !this.hasPrecedingLineBreak() && this.eat(35) && (e4.definite = true);
            const r3 = this.tsTryParseTypeAnnotation();
            r3 && (e4.id.typeAnnotation = r3, this.resetEndLocation(e4.id));
          }
          parseAsyncArrowFromCallExpression(e4, t3) {
            return this.match(14) && (e4.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(e4, t3);
          }
          parseMaybeAssign(e4, t3) {
            var r3, n2, s2, i2, o2;
            let a2, l2, p2, c2;
            if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
              if (a2 = this.state.clone(), l2 = this.tryParse(() => super.parseMaybeAssign(e4, t3), a2), !l2.error) return l2.node;
              const { context: r4 } = this.state, n3 = r4[r4.length - 1];
              n3 !== d.j_oTag && n3 !== d.j_expr || r4.pop();
            }
            if (!(null != (r3 = l2) && r3.error || this.match(47))) return super.parseMaybeAssign(e4, t3);
            a2 && a2 !== this.state || (a2 = this.state.clone());
            const u2 = this.tryParse((r4) => {
              var n3, s3;
              c2 = this.tsParseTypeParameters(this.tsParseConstModifier);
              const i3 = super.parseMaybeAssign(e4, t3);
              return ("ArrowFunctionExpression" !== i3.type || null != (n3 = i3.extra) && n3.parenthesized) && r4(), 0 !== (null == (s3 = c2) ? void 0 : s3.params.length) && this.resetStartLocationFromNode(i3, c2), i3.typeParameters = c2, i3;
            }, a2);
            if (!u2.error && !u2.aborted) return c2 && this.reportReservedArrowTypeParam(c2), u2.node;
            if (!l2 && (assert(!this.hasPlugin("jsx")), p2 = this.tryParse(() => super.parseMaybeAssign(e4, t3), a2), !p2.error)) return p2.node;
            if (null != (n2 = l2) && n2.node) return this.state = l2.failState, l2.node;
            if (u2.node) return this.state = u2.failState, c2 && this.reportReservedArrowTypeParam(c2), u2.node;
            if (null != (s2 = p2) && s2.node) return this.state = p2.failState, p2.node;
            throw (null == (i2 = l2) ? void 0 : i2.error) || u2.error || (null == (o2 = p2) ? void 0 : o2.error);
          }
          reportReservedArrowTypeParam(e4) {
            var t3;
            1 !== e4.params.length || e4.params[0].constraint || null != (t3 = e4.extra) && t3.trailingComma || !this.getPluginOption("typescript", "disallowAmbiguousJSXLike") || this.raise(Q.ReservedArrowTypeParam, e4);
          }
          parseMaybeUnary(e4, t3) {
            return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(e4, t3);
          }
          parseArrow(e4) {
            if (this.match(14)) {
              const t3 = this.tryParse((e5) => {
                const t4 = this.tsParseTypeOrTypePredicateAnnotation(14);
                return !this.canInsertSemicolon() && this.match(19) || e5(), t4;
              });
              if (t3.aborted) return;
              t3.thrown || (t3.error && (this.state = t3.failState), e4.returnType = t3.node);
            }
            return super.parseArrow(e4);
          }
          parseFunctionParamType(e4) {
            this.eat(17) && (e4.optional = true);
            const t3 = this.tsTryParseTypeAnnotation();
            return t3 && (e4.typeAnnotation = t3), this.resetEndLocation(e4), e4;
          }
          isAssignable(e4, t3) {
            switch (e4.type) {
              case "TSTypeCastExpression":
                return this.isAssignable(e4.expression, t3);
              case "TSParameterProperty":
                return true;
              default:
                return super.isAssignable(e4, t3);
            }
          }
          toAssignable(e4, t3 = false) {
            switch (e4.type) {
              case "ParenthesizedExpression":
                this.toAssignableParenthesizedExpression(e4, t3);
                break;
              case "TSAsExpression":
              case "TSSatisfiesExpression":
              case "TSNonNullExpression":
              case "TSTypeAssertion":
                t3 ? this.expressionScope.recordArrowParameterBindingError(Q.UnexpectedTypeCastInParameter, e4) : this.raise(Q.UnexpectedTypeCastInParameter, e4), this.toAssignable(e4.expression, t3);
                break;
              case "AssignmentExpression":
                t3 || "TSTypeCastExpression" !== e4.left.type || (e4.left = this.typeCastToParameter(e4.left));
              default:
                super.toAssignable(e4, t3);
            }
          }
          toAssignableParenthesizedExpression(e4, t3) {
            switch (e4.expression.type) {
              case "TSAsExpression":
              case "TSSatisfiesExpression":
              case "TSNonNullExpression":
              case "TSTypeAssertion":
              case "ParenthesizedExpression":
                this.toAssignable(e4.expression, t3);
                break;
              default:
                super.toAssignable(e4, t3);
            }
          }
          checkToRestConversion(e4, t3) {
            switch (e4.type) {
              case "TSAsExpression":
              case "TSSatisfiesExpression":
              case "TSTypeAssertion":
              case "TSNonNullExpression":
                this.checkToRestConversion(e4.expression, false);
                break;
              default:
                super.checkToRestConversion(e4, t3);
            }
          }
          isValidLVal(e4, t3, r3) {
            switch (e4) {
              case "TSTypeCastExpression":
                return true;
              case "TSParameterProperty":
                return "parameter";
              case "TSNonNullExpression":
                return "expression";
              case "TSAsExpression":
              case "TSSatisfiesExpression":
              case "TSTypeAssertion":
                return (64 !== r3 || !t3) && ["expression", true];
              default:
                return super.isValidLVal(e4, t3, r3);
            }
          }
          parseBindingAtom() {
            return 78 === this.state.type ? this.parseIdentifier(true) : super.parseBindingAtom();
          }
          parseMaybeDecoratorArguments(e4, t3) {
            if (this.match(47) || this.match(51)) {
              const r3 = this.tsParseTypeArgumentsInExpression();
              if (this.match(10)) {
                const n2 = super.parseMaybeDecoratorArguments(e4, t3);
                return n2.typeParameters = r3, n2;
              }
              this.unexpected(null, 10);
            }
            return super.parseMaybeDecoratorArguments(e4, t3);
          }
          checkCommaAfterRest(e4) {
            return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === e4 ? (this.next(), false) : super.checkCommaAfterRest(e4);
          }
          isClassMethod() {
            return this.match(47) || super.isClassMethod();
          }
          isClassProperty() {
            return this.match(35) || this.match(14) || super.isClassProperty();
          }
          parseMaybeDefault(e4, t3) {
            const r3 = super.parseMaybeDefault(e4, t3);
            return "AssignmentPattern" === r3.type && r3.typeAnnotation && r3.right.start < r3.typeAnnotation.start && this.raise(Q.TypeAnnotationAfterAssign, r3.typeAnnotation), r3;
          }
          getTokenFromCode(e4) {
            if (this.state.inType) {
              if (62 === e4) return void this.finishOp(48, 1);
              if (60 === e4) return void this.finishOp(47, 1);
            }
            super.getTokenFromCode(e4);
          }
          reScan_lt_gt() {
            const { type: e4 } = this.state;
            47 === e4 ? (this.state.pos -= 1, this.readToken_lt()) : 48 === e4 && (this.state.pos -= 1, this.readToken_gt());
          }
          reScan_lt() {
            const { type: e4 } = this.state;
            return 51 === e4 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : e4;
          }
          toAssignableListItem(e4, t3, r3) {
            const n2 = e4[t3];
            "TSTypeCastExpression" === n2.type && (e4[t3] = this.typeCastToParameter(n2)), super.toAssignableListItem(e4, t3, r3);
          }
          typeCastToParameter(e4) {
            return e4.expression.typeAnnotation = e4.typeAnnotation, this.resetEndLocation(e4.expression, e4.typeAnnotation.loc.end), e4.expression;
          }
          shouldParseArrow(e4) {
            return this.match(14) ? e4.every((e5) => this.isAssignable(e5, true)) : super.shouldParseArrow(e4);
          }
          shouldParseAsyncArrow() {
            return this.match(14) || super.shouldParseAsyncArrow();
          }
          canHaveLeadingDecorator() {
            return super.canHaveLeadingDecorator() || this.isAbstractClass();
          }
          jsxParseOpeningElementAfterName(e4) {
            if (this.match(47) || this.match(51)) {
              const t3 = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
              t3 && (e4.typeParameters = t3);
            }
            return super.jsxParseOpeningElementAfterName(e4);
          }
          getGetterSetterExpectedParamCount(e4) {
            const t3 = super.getGetterSetterExpectedParamCount(e4), r3 = this.getObjectOrClassMethodParams(e4)[0];
            return r3 && this.isThisParam(r3) ? t3 + 1 : t3;
          }
          parseCatchClauseParam() {
            const e4 = super.parseCatchClauseParam(), t3 = this.tsTryParseTypeAnnotation();
            return t3 && (e4.typeAnnotation = t3, this.resetEndLocation(e4)), e4;
          }
          tsInAmbientContext(e4) {
            const { isAmbientContext: t3, strict: r3 } = this.state;
            this.state.isAmbientContext = true, this.state.strict = false;
            try {
              return e4();
            } finally {
              this.state.isAmbientContext = t3, this.state.strict = r3;
            }
          }
          parseClass(e4, t3, r3) {
            const n2 = this.state.inAbstractClass;
            this.state.inAbstractClass = !!e4.abstract;
            try {
              return super.parseClass(e4, t3, r3);
            } finally {
              this.state.inAbstractClass = n2;
            }
          }
          tsParseAbstractDeclaration(e4, t3) {
            if (this.match(80)) return e4.abstract = true, this.maybeTakeDecorators(t3, this.parseClass(e4, true, false));
            if (this.isContextual(129)) {
              if (!this.hasFollowingLineBreak()) return e4.abstract = true, this.raise(Q.NonClassMethodPropertyHasAbstractModifier, e4), this.tsParseInterfaceDeclaration(e4);
            } else this.unexpected(null, 80);
          }
          parseMethod(e4, t3, r3, n2, s2, i2, o2) {
            const a2 = super.parseMethod(e4, t3, r3, n2, s2, i2, o2);
            if (a2.abstract || "TSAbstractMethodDefinition" === a2.type) {
              if ((this.hasPlugin("estree") ? a2.value : a2).body) {
                const { key: e5 } = a2;
                this.raise(Q.AbstractMethodHasImplementation, a2, { methodName: "Identifier" !== e5.type || a2.computed ? `[${this.input.slice(this.offsetToSourcePos(e5.start), this.offsetToSourcePos(e5.end))}]` : e5.name });
              }
            }
            return a2;
          }
          tsParseTypeParameterName() {
            return this.parseIdentifier().name;
          }
          shouldParseAsAmbientContext() {
            return !!this.getPluginOption("typescript", "dts");
          }
          parse() {
            return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.parse();
          }
          getExpression() {
            return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.getExpression();
          }
          parseExportSpecifier(e4, t3, r3, n2) {
            return !t3 && n2 ? (this.parseTypeOnlyImportExportSpecifier(e4, false, r3), this.finishNode(e4, "ExportSpecifier")) : (e4.exportKind = "value", super.parseExportSpecifier(e4, t3, r3, n2));
          }
          parseImportSpecifier(e4, t3, r3, n2, s2) {
            return !t3 && n2 ? (this.parseTypeOnlyImportExportSpecifier(e4, true, r3), this.finishNode(e4, "ImportSpecifier")) : (e4.importKind = "value", super.parseImportSpecifier(e4, t3, r3, n2, r3 ? 4098 : 4096));
          }
          parseTypeOnlyImportExportSpecifier(e4, t3, r3) {
            const n2 = t3 ? "imported" : "local", s2 = t3 ? "local" : "exported";
            let i2, o2 = e4[n2], a2 = false, l2 = true;
            const p2 = o2.loc.start;
            if (this.isContextual(93)) {
              const e5 = this.parseIdentifier();
              if (this.isContextual(93)) {
                const r4 = this.parseIdentifier();
                tokenIsKeywordOrIdentifier(this.state.type) ? (a2 = true, o2 = e5, i2 = t3 ? this.parseIdentifier() : this.parseModuleExportName(), l2 = false) : (i2 = r4, l2 = false);
              } else tokenIsKeywordOrIdentifier(this.state.type) ? (l2 = false, i2 = t3 ? this.parseIdentifier() : this.parseModuleExportName()) : (a2 = true, o2 = e5);
            } else tokenIsKeywordOrIdentifier(this.state.type) && (a2 = true, t3 ? (o2 = this.parseIdentifier(true), this.isContextual(93) || this.checkReservedWord(o2.name, o2.loc.start, true, true)) : o2 = this.parseModuleExportName());
            a2 && r3 && this.raise(t3 ? Q.TypeModifierIsUsedInTypeImports : Q.TypeModifierIsUsedInTypeExports, p2), e4[n2] = o2, e4[s2] = i2;
            e4[t3 ? "importKind" : "exportKind"] = a2 ? "type" : "value", l2 && this.eatContextual(93) && (e4[s2] = t3 ? this.parseIdentifier() : this.parseModuleExportName()), e4[s2] || (e4[s2] = this.cloneIdentifier(e4[n2])), t3 && this.checkIdentifier(e4[s2], a2 ? 4098 : 4096);
          }
          fillOptionalPropertiesForTSESLint(e4) {
            switch (e4.type) {
              case "ExpressionStatement":
                return void (null != e4.directive || (e4.directive = void 0));
              case "RestElement":
                e4.value = void 0;
              case "Identifier":
              case "ArrayPattern":
              case "AssignmentPattern":
              case "ObjectPattern":
                return null != e4.decorators || (e4.decorators = []), null != e4.optional || (e4.optional = false), void (null != e4.typeAnnotation || (e4.typeAnnotation = void 0));
              case "TSParameterProperty":
                return null != e4.accessibility || (e4.accessibility = void 0), null != e4.decorators || (e4.decorators = []), null != e4.override || (e4.override = false), null != e4.readonly || (e4.readonly = false), void (null != e4.static || (e4.static = false));
              case "TSEmptyBodyFunctionExpression":
                e4.body = null;
              case "TSDeclareFunction":
              case "FunctionDeclaration":
              case "FunctionExpression":
              case "ClassMethod":
              case "ClassPrivateMethod":
                return null != e4.declare || (e4.declare = false), null != e4.returnType || (e4.returnType = void 0), void (null != e4.typeParameters || (e4.typeParameters = void 0));
              case "Property":
                return void (null != e4.optional || (e4.optional = false));
              case "TSMethodSignature":
              case "TSPropertySignature":
                null != e4.optional || (e4.optional = false);
              case "TSIndexSignature":
                return null != e4.accessibility || (e4.accessibility = void 0), null != e4.readonly || (e4.readonly = false), void (null != e4.static || (e4.static = false));
              case "TSAbstractPropertyDefinition":
              case "PropertyDefinition":
              case "TSAbstractAccessorProperty":
              case "AccessorProperty":
                null != e4.declare || (e4.declare = false), null != e4.definite || (e4.definite = false), null != e4.readonly || (e4.readonly = false), null != e4.typeAnnotation || (e4.typeAnnotation = void 0);
              case "TSAbstractMethodDefinition":
              case "MethodDefinition":
                return null != e4.accessibility || (e4.accessibility = void 0), null != e4.decorators || (e4.decorators = []), null != e4.override || (e4.override = false), void (null != e4.optional || (e4.optional = false));
              case "ClassExpression":
                null != e4.id || (e4.id = null);
              case "ClassDeclaration":
                return null != e4.abstract || (e4.abstract = false), null != e4.declare || (e4.declare = false), null != e4.decorators || (e4.decorators = []), null != e4.implements || (e4.implements = []), null != e4.superTypeArguments || (e4.superTypeArguments = void 0), void (null != e4.typeParameters || (e4.typeParameters = void 0));
              case "TSTypeAliasDeclaration":
              case "VariableDeclaration":
                return void (null != e4.declare || (e4.declare = false));
              case "VariableDeclarator":
                return void (null != e4.definite || (e4.definite = false));
              case "TSEnumDeclaration":
                return null != e4.const || (e4.const = false), void (null != e4.declare || (e4.declare = false));
              case "TSEnumMember":
                return void (null != e4.computed || (e4.computed = false));
              case "TSImportType":
                return null != e4.qualifier || (e4.qualifier = null), void (null != e4.options || (e4.options = null));
              case "TSInterfaceDeclaration":
                return null != e4.declare || (e4.declare = false), void (null != e4.extends || (e4.extends = []));
              case "TSMappedType":
                return null != e4.optional || (e4.optional = false), void (null != e4.readonly || (e4.readonly = void 0));
              case "TSModuleDeclaration":
                return null != e4.declare || (e4.declare = false), void (null != e4.global || (e4.global = "global" === e4.kind));
              case "TSTypeParameter":
                return null != e4.const || (e4.const = false), null != e4.in || (e4.in = false), void (null != e4.out || (e4.out = false));
            }
          }
        }, v8intrinsic: (e3) => class extends e3 {
          parseV8Intrinsic() {
            if (this.match(54)) {
              const e4 = this.state.startLoc, t3 = this.startNode();
              if (this.next(), tokenIsIdentifier(this.state.type)) {
                const e5 = this.parseIdentifierName(), r3 = this.createIdentifier(t3, e5);
                if (this.castNodeTo(r3, "V8IntrinsicIdentifier"), this.match(10)) return r3;
              }
              this.unexpected(e4);
            }
          }
          parseExprAtom(e4) {
            return this.parseV8Intrinsic() || super.parseExprAtom(e4);
          }
        }, placeholders: (e3) => class extends e3 {
          parsePlaceholder(e4) {
            if (this.match(133)) {
              const t3 = this.startNode();
              return this.next(), this.assertNoSpace(), t3.name = super.parseIdentifier(true), this.assertNoSpace(), this.expect(133), this.finishPlaceholder(t3, e4);
            }
          }
          finishPlaceholder(e4, t3) {
            let r3 = e4;
            return r3.expectedNode && r3.type || (r3 = this.finishNode(r3, "Placeholder")), r3.expectedNode = t3, r3;
          }
          getTokenFromCode(e4) {
            37 === e4 && 37 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(133, 2) : super.getTokenFromCode(e4);
          }
          parseExprAtom(e4) {
            return this.parsePlaceholder("Expression") || super.parseExprAtom(e4);
          }
          parseIdentifier(e4) {
            return this.parsePlaceholder("Identifier") || super.parseIdentifier(e4);
          }
          checkReservedWord(e4, t3, r3, n2) {
            void 0 !== e4 && super.checkReservedWord(e4, t3, r3, n2);
          }
          cloneIdentifier(e4) {
            const t3 = super.cloneIdentifier(e4);
            return "Placeholder" === t3.type && (t3.expectedNode = e4.expectedNode), t3;
          }
          cloneStringLiteral(e4) {
            return "Placeholder" === e4.type ? this.cloneIdentifier(e4) : super.cloneStringLiteral(e4);
          }
          parseBindingAtom() {
            return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
          }
          isValidLVal(e4, t3, r3) {
            return "Placeholder" === e4 || super.isValidLVal(e4, t3, r3);
          }
          toAssignable(e4, t3) {
            e4 && "Placeholder" === e4.type && "Expression" === e4.expectedNode ? e4.expectedNode = "Pattern" : super.toAssignable(e4, t3);
          }
          chStartsBindingIdentifier(e4, t3) {
            if (super.chStartsBindingIdentifier(e4, t3)) return true;
            const r3 = this.nextTokenStart();
            return 37 === this.input.charCodeAt(r3) && 37 === this.input.charCodeAt(r3 + 1);
          }
          verifyBreakContinue(e4, t3) {
            e4.label && "Placeholder" === e4.label.type || super.verifyBreakContinue(e4, t3);
          }
          parseExpressionStatement(e4, t3) {
            var r3;
            if ("Placeholder" !== t3.type || null != (r3 = t3.extra) && r3.parenthesized) return super.parseExpressionStatement(e4, t3);
            if (this.match(14)) {
              const r4 = e4;
              return r4.label = this.finishPlaceholder(t3, "Identifier"), this.next(), r4.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration(), this.finishNode(r4, "LabeledStatement");
            }
            this.semicolon();
            const n2 = e4;
            return n2.name = t3.name, this.finishPlaceholder(n2, "Statement");
          }
          parseBlock(e4, t3, r3) {
            return this.parsePlaceholder("BlockStatement") || super.parseBlock(e4, t3, r3);
          }
          parseFunctionId(e4) {
            return this.parsePlaceholder("Identifier") || super.parseFunctionId(e4);
          }
          parseClass(e4, t3, r3) {
            const n2 = t3 ? "ClassDeclaration" : "ClassExpression";
            this.next();
            const s2 = this.state.strict, i2 = this.parsePlaceholder("Identifier");
            if (i2) {
              if (!(this.match(81) || this.match(133) || this.match(5))) {
                if (r3 || !t3) return e4.id = null, e4.body = this.finishPlaceholder(i2, "ClassBody"), this.finishNode(e4, n2);
                throw this.raise(Z.ClassNameIsRequired, this.state.startLoc);
              }
              e4.id = i2;
            } else this.parseClassId(e4, t3, r3);
            return super.parseClassSuper(e4), e4.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!e4.superClass, s2), this.finishNode(e4, n2);
          }
          parseExport(e4, t3) {
            const r3 = this.parsePlaceholder("Identifier");
            if (!r3) return super.parseExport(e4, t3);
            const n2 = e4;
            if (!this.isContextual(98) && !this.match(12)) return n2.specifiers = [], n2.source = null, n2.declaration = this.finishPlaceholder(r3, "Declaration"), this.finishNode(n2, "ExportNamedDeclaration");
            this.expectPlugin("exportDefaultFrom");
            const s2 = this.startNode();
            return s2.exported = r3, n2.specifiers = [this.finishNode(s2, "ExportDefaultSpecifier")], super.parseExport(n2, t3);
          }
          isExportDefaultSpecifier() {
            if (this.match(65)) {
              const e4 = this.nextTokenStart();
              if (this.isUnparsedContextual(e4, "from") && this.input.startsWith(tokenLabelName(133), this.nextTokenStartSince(e4 + 4))) return true;
            }
            return super.isExportDefaultSpecifier();
          }
          maybeParseExportDefaultSpecifier(e4, t3) {
            var r3;
            return !(null == (r3 = e4.specifiers) || !r3.length) || super.maybeParseExportDefaultSpecifier(e4, t3);
          }
          checkExport(e4) {
            const { specifiers: t3 } = e4;
            null != t3 && t3.length && (e4.specifiers = t3.filter((e5) => "Placeholder" === e5.exported.type)), super.checkExport(e4), e4.specifiers = t3;
          }
          parseImport(e4) {
            const t3 = this.parsePlaceholder("Identifier");
            if (!t3) return super.parseImport(e4);
            if (e4.specifiers = [], !this.isContextual(98) && !this.match(12)) return e4.source = this.finishPlaceholder(t3, "StringLiteral"), this.semicolon(), this.finishNode(e4, "ImportDeclaration");
            const r3 = this.startNodeAtNode(t3);
            if (r3.local = t3, e4.specifiers.push(this.finishNode(r3, "ImportDefaultSpecifier")), this.eat(12)) {
              this.maybeParseStarImportSpecifier(e4) || this.parseNamedImportSpecifiers(e4);
            }
            return this.expectContextual(98), e4.source = this.parseImportSource(), this.semicolon(), this.finishNode(e4, "ImportDeclaration");
          }
          parseImportSource() {
            return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
          }
          assertNoSpace() {
            this.state.start > this.offsetToSourcePos(this.state.lastTokEndLoc.index) && this.raise(Z.UnexpectedSpace, this.state.lastTokEndLoc);
          }
        } }, ne = Object.keys(re);
        class ExpressionParser extends LValParser {
          checkProto(e3, t3, r3, n2) {
            if ("SpreadElement" === e3.type || this.isObjectMethod(e3) || e3.computed || e3.shorthand) return r3;
            const s2 = e3.key;
            return "__proto__" === ("Identifier" === s2.type ? s2.name : s2.value) ? t3 ? (this.raise(c.RecordNoProto, s2), true) : (r3 && (n2 ? null === n2.doubleProtoLoc && (n2.doubleProtoLoc = s2.loc.start) : this.raise(c.DuplicateProto, s2)), true) : r3;
          }
          shouldExitDescending(e3, t3) {
            return "ArrowFunctionExpression" === e3.type && this.offsetToSourcePos(e3.start) === t3;
          }
          getExpression() {
            if (this.enterInitialScopes(), this.nextToken(), this.match(140)) throw this.raise(c.ParseExpressionEmptyInput, this.state.startLoc);
            const e3 = this.parseExpression();
            if (!this.match(140)) throw this.raise(c.ParseExpressionExpectsEOF, this.state.startLoc, { unexpected: this.input.codePointAt(this.state.start) });
            return this.finalizeRemainingComments(), e3.comments = this.comments, e3.errors = this.state.errors, 256 & this.optionFlags && (e3.tokens = this.tokens), e3;
          }
          parseExpression(e3, t3) {
            return e3 ? this.disallowInAnd(() => this.parseExpressionBase(t3)) : this.allowInAnd(() => this.parseExpressionBase(t3));
          }
          parseExpressionBase(e3) {
            const t3 = this.state.startLoc, r3 = this.parseMaybeAssign(e3);
            if (this.match(12)) {
              const n2 = this.startNodeAt(t3);
              for (n2.expressions = [r3]; this.eat(12); ) n2.expressions.push(this.parseMaybeAssign(e3));
              return this.toReferencedList(n2.expressions), this.finishNode(n2, "SequenceExpression");
            }
            return r3;
          }
          parseMaybeAssignDisallowIn(e3, t3) {
            return this.disallowInAnd(() => this.parseMaybeAssign(e3, t3));
          }
          parseMaybeAssignAllowIn(e3, t3) {
            return this.allowInAnd(() => this.parseMaybeAssign(e3, t3));
          }
          setOptionalParametersError(e3) {
            e3.optionalParametersLoc = this.state.startLoc;
          }
          parseMaybeAssign(e3, t3) {
            const r3 = this.state.startLoc, n2 = this.isContextual(108);
            if (n2 && this.prodParam.hasYield) {
              this.next();
              let e4 = this.parseYield(r3);
              return t3 && (e4 = t3.call(this, e4, r3)), e4;
            }
            let s2;
            e3 ? s2 = false : (e3 = new ExpressionErrors(), s2 = true);
            const { type: i2 } = this.state;
            (10 === i2 || tokenIsIdentifier(i2)) && (this.state.potentialArrowAt = this.state.start);
            let o2 = this.parseMaybeConditional(e3);
            if (t3 && (o2 = t3.call(this, o2, r3)), (a2 = this.state.type) >= 29 && a2 <= 33) {
              const t4 = this.startNodeAt(r3), n3 = this.state.value;
              if (t4.operator = n3, this.match(29)) {
                this.toAssignable(o2, true), t4.left = o2;
                const n4 = r3.index;
                null != e3.doubleProtoLoc && e3.doubleProtoLoc.index >= n4 && (e3.doubleProtoLoc = null), null != e3.shorthandAssignLoc && e3.shorthandAssignLoc.index >= n4 && (e3.shorthandAssignLoc = null), null != e3.privateKeyLoc && e3.privateKeyLoc.index >= n4 && (this.checkDestructuringPrivate(e3), e3.privateKeyLoc = null), null != e3.voidPatternLoc && e3.voidPatternLoc.index >= n4 && (e3.voidPatternLoc = null);
              } else t4.left = o2;
              return this.next(), t4.right = this.parseMaybeAssign(), this.checkLVal(o2, this.finishNode(t4, "AssignmentExpression")), t4;
            }
            var a2;
            if (s2 && this.checkExpressionErrors(e3, true), n2) {
              const { type: e4 } = this.state;
              if ((this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(e4) : tokenCanStartExpression(e4) && !this.match(54)) && !this.isAmbiguousPrefixOrIdentifier()) return this.raiseOverwrite(c.YieldNotInGeneratorFunction, r3), this.parseYield(r3);
            }
            return o2;
          }
          parseMaybeConditional(e3) {
            const t3 = this.state.startLoc, r3 = this.state.potentialArrowAt, n2 = this.parseExprOps(e3);
            return this.shouldExitDescending(n2, r3) ? n2 : this.parseConditional(n2, t3, e3);
          }
          parseConditional(e3, t3, r3) {
            if (this.eat(17)) {
              const r4 = this.startNodeAt(t3);
              return r4.test = e3, r4.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), r4.alternate = this.parseMaybeAssign(), this.finishNode(r4, "ConditionalExpression");
            }
            return e3;
          }
          parseMaybeUnaryOrPrivate(e3) {
            return this.match(139) ? this.parsePrivateName() : this.parseMaybeUnary(e3);
          }
          parseExprOps(e3) {
            const t3 = this.state.startLoc, r3 = this.state.potentialArrowAt, n2 = this.parseMaybeUnaryOrPrivate(e3);
            return this.shouldExitDescending(n2, r3) ? n2 : this.parseExprOp(n2, t3, -1);
          }
          parseExprOp(e3, t3, r3) {
            if (this.isPrivateName(e3)) {
              const t4 = this.getPrivateNameSV(e3);
              (r3 >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(c.PrivateInExpectedIn, e3, { identifierName: t4 }), this.classScope.usePrivateName(t4, e3.loc.start);
            }
            const n2 = this.state.type;
            if ((s2 = n2) >= 39 && s2 <= 59 && (this.prodParam.hasIn || !this.match(58))) {
              let s3 = tokenOperatorPrecedence(n2);
              if (s3 > r3) {
                if (39 === n2) {
                  if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody) return e3;
                  this.checkPipelineAtInfixOperator(e3, t3);
                }
                const i2 = this.startNodeAt(t3);
                i2.left = e3, i2.operator = this.state.value;
                const o2 = 41 === n2 || 42 === n2, a2 = 40 === n2;
                if (a2 && (s3 = tokenOperatorPrecedence(42)), this.next(), 39 === n2 && this.hasPlugin(["pipelineOperator", { proposal: "minimal" }]) && 96 === this.state.type && this.prodParam.hasAwait) throw this.raise(c.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
                i2.right = this.parseExprOpRightExpr(n2, s3);
                const l2 = this.finishNode(i2, o2 || a2 ? "LogicalExpression" : "BinaryExpression"), p2 = this.state.type;
                if (a2 && (41 === p2 || 42 === p2) || o2 && 40 === p2) throw this.raise(c.MixingCoalesceWithLogical, this.state.startLoc);
                return this.parseExprOp(l2, t3, r3);
              }
            }
            var s2;
            return e3;
          }
          parseExprOpRightExpr(e3, t3) {
            const r3 = this.state.startLoc;
            if (39 === e3) {
              switch (this.getPluginOption("pipelineOperator", "proposal")) {
                case "hack":
                  return this.withTopicBindingContext(() => this.parseHackPipeBody());
                case "fsharp":
                  return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(t3));
              }
              if ("smart" === this.getPluginOption("pipelineOperator", "proposal")) return this.withTopicBindingContext(() => {
                if (this.prodParam.hasYield && this.isContextual(108)) throw this.raise(c.PipeBodyIsTighter, this.state.startLoc);
                return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(e3, t3), r3);
              });
            }
            return this.parseExprOpBaseRightExpr(e3, t3);
          }
          parseExprOpBaseRightExpr(e3, t3) {
            const r3 = this.state.startLoc;
            return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), r3, 57 === e3 ? t3 - 1 : t3);
          }
          parseHackPipeBody() {
            var e3;
            const { startLoc: t3 } = this.state, r3 = this.parseMaybeAssign();
            return !a.has(r3.type) || null != (e3 = r3.extra) && e3.parenthesized || this.raise(c.PipeUnparenthesizedBody, t3, { type: r3.type }), this.topicReferenceWasUsedInCurrentContext() || this.raise(c.PipeTopicUnused, t3), r3;
          }
          checkExponentialAfterUnary(e3) {
            this.match(57) && this.raise(c.UnexpectedTokenUnaryExponentiation, e3.argument);
          }
          parseMaybeUnary(e3, t3) {
            const r3 = this.state.startLoc, n2 = this.isContextual(96);
            if (n2 && this.recordAwaitIfAllowed()) {
              this.next();
              const e4 = this.parseAwait(r3);
              return t3 || this.checkExponentialAfterUnary(e4), e4;
            }
            const s2 = this.match(34), i2 = this.startNode();
            if (o2 = this.state.type, _[o2]) {
              i2.operator = this.state.value, i2.prefix = true, this.match(72) && this.expectPlugin("throwExpressions");
              const r4 = this.match(89);
              if (this.next(), i2.argument = this.parseMaybeUnary(null, true), this.checkExpressionErrors(e3, true), this.state.strict && r4) {
                const e4 = i2.argument;
                "Identifier" === e4.type ? this.raise(c.StrictDelete, i2) : this.hasPropertyAsPrivateName(e4) && this.raise(c.DeletePrivateField, i2);
              }
              if (!s2) return t3 || this.checkExponentialAfterUnary(i2), this.finishNode(i2, "UnaryExpression");
            }
            var o2;
            const a2 = this.parseUpdate(i2, s2, e3);
            if (n2) {
              const { type: e4 } = this.state;
              if ((this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(e4) : tokenCanStartExpression(e4) && !this.match(54)) && !this.isAmbiguousPrefixOrIdentifier()) return this.raiseOverwrite(c.AwaitNotInAsyncContext, r3), this.parseAwait(r3);
            }
            return a2;
          }
          parseUpdate(e3, t3, r3) {
            if (t3) {
              const t4 = e3;
              return this.checkLVal(t4.argument, this.finishNode(t4, "UpdateExpression")), e3;
            }
            const n2 = this.state.startLoc;
            let s2 = this.parseExprSubscripts(r3);
            if (this.checkExpressionErrors(r3, false)) return s2;
            for (; tokenIsPostfix(this.state.type) && !this.canInsertSemicolon(); ) {
              const e4 = this.startNodeAt(n2);
              e4.operator = this.state.value, e4.prefix = false, e4.argument = s2, this.next(), this.checkLVal(s2, s2 = this.finishNode(e4, "UpdateExpression"));
            }
            return s2;
          }
          parseExprSubscripts(e3) {
            const t3 = this.state.startLoc, r3 = this.state.potentialArrowAt, n2 = this.parseExprAtom(e3);
            return this.shouldExitDescending(n2, r3) ? n2 : this.parseSubscripts(n2, t3);
          }
          parseSubscripts(e3, t3, r3) {
            const n2 = { optionalChainMember: false, maybeAsyncArrow: this.atPossibleAsyncArrow(e3), stop: false };
            do {
              e3 = this.parseSubscript(e3, t3, r3, n2), n2.maybeAsyncArrow = false;
            } while (!n2.stop);
            return e3;
          }
          parseSubscript(e3, t3, r3, n2) {
            const { type: s2 } = this.state;
            if (!r3 && 15 === s2) return this.parseBind(e3, t3, r3, n2);
            if (tokenIsTemplate(s2)) return this.parseTaggedTemplateExpression(e3, t3, n2);
            let i2 = false;
            if (18 === s2) {
              if (r3 && (this.raise(c.OptionalChainingNoNew, this.state.startLoc), 40 === this.lookaheadCharCode())) return this.stopParseSubscript(e3, n2);
              n2.optionalChainMember = i2 = true, this.next();
            }
            if (!r3 && this.match(10)) return this.parseCoverCallAndAsyncArrowHead(e3, t3, n2, i2);
            {
              const r4 = this.eat(0);
              return r4 || i2 || this.eat(16) ? this.parseMember(e3, t3, n2, r4, i2) : this.stopParseSubscript(e3, n2);
            }
          }
          stopParseSubscript(e3, t3) {
            return t3.stop = true, e3;
          }
          parseMember(e3, t3, r3, n2, s2) {
            const i2 = this.startNodeAt(t3);
            return i2.object = e3, i2.computed = n2, n2 ? (i2.property = this.parseExpression(), this.expect(3)) : this.match(139) ? ("Super" === e3.type && this.raise(c.SuperPrivateField, t3), this.classScope.usePrivateName(this.state.value, this.state.startLoc), i2.property = this.parsePrivateName()) : i2.property = this.parseIdentifier(true), r3.optionalChainMember ? (i2.optional = s2, this.finishNode(i2, "OptionalMemberExpression")) : this.finishNode(i2, "MemberExpression");
          }
          parseBind(e3, t3, r3, n2) {
            const s2 = this.startNodeAt(t3);
            return s2.object = e3, this.next(), s2.callee = this.parseNoCallExpr(), n2.stop = true, this.parseSubscripts(this.finishNode(s2, "BindExpression"), t3, r3);
          }
          parseCoverCallAndAsyncArrowHead(e3, t3, r3, n2) {
            const s2 = this.state.maybeInArrowParameters;
            let i2 = null;
            this.state.maybeInArrowParameters = true, this.next();
            const o2 = this.startNodeAt(t3);
            o2.callee = e3;
            const { maybeAsyncArrow: a2, optionalChainMember: l2 } = r3;
            a2 && (this.expressionScope.enter(new ArrowHeadParsingScope(2)), i2 = new ExpressionErrors()), l2 && (o2.optional = n2), o2.arguments = n2 ? this.parseCallExpressionArguments() : this.parseCallExpressionArguments("Super" !== e3.type, o2, i2);
            let p2 = this.finishCallExpression(o2, l2);
            return a2 && this.shouldParseAsyncArrow() && !n2 ? (r3.stop = true, this.checkDestructuringPrivate(i2), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), p2 = this.parseAsyncArrowFromCallExpression(this.startNodeAt(t3), p2)) : (a2 && (this.checkExpressionErrors(i2, true), this.expressionScope.exit()), this.toReferencedArguments(p2)), this.state.maybeInArrowParameters = s2, p2;
          }
          toReferencedArguments(e3, t3) {
            this.toReferencedListDeep(e3.arguments, t3);
          }
          parseTaggedTemplateExpression(e3, t3, r3) {
            const n2 = this.startNodeAt(t3);
            return n2.tag = e3, n2.quasi = this.parseTemplate(true), r3.optionalChainMember && this.raise(c.OptionalChainingNoTemplate, t3), this.finishNode(n2, "TaggedTemplateExpression");
          }
          atPossibleAsyncArrow(e3) {
            return "Identifier" === e3.type && "async" === e3.name && this.state.lastTokEndLoc.index === e3.end && !this.canInsertSemicolon() && e3.end - e3.start === 5 && this.offsetToSourcePos(e3.start) === this.state.potentialArrowAt;
          }
          finishCallExpression(e3, t3) {
            if ("Import" === e3.callee.type) if (0 === e3.arguments.length || e3.arguments.length > 2) this.raise(c.ImportCallArity, e3);
            else for (const t4 of e3.arguments) "SpreadElement" === t4.type && this.raise(c.ImportCallSpreadArgument, t4);
            return this.finishNode(e3, t3 ? "OptionalCallExpression" : "CallExpression");
          }
          parseCallExpressionArguments(e3, t3, r3) {
            const n2 = [];
            let s2 = true;
            const i2 = this.state.inFSharpPipelineDirectBody;
            for (this.state.inFSharpPipelineDirectBody = false; !this.eat(11); ) {
              if (s2) s2 = false;
              else if (this.expect(12), this.match(11)) {
                t3 && this.addTrailingCommaExtraToNode(t3), this.next();
                break;
              }
              n2.push(this.parseExprListItem(11, false, r3, e3));
            }
            return this.state.inFSharpPipelineDirectBody = i2, n2;
          }
          shouldParseAsyncArrow() {
            return this.match(19) && !this.canInsertSemicolon();
          }
          parseAsyncArrowFromCallExpression(e3, t3) {
            var r3;
            return this.resetPreviousNodeTrailingComments(t3), this.expect(19), this.parseArrowExpression(e3, t3.arguments, true, null == (r3 = t3.extra) ? void 0 : r3.trailingCommaLoc), t3.innerComments && setInnerComments(e3, t3.innerComments), t3.callee.trailingComments && setInnerComments(e3, t3.callee.trailingComments), e3;
          }
          parseNoCallExpr() {
            const e3 = this.state.startLoc;
            return this.parseSubscripts(this.parseExprAtom(), e3, true);
          }
          parseExprAtom(e3) {
            let t3, r3 = null;
            const { type: n2 } = this.state;
            switch (n2) {
              case 79:
                return this.parseSuper();
              case 83:
                return t3 = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaPropertyOrPhaseCall(t3) : this.match(10) ? 512 & this.optionFlags ? this.parseImportCall(t3) : this.finishNode(t3, "Import") : (this.raise(c.UnsupportedImport, this.state.lastTokStartLoc), this.finishNode(t3, "Import"));
              case 78:
                return t3 = this.startNode(), this.next(), this.finishNode(t3, "ThisExpression");
              case 90:
                return this.parseDo(this.startNode(), false);
              case 56:
              case 31:
                return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
              case 135:
                return this.parseNumericLiteral(this.state.value);
              case 136:
                return this.parseBigIntLiteral(this.state.value);
              case 134:
                return this.parseStringLiteral(this.state.value);
              case 84:
                return this.parseNullLiteral();
              case 85:
                return this.parseBooleanLiteral(true);
              case 86:
                return this.parseBooleanLiteral(false);
              case 10: {
                const e4 = this.state.potentialArrowAt === this.state.start;
                return this.parseParenAndDistinguishExpression(e4);
              }
              case 0:
                return this.parseArrayLike(3, true, false, e3);
              case 5:
                return this.parseObjectLike(8, false, false, e3);
              case 68:
                return this.parseFunctionOrFunctionSent();
              case 26:
                r3 = this.parseDecorators();
              case 80:
                return this.parseClass(this.maybeTakeDecorators(r3, this.startNode()), false);
              case 77:
                return this.parseNewOrNewTarget();
              case 25:
              case 24:
                return this.parseTemplate(false);
              case 15: {
                t3 = this.startNode(), this.next(), t3.object = null;
                const e4 = t3.callee = this.parseNoCallExpr();
                if ("MemberExpression" === e4.type) return this.finishNode(t3, "BindExpression");
                throw this.raise(c.UnsupportedBind, e4);
              }
              case 139:
                return this.raise(c.PrivateInExpectedIn, this.state.startLoc, { identifierName: this.state.value }), this.parsePrivateName();
              case 33:
                return this.parseTopicReferenceThenEqualsSign(54, "%");
              case 32:
                return this.parseTopicReferenceThenEqualsSign(44, "^");
              case 37:
              case 38:
                return this.parseTopicReference("hack");
              case 44:
              case 54:
              case 27: {
                const e4 = this.getPluginOption("pipelineOperator", "proposal");
                if (e4) return this.parseTopicReference(e4);
                this.unexpected();
                break;
              }
              case 47: {
                const e4 = this.input.codePointAt(this.nextTokenStart());
                isIdentifierStart(e4) || 62 === e4 ? this.expectOnePlugin(["jsx", "flow", "typescript"]) : this.unexpected();
                break;
              }
              default:
                if (137 === n2) return this.parseDecimalLiteral(this.state.value);
                if (2 === n2 || 1 === n2) return this.parseArrayLike(2 === this.state.type ? 4 : 3, false, true);
                if (6 === n2 || 7 === n2) return this.parseObjectLike(6 === this.state.type ? 9 : 8, false, true);
                if (tokenIsIdentifier(n2)) {
                  if (this.isContextual(127) && 123 === this.lookaheadInLineCharCode()) return this.parseModuleExpression();
                  const e4 = this.state.potentialArrowAt === this.state.start, t4 = this.state.containsEsc, r4 = this.parseIdentifier();
                  if (!t4 && "async" === r4.name && !this.canInsertSemicolon()) {
                    const { type: e5 } = this.state;
                    if (68 === e5) return this.resetPreviousNodeTrailingComments(r4), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(r4));
                    if (tokenIsIdentifier(e5)) return 61 === this.lookaheadCharCode() ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(r4)) : r4;
                    if (90 === e5) return this.resetPreviousNodeTrailingComments(r4), this.parseDo(this.startNodeAtNode(r4), true);
                  }
                  return e4 && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(r4), [r4], false)) : r4;
                }
                this.unexpected();
            }
          }
          parseTopicReferenceThenEqualsSign(e3, t3) {
            const r3 = this.getPluginOption("pipelineOperator", "proposal");
            if (r3) return this.state.type = e3, this.state.value = t3, this.state.pos--, this.state.end--, this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1), this.parseTopicReference(r3);
            this.unexpected();
          }
          parseTopicReference(e3) {
            const t3 = this.startNode(), r3 = this.state.startLoc, n2 = this.state.type;
            return this.next(), this.finishTopicReference(t3, r3, e3, n2);
          }
          finishTopicReference(e3, t3, r3, n2) {
            if (this.testTopicReferenceConfiguration(r3, t3, n2)) return "hack" === r3 ? (this.topicReferenceIsAllowedInCurrentContext() || this.raise(c.PipeTopicUnbound, t3), this.registerTopicReference(), this.finishNode(e3, "TopicReference")) : (this.topicReferenceIsAllowedInCurrentContext() || this.raise(c.PrimaryTopicNotAllowed, t3), this.registerTopicReference(), this.finishNode(e3, "PipelinePrimaryTopicReference"));
            throw this.raise(c.PipeTopicUnconfiguredToken, t3, { token: tokenLabelName(n2) });
          }
          testTopicReferenceConfiguration(e3, t3, r3) {
            switch (e3) {
              case "hack":
                return this.hasPlugin(["pipelineOperator", { topicToken: tokenLabelName(r3) }]);
              case "smart":
                return 27 === r3;
              default:
                throw this.raise(c.PipeTopicRequiresHackPipes, t3);
            }
          }
          parseAsyncArrowUnaryFunction(e3) {
            this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));
            const t3 = [this.parseIdentifier()];
            return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(c.LineTerminatorBeforeArrow, this.state.curPosition()), this.expect(19), this.parseArrowExpression(e3, t3, true);
          }
          parseDo(e3, t3) {
            this.expectPlugin("doExpressions"), t3 && this.expectPlugin("asyncDoExpressions"), e3.async = t3, this.next();
            const r3 = this.state.labels;
            return this.state.labels = [], t3 ? (this.prodParam.enter(2), e3.body = this.parseBlock(), this.prodParam.exit()) : e3.body = this.parseBlock(), this.state.labels = r3, this.finishNode(e3, "DoExpression");
          }
          parseSuper() {
            const e3 = this.startNode();
            return this.next(), !this.match(10) || this.scope.allowDirectSuper || 16 & this.optionFlags ? this.scope.allowSuper || 16 & this.optionFlags || this.raise(c.UnexpectedSuper, e3) : this.raise(c.SuperNotAllowed, e3), this.match(10) || this.match(0) || this.match(16) || this.raise(c.UnsupportedSuper, e3), this.finishNode(e3, "Super");
          }
          parsePrivateName() {
            const e3 = this.startNode(), t3 = this.startNodeAt(createPositionWithColumnOffset(this.state.startLoc, 1)), r3 = this.state.value;
            return this.next(), e3.id = this.createIdentifier(t3, r3), this.finishNode(e3, "PrivateName");
          }
          parseFunctionOrFunctionSent() {
            const e3 = this.startNode();
            if (this.next(), this.prodParam.hasYield && this.match(16)) {
              const t3 = this.createIdentifier(this.startNodeAtNode(e3), "function");
              return this.next(), this.match(103) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.parseMetaProperty(e3, t3, "sent");
            }
            return this.parseFunction(e3);
          }
          parseMetaProperty(e3, t3, r3) {
            e3.meta = t3;
            const n2 = this.state.containsEsc;
            return e3.property = this.parseIdentifier(true), (e3.property.name !== r3 || n2) && this.raise(c.UnsupportedMetaProperty, e3.property, { target: t3.name, onlyValidPropertyName: r3 }), this.finishNode(e3, "MetaProperty");
          }
          parseImportMetaPropertyOrPhaseCall(e3) {
            if (this.next(), this.isContextual(105) || this.isContextual(97)) {
              const t3 = this.isContextual(105);
              return this.expectPlugin(t3 ? "sourcePhaseImports" : "deferredImportEvaluation"), this.next(), e3.phase = t3 ? "source" : "defer", this.parseImportCall(e3);
            }
            {
              const t3 = this.createIdentifierAt(this.startNodeAtNode(e3), "import", this.state.lastTokStartLoc);
              return this.isContextual(101) && (this.inModule || this.raise(c.ImportMetaOutsideModule, t3), this.sawUnambiguousESM = true), this.parseMetaProperty(e3, t3, "meta");
            }
          }
          parseLiteralAtNode(e3, t3, r3) {
            return this.addExtra(r3, "rawValue", e3), this.addExtra(r3, "raw", this.input.slice(this.offsetToSourcePos(r3.start), this.state.end)), r3.value = e3, this.next(), this.finishNode(r3, t3);
          }
          parseLiteral(e3, t3) {
            const r3 = this.startNode();
            return this.parseLiteralAtNode(e3, t3, r3);
          }
          parseStringLiteral(e3) {
            return this.parseLiteral(e3, "StringLiteral");
          }
          parseNumericLiteral(e3) {
            return this.parseLiteral(e3, "NumericLiteral");
          }
          parseBigIntLiteral(e3) {
            return this.parseLiteral(e3, "BigIntLiteral");
          }
          parseDecimalLiteral(e3) {
            return this.parseLiteral(e3, "DecimalLiteral");
          }
          parseRegExpLiteral(e3) {
            const t3 = this.startNode();
            return this.addExtra(t3, "raw", this.input.slice(this.offsetToSourcePos(t3.start), this.state.end)), t3.pattern = e3.pattern, t3.flags = e3.flags, this.next(), this.finishNode(t3, "RegExpLiteral");
          }
          parseBooleanLiteral(e3) {
            const t3 = this.startNode();
            return t3.value = e3, this.next(), this.finishNode(t3, "BooleanLiteral");
          }
          parseNullLiteral() {
            const e3 = this.startNode();
            return this.next(), this.finishNode(e3, "NullLiteral");
          }
          parseParenAndDistinguishExpression(e3) {
            const t3 = this.state.startLoc;
            let r3;
            this.next(), this.expressionScope.enter(new ArrowHeadParsingScope(1));
            const n2 = this.state.maybeInArrowParameters, s2 = this.state.inFSharpPipelineDirectBody;
            this.state.maybeInArrowParameters = true, this.state.inFSharpPipelineDirectBody = false;
            const i2 = this.state.startLoc, o2 = [], a2 = new ExpressionErrors();
            let l2, p2, c2 = true;
            for (; !this.match(11); ) {
              if (c2) c2 = false;
              else if (this.expect(12, null === a2.optionalParametersLoc ? null : a2.optionalParametersLoc), this.match(11)) {
                p2 = this.state.startLoc;
                break;
              }
              if (this.match(21)) {
                const e4 = this.state.startLoc;
                if (l2 = this.state.startLoc, o2.push(this.parseParenItem(this.parseRestBinding(), e4)), !this.checkCommaAfterRest(41)) break;
              } else o2.push(this.parseMaybeAssignAllowInOrVoidPattern(11, a2, this.parseParenItem));
            }
            const u2 = this.state.lastTokEndLoc;
            this.expect(11), this.state.maybeInArrowParameters = n2, this.state.inFSharpPipelineDirectBody = s2;
            let d2 = this.startNodeAt(t3);
            return e3 && this.shouldParseArrow(o2) && (d2 = this.parseArrow(d2)) ? (this.checkDestructuringPrivate(a2), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(d2, o2, false), d2) : (this.expressionScope.exit(), o2.length || this.unexpected(this.state.lastTokStartLoc), p2 && this.unexpected(p2), l2 && this.unexpected(l2), this.checkExpressionErrors(a2, true), this.toReferencedListDeep(o2, true), o2.length > 1 ? (r3 = this.startNodeAt(i2), r3.expressions = o2, this.finishNode(r3, "SequenceExpression"), this.resetEndLocation(r3, u2)) : r3 = o2[0], this.wrapParenthesis(t3, r3));
          }
          wrapParenthesis(e3, t3) {
            if (!(1024 & this.optionFlags)) return this.addExtra(t3, "parenthesized", true), this.addExtra(t3, "parenStart", e3.index), this.takeSurroundingComments(t3, e3.index, this.state.lastTokEndLoc.index), t3;
            const r3 = this.startNodeAt(e3);
            return r3.expression = t3, this.finishNode(r3, "ParenthesizedExpression");
          }
          shouldParseArrow(e3) {
            return !this.canInsertSemicolon();
          }
          parseArrow(e3) {
            if (this.eat(19)) return e3;
          }
          parseParenItem(e3, t3) {
            return e3;
          }
          parseNewOrNewTarget() {
            const e3 = this.startNode();
            if (this.next(), this.match(16)) {
              const t3 = this.createIdentifier(this.startNodeAtNode(e3), "new");
              this.next();
              const r3 = this.parseMetaProperty(e3, t3, "target");
              return this.scope.allowNewTarget || this.raise(c.UnexpectedNewTarget, r3), r3;
            }
            return this.parseNew(e3);
          }
          parseNew(e3) {
            if (this.parseNewCallee(e3), this.eat(10)) {
              const t3 = this.parseExprList(11);
              this.toReferencedList(t3), e3.arguments = t3;
            } else e3.arguments = [];
            return this.finishNode(e3, "NewExpression");
          }
          parseNewCallee(e3) {
            const t3 = this.match(83), r3 = this.parseNoCallExpr();
            e3.callee = r3, !t3 || "Import" !== r3.type && "ImportExpression" !== r3.type || this.raise(c.ImportCallNotNewExpression, r3);
          }
          parseTemplateElement(e3) {
            const { start: t3, startLoc: r3, end: n2, value: s2 } = this.state, i2 = t3 + 1, o2 = this.startNodeAt(createPositionWithColumnOffset(r3, 1));
            null === s2 && (e3 || this.raise(c.InvalidEscapeSequenceTemplate, createPositionWithColumnOffset(this.state.firstInvalidTemplateEscapePos, 1)));
            const a2 = this.match(24), l2 = a2 ? -1 : -2, p2 = n2 + l2;
            o2.value = { raw: this.input.slice(i2, p2).replace(/\r\n?/g, "\n"), cooked: null === s2 ? null : s2.slice(1, l2) }, o2.tail = a2, this.next();
            const u2 = this.finishNode(o2, "TemplateElement");
            return this.resetEndLocation(u2, createPositionWithColumnOffset(this.state.lastTokEndLoc, l2)), u2;
          }
          parseTemplate(e3) {
            const t3 = this.startNode();
            let r3 = this.parseTemplateElement(e3);
            const n2 = [r3], s2 = [];
            for (; !r3.tail; ) s2.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), n2.push(r3 = this.parseTemplateElement(e3));
            return t3.expressions = s2, t3.quasis = n2, this.finishNode(t3, "TemplateLiteral");
          }
          parseTemplateSubstitution() {
            return this.parseExpression();
          }
          parseObjectLike(e3, t3, r3, n2) {
            r3 && this.expectPlugin("recordAndTuple");
            const s2 = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = false;
            let i2 = false, o2 = true;
            const a2 = this.startNode();
            for (a2.properties = [], this.next(); !this.match(e3); ) {
              if (o2) o2 = false;
              else if (this.expect(12), this.match(e3)) {
                this.addTrailingCommaExtraToNode(a2);
                break;
              }
              let s3;
              t3 ? s3 = this.parseBindingProperty() : (s3 = this.parsePropertyDefinition(n2), i2 = this.checkProto(s3, r3, i2, n2)), r3 && !this.isObjectProperty(s3) && "SpreadElement" !== s3.type && this.raise(c.InvalidRecordProperty, s3), s3.shorthand && this.addExtra(s3, "shorthand", true), a2.properties.push(s3);
            }
            this.next(), this.state.inFSharpPipelineDirectBody = s2;
            let l2 = "ObjectExpression";
            return t3 ? l2 = "ObjectPattern" : r3 && (l2 = "RecordExpression"), this.finishNode(a2, l2);
          }
          addTrailingCommaExtraToNode(e3) {
            this.addExtra(e3, "trailingComma", this.state.lastTokStartLoc.index), this.addExtra(e3, "trailingCommaLoc", this.state.lastTokStartLoc, false);
          }
          maybeAsyncOrAccessorProp(e3) {
            return !e3.computed && "Identifier" === e3.key.type && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
          }
          parsePropertyDefinition(e3) {
            let t3 = [];
            if (this.match(26)) for (this.hasPlugin("decorators") && this.raise(c.UnsupportedPropertyDecorator, this.state.startLoc); this.match(26); ) t3.push(this.parseDecorator());
            const r3 = this.startNode();
            let n2, s2 = false, i2 = false;
            if (this.match(21)) return t3.length && this.unexpected(), this.parseSpread();
            t3.length && (r3.decorators = t3, t3 = []), r3.method = false, e3 && (n2 = this.state.startLoc);
            let o2 = this.eat(55);
            this.parsePropertyNamePrefixOperator(r3);
            const a2 = this.state.containsEsc;
            if (this.parsePropertyName(r3, e3), !o2 && !a2 && this.maybeAsyncOrAccessorProp(r3)) {
              const { key: e4 } = r3, t4 = e4.name;
              "async" !== t4 || this.hasPrecedingLineBreak() || (s2 = true, this.resetPreviousNodeTrailingComments(e4), o2 = this.eat(55), this.parsePropertyName(r3)), "get" !== t4 && "set" !== t4 || (i2 = true, this.resetPreviousNodeTrailingComments(e4), r3.kind = t4, this.match(55) && (o2 = true, this.raise(c.AccessorIsGenerator, this.state.curPosition(), { kind: t4 }), this.next()), this.parsePropertyName(r3));
            }
            return this.parseObjPropValue(r3, n2, o2, s2, false, i2, e3);
          }
          getGetterSetterExpectedParamCount(e3) {
            return "get" === e3.kind ? 0 : 1;
          }
          getObjectOrClassMethodParams(e3) {
            return e3.params;
          }
          checkGetterSetterParams(e3) {
            var t3;
            const r3 = this.getGetterSetterExpectedParamCount(e3), n2 = this.getObjectOrClassMethodParams(e3);
            n2.length !== r3 && this.raise("get" === e3.kind ? c.BadGetterArity : c.BadSetterArity, e3), "set" === e3.kind && "RestElement" === (null == (t3 = n2[n2.length - 1]) ? void 0 : t3.type) && this.raise(c.BadSetterRestParameter, e3);
          }
          parseObjectMethod(e3, t3, r3, n2, s2) {
            if (s2) {
              const r4 = this.parseMethod(e3, t3, false, false, false, "ObjectMethod");
              return this.checkGetterSetterParams(r4), r4;
            }
            if (r3 || t3 || this.match(10)) return n2 && this.unexpected(), e3.kind = "method", e3.method = true, this.parseMethod(e3, t3, r3, false, false, "ObjectMethod");
          }
          parseObjectProperty(e3, t3, r3, n2) {
            if (e3.shorthand = false, this.eat(14)) return e3.value = r3 ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowInOrVoidPattern(8, n2), this.finishObjectProperty(e3);
            if (!e3.computed && "Identifier" === e3.key.type) {
              if (this.checkReservedWord(e3.key.name, e3.key.loc.start, true, false), r3) e3.value = this.parseMaybeDefault(t3, this.cloneIdentifier(e3.key));
              else if (this.match(29)) {
                const r4 = this.state.startLoc;
                null != n2 ? null === n2.shorthandAssignLoc && (n2.shorthandAssignLoc = r4) : this.raise(c.InvalidCoverInitializedName, r4), e3.value = this.parseMaybeDefault(t3, this.cloneIdentifier(e3.key));
              } else e3.value = this.cloneIdentifier(e3.key);
              return e3.shorthand = true, this.finishObjectProperty(e3);
            }
          }
          finishObjectProperty(e3) {
            return this.finishNode(e3, "ObjectProperty");
          }
          parseObjPropValue(e3, t3, r3, n2, s2, i2, o2) {
            const a2 = this.parseObjectMethod(e3, r3, n2, s2, i2) || this.parseObjectProperty(e3, t3, s2, o2);
            return a2 || this.unexpected(), a2;
          }
          parsePropertyName(e3, t3) {
            if (this.eat(0)) e3.computed = true, e3.key = this.parseMaybeAssignAllowIn(), this.expect(3);
            else {
              const { type: r3, value: n2 } = this.state;
              let s2;
              if (tokenIsKeywordOrIdentifier(r3)) s2 = this.parseIdentifier(true);
              else switch (r3) {
                case 135:
                  s2 = this.parseNumericLiteral(n2);
                  break;
                case 134:
                  s2 = this.parseStringLiteral(n2);
                  break;
                case 136:
                  s2 = this.parseBigIntLiteral(n2);
                  break;
                case 139: {
                  const e4 = this.state.startLoc;
                  null != t3 ? null === t3.privateKeyLoc && (t3.privateKeyLoc = e4) : this.raise(c.UnexpectedPrivateField, e4), s2 = this.parsePrivateName();
                  break;
                }
                default:
                  if (137 === r3) {
                    s2 = this.parseDecimalLiteral(n2);
                    break;
                  }
                  this.unexpected();
              }
              e3.key = s2, 139 !== r3 && (e3.computed = false);
            }
          }
          initFunction(e3, t3) {
            e3.id = null, e3.generator = false, e3.async = t3;
          }
          parseMethod(e3, t3, r3, n2, s2, i2, o2 = false) {
            this.initFunction(e3, r3), e3.generator = t3, this.scope.enter(530 | (o2 ? 576 : 0) | (s2 ? 32 : 0)), this.prodParam.enter(functionFlags(r3, e3.generator)), this.parseFunctionParams(e3, n2);
            const a2 = this.parseFunctionBodyAndFinish(e3, i2, true);
            return this.prodParam.exit(), this.scope.exit(), a2;
          }
          parseArrayLike(e3, t3, r3, n2) {
            r3 && this.expectPlugin("recordAndTuple");
            const s2 = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = false;
            const i2 = this.startNode();
            return this.next(), i2.elements = this.parseExprList(e3, !r3, n2, i2), this.state.inFSharpPipelineDirectBody = s2, this.finishNode(i2, r3 ? "TupleExpression" : "ArrayExpression");
          }
          parseArrowExpression(e3, t3, r3, n2) {
            this.scope.enter(518);
            let s2 = functionFlags(r3, false);
            !this.match(5) && this.prodParam.hasIn && (s2 |= 8), this.prodParam.enter(s2), this.initFunction(e3, r3);
            const i2 = this.state.maybeInArrowParameters;
            return t3 && (this.state.maybeInArrowParameters = true, this.setArrowFunctionParameters(e3, t3, n2)), this.state.maybeInArrowParameters = false, this.parseFunctionBody(e3, true), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = i2, this.finishNode(e3, "ArrowFunctionExpression");
          }
          setArrowFunctionParameters(e3, t3, r3) {
            this.toAssignableList(t3, r3, false), e3.params = t3;
          }
          parseFunctionBodyAndFinish(e3, t3, r3 = false) {
            return this.parseFunctionBody(e3, false, r3), this.finishNode(e3, t3);
          }
          parseFunctionBody(e3, t3, r3 = false) {
            const n2 = t3 && !this.match(5);
            if (this.expressionScope.enter(newExpressionScope()), n2) e3.body = this.parseMaybeAssign(), this.checkParams(e3, false, t3, false);
            else {
              const n3 = this.state.strict, s2 = this.state.labels;
              this.state.labels = [], this.prodParam.enter(4 | this.prodParam.currentFlags()), e3.body = this.parseBlock(true, false, (s3) => {
                const i2 = !this.isSimpleParamList(e3.params);
                s3 && i2 && this.raise(c.IllegalLanguageModeDirective, "method" !== e3.kind && "constructor" !== e3.kind || !e3.key ? e3 : e3.key.loc.end);
                const o2 = !n3 && this.state.strict;
                this.checkParams(e3, !(this.state.strict || t3 || r3 || i2), t3, o2), this.state.strict && e3.id && this.checkIdentifier(e3.id, 65, o2);
              }), this.prodParam.exit(), this.state.labels = s2;
            }
            this.expressionScope.exit();
          }
          isSimpleParameter(e3) {
            return "Identifier" === e3.type;
          }
          isSimpleParamList(e3) {
            for (let t3 = 0, r3 = e3.length; t3 < r3; t3++) if (!this.isSimpleParameter(e3[t3])) return false;
            return true;
          }
          checkParams(e3, t3, r3, n2 = true) {
            const s2 = !t3 && /* @__PURE__ */ new Set(), i2 = { type: "FormalParameters" };
            for (const t4 of e3.params) this.checkLVal(t4, i2, 5, s2, n2);
          }
          parseExprList(e3, t3, r3, n2) {
            const s2 = [];
            let i2 = true;
            for (; !this.eat(e3); ) {
              if (i2) i2 = false;
              else if (this.expect(12), this.match(e3)) {
                n2 && this.addTrailingCommaExtraToNode(n2), this.next();
                break;
              }
              s2.push(this.parseExprListItem(e3, t3, r3));
            }
            return s2;
          }
          parseExprListItem(e3, t3, r3, n2) {
            let s2;
            if (this.match(12)) t3 || this.raise(c.UnexpectedToken, this.state.curPosition(), { unexpected: "," }), s2 = null;
            else if (this.match(21)) {
              const e4 = this.state.startLoc;
              s2 = this.parseParenItem(this.parseSpread(r3), e4);
            } else if (this.match(17)) {
              this.expectPlugin("partialApplication"), n2 || this.raise(c.UnexpectedArgumentPlaceholder, this.state.startLoc);
              const e4 = this.startNode();
              this.next(), s2 = this.finishNode(e4, "ArgumentPlaceholder");
            } else s2 = this.parseMaybeAssignAllowInOrVoidPattern(e3, r3, this.parseParenItem);
            return s2;
          }
          parseIdentifier(e3) {
            const t3 = this.startNode(), r3 = this.parseIdentifierName(e3);
            return this.createIdentifier(t3, r3);
          }
          createIdentifier(e3, t3) {
            return e3.name = t3, e3.loc.identifierName = t3, this.finishNode(e3, "Identifier");
          }
          createIdentifierAt(e3, t3, r3) {
            return e3.name = t3, e3.loc.identifierName = t3, this.finishNodeAt(e3, "Identifier", r3);
          }
          parseIdentifierName(e3) {
            let t3;
            const { startLoc: r3, type: n2 } = this.state;
            tokenIsKeywordOrIdentifier(n2) ? t3 = this.state.value : this.unexpected();
            const s2 = n2 <= 92;
            return e3 ? s2 && this.replaceToken(132) : this.checkReservedWord(t3, r3, s2, false), this.next(), t3;
          }
          checkReservedWord(e3, t3, r3, n2) {
            if (e3.length > 10) return;
            if (!(function(e4) {
              return B.has(e4);
            })(e3)) return;
            if (r3 && (function(e4) {
              return F.has(e4);
            })(e3)) return void this.raise(c.UnexpectedKeyword, t3, { keyword: e3 });
            if ((this.state.strict ? n2 ? isStrictBindReservedWord : isStrictReservedWord : isReservedWord)(e3, this.inModule)) this.raise(c.UnexpectedReservedWord, t3, { reservedWord: e3 });
            else if ("yield" === e3) {
              if (this.prodParam.hasYield) return void this.raise(c.YieldBindingIdentifier, t3);
            } else if ("await" === e3) {
              if (this.prodParam.hasAwait) return void this.raise(c.AwaitBindingIdentifier, t3);
              if (this.scope.inStaticBlock) return void this.raise(c.AwaitBindingIdentifierInStaticBlock, t3);
              this.expressionScope.recordAsyncArrowParametersError(t3);
            } else if ("arguments" === e3 && this.scope.inClassAndNotInNonArrowFunction) return void this.raise(c.ArgumentsInClass, t3);
          }
          recordAwaitIfAllowed() {
            const e3 = this.prodParam.hasAwait;
            return e3 && !this.scope.inFunction && (this.state.hasTopLevelAwait = true), e3;
          }
          parseAwait(e3) {
            const t3 = this.startNodeAt(e3);
            return this.expressionScope.recordParameterInitializerError(c.AwaitExpressionFormalParameter, t3), this.eat(55) && this.raise(c.ObsoleteAwaitStar, t3), this.scope.inFunction || 1 & this.optionFlags || (this.isAmbiguousPrefixOrIdentifier() ? this.ambiguousScriptDifferentAst = true : this.sawUnambiguousESM = true), this.state.soloAwait || (t3.argument = this.parseMaybeUnary(null, true)), this.finishNode(t3, "AwaitExpression");
          }
          isAmbiguousPrefixOrIdentifier() {
            if (this.hasPrecedingLineBreak()) return true;
            const { type: e3 } = this.state;
            return 53 === e3 || 10 === e3 || 0 === e3 || tokenIsTemplate(e3) || 102 === e3 && !this.state.containsEsc || 138 === e3 || 56 === e3 || this.hasPlugin("v8intrinsic") && 54 === e3;
          }
          parseYield(e3) {
            const t3 = this.startNodeAt(e3);
            this.expressionScope.recordParameterInitializerError(c.YieldInParameter, t3);
            let r3 = false, n2 = null;
            if (!this.hasPrecedingLineBreak()) switch (r3 = this.eat(55), this.state.type) {
              case 13:
              case 140:
              case 8:
              case 11:
              case 3:
              case 9:
              case 14:
              case 12:
                if (!r3) break;
              default:
                n2 = this.parseMaybeAssign();
            }
            return t3.delegate = r3, t3.argument = n2, this.finishNode(t3, "YieldExpression");
          }
          parseImportCall(e3) {
            if (this.next(), e3.source = this.parseMaybeAssignAllowIn(), e3.options = null, this.eat(12)) {
              if (this.match(11)) this.addTrailingCommaExtraToNode(e3.source);
              else if (e3.options = this.parseMaybeAssignAllowIn(), this.eat(12) && (this.addTrailingCommaExtraToNode(e3.options), !this.match(11))) {
                do {
                  this.parseMaybeAssignAllowIn();
                } while (this.eat(12) && !this.match(11));
                this.raise(c.ImportCallArity, e3);
              }
            }
            return this.expect(11), this.finishNode(e3, "ImportExpression");
          }
          checkPipelineAtInfixOperator(e3, t3) {
            this.hasPlugin(["pipelineOperator", { proposal: "smart" }]) && "SequenceExpression" === e3.type && this.raise(c.PipelineHeadSequenceExpression, t3);
          }
          parseSmartPipelineBodyInStyle(e3, t3) {
            if (this.isSimpleReference(e3)) {
              const r3 = this.startNodeAt(t3);
              return r3.callee = e3, this.finishNode(r3, "PipelineBareFunction");
            }
            {
              const r3 = this.startNodeAt(t3);
              return this.checkSmartPipeTopicBodyEarlyErrors(t3), r3.expression = e3, this.finishNode(r3, "PipelineTopicExpression");
            }
          }
          isSimpleReference(e3) {
            switch (e3.type) {
              case "MemberExpression":
                return !e3.computed && this.isSimpleReference(e3.object);
              case "Identifier":
                return true;
              default:
                return false;
            }
          }
          checkSmartPipeTopicBodyEarlyErrors(e3) {
            if (this.match(19)) throw this.raise(c.PipelineBodyNoArrow, this.state.startLoc);
            this.topicReferenceWasUsedInCurrentContext() || this.raise(c.PipelineTopicUnused, e3);
          }
          withTopicBindingContext(e3) {
            const t3 = this.state.topicContext;
            this.state.topicContext = { maxNumOfResolvableTopics: 1, maxTopicIndex: null };
            try {
              return e3();
            } finally {
              this.state.topicContext = t3;
            }
          }
          withSmartMixTopicForbiddingContext(e3) {
            if (!this.hasPlugin(["pipelineOperator", { proposal: "smart" }])) return e3();
            {
              const t3 = this.state.topicContext;
              this.state.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null };
              try {
                return e3();
              } finally {
                this.state.topicContext = t3;
              }
            }
          }
          withSoloAwaitPermittingContext(e3) {
            const t3 = this.state.soloAwait;
            this.state.soloAwait = true;
            try {
              return e3();
            } finally {
              this.state.soloAwait = t3;
            }
          }
          allowInAnd(e3) {
            const t3 = this.prodParam.currentFlags();
            if (8 & ~t3) {
              this.prodParam.enter(8 | t3);
              try {
                return e3();
              } finally {
                this.prodParam.exit();
              }
            }
            return e3();
          }
          disallowInAnd(e3) {
            const t3 = this.prodParam.currentFlags();
            if (8 & t3) {
              this.prodParam.enter(-9 & t3);
              try {
                return e3();
              } finally {
                this.prodParam.exit();
              }
            }
            return e3();
          }
          registerTopicReference() {
            this.state.topicContext.maxTopicIndex = 0;
          }
          topicReferenceIsAllowedInCurrentContext() {
            return this.state.topicContext.maxNumOfResolvableTopics >= 1;
          }
          topicReferenceWasUsedInCurrentContext() {
            return null != this.state.topicContext.maxTopicIndex && this.state.topicContext.maxTopicIndex >= 0;
          }
          parseFSharpPipelineBody(e3) {
            const t3 = this.state.startLoc;
            this.state.potentialArrowAt = this.state.start;
            const r3 = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = true;
            const n2 = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), t3, e3);
            return this.state.inFSharpPipelineDirectBody = r3, n2;
          }
          parseModuleExpression() {
            this.expectPlugin("moduleBlocks");
            const e3 = this.startNode();
            this.next(), this.match(5) || this.unexpected(null, 5);
            const t3 = this.startNodeAt(this.state.endLoc);
            this.next();
            const r3 = this.initializeScopes(true);
            this.enterInitialScopes();
            try {
              e3.body = this.parseProgram(t3, 8, "module");
            } finally {
              r3();
            }
            return this.finishNode(e3, "ModuleExpression");
          }
          parseVoidPattern(e3) {
            this.expectPlugin("discardBinding");
            const t3 = this.startNode();
            return null != e3 && (e3.voidPatternLoc = this.state.startLoc), this.next(), this.finishNode(t3, "VoidPattern");
          }
          parseMaybeAssignAllowInOrVoidPattern(e3, t3, r3) {
            if (null != t3 && this.match(88)) {
              const r4 = this.lookaheadCharCode();
              if (44 === r4 || r4 === (3 === e3 ? 93 : 8 === e3 ? 125 : 41) || 61 === r4) return this.parseMaybeDefault(this.state.startLoc, this.parseVoidPattern(t3));
            }
            return this.parseMaybeAssignAllowIn(t3, r3);
          }
          parsePropertyNamePrefixOperator(e3) {
          }
        }
        const se = { kind: 1 }, ie = { kind: 2 }, oe = /[\uD800-\uDFFF]/u, ae = /in(?:stanceof)?/y;
        class StatementParser extends ExpressionParser {
          parseTopLevel(e3, t3) {
            return e3.program = this.parseProgram(t3, 140, "module" === this.options.sourceType ? "module" : "script"), e3.comments = this.comments, 256 & this.optionFlags && (e3.tokens = (function(e4, t4, r3) {
              for (let n2 = 0; n2 < e4.length; n2++) {
                const s2 = e4[n2], { type: i2 } = s2;
                if ("number" == typeof i2) {
                  if (139 === i2) {
                    const { loc: t5, start: r4, value: i3, end: o2 } = s2, a2 = r4 + 1, l2 = createPositionWithColumnOffset(t5.start, 1);
                    e4.splice(n2, 1, new Token({ type: getExportedToken(27), value: "#", start: r4, end: a2, startLoc: t5.start, endLoc: l2 }), new Token({ type: getExportedToken(132), value: i3, start: a2, end: o2, startLoc: l2, endLoc: t5.end })), n2++;
                    continue;
                  }
                  if (tokenIsTemplate(i2)) {
                    const { loc: o2, start: a2, value: l2, end: p2 } = s2, c2 = a2 + 1, u2 = createPositionWithColumnOffset(o2.start, 1);
                    let d2, h2, m2, f2, y2;
                    d2 = 96 === t4.charCodeAt(a2 - r3) ? new Token({ type: getExportedToken(22), value: "`", start: a2, end: c2, startLoc: o2.start, endLoc: u2 }) : new Token({ type: getExportedToken(8), value: "}", start: a2, end: c2, startLoc: o2.start, endLoc: u2 }), 24 === i2 ? (m2 = p2 - 1, f2 = createPositionWithColumnOffset(o2.end, -1), h2 = null === l2 ? null : l2.slice(1, -1), y2 = new Token({ type: getExportedToken(22), value: "`", start: m2, end: p2, startLoc: f2, endLoc: o2.end })) : (m2 = p2 - 2, f2 = createPositionWithColumnOffset(o2.end, -2), h2 = null === l2 ? null : l2.slice(1, -2), y2 = new Token({ type: getExportedToken(23), value: "${", start: m2, end: p2, startLoc: f2, endLoc: o2.end })), e4.splice(n2, 1, d2, new Token({ type: getExportedToken(20), value: h2, start: c2, end: m2, startLoc: u2, endLoc: f2 }), y2), n2 += 2;
                    continue;
                  }
                  s2.type = getExportedToken(i2);
                }
              }
              return e4;
            })(this.tokens, this.input, this.startIndex)), this.finishNode(e3, "File");
          }
          parseProgram(e3, t3, r3) {
            if (e3.sourceType = r3, e3.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(e3, true, true, t3), this.inModule) {
              if (!(64 & this.optionFlags) && this.scope.undefinedExports.size > 0) for (const [e4, t4] of Array.from(this.scope.undefinedExports)) this.raise(c.ModuleExportUndefined, t4, { localName: e4 });
              this.addExtra(e3, "topLevelAwait", this.state.hasTopLevelAwait);
            }
            let n2;
            return n2 = 140 === t3 ? this.finishNode(e3, "Program") : this.finishNodeAt(e3, "Program", createPositionWithColumnOffset(this.state.startLoc, -1)), n2;
          }
          stmtToDirective(e3) {
            const t3 = this.castNodeTo(e3, "Directive"), r3 = this.castNodeTo(e3.expression, "DirectiveLiteral"), n2 = r3.value, s2 = this.input.slice(this.offsetToSourcePos(r3.start), this.offsetToSourcePos(r3.end)), i2 = r3.value = s2.slice(1, -1);
            return this.addExtra(r3, "raw", s2), this.addExtra(r3, "rawValue", i2), this.addExtra(r3, "expressionValue", n2), t3.value = r3, delete e3.expression, t3;
          }
          parseInterpreterDirective() {
            if (!this.match(28)) return null;
            const e3 = this.startNode();
            return e3.value = this.state.value, this.next(), this.finishNode(e3, "InterpreterDirective");
          }
          isLet() {
            return !!this.isContextual(100) && this.hasFollowingBindingAtom();
          }
          isUsing() {
            if (!this.isContextual(107)) return false;
            const e3 = this.nextTokenInLineStart(), t3 = this.codePointAtPos(e3);
            return this.chStartsBindingIdentifier(t3, e3);
          }
          isForUsing() {
            if (!this.isContextual(107)) return false;
            const e3 = this.nextTokenInLineStart(), t3 = this.codePointAtPos(e3);
            if (this.isUnparsedContextual(e3, "of")) {
              const t4 = this.lookaheadCharCodeSince(e3 + 2);
              if (61 !== t4 && 58 !== t4 && 59 !== t4) return false;
            }
            return !(!this.chStartsBindingIdentifier(t3, e3) && !this.isUnparsedContextual(e3, "void"));
          }
          isAwaitUsing() {
            if (!this.isContextual(96)) return false;
            let e3 = this.nextTokenInLineStart();
            if (this.isUnparsedContextual(e3, "using")) {
              e3 = this.nextTokenInLineStartSince(e3 + 5);
              const t3 = this.codePointAtPos(e3);
              if (this.chStartsBindingIdentifier(t3, e3)) return true;
            }
            return false;
          }
          chStartsBindingIdentifier(e3, t3) {
            if (isIdentifierStart(e3)) {
              if (ae.lastIndex = t3, ae.test(this.input)) {
                const e4 = this.codePointAtPos(ae.lastIndex);
                if (!isIdentifierChar(e4) && 92 !== e4) return false;
              }
              return true;
            }
            return 92 === e3;
          }
          chStartsBindingPattern(e3) {
            return 91 === e3 || 123 === e3;
          }
          hasFollowingBindingAtom() {
            const e3 = this.nextTokenStart(), t3 = this.codePointAtPos(e3);
            return this.chStartsBindingPattern(t3) || this.chStartsBindingIdentifier(t3, e3);
          }
          hasInLineFollowingBindingIdentifierOrBrace() {
            const e3 = this.nextTokenInLineStart(), t3 = this.codePointAtPos(e3);
            return 123 === t3 || this.chStartsBindingIdentifier(t3, e3);
          }
          allowsUsing() {
            return (this.scope.inModule || !this.scope.inTopLevel) && !this.scope.inBareCaseStatement;
          }
          parseModuleItem() {
            return this.parseStatementLike(15);
          }
          parseStatementListItem() {
            return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
          }
          parseStatementOrSloppyAnnexBFunctionDeclaration(e3 = false) {
            let t3 = 0;
            return this.options.annexB && !this.state.strict && (t3 |= 4, e3 && (t3 |= 8)), this.parseStatementLike(t3);
          }
          parseStatement() {
            return this.parseStatementLike(0);
          }
          parseStatementLike(e3) {
            let t3 = null;
            return this.match(26) && (t3 = this.parseDecorators(true)), this.parseStatementContent(e3, t3);
          }
          parseStatementContent(e3, t3) {
            const r3 = this.state.type, n2 = this.startNode(), s2 = !!(2 & e3), i2 = !!(4 & e3), o2 = 1 & e3;
            switch (r3) {
              case 60:
                return this.parseBreakContinueStatement(n2, true);
              case 63:
                return this.parseBreakContinueStatement(n2, false);
              case 64:
                return this.parseDebuggerStatement(n2);
              case 90:
                return this.parseDoWhileStatement(n2);
              case 91:
                return this.parseForStatement(n2);
              case 68:
                if (46 === this.lookaheadCharCode()) break;
                return i2 || this.raise(this.state.strict ? c.StrictFunction : this.options.annexB ? c.SloppyFunctionAnnexB : c.SloppyFunction, this.state.startLoc), this.parseFunctionStatement(n2, false, !s2 && i2);
              case 80:
                return s2 || this.unexpected(), this.parseClass(this.maybeTakeDecorators(t3, n2), true);
              case 69:
                return this.parseIfStatement(n2);
              case 70:
                return this.parseReturnStatement(n2);
              case 71:
                return this.parseSwitchStatement(n2);
              case 72:
                return this.parseThrowStatement(n2);
              case 73:
                return this.parseTryStatement(n2);
              case 96:
                if (this.isAwaitUsing()) return this.allowsUsing() ? s2 ? this.recordAwaitIfAllowed() || this.raise(c.AwaitUsingNotInAsyncContext, n2) : this.raise(c.UnexpectedLexicalDeclaration, n2) : this.raise(c.UnexpectedUsingDeclaration, n2), this.next(), this.parseVarStatement(n2, "await using");
                break;
              case 107:
                if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifierOrBrace()) break;
                return this.allowsUsing() ? s2 || this.raise(c.UnexpectedLexicalDeclaration, this.state.startLoc) : this.raise(c.UnexpectedUsingDeclaration, this.state.startLoc), this.parseVarStatement(n2, "using");
              case 100: {
                if (this.state.containsEsc) break;
                const e4 = this.nextTokenStart(), t4 = this.codePointAtPos(e4);
                if (91 !== t4) {
                  if (!s2 && this.hasFollowingLineBreak()) break;
                  if (!this.chStartsBindingIdentifier(t4, e4) && 123 !== t4) break;
                }
              }
              case 75:
                s2 || this.raise(c.UnexpectedLexicalDeclaration, this.state.startLoc);
              case 74: {
                const e4 = this.state.value;
                return this.parseVarStatement(n2, e4);
              }
              case 92:
                return this.parseWhileStatement(n2);
              case 76:
                return this.parseWithStatement(n2);
              case 5:
                return this.parseBlock();
              case 13:
                return this.parseEmptyStatement(n2);
              case 83: {
                const e4 = this.lookaheadCharCode();
                if (40 === e4 || 46 === e4) break;
              }
              case 82: {
                let e4;
                return 8 & this.optionFlags || o2 || this.raise(c.UnexpectedImportExport, this.state.startLoc), this.next(), e4 = 83 === r3 ? this.parseImport(n2) : this.parseExport(n2, t3), this.assertModuleNodeAllowed(e4), e4;
              }
              default:
                if (this.isAsyncFunction()) return s2 || this.raise(c.AsyncFunctionInSingleStatementContext, this.state.startLoc), this.next(), this.parseFunctionStatement(n2, true, !s2 && i2);
            }
            const a2 = this.state.value, l2 = this.parseExpression();
            return tokenIsIdentifier(r3) && "Identifier" === l2.type && this.eat(14) ? this.parseLabeledStatement(n2, a2, l2, e3) : this.parseExpressionStatement(n2, l2, t3);
          }
          assertModuleNodeAllowed(e3) {
            8 & this.optionFlags || this.inModule || this.raise(c.ImportOutsideModule, e3);
          }
          decoratorsEnabledBeforeExport() {
            return !!this.hasPlugin("decorators-legacy") || this.hasPlugin("decorators") && false !== this.getPluginOption("decorators", "decoratorsBeforeExport");
          }
          maybeTakeDecorators(e3, t3, r3) {
            var n2;
            e3 && (null != (n2 = t3.decorators) && n2.length ? ("boolean" != typeof this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(c.DecoratorsBeforeAfterExport, t3.decorators[0]), t3.decorators.unshift(...e3)) : t3.decorators = e3, this.resetStartLocationFromNode(t3, e3[0]), r3 && this.resetStartLocationFromNode(r3, t3));
            return t3;
          }
          canHaveLeadingDecorator() {
            return this.match(80);
          }
          parseDecorators(e3) {
            const t3 = [];
            do {
              t3.push(this.parseDecorator());
            } while (this.match(26));
            if (this.match(82)) e3 || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(c.DecoratorExportClass, this.state.startLoc);
            else if (!this.canHaveLeadingDecorator()) throw this.raise(c.UnexpectedLeadingDecorator, this.state.startLoc);
            return t3;
          }
          parseDecorator() {
            this.expectOnePlugin(["decorators", "decorators-legacy"]);
            const e3 = this.startNode();
            if (this.next(), this.hasPlugin("decorators")) {
              const t3 = this.state.startLoc;
              let r3;
              if (this.match(10)) {
                const t4 = this.state.startLoc;
                this.next(), r3 = this.parseExpression(), this.expect(11), r3 = this.wrapParenthesis(t4, r3);
                const n2 = this.state.startLoc;
                e3.expression = this.parseMaybeDecoratorArguments(r3, t4), false === this.getPluginOption("decorators", "allowCallParenthesized") && e3.expression !== r3 && this.raise(c.DecoratorArgumentsOutsideParentheses, n2);
              } else {
                for (r3 = this.parseIdentifier(false); this.eat(16); ) {
                  const e4 = this.startNodeAt(t3);
                  e4.object = r3, this.match(139) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), e4.property = this.parsePrivateName()) : e4.property = this.parseIdentifier(true), e4.computed = false, r3 = this.finishNode(e4, "MemberExpression");
                }
                e3.expression = this.parseMaybeDecoratorArguments(r3, t3);
              }
            } else e3.expression = this.parseExprSubscripts();
            return this.finishNode(e3, "Decorator");
          }
          parseMaybeDecoratorArguments(e3, t3) {
            if (this.eat(10)) {
              const r3 = this.startNodeAt(t3);
              return r3.callee = e3, r3.arguments = this.parseCallExpressionArguments(), this.toReferencedList(r3.arguments), this.finishNode(r3, "CallExpression");
            }
            return e3;
          }
          parseBreakContinueStatement(e3, t3) {
            return this.next(), this.isLineTerminator() ? e3.label = null : (e3.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(e3, t3), this.finishNode(e3, t3 ? "BreakStatement" : "ContinueStatement");
          }
          verifyBreakContinue(e3, t3) {
            let r3;
            for (r3 = 0; r3 < this.state.labels.length; ++r3) {
              const n2 = this.state.labels[r3];
              if (null == e3.label || n2.name === e3.label.name) {
                if (null != n2.kind && (t3 || 1 === n2.kind)) break;
                if (e3.label && t3) break;
              }
            }
            if (r3 === this.state.labels.length) {
              const r4 = t3 ? "BreakStatement" : "ContinueStatement";
              this.raise(c.IllegalBreakContinue, e3, { type: r4 });
            }
          }
          parseDebuggerStatement(e3) {
            return this.next(), this.semicolon(), this.finishNode(e3, "DebuggerStatement");
          }
          parseHeaderExpression() {
            this.expect(10);
            const e3 = this.parseExpression();
            return this.expect(11), e3;
          }
          parseDoWhileStatement(e3) {
            return this.next(), this.state.labels.push(se), e3.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.expect(92), e3.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(e3, "DoWhileStatement");
          }
          parseForStatement(e3) {
            this.next(), this.state.labels.push(se);
            let t3 = null;
            if (this.isContextual(96) && this.recordAwaitIfAllowed() && (t3 = this.state.startLoc, this.next()), this.scope.enter(0), this.expect(10), this.match(13)) return null !== t3 && this.unexpected(t3), this.parseFor(e3, null);
            const r3 = this.isContextual(100);
            {
              const n3 = this.isAwaitUsing(), s3 = n3 || this.isForUsing(), i3 = r3 && this.hasFollowingBindingAtom() || s3;
              if (this.match(74) || this.match(75) || i3) {
                const r4 = this.startNode();
                let i4;
                n3 ? (i4 = "await using", this.recordAwaitIfAllowed() || this.raise(c.AwaitUsingNotInAsyncContext, this.state.startLoc), this.next()) : i4 = this.state.value, this.next(), this.parseVar(r4, true, i4);
                const o3 = this.finishNode(r4, "VariableDeclaration"), a2 = this.match(58);
                return a2 && s3 && this.raise(c.ForInUsing, o3), (a2 || this.isContextual(102)) && 1 === o3.declarations.length ? this.parseForIn(e3, o3, t3) : (null !== t3 && this.unexpected(t3), this.parseFor(e3, o3));
              }
            }
            const n2 = this.isContextual(95), s2 = new ExpressionErrors(), i2 = this.parseExpression(true, s2), o2 = this.isContextual(102);
            if (o2 && (r3 && this.raise(c.ForOfLet, i2), null === t3 && n2 && "Identifier" === i2.type && this.raise(c.ForOfAsync, i2)), o2 || this.match(58)) {
              this.checkDestructuringPrivate(s2), this.toAssignable(i2, true);
              const r4 = o2 ? "ForOfStatement" : "ForInStatement";
              return this.checkLVal(i2, { type: r4 }), this.parseForIn(e3, i2, t3);
            }
            return this.checkExpressionErrors(s2, true), null !== t3 && this.unexpected(t3), this.parseFor(e3, i2);
          }
          parseFunctionStatement(e3, t3, r3) {
            return this.next(), this.parseFunction(e3, 1 | (r3 ? 2 : 0) | (t3 ? 8 : 0));
          }
          parseIfStatement(e3) {
            return this.next(), e3.test = this.parseHeaderExpression(), e3.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration(), e3.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null, this.finishNode(e3, "IfStatement");
          }
          parseReturnStatement(e3) {
            return this.prodParam.hasReturn || this.raise(c.IllegalReturn, this.state.startLoc), this.next(), this.isLineTerminator() ? e3.argument = null : (e3.argument = this.parseExpression(), this.semicolon()), this.finishNode(e3, "ReturnStatement");
          }
          parseSwitchStatement(e3) {
            this.next(), e3.discriminant = this.parseHeaderExpression();
            const t3 = e3.cases = [];
            let r3;
            this.expect(5), this.state.labels.push(ie), this.scope.enter(256);
            for (let e4; !this.match(8); ) if (this.match(61) || this.match(65)) {
              const n2 = this.match(61);
              r3 && this.finishNode(r3, "SwitchCase"), t3.push(r3 = this.startNode()), r3.consequent = [], this.next(), n2 ? r3.test = this.parseExpression() : (e4 && this.raise(c.MultipleDefaultsInSwitch, this.state.lastTokStartLoc), e4 = true, r3.test = null), this.expect(14);
            } else r3 ? r3.consequent.push(this.parseStatementListItem()) : this.unexpected();
            return this.scope.exit(), r3 && this.finishNode(r3, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(e3, "SwitchStatement");
          }
          parseThrowStatement(e3) {
            return this.next(), this.hasPrecedingLineBreak() && this.raise(c.NewlineAfterThrow, this.state.lastTokEndLoc), e3.argument = this.parseExpression(), this.semicolon(), this.finishNode(e3, "ThrowStatement");
          }
          parseCatchClauseParam() {
            const e3 = this.parseBindingAtom();
            return this.scope.enter(this.options.annexB && "Identifier" === e3.type ? 8 : 0), this.checkLVal(e3, { type: "CatchClause" }, 9), e3;
          }
          parseTryStatement(e3) {
            if (this.next(), e3.block = this.parseBlock(), e3.handler = null, this.match(62)) {
              const t3 = this.startNode();
              this.next(), this.match(10) ? (this.expect(10), t3.param = this.parseCatchClauseParam(), this.expect(11)) : (t3.param = null, this.scope.enter(0)), t3.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false)), this.scope.exit(), e3.handler = this.finishNode(t3, "CatchClause");
            }
            return e3.finalizer = this.eat(67) ? this.parseBlock() : null, e3.handler || e3.finalizer || this.raise(c.NoCatchOrFinally, e3), this.finishNode(e3, "TryStatement");
          }
          parseVarStatement(e3, t3, r3 = false) {
            return this.next(), this.parseVar(e3, false, t3, r3), this.semicolon(), this.finishNode(e3, "VariableDeclaration");
          }
          parseWhileStatement(e3) {
            return this.next(), e3.test = this.parseHeaderExpression(), this.state.labels.push(se), e3.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.finishNode(e3, "WhileStatement");
          }
          parseWithStatement(e3) {
            return this.state.strict && this.raise(c.StrictWith, this.state.startLoc), this.next(), e3.object = this.parseHeaderExpression(), e3.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.finishNode(e3, "WithStatement");
          }
          parseEmptyStatement(e3) {
            return this.next(), this.finishNode(e3, "EmptyStatement");
          }
          parseLabeledStatement(e3, t3, r3, n2) {
            for (const e4 of this.state.labels) e4.name === t3 && this.raise(c.LabelRedeclaration, r3, { labelName: t3 });
            const s2 = (i2 = this.state.type) >= 90 && i2 <= 92 ? 1 : this.match(71) ? 2 : null;
            var i2;
            for (let t4 = this.state.labels.length - 1; t4 >= 0; t4--) {
              const r4 = this.state.labels[t4];
              if (r4.statementStart !== e3.start) break;
              r4.statementStart = this.sourceToOffsetPos(this.state.start), r4.kind = s2;
            }
            return this.state.labels.push({ name: t3, kind: s2, statementStart: this.sourceToOffsetPos(this.state.start) }), e3.body = 8 & n2 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(true) : this.parseStatement(), this.state.labels.pop(), e3.label = r3, this.finishNode(e3, "LabeledStatement");
          }
          parseExpressionStatement(e3, t3, r3) {
            return e3.expression = t3, this.semicolon(), this.finishNode(e3, "ExpressionStatement");
          }
          parseBlock(e3 = false, t3 = true, r3) {
            const n2 = this.startNode();
            return e3 && this.state.strictErrors.clear(), this.expect(5), t3 && this.scope.enter(0), this.parseBlockBody(n2, e3, false, 8, r3), t3 && this.scope.exit(), this.finishNode(n2, "BlockStatement");
          }
          isValidDirective(e3) {
            return "ExpressionStatement" === e3.type && "StringLiteral" === e3.expression.type && !e3.expression.extra.parenthesized;
          }
          parseBlockBody(e3, t3, r3, n2, s2) {
            const i2 = e3.body = [], o2 = e3.directives = [];
            this.parseBlockOrModuleBlockBody(i2, t3 ? o2 : void 0, r3, n2, s2);
          }
          parseBlockOrModuleBlockBody(e3, t3, r3, n2, s2) {
            const i2 = this.state.strict;
            let o2 = false, a2 = false;
            for (; !this.match(n2); ) {
              const n3 = r3 ? this.parseModuleItem() : this.parseStatementListItem();
              if (t3 && !a2) {
                if (this.isValidDirective(n3)) {
                  const e4 = this.stmtToDirective(n3);
                  t3.push(e4), o2 || "use strict" !== e4.value.value || (o2 = true, this.setStrict(true));
                  continue;
                }
                a2 = true, this.state.strictErrors.clear();
              }
              e3.push(n3);
            }
            null == s2 || s2.call(this, o2), i2 || this.setStrict(false), this.next();
          }
          parseFor(e3, t3) {
            return e3.init = t3, this.semicolon(false), e3.test = this.match(13) ? null : this.parseExpression(), this.semicolon(false), e3.update = this.match(11) ? null : this.parseExpression(), this.expect(11), e3.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(e3, "ForStatement");
          }
          parseForIn(e3, t3, r3) {
            const n2 = this.match(58);
            return this.next(), n2 ? null !== r3 && this.unexpected(r3) : e3.await = null !== r3, "VariableDeclaration" !== t3.type || null == t3.declarations[0].init || n2 && this.options.annexB && !this.state.strict && "var" === t3.kind && "Identifier" === t3.declarations[0].id.type || this.raise(c.ForInOfLoopInitializer, t3, { type: n2 ? "ForInStatement" : "ForOfStatement" }), "AssignmentPattern" === t3.type && this.raise(c.InvalidLhs, t3, { ancestor: { type: "ForStatement" } }), e3.left = t3, e3.right = n2 ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), e3.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(e3, n2 ? "ForInStatement" : "ForOfStatement");
          }
          parseVar(e3, t3, r3, n2 = false) {
            const s2 = e3.declarations = [];
            for (e3.kind = r3; ; ) {
              const e4 = this.startNode();
              if (this.parseVarId(e4, r3), e4.init = this.eat(29) ? t3 ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, null !== e4.init || n2 || ("Identifier" === e4.id.type || t3 && (this.match(58) || this.isContextual(102)) ? "const" !== r3 && "using" !== r3 && "await using" !== r3 || this.match(58) || this.isContextual(102) || this.raise(c.DeclarationMissingInitializer, this.state.lastTokEndLoc, { kind: r3 }) : this.raise(c.DeclarationMissingInitializer, this.state.lastTokEndLoc, { kind: "destructuring" })), s2.push(this.finishNode(e4, "VariableDeclarator")), !this.eat(12)) break;
            }
            return e3;
          }
          parseVarId(e3, t3) {
            const r3 = this.parseBindingAtom();
            "using" === t3 || "await using" === t3 ? "ArrayPattern" !== r3.type && "ObjectPattern" !== r3.type || this.raise(c.UsingDeclarationHasBindingPattern, r3.loc.start) : "VoidPattern" === r3.type && this.raise(c.UnexpectedVoidPattern, r3.loc.start), this.checkLVal(r3, { type: "VariableDeclarator" }, "var" === t3 ? 5 : 8201), e3.id = r3;
          }
          parseAsyncFunctionExpression(e3) {
            return this.parseFunction(e3, 8);
          }
          parseFunction(e3, t3 = 0) {
            const r3 = 2 & t3, n2 = !!(1 & t3), s2 = n2 && !(4 & t3), i2 = !!(8 & t3);
            this.initFunction(e3, i2), this.match(55) && (r3 && this.raise(c.GeneratorInSingleStatementContext, this.state.startLoc), this.next(), e3.generator = true), n2 && (e3.id = this.parseFunctionId(s2));
            const o2 = this.state.maybeInArrowParameters;
            return this.state.maybeInArrowParameters = false, this.scope.enter(514), this.prodParam.enter(functionFlags(i2, e3.generator)), n2 || (e3.id = this.parseFunctionId()), this.parseFunctionParams(e3, false), this.withSmartMixTopicForbiddingContext(() => {
              this.parseFunctionBodyAndFinish(e3, n2 ? "FunctionDeclaration" : "FunctionExpression");
            }), this.prodParam.exit(), this.scope.exit(), n2 && !r3 && this.registerFunctionStatementId(e3), this.state.maybeInArrowParameters = o2, e3;
          }
          parseFunctionId(e3) {
            return e3 || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;
          }
          parseFunctionParams(e3, t3) {
            this.expect(10), this.expressionScope.enter(new ExpressionScope(3)), e3.params = this.parseBindingList(11, 41, 2 | (t3 ? 4 : 0)), this.expressionScope.exit();
          }
          registerFunctionStatementId(e3) {
            e3.id && this.scope.declareName(e3.id.name, !this.options.annexB || this.state.strict || e3.generator || e3.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, e3.id.loc.start);
          }
          parseClass(e3, t3, r3) {
            this.next();
            const n2 = this.state.strict;
            return this.state.strict = true, this.parseClassId(e3, t3, r3), this.parseClassSuper(e3), e3.body = this.parseClassBody(!!e3.superClass, n2), this.finishNode(e3, t3 ? "ClassDeclaration" : "ClassExpression");
          }
          isClassProperty() {
            return this.match(29) || this.match(13) || this.match(8);
          }
          isClassMethod() {
            return this.match(10);
          }
          nameIsConstructor(e3) {
            return "Identifier" === e3.type && "constructor" === e3.name || "StringLiteral" === e3.type && "constructor" === e3.value;
          }
          isNonstaticConstructor(e3) {
            return !e3.computed && !e3.static && this.nameIsConstructor(e3.key);
          }
          parseClassBody(e3, t3) {
            this.classScope.enter();
            const r3 = { hadConstructor: false, hadSuperClass: e3 };
            let n2 = [];
            const s2 = this.startNode();
            if (s2.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
              for (; !this.match(8); ) {
                if (this.eat(13)) {
                  if (n2.length > 0) throw this.raise(c.DecoratorSemicolon, this.state.lastTokEndLoc);
                  continue;
                }
                if (this.match(26)) {
                  n2.push(this.parseDecorator());
                  continue;
                }
                const e4 = this.startNode();
                n2.length && (e4.decorators = n2, this.resetStartLocationFromNode(e4, n2[0]), n2 = []), this.parseClassMember(s2, e4, r3), "constructor" === e4.kind && e4.decorators && e4.decorators.length > 0 && this.raise(c.DecoratorConstructor, e4);
              }
            }), this.state.strict = t3, this.next(), n2.length) throw this.raise(c.TrailingDecorator, this.state.startLoc);
            return this.classScope.exit(), this.finishNode(s2, "ClassBody");
          }
          parseClassMemberFromModifier(e3, t3) {
            const r3 = this.parseIdentifier(true);
            if (this.isClassMethod()) {
              const n2 = t3;
              return n2.kind = "method", n2.computed = false, n2.key = r3, n2.static = false, this.pushClassMethod(e3, n2, false, false, false, false), true;
            }
            if (this.isClassProperty()) {
              const n2 = t3;
              return n2.computed = false, n2.key = r3, n2.static = false, e3.body.push(this.parseClassProperty(n2)), true;
            }
            return this.resetPreviousNodeTrailingComments(r3), false;
          }
          parseClassMember(e3, t3, r3) {
            const n2 = this.isContextual(106);
            if (n2) {
              if (this.parseClassMemberFromModifier(e3, t3)) return;
              if (this.eat(5)) return void this.parseClassStaticBlock(e3, t3);
            }
            this.parseClassMemberWithIsStatic(e3, t3, r3, n2);
          }
          parseClassMemberWithIsStatic(e3, t3, r3, n2) {
            const s2 = t3, i2 = t3, o2 = t3, a2 = t3, l2 = t3, p2 = s2, u2 = s2;
            if (t3.static = n2, this.parsePropertyNamePrefixOperator(t3), this.eat(55)) {
              p2.kind = "method";
              const t4 = this.match(139);
              return this.parseClassElementName(p2), this.parsePostMemberNameModifiers(p2), t4 ? void this.pushClassPrivateMethod(e3, i2, true, false) : (this.isNonstaticConstructor(s2) && this.raise(c.ConstructorIsGenerator, s2.key), void this.pushClassMethod(e3, s2, true, false, false, false));
            }
            const d2 = !this.state.containsEsc && tokenIsIdentifier(this.state.type), h2 = this.parseClassElementName(t3), m2 = d2 ? h2.name : null, f2 = this.isPrivateName(h2), y2 = this.state.startLoc;
            if (this.parsePostMemberNameModifiers(u2), this.isClassMethod()) {
              if (p2.kind = "method", f2) return void this.pushClassPrivateMethod(e3, i2, false, false);
              const n3 = this.isNonstaticConstructor(s2);
              let o3 = false;
              n3 && (s2.kind = "constructor", r3.hadConstructor && !this.hasPlugin("typescript") && this.raise(c.DuplicateConstructor, h2), n3 && this.hasPlugin("typescript") && t3.override && this.raise(c.OverrideOnConstructor, h2), r3.hadConstructor = true, o3 = r3.hadSuperClass), this.pushClassMethod(e3, s2, false, false, n3, o3);
            } else if (this.isClassProperty()) f2 ? this.pushClassPrivateProperty(e3, a2) : this.pushClassProperty(e3, o2);
            else if ("async" !== m2 || this.isLineTerminator()) if ("get" !== m2 && "set" !== m2 || this.match(55) && this.isLineTerminator()) if ("accessor" !== m2 || this.isLineTerminator()) this.isLineTerminator() ? f2 ? this.pushClassPrivateProperty(e3, a2) : this.pushClassProperty(e3, o2) : this.unexpected();
            else {
              this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(h2);
              const t4 = this.match(139);
              this.parseClassElementName(o2), this.pushClassAccessorProperty(e3, l2, t4);
            }
            else {
              this.resetPreviousNodeTrailingComments(h2), p2.kind = m2;
              const t4 = this.match(139);
              this.parseClassElementName(s2), t4 ? this.pushClassPrivateMethod(e3, i2, false, false) : (this.isNonstaticConstructor(s2) && this.raise(c.ConstructorIsAccessor, s2.key), this.pushClassMethod(e3, s2, false, false, false, false)), this.checkGetterSetterParams(s2);
            }
            else {
              this.resetPreviousNodeTrailingComments(h2);
              const t4 = this.eat(55);
              u2.optional && this.unexpected(y2), p2.kind = "method";
              const r4 = this.match(139);
              this.parseClassElementName(p2), this.parsePostMemberNameModifiers(u2), r4 ? this.pushClassPrivateMethod(e3, i2, t4, true) : (this.isNonstaticConstructor(s2) && this.raise(c.ConstructorIsAsync, s2.key), this.pushClassMethod(e3, s2, t4, true, false, false));
            }
          }
          parseClassElementName(e3) {
            const { type: t3, value: r3 } = this.state;
            if (132 !== t3 && 134 !== t3 || !e3.static || "prototype" !== r3 || this.raise(c.StaticPrototype, this.state.startLoc), 139 === t3) {
              "constructor" === r3 && this.raise(c.ConstructorClassPrivateField, this.state.startLoc);
              const t4 = this.parsePrivateName();
              return e3.key = t4, t4;
            }
            return this.parsePropertyName(e3), e3.key;
          }
          parseClassStaticBlock(e3, t3) {
            var r3;
            this.scope.enter(720);
            const n2 = this.state.labels;
            this.state.labels = [], this.prodParam.enter(0);
            const s2 = t3.body = [];
            this.parseBlockOrModuleBlockBody(s2, void 0, false, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = n2, e3.body.push(this.finishNode(t3, "StaticBlock")), null != (r3 = t3.decorators) && r3.length && this.raise(c.DecoratorStaticBlock, t3);
          }
          pushClassProperty(e3, t3) {
            !t3.computed && this.nameIsConstructor(t3.key) && this.raise(c.ConstructorClassField, t3.key), e3.body.push(this.parseClassProperty(t3));
          }
          pushClassPrivateProperty(e3, t3) {
            const r3 = this.parseClassPrivateProperty(t3);
            e3.body.push(r3), this.classScope.declarePrivateName(this.getPrivateNameSV(r3.key), 0, r3.key.loc.start);
          }
          pushClassAccessorProperty(e3, t3, r3) {
            r3 || t3.computed || !this.nameIsConstructor(t3.key) || this.raise(c.ConstructorClassField, t3.key);
            const n2 = this.parseClassAccessorProperty(t3);
            e3.body.push(n2), r3 && this.classScope.declarePrivateName(this.getPrivateNameSV(n2.key), 0, n2.key.loc.start);
          }
          pushClassMethod(e3, t3, r3, n2, s2, i2) {
            e3.body.push(this.parseMethod(t3, r3, n2, s2, i2, "ClassMethod", true));
          }
          pushClassPrivateMethod(e3, t3, r3, n2) {
            const s2 = this.parseMethod(t3, r3, n2, false, false, "ClassPrivateMethod", true);
            e3.body.push(s2);
            const i2 = "get" === s2.kind ? s2.static ? 6 : 2 : "set" === s2.kind ? s2.static ? 5 : 1 : 0;
            this.declareClassPrivateMethodInScope(s2, i2);
          }
          declareClassPrivateMethodInScope(e3, t3) {
            this.classScope.declarePrivateName(this.getPrivateNameSV(e3.key), t3, e3.key.loc.start);
          }
          parsePostMemberNameModifiers(e3) {
          }
          parseClassPrivateProperty(e3) {
            return this.parseInitializer(e3), this.semicolon(), this.finishNode(e3, "ClassPrivateProperty");
          }
          parseClassProperty(e3) {
            return this.parseInitializer(e3), this.semicolon(), this.finishNode(e3, "ClassProperty");
          }
          parseClassAccessorProperty(e3) {
            return this.parseInitializer(e3), this.semicolon(), this.finishNode(e3, "ClassAccessorProperty");
          }
          parseInitializer(e3) {
            this.scope.enter(592), this.expressionScope.enter(newExpressionScope()), this.prodParam.enter(0), e3.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
          }
          parseClassId(e3, t3, r3, n2 = 8331) {
            if (tokenIsIdentifier(this.state.type)) e3.id = this.parseIdentifier(), t3 && this.declareNameFromIdentifier(e3.id, n2);
            else {
              if (!r3 && t3) throw this.raise(c.MissingClassName, this.state.startLoc);
              e3.id = null;
            }
          }
          parseClassSuper(e3) {
            e3.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
          }
          parseExport(e3, t3) {
            const r3 = this.parseMaybeImportPhase(e3, true), n2 = this.maybeParseExportDefaultSpecifier(e3, r3), s2 = !n2 || this.eat(12), i2 = s2 && this.eatExportStar(e3), o2 = i2 && this.maybeParseExportNamespaceSpecifier(e3), a2 = s2 && (!o2 || this.eat(12)), l2 = n2 || i2;
            if (i2 && !o2) {
              if (n2 && this.unexpected(), t3) throw this.raise(c.UnsupportedDecoratorExport, e3);
              return this.parseExportFrom(e3, true), this.sawUnambiguousESM = true, this.finishNode(e3, "ExportAllDeclaration");
            }
            const p2 = this.maybeParseExportNamedSpecifiers(e3);
            let u2;
            if (n2 && s2 && !i2 && !p2 && this.unexpected(null, 5), o2 && a2 && this.unexpected(null, 98), l2 || p2) {
              if (u2 = false, t3) throw this.raise(c.UnsupportedDecoratorExport, e3);
              this.parseExportFrom(e3, l2);
            } else u2 = this.maybeParseExportDeclaration(e3);
            if (l2 || p2 || u2) {
              var d2;
              const r4 = e3;
              if (this.checkExport(r4, true, false, !!r4.source), "ClassDeclaration" === (null == (d2 = r4.declaration) ? void 0 : d2.type)) this.maybeTakeDecorators(t3, r4.declaration, r4);
              else if (t3) throw this.raise(c.UnsupportedDecoratorExport, e3);
              return this.sawUnambiguousESM = true, this.finishNode(r4, "ExportNamedDeclaration");
            }
            if (this.eat(65)) {
              const r4 = e3, n3 = this.parseExportDefaultExpression();
              if (r4.declaration = n3, "ClassDeclaration" === n3.type) this.maybeTakeDecorators(t3, n3, r4);
              else if (t3) throw this.raise(c.UnsupportedDecoratorExport, e3);
              return this.checkExport(r4, true, true), this.sawUnambiguousESM = true, this.finishNode(r4, "ExportDefaultDeclaration");
            }
            this.unexpected(null, 5);
          }
          eatExportStar(e3) {
            return this.eat(55);
          }
          maybeParseExportDefaultSpecifier(e3, t3) {
            if (t3 || this.isExportDefaultSpecifier()) {
              this.expectPlugin("exportDefaultFrom", null == t3 ? void 0 : t3.loc.start);
              const r3 = t3 || this.parseIdentifier(true), n2 = this.startNodeAtNode(r3);
              return n2.exported = r3, e3.specifiers = [this.finishNode(n2, "ExportDefaultSpecifier")], true;
            }
            return false;
          }
          maybeParseExportNamespaceSpecifier(e3) {
            if (this.isContextual(93)) {
              var t3;
              null != (t3 = e3).specifiers || (t3.specifiers = []);
              const r3 = this.startNodeAt(this.state.lastTokStartLoc);
              return this.next(), r3.exported = this.parseModuleExportName(), e3.specifiers.push(this.finishNode(r3, "ExportNamespaceSpecifier")), true;
            }
            return false;
          }
          maybeParseExportNamedSpecifiers(e3) {
            if (this.match(5)) {
              const t3 = e3;
              t3.specifiers || (t3.specifiers = []);
              const r3 = "type" === t3.exportKind;
              return t3.specifiers.push(...this.parseExportSpecifiers(r3)), t3.source = null, this.hasPlugin("importAssertions") ? t3.assertions = [] : t3.attributes = [], t3.declaration = null, true;
            }
            return false;
          }
          maybeParseExportDeclaration(e3) {
            return !!this.shouldParseExportDeclaration() && (e3.specifiers = [], e3.source = null, this.hasPlugin("importAssertions") ? e3.assertions = [] : e3.attributes = [], e3.declaration = this.parseExportDeclaration(e3), true);
          }
          isAsyncFunction() {
            if (!this.isContextual(95)) return false;
            const e3 = this.nextTokenInLineStart();
            return this.isUnparsedContextual(e3, "function");
          }
          parseExportDefaultExpression() {
            const e3 = this.startNode();
            if (this.match(68)) return this.next(), this.parseFunction(e3, 5);
            if (this.isAsyncFunction()) return this.next(), this.next(), this.parseFunction(e3, 13);
            if (this.match(80)) return this.parseClass(e3, true, true);
            if (this.match(26)) return this.hasPlugin("decorators") && true === this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(c.DecoratorBeforeExport, this.state.startLoc), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(false), this.startNode()), true, true);
            if (this.match(75) || this.match(74) || this.isLet() || this.isUsing() || this.isAwaitUsing()) throw this.raise(c.UnsupportedDefaultExport, this.state.startLoc);
            const t3 = this.parseMaybeAssignAllowIn();
            return this.semicolon(), t3;
          }
          parseExportDeclaration(e3) {
            if (this.match(80)) {
              return this.parseClass(this.startNode(), true, false);
            }
            return this.parseStatementListItem();
          }
          isExportDefaultSpecifier() {
            const { type: e3 } = this.state;
            if (tokenIsIdentifier(e3)) {
              if (95 === e3 && !this.state.containsEsc || 100 === e3) return false;
              if ((130 === e3 || 129 === e3) && !this.state.containsEsc) {
                const e4 = this.nextTokenStart(), t4 = this.input.charCodeAt(e4);
                if (123 === t4 || this.chStartsBindingIdentifier(t4, e4) && !this.input.startsWith("from", e4)) return this.expectOnePlugin(["flow", "typescript"]), false;
              }
            } else if (!this.match(65)) return false;
            const t3 = this.nextTokenStart(), r3 = this.isUnparsedContextual(t3, "from");
            if (44 === this.input.charCodeAt(t3) || tokenIsIdentifier(this.state.type) && r3) return true;
            if (this.match(65) && r3) {
              const e4 = this.input.charCodeAt(this.nextTokenStartSince(t3 + 4));
              return 34 === e4 || 39 === e4;
            }
            return false;
          }
          parseExportFrom(e3, t3) {
            this.eatContextual(98) ? (e3.source = this.parseImportSource(), this.checkExport(e3), this.maybeParseImportAttributes(e3), this.checkJSONModuleImport(e3)) : t3 && this.unexpected(), this.semicolon();
          }
          shouldParseExportDeclaration() {
            const { type: e3 } = this.state;
            return 26 === e3 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators")) ? (true === this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(c.DecoratorBeforeExport, this.state.startLoc), true) : this.isUsing() || this.isAwaitUsing() ? (this.raise(c.UsingDeclarationExport, this.state.startLoc), true) : 74 === e3 || 75 === e3 || 68 === e3 || 80 === e3 || this.isLet() || this.isAsyncFunction();
          }
          checkExport(e3, t3, r3, n2) {
            var s2;
            if (t3) {
              if (r3) {
                if (this.checkDuplicateExports(e3, "default"), this.hasPlugin("exportDefaultFrom")) {
                  var i2;
                  const t4 = e3.declaration;
                  "Identifier" !== t4.type || "from" !== t4.name || t4.end - t4.start !== 4 || null != (i2 = t4.extra) && i2.parenthesized || this.raise(c.ExportDefaultFromAsIdentifier, t4);
                }
              } else if (null != (s2 = e3.specifiers) && s2.length) for (const t4 of e3.specifiers) {
                const { exported: e4 } = t4, r4 = "Identifier" === e4.type ? e4.name : e4.value;
                if (this.checkDuplicateExports(t4, r4), !n2 && t4.local) {
                  const { local: e5 } = t4;
                  "Identifier" !== e5.type ? this.raise(c.ExportBindingIsString, t4, { localName: e5.value, exportName: r4 }) : (this.checkReservedWord(e5.name, e5.loc.start, true, false), this.scope.checkLocalExport(e5));
                }
              }
              else if (e3.declaration) {
                const t4 = e3.declaration;
                if ("FunctionDeclaration" === t4.type || "ClassDeclaration" === t4.type) {
                  const { id: r4 } = t4;
                  if (!r4) throw new Error("Assertion failure");
                  this.checkDuplicateExports(e3, r4.name);
                } else if ("VariableDeclaration" === t4.type) for (const e4 of t4.declarations) this.checkDeclaration(e4.id);
              }
            }
          }
          checkDeclaration(e3) {
            if ("Identifier" === e3.type) this.checkDuplicateExports(e3, e3.name);
            else if ("ObjectPattern" === e3.type) for (const t3 of e3.properties) this.checkDeclaration(t3);
            else if ("ArrayPattern" === e3.type) for (const t3 of e3.elements) t3 && this.checkDeclaration(t3);
            else "ObjectProperty" === e3.type ? this.checkDeclaration(e3.value) : "RestElement" === e3.type ? this.checkDeclaration(e3.argument) : "AssignmentPattern" === e3.type && this.checkDeclaration(e3.left);
          }
          checkDuplicateExports(e3, t3) {
            this.exportedIdentifiers.has(t3) && ("default" === t3 ? this.raise(c.DuplicateDefaultExport, e3) : this.raise(c.DuplicateExport, e3, { exportName: t3 })), this.exportedIdentifiers.add(t3);
          }
          parseExportSpecifiers(e3) {
            const t3 = [];
            let r3 = true;
            for (this.expect(5); !this.eat(8); ) {
              if (r3) r3 = false;
              else if (this.expect(12), this.eat(8)) break;
              const n2 = this.isContextual(130), s2 = this.match(134), i2 = this.startNode();
              i2.local = this.parseModuleExportName(), t3.push(this.parseExportSpecifier(i2, s2, e3, n2));
            }
            return t3;
          }
          parseExportSpecifier(e3, t3, r3, n2) {
            return this.eatContextual(93) ? e3.exported = this.parseModuleExportName() : t3 ? e3.exported = this.cloneStringLiteral(e3.local) : e3.exported || (e3.exported = this.cloneIdentifier(e3.local)), this.finishNode(e3, "ExportSpecifier");
          }
          parseModuleExportName() {
            if (this.match(134)) {
              const e3 = this.parseStringLiteral(this.state.value), t3 = oe.exec(e3.value);
              return t3 && this.raise(c.ModuleExportNameHasLoneSurrogate, e3, { surrogateCharCode: t3[0].charCodeAt(0) }), e3;
            }
            return this.parseIdentifier(true);
          }
          isJSONModuleImport(e3) {
            return null != e3.assertions && e3.assertions.some(({ key: e4, value: t3 }) => "json" === t3.value && ("Identifier" === e4.type ? "type" === e4.name : "type" === e4.value));
          }
          checkImportReflection(e3) {
            const { specifiers: t3 } = e3, r3 = 1 === t3.length ? t3[0].type : null;
            if ("source" === e3.phase) "ImportDefaultSpecifier" !== r3 && this.raise(c.SourcePhaseImportRequiresDefault, t3[0].loc.start);
            else if ("defer" === e3.phase) "ImportNamespaceSpecifier" !== r3 && this.raise(c.DeferImportRequiresNamespace, t3[0].loc.start);
            else if (e3.module) {
              var n2;
              "ImportDefaultSpecifier" !== r3 && this.raise(c.ImportReflectionNotBinding, t3[0].loc.start), (null == (n2 = e3.assertions) ? void 0 : n2.length) > 0 && this.raise(c.ImportReflectionHasAssertion, t3[0].loc.start);
            }
          }
          checkJSONModuleImport(e3) {
            if (this.isJSONModuleImport(e3) && "ExportAllDeclaration" !== e3.type) {
              const { specifiers: t3 } = e3;
              if (null != t3) {
                const e4 = t3.find((e5) => {
                  let t4;
                  if ("ExportSpecifier" === e5.type ? t4 = e5.local : "ImportSpecifier" === e5.type && (t4 = e5.imported), void 0 !== t4) return "Identifier" === t4.type ? "default" !== t4.name : "default" !== t4.value;
                });
                void 0 !== e4 && this.raise(c.ImportJSONBindingNotDefault, e4.loc.start);
              }
            }
          }
          isPotentialImportPhase(e3) {
            return !e3 && (this.isContextual(105) || this.isContextual(97) || this.isContextual(127));
          }
          applyImportPhase(e3, t3, r3, n2) {
            t3 || ("module" === r3 ? (this.expectPlugin("importReflection", n2), e3.module = true) : this.hasPlugin("importReflection") && (e3.module = false), "source" === r3 ? (this.expectPlugin("sourcePhaseImports", n2), e3.phase = "source") : "defer" === r3 ? (this.expectPlugin("deferredImportEvaluation", n2), e3.phase = "defer") : this.hasPlugin("sourcePhaseImports") && (e3.phase = null));
          }
          parseMaybeImportPhase(e3, t3) {
            if (!this.isPotentialImportPhase(t3)) return this.applyImportPhase(e3, t3, null), null;
            const r3 = this.startNode(), n2 = this.parseIdentifierName(true), { type: s2 } = this.state;
            return (tokenIsKeywordOrIdentifier(s2) ? 98 !== s2 || 102 === this.lookaheadCharCode() : 12 !== s2) ? (this.applyImportPhase(e3, t3, n2, r3.loc.start), null) : (this.applyImportPhase(e3, t3, null), this.createIdentifier(r3, n2));
          }
          isPrecedingIdImportPhase(e3) {
            const { type: t3 } = this.state;
            return tokenIsIdentifier(t3) ? 98 !== t3 || 102 === this.lookaheadCharCode() : 12 !== t3;
          }
          parseImport(e3) {
            return this.match(134) ? this.parseImportSourceAndAttributes(e3) : this.parseImportSpecifiersAndAfter(e3, this.parseMaybeImportPhase(e3, false));
          }
          parseImportSpecifiersAndAfter(e3, t3) {
            e3.specifiers = [];
            const r3 = !this.maybeParseDefaultImportSpecifier(e3, t3) || this.eat(12), n2 = r3 && this.maybeParseStarImportSpecifier(e3);
            return r3 && !n2 && this.parseNamedImportSpecifiers(e3), this.expectContextual(98), this.parseImportSourceAndAttributes(e3);
          }
          parseImportSourceAndAttributes(e3) {
            return null != e3.specifiers || (e3.specifiers = []), e3.source = this.parseImportSource(), this.maybeParseImportAttributes(e3), this.checkImportReflection(e3), this.checkJSONModuleImport(e3), this.semicolon(), this.sawUnambiguousESM = true, this.finishNode(e3, "ImportDeclaration");
          }
          parseImportSource() {
            return this.match(134) || this.unexpected(), this.parseExprAtom();
          }
          parseImportSpecifierLocal(e3, t3, r3) {
            t3.local = this.parseIdentifier(), e3.specifiers.push(this.finishImportSpecifier(t3, r3));
          }
          finishImportSpecifier(e3, t3, r3 = 8201) {
            return this.checkLVal(e3.local, { type: t3 }, r3), this.finishNode(e3, t3);
          }
          parseImportAttributes() {
            this.expect(5);
            const e3 = [], t3 = /* @__PURE__ */ new Set();
            do {
              if (this.match(8)) break;
              const r3 = this.startNode(), n2 = this.state.value;
              if (t3.has(n2) && this.raise(c.ModuleAttributesWithDuplicateKeys, this.state.startLoc, { key: n2 }), t3.add(n2), this.match(134) ? r3.key = this.parseStringLiteral(n2) : r3.key = this.parseIdentifier(true), this.expect(14), !this.match(134)) throw this.raise(c.ModuleAttributeInvalidValue, this.state.startLoc);
              r3.value = this.parseStringLiteral(this.state.value), e3.push(this.finishNode(r3, "ImportAttribute"));
            } while (this.eat(12));
            return this.expect(8), e3;
          }
          parseModuleAttributes() {
            const e3 = [], t3 = /* @__PURE__ */ new Set();
            do {
              const r3 = this.startNode();
              if (r3.key = this.parseIdentifier(true), "type" !== r3.key.name && this.raise(c.ModuleAttributeDifferentFromType, r3.key), t3.has(r3.key.name) && this.raise(c.ModuleAttributesWithDuplicateKeys, r3.key, { key: r3.key.name }), t3.add(r3.key.name), this.expect(14), !this.match(134)) throw this.raise(c.ModuleAttributeInvalidValue, this.state.startLoc);
              r3.value = this.parseStringLiteral(this.state.value), e3.push(this.finishNode(r3, "ImportAttribute"));
            } while (this.eat(12));
            return e3;
          }
          maybeParseImportAttributes(e3) {
            let t3;
            var r3 = false;
            if (this.match(76)) {
              if (this.hasPrecedingLineBreak() && 40 === this.lookaheadCharCode()) return;
              this.next(), this.hasPlugin("moduleAttributes") ? (t3 = this.parseModuleAttributes(), this.addExtra(e3, "deprecatedWithLegacySyntax", true)) : t3 = this.parseImportAttributes(), r3 = true;
            } else this.isContextual(94) && !this.hasPrecedingLineBreak() ? (this.hasPlugin("deprecatedImportAssert") || this.hasPlugin("importAssertions") || this.raise(c.ImportAttributesUseAssert, this.state.startLoc), this.hasPlugin("importAssertions") || this.addExtra(e3, "deprecatedAssertSyntax", true), this.next(), t3 = this.parseImportAttributes()) : t3 = [];
            !r3 && this.hasPlugin("importAssertions") ? e3.assertions = t3 : e3.attributes = t3;
          }
          maybeParseDefaultImportSpecifier(e3, t3) {
            if (t3) {
              const r3 = this.startNodeAtNode(t3);
              return r3.local = t3, e3.specifiers.push(this.finishImportSpecifier(r3, "ImportDefaultSpecifier")), true;
            }
            return !!tokenIsKeywordOrIdentifier(this.state.type) && (this.parseImportSpecifierLocal(e3, this.startNode(), "ImportDefaultSpecifier"), true);
          }
          maybeParseStarImportSpecifier(e3) {
            if (this.match(55)) {
              const t3 = this.startNode();
              return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(e3, t3, "ImportNamespaceSpecifier"), true;
            }
            return false;
          }
          parseNamedImportSpecifiers(e3) {
            let t3 = true;
            for (this.expect(5); !this.eat(8); ) {
              if (t3) t3 = false;
              else {
                if (this.eat(14)) throw this.raise(c.DestructureNamedImport, this.state.startLoc);
                if (this.expect(12), this.eat(8)) break;
              }
              const r3 = this.startNode(), n2 = this.match(134), s2 = this.isContextual(130);
              r3.imported = this.parseModuleExportName();
              const i2 = this.parseImportSpecifier(r3, n2, "type" === e3.importKind || "typeof" === e3.importKind, s2, void 0);
              e3.specifiers.push(i2);
            }
          }
          parseImportSpecifier(e3, t3, r3, n2, s2) {
            if (this.eatContextual(93)) e3.local = this.parseIdentifier();
            else {
              const { imported: r4 } = e3;
              if (t3) throw this.raise(c.ImportBindingIsString, e3, { importName: r4.value });
              this.checkReservedWord(r4.name, e3.loc.start, true, true), e3.local || (e3.local = this.cloneIdentifier(r4));
            }
            return this.finishImportSpecifier(e3, "ImportSpecifier", s2);
          }
          isThisParam(e3) {
            return "Identifier" === e3.type && "this" === e3.name;
          }
        }
        class Parser extends StatementParser {
          constructor(e3, t3, r3) {
            super(e3 = (function(e4) {
              const t4 = { sourceType: "script", sourceFilename: void 0, startIndex: 0, startColumn: 0, startLine: 1, allowAwaitOutsideFunction: false, allowReturnOutsideFunction: false, allowNewTargetOutsideFunction: false, allowImportExportEverywhere: false, allowSuperOutsideMethod: false, allowUndeclaredExports: false, allowYieldOutsideFunction: false, plugins: [], strictMode: null, ranges: false, tokens: false, createImportExpressions: false, createParenthesizedExpressions: false, errorRecovery: false, attachComment: true, annexB: true };
              if (null == e4) return t4;
              if (null != e4.annexB && false !== e4.annexB) throw new Error("The `annexB` option can only be set to `false`.");
              for (const r4 of Object.keys(t4)) null != e4[r4] && (t4[r4] = e4[r4]);
              if (1 === t4.startLine) null == e4.startIndex && t4.startColumn > 0 ? t4.startIndex = t4.startColumn : null == e4.startColumn && t4.startIndex > 0 && (t4.startColumn = t4.startIndex);
              else if ((null == e4.startColumn || null == e4.startIndex) && null != e4.startIndex) throw new Error("With a `startLine > 1` you must also specify `startIndex` and `startColumn`.");
              if ("commonjs" === t4.sourceType) {
                if (null != e4.allowAwaitOutsideFunction) throw new Error("The `allowAwaitOutsideFunction` option cannot be used with `sourceType: 'commonjs'`.");
                if (null != e4.allowReturnOutsideFunction) throw new Error("`sourceType: 'commonjs'` implies `allowReturnOutsideFunction: true`, please remove the `allowReturnOutsideFunction` option or use `sourceType: 'script'`.");
                if (null != e4.allowNewTargetOutsideFunction) throw new Error("`sourceType: 'commonjs'` implies `allowNewTargetOutsideFunction: true`, please remove the `allowNewTargetOutsideFunction` option or use `sourceType: 'script'`.");
              }
              return t4;
            })(e3), t3), this.options = e3, this.initializeScopes(), this.plugins = r3, this.filename = e3.sourceFilename, this.startIndex = e3.startIndex;
            let n2 = 0;
            e3.allowAwaitOutsideFunction && (n2 |= 1), e3.allowReturnOutsideFunction && (n2 |= 2), e3.allowImportExportEverywhere && (n2 |= 8), e3.allowSuperOutsideMethod && (n2 |= 16), e3.allowUndeclaredExports && (n2 |= 64), e3.allowNewTargetOutsideFunction && (n2 |= 4), e3.allowYieldOutsideFunction && (n2 |= 32), e3.ranges && (n2 |= 128), e3.tokens && (n2 |= 256), e3.createImportExpressions && (n2 |= 512), e3.createParenthesizedExpressions && (n2 |= 1024), e3.errorRecovery && (n2 |= 2048), e3.attachComment && (n2 |= 4096), e3.annexB && (n2 |= 8192), this.optionFlags = n2;
          }
          getScopeHandler() {
            return ScopeHandler;
          }
          parse() {
            this.enterInitialScopes();
            const e3 = this.startNode(), t3 = this.startNode();
            return this.nextToken(), e3.errors = null, this.parseTopLevel(e3, t3), e3.errors = this.state.errors, e3.comments.length = this.state.commentsLen, e3;
          }
        }
        const le = (function(e3) {
          const t3 = {};
          for (const r3 of Object.keys(e3)) t3[r3] = getExportedToken(e3[r3]);
          return t3;
        })(A);
        function getParser(e3, t3) {
          let r3 = Parser;
          const n2 = /* @__PURE__ */ new Map();
          if (null != e3 && e3.plugins) {
            for (const t4 of e3.plugins) {
              let e4, r4;
              "string" == typeof t4 ? e4 = t4 : [e4, r4] = t4, n2.has(e4) || n2.set(e4, r4 || {});
            }
            !(function(e4) {
              if (e4.has("decorators")) {
                if (e4.has("decorators-legacy")) throw new Error("Cannot use the decorators and decorators-legacy plugin together");
                const t5 = e4.get("decorators").decoratorsBeforeExport;
                if (null != t5 && "boolean" != typeof t5) throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
                const r5 = e4.get("decorators").allowCallParenthesized;
                if (null != r5 && "boolean" != typeof r5) throw new Error("'allowCallParenthesized' must be a boolean.");
              }
              if (e4.has("flow") && e4.has("typescript")) throw new Error("Cannot combine flow and typescript plugins.");
              if (e4.has("placeholders") && e4.has("v8intrinsic")) throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
              if (e4.has("pipelineOperator")) {
                var t4;
                const n3 = e4.get("pipelineOperator").proposal;
                if (!ee.includes(n3)) {
                  const e5 = ee.map((e6) => `"${e6}"`).join(", ");
                  throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${e5}.`);
                }
                if ("hack" === n3) {
                  if (e4.has("placeholders")) throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
                  if (e4.has("v8intrinsic")) throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
                  const t5 = e4.get("pipelineOperator").topicToken;
                  if (!te.includes(t5)) {
                    const e5 = te.map((e6) => `"${e6}"`).join(", ");
                    throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${e5}.`);
                  }
                  var r4;
                  if ("#" === t5 && "hash" === (null == (r4 = e4.get("recordAndTuple")) ? void 0 : r4.syntaxType)) throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "hack", topicToken: "#" }]\` and \`${JSON.stringify(["recordAndTuple", e4.get("recordAndTuple")])}\`.`);
                } else if ("smart" === n3 && "hash" === (null == (t4 = e4.get("recordAndTuple")) ? void 0 : t4.syntaxType)) throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "smart" }]\` and \`${JSON.stringify(["recordAndTuple", e4.get("recordAndTuple")])}\`.`);
              }
              if (e4.has("moduleAttributes")) {
                if (e4.has("deprecatedImportAssert") || e4.has("importAssertions")) throw new Error("Cannot combine importAssertions, deprecatedImportAssert and moduleAttributes plugins.");
                if ("may-2020" !== e4.get("moduleAttributes").version) throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
              }
              if (e4.has("importAssertions") && e4.has("deprecatedImportAssert")) throw new Error("Cannot combine importAssertions and deprecatedImportAssert plugins.");
              if (!e4.has("deprecatedImportAssert") && e4.has("importAttributes") && e4.get("importAttributes").deprecatedAssertSyntax && e4.set("deprecatedImportAssert", {}), e4.has("recordAndTuple")) {
                const t5 = e4.get("recordAndTuple").syntaxType;
                if (null != t5) {
                  const e5 = ["hash", "bar"];
                  if (!e5.includes(t5)) throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + e5.map((e6) => `'${e6}'`).join(", "));
                }
              }
              if (e4.has("asyncDoExpressions") && !e4.has("doExpressions")) {
                const e5 = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
                throw e5.missingPlugins = "doExpressions", e5;
              }
              if (e4.has("optionalChainingAssign") && "2023-07" !== e4.get("optionalChainingAssign").version) throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is '2023-07'.");
              if (e4.has("discardBinding") && "void" !== e4.get("discardBinding").syntaxType) throw new Error("The 'discardBinding' plugin requires a 'syntaxType' option. Currently the only supported value is 'void'.");
            })(n2), r3 = (function(e4) {
              const t4 = [];
              for (const r5 of ne) e4.has(r5) && t4.push(r5);
              const r4 = t4.join("|");
              let n3 = pe.get(r4);
              if (!n3) {
                n3 = Parser;
                for (const e5 of t4) n3 = re[e5](n3);
                pe.set(r4, n3);
              }
              return n3;
            })(n2);
          }
          return new r3(e3, t3, n2);
        }
        const pe = /* @__PURE__ */ new Map();
        t2.parse = function(e3, t3) {
          var r3;
          if ("unambiguous" !== (null == (r3 = t3) ? void 0 : r3.sourceType)) return getParser(t3, e3).parse();
          t3 = Object.assign({}, t3);
          try {
            t3.sourceType = "module";
            const r4 = getParser(t3, e3), n2 = r4.parse();
            if (r4.sawUnambiguousESM) return n2;
            if (r4.ambiguousScriptDifferentAst) try {
              return t3.sourceType = "script", getParser(t3, e3).parse();
            } catch (e4) {
            }
            else n2.program.sourceType = "script";
            return n2;
          } catch (r4) {
            try {
              return t3.sourceType = "script", getParser(t3, e3).parse();
            } catch (e4) {
            }
            throw r4;
          }
        }, t2.parseExpression = function(e3, t3) {
          const r3 = getParser(t3, e3);
          return r3.options.strictMode && (r3.state.strict = true), r3.getExpression();
        }, t2.tokTypes = le;
      }, "./node_modules/.pnpm/@babel+plugin-proposal-decorators@7.28.0_@babel+core@7.28.4/node_modules/@babel/plugin-proposal-decorators/lib/index.js": function(e2, t2, r2) {
        "use strict";
        t2.default = void 0;
        var n = r2("./node_modules/.pnpm/@babel+helper-plugin-utils@7.27.1/node_modules/@babel/helper-plugin-utils/lib/index.js"), s = r2("./node_modules/.pnpm/@babel+plugin-syntax-decorators@7.27.1_@babel+core@7.28.4/node_modules/@babel/plugin-syntax-decorators/lib/index.js"), i = r2("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.28.3_@babel+core@7.28.4/node_modules/@babel/helper-create-class-features-plugin/lib/index.js"), o = r2("./node_modules/.pnpm/@babel+plugin-proposal-decorators@7.28.0_@babel+core@7.28.4/node_modules/@babel/plugin-proposal-decorators/lib/transformer-legacy.js");
        t2.default = (0, n.declare)((e3, t3) => {
          e3.assertVersion(7);
          var { legacy: r3 } = t3;
          const { version: n2 } = t3;
          if (r3 || "legacy" === n2) return { name: "proposal-decorators", inherits: s.default, visitor: o.default };
          if (n2 && "2018-09" !== n2 && "2021-12" !== n2 && "2022-03" !== n2 && "2023-01" !== n2 && "2023-05" !== n2 && "2023-11" !== n2) throw new Error("The '.version' option must be one of 'legacy', '2023-11', '2023-05', '2023-01', '2022-03', or '2021-12'.");
          return e3.assertVersion("^7.0.2"), (0, i.createClassFeaturePlugin)({ name: "proposal-decorators", api: e3, feature: i.FEATURES.decorators, inherits: s.default, decoratorVersion: n2 });
        });
      }, "./node_modules/.pnpm/@babel+plugin-proposal-decorators@7.28.0_@babel+core@7.28.4/node_modules/@babel/plugin-proposal-decorators/lib/transformer-legacy.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var n = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/index.js");
        const s = n.template.statement("\n  DECORATOR(CLASS_REF = INNER) || CLASS_REF;\n"), i = (0, n.template)("\n  CLASS_REF.prototype;\n"), o = (0, n.template)("\n    Object.getOwnPropertyDescriptor(TARGET, PROPERTY);\n"), a = (0, n.template)("\n    (TEMP = Object.getOwnPropertyDescriptor(TARGET, PROPERTY), (TEMP = TEMP ? TEMP.value : undefined), {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        initializer: function(){\n            return TEMP;\n        }\n    })\n"), l = /* @__PURE__ */ new WeakSet();
        function applyEnsureOrdering(e3) {
          const t3 = (e3.isClass() ? [e3, ...e3.get("body.body")] : e3.get("properties")).reduce((e4, t4) => e4.concat(t4.node.decorators || []), []).filter((e4) => !n.types.isIdentifier(e4.expression));
          if (0 !== t3.length) return n.types.sequenceExpression(t3.map((t4) => {
            const r3 = t4.expression, s2 = t4.expression = e3.scope.generateDeclaredUidIdentifier("dec");
            return n.types.assignmentExpression("=", s2, r3);
          }).concat([e3.node]));
        }
        function hasClassDecorators(e3) {
          var t3;
          return !(null == (t3 = e3.decorators) || !t3.length);
        }
        function hasMethodDecorators(e3) {
          return e3.some((e4) => {
            var t3;
            return null == (t3 = e4.decorators) ? void 0 : t3.length;
          });
        }
        function applyTargetDecorators(e3, t3, r3) {
          const s2 = e3.scope.generateDeclaredUidIdentifier(e3.isClass() ? "class" : "obj"), p2 = r3.reduce(function(r4, p3) {
            let c = [];
            if (null != p3.decorators && (c = p3.decorators, p3.decorators = null), 0 === c.length) return r4;
            if (p3.computed) throw e3.buildCodeFrameError("Computed method/property decorators are not yet supported.");
            const u = n.types.isLiteral(p3.key) ? p3.key : n.types.stringLiteral(p3.key.name), d = e3.isClass() && !p3.static ? i({ CLASS_REF: s2 }).expression : s2;
            if (n.types.isClassProperty(p3, { static: false })) {
              const s3 = e3.scope.generateDeclaredUidIdentifier("descriptor"), i2 = p3.value ? n.types.functionExpression(null, [], n.types.blockStatement([n.types.returnStatement(p3.value)])) : n.types.nullLiteral();
              p3.value = n.types.callExpression(t3.addHelper("initializerWarningHelper"), [s3, n.types.thisExpression()]), l.add(p3.value), r4.push(n.types.assignmentExpression("=", n.types.cloneNode(s3), n.types.callExpression(t3.addHelper("applyDecoratedDescriptor"), [n.types.cloneNode(d), n.types.cloneNode(u), n.types.arrayExpression(c.map((e4) => n.types.cloneNode(e4.expression))), n.types.objectExpression([n.types.objectProperty(n.types.identifier("configurable"), n.types.booleanLiteral(true)), n.types.objectProperty(n.types.identifier("enumerable"), n.types.booleanLiteral(true)), n.types.objectProperty(n.types.identifier("writable"), n.types.booleanLiteral(true)), n.types.objectProperty(n.types.identifier("initializer"), i2)])])));
            } else r4.push(n.types.callExpression(t3.addHelper("applyDecoratedDescriptor"), [n.types.cloneNode(d), n.types.cloneNode(u), n.types.arrayExpression(c.map((e4) => n.types.cloneNode(e4.expression))), n.types.isObjectProperty(p3) || n.types.isClassProperty(p3, { static: true }) ? a({ TEMP: e3.scope.generateDeclaredUidIdentifier("init"), TARGET: n.types.cloneNode(d), PROPERTY: n.types.cloneNode(u) }).expression : o({ TARGET: n.types.cloneNode(d), PROPERTY: n.types.cloneNode(u) }).expression, n.types.cloneNode(d)]));
            return r4;
          }, []);
          return n.types.sequenceExpression([n.types.assignmentExpression("=", n.types.cloneNode(s2), e3.node), n.types.sequenceExpression(p2), n.types.cloneNode(s2)]);
        }
        function decoratedClassToExpression({ node: e3, scope: t3 }) {
          if (!hasClassDecorators(e3) && !hasMethodDecorators(e3.body.body)) return;
          const r3 = e3.id ? n.types.cloneNode(e3.id) : t3.generateUidIdentifier("class");
          return n.types.variableDeclaration("let", [n.types.variableDeclarator(r3, n.types.toExpression(e3))]);
        }
        const p = { ExportDefaultDeclaration(e3) {
          const t3 = e3.get("declaration");
          if (!t3.isClassDeclaration()) return;
          const r3 = decoratedClassToExpression(t3);
          if (r3) {
            const [s2] = e3.replaceWithMultiple([r3, n.types.exportNamedDeclaration(null, [n.types.exportSpecifier(n.types.cloneNode(r3.declarations[0].id), n.types.identifier("default"))])]);
            t3.node.id || e3.scope.registerDeclaration(s2);
          }
        }, ClassDeclaration(e3) {
          const t3 = decoratedClassToExpression(e3);
          if (t3) {
            const [r3] = e3.replaceWith(t3), n2 = r3.get("declarations.0"), s2 = n2.node.id, i2 = e3.scope.getOwnBinding(s2.name);
            i2.identifier = s2, i2.path = n2;
          }
        }, ClassExpression(e3, t3) {
          const r3 = applyEnsureOrdering(e3) || (function(e4) {
            if (!hasClassDecorators(e4.node)) return;
            const t4 = e4.node.decorators || [];
            e4.node.decorators = null;
            const r4 = e4.scope.generateDeclaredUidIdentifier("class");
            return t4.map((e5) => e5.expression).reverse().reduce(function(e5, t5) {
              return s({ CLASS_REF: n.types.cloneNode(r4), DECORATOR: n.types.cloneNode(t5), INNER: e5 }).expression;
            }, e4.node);
          })(e3) || (function(e4, t4) {
            if (hasMethodDecorators(e4.node.body.body)) return applyTargetDecorators(e4, t4, e4.node.body.body);
          })(e3, t3);
          r3 && e3.replaceWith(r3);
        }, ObjectExpression(e3, t3) {
          const r3 = applyEnsureOrdering(e3) || (function(e4, t4) {
            if (hasMethodDecorators(e4.node.properties)) return applyTargetDecorators(e4, t4, e4.node.properties.filter((e5) => "SpreadElement" !== e5.type));
          })(e3, t3);
          r3 && e3.replaceWith(r3);
        }, AssignmentExpression(e3, t3) {
          l.has(e3.node.right) && e3.replaceWith(n.types.callExpression(t3.addHelper("initializerDefineProperty"), [n.types.cloneNode(e3.get("left.object").node), n.types.stringLiteral(e3.get("left.property").node.name || e3.get("left.property").node.value), n.types.cloneNode(e3.get("right.arguments")[0].node), n.types.cloneNode(e3.get("right.arguments")[1].node)]));
        }, CallExpression(e3, t3) {
          3 === e3.node.arguments.length && l.has(e3.node.arguments[2]) && e3.node.callee.name === t3.addHelper("defineProperty").name && e3.replaceWith(n.types.callExpression(t3.addHelper("initializerDefineProperty"), [n.types.cloneNode(e3.get("arguments")[0].node), n.types.cloneNode(e3.get("arguments")[1].node), n.types.cloneNode(e3.get("arguments.2.arguments")[0].node), n.types.cloneNode(e3.get("arguments.2.arguments")[1].node)]));
        } };
        t2.default = p;
      }, "./node_modules/.pnpm/@babel+plugin-syntax-decorators@7.27.1_@babel+core@7.28.4/node_modules/@babel/plugin-syntax-decorators/lib/index.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var n = r2("./node_modules/.pnpm/@babel+helper-plugin-utils@7.27.1/node_modules/@babel/helper-plugin-utils/lib/index.js");
        t2.default = (0, n.declare)((e3, t3) => {
          e3.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");
          let { version: r3 } = t3;
          {
            const { legacy: e4 } = t3;
            if (void 0 !== e4) {
              if ("boolean" != typeof e4) throw new Error(".legacy must be a boolean.");
              if (void 0 !== r3) throw new Error("You can either use the .legacy or the .version option, not both.");
            }
            if (void 0 === r3) r3 = e4 ? "legacy" : "2018-09";
            else if ("2023-11" !== r3 && "2023-05" !== r3 && "2023-01" !== r3 && "2022-03" !== r3 && "2021-12" !== r3 && "2018-09" !== r3 && "legacy" !== r3) throw new Error("Unsupported decorators version: " + r3);
            var { decoratorsBeforeExport: n2 } = t3;
            if (void 0 === n2) {
              if ("2021-12" === r3 || "2022-03" === r3) n2 = false;
              else if ("2018-09" === r3) throw new Error("The decorators plugin, when .version is '2018-09' or not specified, requires a 'decoratorsBeforeExport' option, whose value must be a boolean.");
            } else {
              if ("legacy" === r3 || "2022-03" === r3 || "2023-01" === r3) throw new Error(`'decoratorsBeforeExport' can't be used with ${r3} decorators.`);
              if ("boolean" != typeof n2) throw new Error("'decoratorsBeforeExport' must be a boolean.");
            }
          }
          return { name: "syntax-decorators", manipulateOptions({ generatorOpts: e4 }, t4) {
            "legacy" === r3 ? t4.plugins.push("decorators-legacy") : "2023-01" === r3 || "2023-05" === r3 || "2023-11" === r3 ? t4.plugins.push(["decorators", { allowCallParenthesized: false }], "decoratorAutoAccessors") : "2022-03" === r3 ? t4.plugins.push(["decorators", { decoratorsBeforeExport: false, allowCallParenthesized: false }], "decoratorAutoAccessors") : "2021-12" === r3 ? (t4.plugins.push(["decorators", { decoratorsBeforeExport: n2 }], "decoratorAutoAccessors"), e4.decoratorsBeforeExport = n2) : "2018-09" === r3 && (t4.plugins.push(["decorators", { decoratorsBeforeExport: n2 }]), e4.decoratorsBeforeExport = n2);
          } };
        });
      }, "./node_modules/.pnpm/@babel+plugin-syntax-import-assertions@7.27.1_@babel+core@7.28.4/node_modules/@babel/plugin-syntax-import-assertions/lib/index.js": function(e2, t2, r2) {
        "use strict";
        t2.default = void 0;
        var n = r2("./node_modules/.pnpm/@babel+helper-plugin-utils@7.27.1/node_modules/@babel/helper-plugin-utils/lib/index.js");
        t2.default = (0, n.declare)((e3) => {
          e3.assertVersion(7);
          const isPlugin = (e4, t3) => "plugin" === t3 || Array.isArray(e4) && "plugin" === e4[0], options = (e4) => Array.isArray(e4) && e4.length > 1 ? e4[1] : {};
          return { name: "syntax-import-assertions", manipulateOptions(e4, { plugins: t3 }) {
            for (let e5 = 0; e5 < t3.length; e5++) {
              const r3 = t3[e5];
              if (isPlugin(r3, "deprecatedImportAssert")) return;
              if (isPlugin(r3, "importAttributes")) return void t3.splice(e5, 1, "deprecatedImportAssert", ["importAttributes", Object.assign({}, options(r3), { deprecatedAssertSyntax: true })]);
            }
            t3.push("importAssertions");
          } };
        });
      }, "./node_modules/.pnpm/@babel+plugin-syntax-jsx@7.27.1_@babel+core@7.28.4/node_modules/@babel/plugin-syntax-jsx/lib/index.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var n = r2("./node_modules/.pnpm/@babel+helper-plugin-utils@7.27.1/node_modules/@babel/helper-plugin-utils/lib/index.js");
        t2.default = (0, n.declare)((e3) => (e3.assertVersion(7), { name: "syntax-jsx", manipulateOptions(e4, t3) {
          t3.plugins.some((e5) => "typescript" === (Array.isArray(e5) ? e5[0] : e5)) || t3.plugins.push("jsx");
        } }));
      }, "./node_modules/.pnpm/@babel+plugin-syntax-typescript@7.27.1_@babel+core@7.28.4/node_modules/@babel/plugin-syntax-typescript/lib/index.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var n = r2("./node_modules/.pnpm/@babel+helper-plugin-utils@7.27.1/node_modules/@babel/helper-plugin-utils/lib/index.js"), removePlugin = function(e3, t3) {
          const r3 = [];
          e3.forEach((e4, n2) => {
            (Array.isArray(e4) ? e4[0] : e4) === t3 && r3.unshift(n2);
          });
          for (const t4 of r3) e3.splice(t4, 1);
        };
        t2.default = (0, n.declare)((e3, t3) => {
          e3.assertVersion(7);
          const { disallowAmbiguousJSXLike: r3, dts: n2 } = t3;
          var { isTSX: s } = t3;
          return { name: "syntax-typescript", manipulateOptions(e4, t4) {
            {
              const { plugins: e5 } = t4;
              removePlugin(e5, "flow"), removePlugin(e5, "jsx"), e5.push("objectRestSpread", "classProperties"), s && e5.push("jsx");
            }
            t4.plugins.push(["typescript", { disallowAmbiguousJSXLike: r3, dts: n2 }]);
          } };
        });
      }, "./node_modules/.pnpm/@babel+plugin-transform-export-namespace-from@7.27.1_@babel+core@7.28.4/node_modules/@babel/plugin-transform-export-namespace-from/lib/index.js": function(e2, t2, r2) {
        "use strict";
        t2.default = void 0;
        var n = r2("./node_modules/.pnpm/@babel+helper-plugin-utils@7.27.1/node_modules/@babel/helper-plugin-utils/lib/index.js"), s = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/index.js");
        t2.default = (0, n.declare)((e3) => (e3.assertVersion(7), { name: "transform-export-namespace-from", manipulateOptions: (e4, t3) => t3.plugins.push("exportNamespaceFrom"), visitor: { ExportNamedDeclaration(e4) {
          var t3;
          const { node: r3, scope: n2 } = e4, { specifiers: i } = r3, o = s.types.isExportDefaultSpecifier(i[0]) ? 1 : 0;
          if (!s.types.isExportNamespaceSpecifier(i[o])) return;
          const a = [];
          1 === o && a.push(s.types.exportNamedDeclaration(null, [i.shift()], r3.source));
          const l = i.shift(), { exported: p } = l, c = n2.generateUidIdentifier(null != (t3 = p.name) ? t3 : p.value);
          a.push(s.types.importDeclaration([s.types.importNamespaceSpecifier(c)], s.types.cloneNode(r3.source)), s.types.exportNamedDeclaration(null, [s.types.exportSpecifier(s.types.cloneNode(c), p)])), r3.specifiers.length >= 1 && a.push(r3);
          const [u] = e4.replaceWithMultiple(a);
          e4.scope.registerDeclaration(u);
        } } }));
      }, "./node_modules/.pnpm/@babel+plugin-transform-modules-commonjs@7.27.1_@babel+core@7.28.4/node_modules/@babel/plugin-transform-modules-commonjs/lib/dynamic-import.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.transformDynamicImport = function(e3, t3, r3) {
          const n2 = t3 ? requireNoInterop : requireInterop;
          e3.replaceWith((0, s.buildDynamicImport)(e3.node, true, false, (e4) => n2(e4, r3)));
        };
        var n = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/index.js"), s = r2("./node_modules/.pnpm/@babel+helper-module-transforms@7.28.3_@babel+core@7.28.4/node_modules/@babel/helper-module-transforms/lib/index.js");
        const requireNoInterop = (e3) => n.template.expression.ast`require(${e3})`, requireInterop = (e3, t3) => n.types.callExpression(t3.addHelper("interopRequireWildcard"), [requireNoInterop(e3)]);
      }, "./node_modules/.pnpm/@babel+plugin-transform-modules-commonjs@7.27.1_@babel+core@7.28.4/node_modules/@babel/plugin-transform-modules-commonjs/lib/hooks.js": function(e2, t2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.defineCommonJSHook = function(e3, t3) {
          let n = e3.get(r2);
          n || e3.set(r2, n = []);
          n.push(t3);
        }, t2.makeInvokers = function(e3) {
          const t3 = e3.get(r2);
          return { getWrapperPayload: (...e4) => findMap(t3, (t4) => null == t4.getWrapperPayload ? void 0 : t4.getWrapperPayload(...e4)), wrapReference: (...e4) => findMap(t3, (t4) => null == t4.wrapReference ? void 0 : t4.wrapReference(...e4)), buildRequireWrapper: (...e4) => findMap(t3, (t4) => null == t4.buildRequireWrapper ? void 0 : t4.buildRequireWrapper(...e4)) };
        };
        const r2 = "@babel/plugin-transform-modules-commonjs/customWrapperPlugin";
        function findMap(e3, t3) {
          if (e3) for (const r3 of e3) {
            const e4 = t3(r3);
            if (null != e4) return e4;
          }
        }
      }, "./node_modules/.pnpm/@babel+plugin-transform-modules-commonjs@7.27.1_@babel+core@7.28.4/node_modules/@babel/plugin-transform-modules-commonjs/lib/index.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0, Object.defineProperty(t2, "defineCommonJSHook", { enumerable: true, get: function() {
          return l.defineCommonJSHook;
        } });
        var n = r2("./node_modules/.pnpm/@babel+helper-plugin-utils@7.27.1/node_modules/@babel/helper-plugin-utils/lib/index.js"), s = r2("./node_modules/.pnpm/@babel+helper-module-transforms@7.28.3_@babel+core@7.28.4/node_modules/@babel/helper-module-transforms/lib/index.js"), i = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/index.js"), o = r2("./node_modules/.pnpm/@babel+plugin-transform-modules-commonjs@7.27.1_@babel+core@7.28.4/node_modules/@babel/plugin-transform-modules-commonjs/lib/dynamic-import.js"), a = r2("./node_modules/.pnpm/@babel+plugin-transform-modules-commonjs@7.27.1_@babel+core@7.28.4/node_modules/@babel/plugin-transform-modules-commonjs/lib/lazy.js"), l = r2("./node_modules/.pnpm/@babel+plugin-transform-modules-commonjs@7.27.1_@babel+core@7.28.4/node_modules/@babel/plugin-transform-modules-commonjs/lib/hooks.js");
        t2.default = (0, n.declare)((e3, t3) => {
          var r3, n2, p;
          e3.assertVersion(7);
          const { strictNamespace: c = false, mjsStrictNamespace: u = c, allowTopLevelThis: d, strict: h, strictMode: m, noInterop: f, importInterop: y, lazy: b = false, allowCommonJSExports: g = true, loose: x = false } = t3, v = null != (r3 = e3.assumption("constantReexports")) ? r3 : x, E = null != (n2 = e3.assumption("enumerableModuleMeta")) ? n2 : x, T = null != (p = e3.assumption("noIncompleteNsImportDetection")) && p;
          if (!("boolean" == typeof b || "function" == typeof b || Array.isArray(b) && b.every((e4) => "string" == typeof e4))) throw new Error(".lazy must be a boolean, array of strings, or a function");
          if ("boolean" != typeof c) throw new Error(".strictNamespace must be a boolean, or undefined");
          if ("boolean" != typeof u) throw new Error(".mjsStrictNamespace must be a boolean, or undefined");
          const getAssertion = (e4) => i.template.expression.ast`
    (function(){
      throw new Error(
        "The CommonJS '" + "${e4}" + "' variable is not available in ES6 modules." +
        "Consider setting setting sourceType:script or sourceType:unambiguous in your " +
        "Babel config for this file.");
    })()
  `, S = { ReferencedIdentifier(e4) {
            const t4 = e4.node.name;
            if ("module" !== t4 && "exports" !== t4) return;
            const r4 = e4.scope.getBinding(t4);
            this.scope.getBinding(t4) !== r4 || e4.parentPath.isObjectProperty({ value: e4.node }) && e4.parentPath.parentPath.isObjectPattern() || e4.parentPath.isAssignmentExpression({ left: e4.node }) || e4.isAssignmentExpression({ left: e4.node }) || e4.replaceWith(getAssertion(t4));
          }, UpdateExpression(e4) {
            const t4 = e4.get("argument");
            if (!t4.isIdentifier()) return;
            const r4 = t4.node.name;
            if ("module" !== r4 && "exports" !== r4) return;
            const n3 = e4.scope.getBinding(r4);
            this.scope.getBinding(r4) === n3 && e4.replaceWith(i.types.assignmentExpression(e4.node.operator[0] + "=", t4.node, getAssertion(r4)));
          }, AssignmentExpression(e4) {
            const t4 = e4.get("left");
            if (t4.isIdentifier()) {
              const r4 = t4.node.name;
              if ("module" !== r4 && "exports" !== r4) return;
              const n3 = e4.scope.getBinding(r4);
              if (this.scope.getBinding(r4) !== n3) return;
              const s2 = e4.get("right");
              s2.replaceWith(i.types.sequenceExpression([s2.node, getAssertion(r4)]));
            } else if (t4.isPattern()) {
              const r4 = t4.getOuterBindingIdentifiers(), n3 = Object.keys(r4).find((t5) => ("module" === t5 || "exports" === t5) && this.scope.getBinding(t5) === e4.scope.getBinding(t5));
              if (n3) {
                const t5 = e4.get("right");
                t5.replaceWith(i.types.sequenceExpression([t5.node, getAssertion(n3)]));
              }
            }
          } };
          return { name: "transform-modules-commonjs", pre() {
            this.file.set("@babel/plugin-transform-modules-*", "commonjs"), b && (0, l.defineCommonJSHook)(this.file, (0, a.lazyImportsHook)(b));
          }, visitor: { ["CallExpression" + (e3.types.importExpression ? "|ImportExpression" : "")](e4) {
            if (!this.file.has("@babel/plugin-proposal-dynamic-import")) return;
            if (e4.isCallExpression() && !i.types.isImport(e4.node.callee)) return;
            let { scope: t4 } = e4;
            do {
              t4.rename("require");
            } while (t4 = t4.parent);
            (0, o.transformDynamicImport)(e4, f, this.file);
          }, Program: { exit(e4, r4) {
            if (!(0, s.isModule)(e4)) return;
            e4.scope.rename("exports"), e4.scope.rename("module"), e4.scope.rename("require"), e4.scope.rename("__filename"), e4.scope.rename("__dirname"), g || e4.traverse(S, { scope: e4.scope });
            let n3 = (0, s.getModuleName)(this.file.opts, t3);
            n3 && (n3 = i.types.stringLiteral(n3));
            const o2 = (0, l.makeInvokers)(this.file), { meta: a2, headers: p2 } = (0, s.rewriteModuleStatementsAndPrepareHeader)(e4, { exportName: "exports", constantReexports: v, enumerableModuleMeta: E, strict: h, strictMode: m, allowTopLevelThis: d, noInterop: f, importInterop: y, wrapReference: o2.wrapReference, getWrapperPayload: o2.getWrapperPayload, esNamespaceOnly: "string" == typeof r4.filename && /\.mjs$/.test(r4.filename) ? u : c, noIncompleteNsImportDetection: T, filename: this.file.opts.filename });
            for (const [t4, r5] of a2.source) {
              const n4 = i.types.callExpression(i.types.identifier("require"), [i.types.stringLiteral(t4)]);
              let l2;
              if ((0, s.isSideEffectImport)(r5)) {
                if (b && "function" === r5.wrap) throw new Error("Assertion failure");
                l2 = i.types.expressionStatement(n4);
              } else {
                const t5 = (0, s.wrapInterop)(e4, n4, r5.interop) || n4;
                if (r5.wrap) {
                  const e5 = o2.buildRequireWrapper(r5.name, t5, r5.wrap, r5.referenced);
                  if (false === e5) continue;
                  l2 = e5;
                }
                null != l2 || (l2 = i.template.statement.ast`
                var ${r5.name} = ${t5};
              `);
              }
              l2.loc = r5.loc, p2.push(l2), p2.push(...(0, s.buildNamespaceInitStatements)(a2, r5, v, o2.wrapReference));
            }
            (0, s.ensureStatementsHoisted)(p2), e4.unshiftContainer("body", p2), e4.get("body").forEach((e5) => {
              p2.includes(e5.node) && e5.isVariableDeclaration() && e5.scope.registerDeclaration(e5);
            });
          } } } };
        });
      }, "./node_modules/.pnpm/@babel+plugin-transform-modules-commonjs@7.27.1_@babel+core@7.28.4/node_modules/@babel/plugin-transform-modules-commonjs/lib/lazy.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.lazyImportsHook = void 0;
        var n = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/index.js"), s = r2("./node_modules/.pnpm/@babel+helper-module-transforms@7.28.3_@babel+core@7.28.4/node_modules/@babel/helper-module-transforms/lib/index.js");
        t2.lazyImportsHook = (e3) => ({ name: "@babel/plugin-transform-modules-commonjs/lazy", version: "7.27.1", getWrapperPayload: (t3, r3) => (0, s.isSideEffectImport)(r3) || r3.reexportAll ? null : true === e3 ? t3.includes(".") ? null : "lazy/function" : Array.isArray(e3) ? e3.includes(t3) ? "lazy/function" : null : "function" == typeof e3 ? e3(t3) ? "lazy/function" : null : void 0, buildRequireWrapper(e4, t3, r3, s2) {
          if ("lazy/function" === r3) return !!s2 && n.template.statement.ast`
        function ${e4}() {
          const data = ${t3};
          ${e4} = function(){ return data; };
          return data;
        }
      `;
        }, wrapReference(e4, t3) {
          if ("lazy/function" === t3) return n.types.callExpression(e4, []);
        } });
      }, "./node_modules/.pnpm/@babel+plugin-transform-react-jsx@7.27.1_@babel+core@7.28.4/node_modules/@babel/plugin-transform-react-jsx/lib/create-plugin.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function({ name: e3, development: t3 }) {
          return (0, s.declare)((r3, s2) => {
            const { pure: h, throwIfNamespace: m = true, filter: f, runtime: y = t3 ? "automatic" : "classic", importSource: b = l.importSource, pragma: g = l.pragma, pragmaFrag: x = l.pragmaFrag } = s2;
            var { useSpread: v = false, useBuiltIns: E = false } = s2;
            if ("classic" === y) {
              if ("boolean" != typeof v) throw new Error("transform-react-jsx currently only accepts a boolean option for useSpread (defaults to false)");
              if ("boolean" != typeof E) throw new Error("transform-react-jsx currently only accepts a boolean option for useBuiltIns (defaults to false)");
              if (v && E) throw new Error("transform-react-jsx currently only accepts useBuiltIns or useSpread but not both");
            }
            const T = { JSXOpeningElement(e4, t4) {
              const r4 = [];
              (function(e5) {
                do {
                  const { path: t5 } = e5;
                  if (t5.isFunctionParent() && !t5.isArrowFunctionExpression()) return !t5.isMethod() || ("constructor" !== t5.node.kind || !isDerivedClass(t5.parentPath.parentPath));
                  if (t5.isTSModuleBlock()) return false;
                } while (e5 = e5.parent);
                return true;
              })(e4.scope) && r4.push(i.types.jsxAttribute(i.types.jsxIdentifier("__self"), i.types.jsxExpressionContainer(i.types.thisExpression()))), r4.push(i.types.jsxAttribute(i.types.jsxIdentifier("__source"), i.types.jsxExpressionContainer((function(e5, t5) {
                const r5 = e5.node.loc;
                if (!r5) return e5.scope.buildUndefinedNode();
                if (!t5.fileNameIdentifier) {
                  const { filename: r6 = "" } = t5, n2 = e5.scope.generateUidIdentifier("_jsxFileName");
                  e5.scope.getProgramParent().push({ id: n2, init: i.types.stringLiteral(r6) }), t5.fileNameIdentifier = n2;
                }
                return (function(e6, t6, r6) {
                  const n2 = null != t6 ? i.types.numericLiteral(t6) : i.types.nullLiteral(), s3 = null != r6 ? i.types.numericLiteral(r6 + 1) : i.types.nullLiteral();
                  return i.template.expression.ast`{
    fileName: ${e6},
    lineNumber: ${n2},
    columnNumber: ${s3},
  }`;
                })(i.types.cloneNode(t5.fileNameIdentifier), r5.start.line, r5.start.column);
              })(e4, t4)))), e4.pushContainer("attributes", r4);
            } };
            return { name: e3, inherits: n.default, visitor: { JSXNamespacedName(e4) {
              if (m) throw e4.buildCodeFrameError("Namespace tags are not supported by default. React's JSX doesn't support namespace tags. You can set `throwIfNamespace: false` to bypass this warning.");
            }, JSXSpreadChild(e4) {
              throw e4.buildCodeFrameError("Spread children are not supported in React.");
            }, Program: { enter(e4, r4) {
              const { file: n2 } = r4;
              let a2 = y, h2 = b, m2 = g, f2 = x, v2 = !!s2.importSource, E2 = !!s2.pragma, S = !!s2.pragmaFrag;
              if (n2.ast.comments) for (const e5 of n2.ast.comments) {
                const t4 = p.exec(e5.value);
                t4 && (h2 = t4[1], v2 = true);
                const r5 = c.exec(e5.value);
                r5 && (a2 = r5[1]);
                const n3 = u.exec(e5.value);
                n3 && (m2 = n3[1], E2 = true);
                const s3 = d.exec(e5.value);
                s3 && (f2 = s3[1], S = true);
              }
              if (set(r4, "runtime", a2), "classic" === a2) {
                if (v2) throw e4.buildCodeFrameError("importSource cannot be set when runtime is classic.");
                const t4 = toMemberExpression(m2), n3 = toMemberExpression(f2);
                set(r4, "id/createElement", () => i.types.cloneNode(t4)), set(r4, "id/fragment", () => i.types.cloneNode(n3)), set(r4, "defaultPure", m2 === l.pragma);
              } else {
                if ("automatic" !== a2) throw e4.buildCodeFrameError('Runtime must be either "classic" or "automatic".');
                {
                  if (E2 || S) throw e4.buildCodeFrameError("pragma and pragmaFrag cannot be set when runtime is automatic.");
                  const define = (n3, s3) => set(r4, n3, /* @__PURE__ */ (function(e5, r5, n4, s4) {
                    return () => {
                      const a3 = (function(e6, r6) {
                        switch (r6) {
                          case "Fragment":
                            return `${e6}/${t3 ? "jsx-dev-runtime" : "jsx-runtime"}`;
                          case "jsxDEV":
                            return `${e6}/jsx-dev-runtime`;
                          case "jsx":
                          case "jsxs":
                            return `${e6}/jsx-runtime`;
                          case "createElement":
                            return e6;
                        }
                      })(s4, n4);
                      if ((0, o.isModule)(r5)) {
                        let t4 = get(e5, `imports/${n4}`);
                        return t4 ? i.types.cloneNode(t4) : (t4 = (0, o.addNamed)(r5, n4, a3, { importedInterop: "uncompiled", importPosition: "after" }), set(e5, `imports/${n4}`, t4), t4);
                      }
                      {
                        let t4 = get(e5, `requires/${a3}`);
                        return t4 ? t4 = i.types.cloneNode(t4) : (t4 = (0, o.addNamespace)(r5, a3, { importedInterop: "uncompiled" }), set(e5, `requires/${a3}`, t4)), i.types.memberExpression(t4, i.types.identifier(n4));
                      }
                    };
                  })(r4, e4, s3, h2));
                  define("id/jsx", t3 ? "jsxDEV" : "jsx"), define("id/jsxs", t3 ? "jsxDEV" : "jsxs"), define("id/createElement", "createElement"), define("id/fragment", "Fragment"), set(r4, "defaultPure", h2 === l.importSource);
                }
              }
              t3 && e4.traverse(T, r4);
            } }, JSXFragment: { exit(e4, r4) {
              let n2;
              n2 = "classic" === get(r4, "runtime") ? (function(e5, t4) {
                if (f && !f(e5.node, t4)) return;
                return call(t4, "createElement", [get(t4, "id/fragment")(), i.types.nullLiteral(), ...i.types.react.buildChildren(e5.node)]);
              })(e4, r4) : (function(e5, r5) {
                const n3 = [get(r5, "id/fragment")()], s3 = i.types.react.buildChildren(e5.node);
                n3.push(i.types.objectExpression(s3.length > 0 ? [buildChildrenProperty(s3)] : [])), t3 && n3.push(e5.scope.buildUndefinedNode(), i.types.booleanLiteral(s3.length > 1));
                return call(r5, s3.length > 1 ? "jsxs" : "jsx", n3);
              })(e4, r4), e4.replaceWith(i.types.inherits(n2, e4.node));
            } }, JSXElement: { exit(e4, r4) {
              let n2;
              n2 = "classic" === get(r4, "runtime") || (function(e5) {
                const t4 = e5.get("openingElement"), r5 = t4.node.attributes;
                let n3 = false;
                for (let e6 = 0; e6 < r5.length; e6++) {
                  const t5 = r5[e6];
                  if (n3 && i.types.isJSXAttribute(t5) && "key" === t5.name.name) return true;
                  i.types.isJSXSpreadAttribute(t5) && (n3 = true);
                }
                return false;
              })(e4) ? (function(e5, t4) {
                const r5 = e5.get("openingElement");
                return call(t4, "createElement", [getTag(r5), buildCreateElementOpeningElementAttributes(t4, e5, r5.get("attributes")), ...i.types.react.buildChildren(e5.node)]);
              })(e4, r4) : (function(e5, r5) {
                const n3 = e5.get("openingElement"), s3 = [getTag(n3)], o2 = [], a2 = /* @__PURE__ */ Object.create(null);
                for (const t4 of n3.get("attributes")) if (t4.isJSXAttribute() && i.types.isJSXIdentifier(t4.node.name)) {
                  const { name: r6 } = t4.node.name;
                  switch (r6) {
                    case "__source":
                    case "__self":
                      if (a2[r6]) throw sourceSelfError(e5, r6);
                    case "key": {
                      const e6 = convertAttributeValue(t4.node.value);
                      if (null === e6) throw t4.buildCodeFrameError('Please provide an explicit key value. Using "key" as a shorthand for "key={true}" is not allowed.');
                      a2[r6] = e6;
                      break;
                    }
                    default:
                      o2.push(t4);
                  }
                } else o2.push(t4);
                const l2 = i.types.react.buildChildren(e5.node);
                let p2;
                p2 = o2.length || l2.length ? (function(e6, t4) {
                  const r6 = e6.reduce(accumulateAttribute, []);
                  (null == t4 ? void 0 : t4.length) > 0 && r6.push(buildChildrenProperty(t4));
                  return i.types.objectExpression(r6);
                })(o2, l2) : i.types.objectExpression([]);
                if (s3.push(p2), t3) {
                  var c2;
                  s3.push(null != (c2 = a2.key) ? c2 : e5.scope.buildUndefinedNode(), i.types.booleanLiteral(l2.length > 1)), a2.__source ? (s3.push(a2.__source), a2.__self && s3.push(a2.__self)) : a2.__self && s3.push(e5.scope.buildUndefinedNode(), a2.__self);
                } else void 0 !== a2.key && s3.push(a2.key);
                return call(r5, l2.length > 1 ? "jsxs" : "jsx", s3);
              })(e4, r4), e4.replaceWith(i.types.inherits(n2, e4.node));
            } }, JSXAttribute(e4) {
              i.types.isJSXElement(e4.node.value) && (e4.node.value = i.types.jsxExpressionContainer(e4.node.value));
            } } };
            function isDerivedClass(e4) {
              return null !== e4.node.superClass;
            }
            function call(e4, t4, r4) {
              const n2 = i.types.callExpression(get(e4, `id/${t4}`)(), r4);
              return (null != h ? h : get(e4, "defaultPure")) && (0, a.default)(n2), n2;
            }
            function convertJSXIdentifier(e4, t4) {
              return i.types.isJSXIdentifier(e4) ? "this" === e4.name && i.types.isReferenced(e4, t4) ? i.types.thisExpression() : i.types.isValidIdentifier(e4.name, false) ? (e4.type = "Identifier", e4) : i.types.stringLiteral(e4.name) : i.types.isJSXMemberExpression(e4) ? i.types.memberExpression(convertJSXIdentifier(e4.object, e4), convertJSXIdentifier(e4.property, e4)) : i.types.isJSXNamespacedName(e4) ? i.types.stringLiteral(`${e4.namespace.name}:${e4.name.name}`) : e4;
            }
            function convertAttributeValue(e4) {
              return i.types.isJSXExpressionContainer(e4) ? e4.expression : e4;
            }
            function accumulateAttribute(e4, t4) {
              if (i.types.isJSXSpreadAttribute(t4.node)) {
                const r5 = t4.node.argument;
                return i.types.isObjectExpression(r5) && !r5.properties.some((e5) => i.types.isObjectProperty(e5, { computed: false, shorthand: false }) && (i.types.isIdentifier(e5.key, { name: "__proto__" }) || i.types.isStringLiteral(e5.key, { value: "__proto__" }))) ? e4.push(...r5.properties) : e4.push(i.types.spreadElement(r5)), e4;
              }
              const r4 = convertAttributeValue("key" !== t4.node.name.name ? t4.node.value || i.types.booleanLiteral(true) : t4.node.value);
              if ("key" === t4.node.name.name && null === r4) throw t4.buildCodeFrameError('Please provide an explicit key value. Using "key" as a shorthand for "key={true}" is not allowed.');
              var n2;
              i.types.isStringLiteral(r4) && !i.types.isJSXExpressionContainer(t4.node.value) && (r4.value = r4.value.replace(/\n\s+/g, " "), null == (n2 = r4.extra) || delete n2.raw);
              return i.types.isJSXNamespacedName(t4.node.name) ? t4.node.name = i.types.stringLiteral(t4.node.name.namespace.name + ":" + t4.node.name.name.name) : i.types.isValidIdentifier(t4.node.name.name, false) ? t4.node.name.type = "Identifier" : t4.node.name = i.types.stringLiteral(t4.node.name.name), e4.push(i.types.inherits(i.types.objectProperty(t4.node.name, r4), t4.node)), e4;
            }
            function buildChildrenProperty(e4) {
              let t4;
              if (1 === e4.length) t4 = e4[0];
              else {
                if (!(e4.length > 1)) return;
                t4 = i.types.arrayExpression(e4);
              }
              return i.types.objectProperty(i.types.identifier("children"), t4);
            }
            function getTag(e4) {
              const t4 = convertJSXIdentifier(e4.node.name, e4.node);
              let r4;
              return i.types.isIdentifier(t4) ? r4 = t4.name : i.types.isStringLiteral(t4) && (r4 = t4.value), i.types.react.isCompatTag(r4) ? i.types.stringLiteral(r4) : t4;
            }
            function buildCreateElementOpeningElementAttributes(e4, t4, r4) {
              const n2 = get(e4, "runtime");
              if ("automatic" !== n2) {
                const t5 = [], n3 = r4.reduce(accumulateAttribute, []);
                if (v) n3.length && t5.push(i.types.objectExpression(n3));
                else {
                  let e5 = 0;
                  n3.forEach((r5, s5) => {
                    i.types.isSpreadElement(r5) && (s5 > e5 && t5.push(i.types.objectExpression(n3.slice(e5, s5))), t5.push(r5.argument), e5 = s5 + 1);
                  }), n3.length > e5 && t5.push(i.types.objectExpression(n3.slice(e5)));
                }
                if (!t5.length) return i.types.nullLiteral();
                if (!(1 !== t5.length || i.types.isSpreadElement(n3[0]) && i.types.isObjectExpression(n3[0].argument))) return t5[0];
                i.types.isObjectExpression(t5[0]) || t5.unshift(i.types.objectExpression([]));
                const s4 = E ? i.types.memberExpression(i.types.identifier("Object"), i.types.identifier("assign")) : e4.addHelper("extends");
                return i.types.callExpression(s4, t5);
              }
              const s3 = [], o2 = /* @__PURE__ */ Object.create(null);
              for (const e5 of r4) {
                const { node: r5 } = e5, a2 = i.types.isJSXAttribute(r5) && i.types.isJSXIdentifier(r5.name) && r5.name.name;
                if ("automatic" === n2 && ("__source" === a2 || "__self" === a2)) {
                  if (o2[a2]) throw sourceSelfError(t4, a2);
                  o2[a2] = true;
                }
                accumulateAttribute(s3, e5);
              }
              return 1 === s3.length && i.types.isSpreadElement(s3[0]) && !i.types.isObjectExpression(s3[0].argument) ? s3[0].argument : s3.length > 0 ? i.types.objectExpression(s3) : i.types.nullLiteral();
            }
          });
        };
        var n = r2("./node_modules/.pnpm/@babel+plugin-syntax-jsx@7.27.1_@babel+core@7.28.4/node_modules/@babel/plugin-syntax-jsx/lib/index.js"), s = r2("./node_modules/.pnpm/@babel+helper-plugin-utils@7.27.1/node_modules/@babel/helper-plugin-utils/lib/index.js"), i = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/index.js"), o = r2("./node_modules/.pnpm/@babel+helper-module-imports@7.27.1/node_modules/@babel/helper-module-imports/lib/index.js"), a = r2("./node_modules/.pnpm/@babel+helper-annotate-as-pure@7.27.3/node_modules/@babel/helper-annotate-as-pure/lib/index.js");
        const l = { importSource: "react", runtime: "automatic", pragma: "React.createElement", pragmaFrag: "React.Fragment" }, p = /^\s*(?:\*\s*)?@jsxImportSource\s+(\S+)\s*$/m, c = /^\s*(?:\*\s*)?@jsxRuntime\s+(\S+)\s*$/m, u = /^\s*(?:\*\s*)?@jsx\s+(\S+)\s*$/m, d = /^\s*(?:\*\s*)?@jsxFrag\s+(\S+)\s*$/m, get = (e3, t3) => e3.get(`@babel/plugin-react-jsx/${t3}`), set = (e3, t3, r3) => e3.set(`@babel/plugin-react-jsx/${t3}`, r3);
        function toMemberExpression(e3) {
          return e3.split(".").map((e4) => i.types.identifier(e4)).reduce((e4, t3) => i.types.memberExpression(e4, t3));
        }
        function sourceSelfError(e3, t3) {
          const r3 = `transform-react-jsx-${t3.slice(2)}`;
          return e3.buildCodeFrameError(`Duplicate ${t3} prop found. You are most likely using the deprecated ${r3} Babel plugin. Both __source and __self are automatically set when using the automatic runtime. Please remove transform-react-jsx-source and transform-react-jsx-self from your Babel config.`);
        }
      }, "./node_modules/.pnpm/@babel+plugin-transform-react-jsx@7.27.1_@babel+core@7.28.4/node_modules/@babel/plugin-transform-react-jsx/lib/index.js": function(e2, t2, r2) {
        "use strict";
        t2.default = void 0;
        var n = r2("./node_modules/.pnpm/@babel+plugin-transform-react-jsx@7.27.1_@babel+core@7.28.4/node_modules/@babel/plugin-transform-react-jsx/lib/create-plugin.js");
        t2.default = (0, n.default)({ name: "transform-react-jsx", development: false });
      }, "./node_modules/.pnpm/@babel+plugin-transform-typescript@7.28.0_@babel+core@7.28.4/node_modules/@babel/plugin-transform-typescript/lib/const-enum.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.EXPORTED_CONST_ENUMS_IN_NAMESPACE = void 0, t2.default = function(e3, t3) {
          const { name: r3 } = e3.node.id, i = e3.parentPath.isExportNamedDeclaration();
          let o = i;
          !o && t3.isProgram(e3.parent) && (o = e3.parent.body.some((e4) => t3.isExportNamedDeclaration(e4) && "type" !== e4.exportKind && !e4.source && e4.specifiers.some((e5) => t3.isExportSpecifier(e5) && "type" !== e5.exportKind && e5.local.name === r3)));
          const { enumValues: a } = (0, n.translateEnumValues)(e3, t3);
          if (o || s.has(e3.node)) {
            const n2 = t3.objectExpression(a.map(([e4, r4]) => t3.objectProperty(t3.isValidIdentifier(e4) ? t3.identifier(e4) : t3.stringLiteral(e4), r4)));
            return void (e3.scope.hasOwnBinding(r3) ? (i ? e3.parentPath : e3).replaceWith(t3.expressionStatement(t3.callExpression(t3.memberExpression(t3.identifier("Object"), t3.identifier("assign")), [e3.node.id, n2]))) : (e3.replaceWith(t3.variableDeclaration("var", [t3.variableDeclarator(e3.node.id, n2)])), e3.scope.registerDeclaration(e3)));
          }
          const l = new Map(a);
          e3.scope.path.traverse({ Scope(e4) {
            e4.scope.hasOwnBinding(r3) && e4.skip();
          }, MemberExpression(e4) {
            if (!t3.isIdentifier(e4.node.object, { name: r3 })) return;
            let n2;
            if (e4.node.computed) {
              if (!t3.isStringLiteral(e4.node.property)) return;
              n2 = e4.node.property.value;
            } else {
              if (!t3.isIdentifier(e4.node.property)) return;
              n2 = e4.node.property.name;
            }
            l.has(n2) && e4.replaceWith(t3.cloneNode(l.get(n2)));
          } }), e3.remove();
        };
        var n = r2("./node_modules/.pnpm/@babel+plugin-transform-typescript@7.28.0_@babel+core@7.28.4/node_modules/@babel/plugin-transform-typescript/lib/enum.js");
        const s = t2.EXPORTED_CONST_ENUMS_IN_NAMESPACE = /* @__PURE__ */ new WeakSet();
      }, "./node_modules/.pnpm/@babel+plugin-transform-typescript@7.28.0_@babel+core@7.28.4/node_modules/@babel/plugin-transform-typescript/lib/enum.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
          const { node: r3, parentPath: n2 } = e3;
          if (r3.declare) return void e3.remove();
          const s2 = r3.id.name, { fill: o2, data: p2, isPure: c2 } = (function(e4, t4, r4) {
            const { enumValues: n3, data: s3, isPure: i2 } = translateEnumValues(e4, t4), o3 = e4.get("members"), a2 = [];
            for (let e5 = 0; e5 < o3.length; e5++) {
              const [s4, i3] = n3[e5];
              a2.push(t4.inheritsComments(buildEnumMember(isSyntacticallyString(i3), { ENUM: t4.cloneNode(r4), NAME: s4, VALUE: i3 }), o3[e5].node));
            }
            return { fill: { ID: t4.cloneNode(r4), ASSIGNMENTS: a2 }, data: s3, isPure: i2 };
          })(e3, t3, r3.id);
          switch (n2.type) {
            case "BlockStatement":
            case "ExportNamedDeclaration":
            case "Program": {
              const u2 = t3.isProgram(e3.parent), d = (function seen(e4) {
                if (e4.isExportDeclaration()) return seen(e4.parentPath);
                return !!e4.getData(s2) || (e4.setData(s2, true), false);
              })(n2);
              let h = t3.objectExpression([]);
              (d || u2) && (h = t3.logicalExpression("||", t3.cloneNode(o2.ID), h));
              const m = l(Object.assign({}, o2, { INIT: h }));
              if (c2 && (0, i.default)(m), d) {
                (n2.isExportDeclaration() ? n2 : e3).replaceWith(t3.expressionStatement(t3.assignmentExpression("=", t3.cloneNode(r3.id), m)));
              } else e3.scope.registerDeclaration(e3.replaceWith(t3.variableDeclaration(u2 ? "var" : "let", [t3.variableDeclarator(r3.id, m)]))[0]);
              a.set(e3.scope.getBindingIdentifier(s2), p2);
              break;
            }
            default:
              throw new Error(`Unexpected enum parent '${e3.parent.type}`);
          }
        }, t2.isSyntacticallyString = isSyntacticallyString, t2.translateEnumValues = translateEnumValues;
        var n = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/index.js"), s = r2("assert"), i = r2("./node_modules/.pnpm/@babel+helper-annotate-as-pure@7.27.3/node_modules/@babel/helper-annotate-as-pure/lib/index.js"), o = r2("./node_modules/.pnpm/@babel+helper-skip-transparent-expression-wrappers@7.27.1/node_modules/@babel/helper-skip-transparent-expression-wrappers/lib/index.js");
        const a = /* @__PURE__ */ new WeakMap(), l = n.template.expression("\n    (function (ID) {\n      ASSIGNMENTS;\n      return ID;\n    })(INIT)\n  ");
        const p = n.template.statement('\n  ENUM["NAME"] = VALUE;\n'), c = n.template.statement('\n  ENUM[ENUM["NAME"] = VALUE] = "NAME";\n'), buildEnumMember = (e3, t3) => (e3 ? p : c)(t3);
        function isSyntacticallyString(e3) {
          switch ((e3 = (0, o.skipTransparentExprWrapperNodes)(e3)).type) {
            case "BinaryExpression": {
              const t3 = e3.left, r3 = e3.right;
              return "+" === e3.operator && (isSyntacticallyString(t3) || isSyntacticallyString(r3));
            }
            case "TemplateLiteral":
            case "StringLiteral":
              return true;
          }
          return false;
        }
        function ReferencedIdentifier(e3, t3) {
          const { seen: r3, path: n2, t: s2 } = t3, i2 = e3.node.name;
          if (r3.has(i2)) {
            for (let t4 = e3.scope; t4 !== n2.scope; t4 = t4.parent) if (t4.hasOwnBinding(i2)) return;
            e3.replaceWith(s2.memberExpression(s2.cloneNode(n2.node.id), s2.cloneNode(e3.node))), e3.skip();
          }
        }
        const u = { ReferencedIdentifier };
        function translateEnumValues(e3, t3) {
          var r3;
          const n2 = e3.scope.getBindingIdentifier(e3.node.id.name), i2 = null != (r3 = a.get(n2)) ? r3 : /* @__PURE__ */ new Map();
          let o2, l2 = -1, p2 = true;
          const c2 = e3.get("members").map((r4) => {
            const n3 = r4.node, a2 = t3.isIdentifier(n3.id) ? n3.id.name : n3.id.value, c3 = r4.get("initializer");
            let d;
            if (n3.initializer) l2 = computeConstantValue(c3, i2), void 0 !== l2 ? (i2.set(a2, l2), s("number" == typeof l2 || "string" == typeof l2), d = l2 === 1 / 0 || Number.isNaN(l2) ? t3.identifier(String(l2)) : l2 === -1 / 0 ? t3.unaryExpression("-", t3.identifier("Infinity")) : t3.valueToNode(l2)) : (p2 && (p2 = c3.isPure()), c3.isReferencedIdentifier() ? ReferencedIdentifier(c3, { t: t3, seen: i2, path: e3 }) : c3.traverse(u, { t: t3, seen: i2, path: e3 }), d = c3.node, i2.set(a2, void 0));
            else if ("number" == typeof l2) l2 += 1, d = t3.numericLiteral(l2), i2.set(a2, l2);
            else {
              if ("string" == typeof l2) throw e3.buildCodeFrameError("Enum member must have initializer.");
              {
                const r5 = t3.memberExpression(t3.cloneNode(e3.node.id), t3.stringLiteral(o2), true);
                d = t3.binaryExpression("+", t3.numericLiteral(1), r5), i2.set(a2, void 0);
              }
            }
            return o2 = a2, [a2, d];
          });
          return { isPure: p2, data: i2, enumValues: c2 };
        }
        function computeConstantValue(e3, t3, r3 = /* @__PURE__ */ new Set()) {
          return evaluate(e3);
          function evaluate(e4) {
            const n2 = e4.node;
            switch (n2.type) {
              case "MemberExpression":
              case "Identifier":
                return evaluateRef(e4, t3, r3);
              case "StringLiteral":
              case "NumericLiteral":
                return n2.value;
              case "UnaryExpression":
                return (function(e5) {
                  const t4 = evaluate(e5.get("argument"));
                  if (void 0 === t4) return;
                  switch (e5.node.operator) {
                    case "+":
                      return t4;
                    case "-":
                      return -t4;
                    case "~":
                      return ~t4;
                    default:
                      return;
                  }
                })(e4);
              case "BinaryExpression":
                return (function(e5) {
                  const t4 = evaluate(e5.get("left"));
                  if (void 0 === t4) return;
                  const r4 = evaluate(e5.get("right"));
                  if (void 0 === r4) return;
                  switch (e5.node.operator) {
                    case "|":
                      return t4 | r4;
                    case "&":
                      return t4 & r4;
                    case ">>":
                      return t4 >> r4;
                    case ">>>":
                      return t4 >>> r4;
                    case "<<":
                      return t4 << r4;
                    case "^":
                      return t4 ^ r4;
                    case "*":
                      return t4 * r4;
                    case "/":
                      return t4 / r4;
                    case "+":
                      return t4 + r4;
                    case "-":
                      return t4 - r4;
                    case "%":
                      return t4 % r4;
                    case "**":
                      return Math.pow(t4, r4);
                    default:
                      return;
                  }
                })(e4);
              case "ParenthesizedExpression":
                return evaluate(e4.get("expression"));
              case "TemplateLiteral": {
                if (1 === n2.quasis.length) return n2.quasis[0].value.cooked;
                const s2 = e4.get("expressions"), i2 = n2.quasis;
                let o2 = "";
                for (let e5 = 0; e5 < i2.length; e5++) if (o2 += i2[e5].value.cooked, e5 + 1 < i2.length) {
                  const n3 = evaluateRef(s2[e5], t3, r3);
                  if (void 0 === n3) return;
                  o2 += n3;
                }
                return o2;
              }
              default:
                return;
            }
          }
          function evaluateRef(e4, t4, r4) {
            if (e4.isMemberExpression()) {
              const t5 = e4.node, r5 = t5.object, s2 = t5.property;
              if (!n.types.isIdentifier(r5) || (t5.computed ? !n.types.isStringLiteral(s2) : !n.types.isIdentifier(s2))) return;
              const i2 = e4.scope.getBindingIdentifier(r5.name), o2 = a.get(i2);
              if (!o2) return;
              return o2.get(s2.computed ? s2.value : s2.name);
            }
            if (e4.isIdentifier()) {
              const n2 = e4.node.name;
              if (["Infinity", "NaN"].includes(n2)) return Number(n2);
              let s2 = null == t4 ? void 0 : t4.get(n2);
              if (void 0 !== s2) return s2;
              if (null != t4 && t4.has(n2)) return;
              if (r4.has(e4.node)) return;
              return r4.add(e4.node), s2 = computeConstantValue(e4.resolve(), t4, r4), s2;
            }
          }
        }
      }, "./node_modules/.pnpm/@babel+plugin-transform-typescript@7.28.0_@babel+core@7.28.4/node_modules/@babel/plugin-transform-typescript/lib/global-types.js": function(e2, t2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.GLOBAL_TYPES = void 0, t2.isGlobalType = function({ scope: e3 }, t3) {
          return !e3.hasBinding(t3) && (!!r2.get(e3).has(t3) || (console.warn(`The exported identifier "${t3}" is not declared in Babel's scope tracker
as a JavaScript value binding, and "@babel/plugin-transform-typescript"
never encountered it as a TypeScript type declaration.
It will be treated as a JavaScript value.

This problem is likely caused by another plugin injecting
"${t3}" without registering it in the scope tracker. If you are the author
 of that plugin, please use "scope.registerDeclaration(declarationPath)".`), false));
        }, t2.registerGlobalType = function(e3, t3) {
          r2.get(e3).add(t3);
        };
        const r2 = t2.GLOBAL_TYPES = /* @__PURE__ */ new WeakMap();
      }, "./node_modules/.pnpm/@babel+plugin-transform-typescript@7.28.0_@babel+core@7.28.4/node_modules/@babel/plugin-transform-typescript/lib/index.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var n = r2("./node_modules/.pnpm/@babel+helper-plugin-utils@7.27.1/node_modules/@babel/helper-plugin-utils/lib/index.js"), s = r2("./node_modules/.pnpm/@babel+plugin-syntax-typescript@7.27.1_@babel+core@7.28.4/node_modules/@babel/plugin-syntax-typescript/lib/index.js"), i = r2("./node_modules/.pnpm/@babel+helper-create-class-features-plugin@7.28.3_@babel+core@7.28.4/node_modules/@babel/helper-create-class-features-plugin/lib/index.js"), o = r2("./node_modules/.pnpm/@babel+plugin-transform-typescript@7.28.0_@babel+core@7.28.4/node_modules/@babel/plugin-transform-typescript/lib/const-enum.js"), a = r2("./node_modules/.pnpm/@babel+plugin-transform-typescript@7.28.0_@babel+core@7.28.4/node_modules/@babel/plugin-transform-typescript/lib/enum.js"), l = r2("./node_modules/.pnpm/@babel+plugin-transform-typescript@7.28.0_@babel+core@7.28.4/node_modules/@babel/plugin-transform-typescript/lib/global-types.js"), p = r2("./node_modules/.pnpm/@babel+plugin-transform-typescript@7.28.0_@babel+core@7.28.4/node_modules/@babel/plugin-transform-typescript/lib/namespace.js");
        function isInType(e3) {
          switch (e3.parent.type) {
            case "TSTypeReference":
            case "TSExpressionWithTypeArguments":
            case "TSExpressionWithTypeArguments":
            case "TSTypeQuery":
              return true;
            case "TSQualifiedName":
              return "TSImportEqualsDeclaration" !== e3.parentPath.findParent((e4) => "TSQualifiedName" !== e4.type).type;
            case "ExportSpecifier":
              return "type" === e3.parent.exportKind || "type" === e3.parentPath.parent.exportKind;
            default:
              return false;
          }
        }
        const c = /* @__PURE__ */ new WeakMap(), u = /* @__PURE__ */ new WeakSet();
        function safeRemove(e3) {
          const t3 = e3.getBindingIdentifiers();
          for (const r3 of Object.keys(t3)) {
            const n2 = e3.scope.getBinding(r3);
            n2 && n2.identifier === t3[r3] && n2.scope.removeBinding(r3);
          }
          e3.opts.noScope = true, e3.remove(), e3.opts.noScope = false;
        }
        function assertCjsTransformEnabled(e3, t3, r3, n2, s2 = "") {
          if ("commonjs" !== t3.file.get("@babel/plugin-transform-modules-*")) throw e3.buildCodeFrameError(`\`${r3}\` is only supported when compiling modules to CommonJS.
Please consider using \`${n2}\`${s2}, or add @babel/plugin-transform-modules-commonjs to your Babel config.`);
        }
        t2.default = (0, n.declare)((e3, t3) => {
          const { types: r3, template: n2 } = e3;
          e3.assertVersion(7);
          const d = /\*?\s*@jsx((?:Frag)?)\s+(\S+)/, { allowNamespaces: h = true, jsxPragma: m = "React.createElement", jsxPragmaFrag: f = "React.Fragment", onlyRemoveTypeImports: y = false, optimizeConstEnums: b = false } = t3;
          var { allowDeclareFields: g = false } = t3;
          const x = { field(e4) {
            const { node: t4 } = e4;
            if (!g && t4.declare) throw e4.buildCodeFrameError("The 'declare' modifier is only allowed when the 'allowDeclareFields' option of @babel/plugin-transform-typescript or @babel/preset-typescript is enabled.");
            if (t4.declare) {
              if (t4.value) throw e4.buildCodeFrameError("Fields with the 'declare' modifier cannot be initialized here, but only in the constructor");
              t4.decorators || e4.remove();
            } else if (t4.definite) {
              if (t4.value) throw e4.buildCodeFrameError("Definitely assigned fields cannot be initialized here, but only in the constructor");
              g || t4.decorators || r3.isClassPrivateProperty(t4) || e4.remove();
            } else t4.abstract ? e4.remove() : g || t4.value || t4.decorators || r3.isClassPrivateProperty(t4) || e4.remove();
            t4.accessibility && (t4.accessibility = null), t4.abstract && (t4.abstract = null), t4.readonly && (t4.readonly = null), t4.optional && (t4.optional = null), t4.typeAnnotation && (t4.typeAnnotation = null), t4.definite && (t4.definite = null), t4.declare && (t4.declare = null), t4.override && (t4.override = null);
          }, method({ node: e4 }) {
            e4.accessibility && (e4.accessibility = null), e4.abstract && (e4.abstract = null), e4.optional && (e4.optional = null), e4.override && (e4.override = null);
          }, constructor(e4, t4) {
            e4.node.accessibility && (e4.node.accessibility = null);
            const s2 = [], { scope: o2 } = e4;
            for (const t5 of e4.get("params")) {
              const e5 = t5.node;
              if ("TSParameterProperty" === e5.type) {
                const i2 = e5.parameter;
                if (u.has(i2)) continue;
                let a2;
                if (u.add(i2), r3.isIdentifier(i2)) a2 = i2;
                else {
                  if (!r3.isAssignmentPattern(i2) || !r3.isIdentifier(i2.left)) throw t5.buildCodeFrameError("Parameter properties can not be destructuring patterns.");
                  a2 = i2.left;
                }
                s2.push(n2.statement.ast`
              this.${r3.cloneNode(a2)} = ${r3.cloneNode(a2)}
            `), t5.replaceWith(t5.get("parameter")), o2.registerBinding("param", t5);
              }
            }
            (0, i.injectInitialization)(t4, e4, s2);
          } };
          return { name: "transform-typescript", inherits: s.default, visitor: { Pattern: visitPattern, Identifier: visitPattern, RestElement: visitPattern, Program: { enter(e4, t4) {
            const { file: r4 } = t4;
            let n3 = null, s2 = null;
            const i2 = e4.scope;
            if (l.GLOBAL_TYPES.has(i2) || l.GLOBAL_TYPES.set(i2, /* @__PURE__ */ new Set()), r4.ast.comments) for (const e5 of r4.ast.comments) {
              const t5 = d.exec(e5.value);
              t5 && (t5[1] ? s2 = t5[2] : n3 = t5[2]);
            }
            let o2 = n3 || m;
            o2 && ([o2] = o2.split("."));
            let a2 = s2 || f;
            a2 && ([a2] = a2.split("."));
            for (let r5 of e4.get("body")) {
              if (r5.isImportDeclaration()) {
                if (c.has(t4.file.ast.program) || c.set(t4.file.ast.program, true), "type" === r5.node.importKind) {
                  for (const e5 of r5.node.specifiers) (0, l.registerGlobalType)(i2, e5.local.name);
                  r5.remove();
                  continue;
                }
                const n4 = /* @__PURE__ */ new Set(), s3 = r5.node.specifiers.length, isAllSpecifiersElided = () => s3 > 0 && s3 === n4.size;
                for (const e5 of r5.node.specifiers) if ("ImportSpecifier" === e5.type && "type" === e5.importKind) {
                  (0, l.registerGlobalType)(i2, e5.local.name);
                  const t5 = r5.scope.getBinding(e5.local.name);
                  t5 && n4.add(t5.path);
                }
                if (y) c.set(e4.node, false);
                else {
                  if (0 === r5.node.specifiers.length) {
                    c.set(e4.node, false);
                    continue;
                  }
                  for (const t5 of r5.node.specifiers) {
                    const s4 = r5.scope.getBinding(t5.local.name);
                    s4 && !n4.has(s4.path) && (isImportTypeOnly({ binding: s4, programPath: e4, pragmaImportName: o2, pragmaFragImportName: a2 }) ? n4.add(s4.path) : c.set(e4.node, false));
                  }
                }
                if (isAllSpecifiersElided() && !y) r5.remove();
                else for (const e5 of n4) e5.remove();
                continue;
              }
              if (!y && r5.isTSImportEqualsDeclaration()) {
                const { id: t5 } = r5.node, n4 = r5.scope.getBinding(t5.name);
                if (n4 && !r5.node.isExport && isImportTypeOnly({ binding: n4, programPath: e4, pragmaImportName: o2, pragmaFragImportName: a2 })) {
                  r5.remove();
                  continue;
                }
              }
              if (r5.isExportDeclaration() && (r5 = r5.get("declaration")), r5.isVariableDeclaration({ declare: true })) for (const e5 of Object.keys(r5.getBindingIdentifiers())) (0, l.registerGlobalType)(i2, e5);
              else (r5.isTSTypeAliasDeclaration() || r5.isTSDeclareFunction() && r5.get("id").isIdentifier() || r5.isTSInterfaceDeclaration() || r5.isClassDeclaration({ declare: true }) || r5.isTSEnumDeclaration({ declare: true }) || r5.isTSModuleDeclaration({ declare: true }) && r5.get("id").isIdentifier()) && (0, l.registerGlobalType)(i2, r5.node.id.name);
            }
          }, exit(e4) {
            "module" === e4.node.sourceType && c.get(e4.node) && e4.pushContainer("body", r3.exportNamedDeclaration());
          } }, ExportNamedDeclaration(e4, t4) {
            if (c.has(t4.file.ast.program) || c.set(t4.file.ast.program, true), "type" !== e4.node.exportKind) if (e4.node.source && e4.node.specifiers.length > 0 && e4.node.specifiers.every((e5) => "ExportSpecifier" === e5.type && "type" === e5.exportKind)) e4.remove();
            else if (!e4.node.source && e4.node.specifiers.length > 0 && e4.node.specifiers.every((t5) => r3.isExportSpecifier(t5) && (0, l.isGlobalType)(e4, t5.local.name))) e4.remove();
            else {
              if (r3.isTSModuleDeclaration(e4.node.declaration)) {
                const t5 = e4.node.declaration;
                if (!r3.isStringLiteral(t5.id)) {
                  const n3 = (0, p.getFirstIdentifier)(t5.id);
                  if (e4.scope.hasOwnBinding(n3.name)) e4.replaceWith(t5);
                  else {
                    const [s2] = e4.replaceWithMultiple([r3.exportNamedDeclaration(r3.variableDeclaration("let", [r3.variableDeclarator(r3.cloneNode(n3))])), t5]);
                    e4.scope.registerDeclaration(s2);
                  }
                }
              }
              c.set(t4.file.ast.program, false);
            }
            else e4.remove();
          }, ExportAllDeclaration(e4) {
            "type" === e4.node.exportKind && e4.remove();
          }, ExportSpecifier(e4) {
            (!e4.parent.source && (0, l.isGlobalType)(e4, e4.node.local.name) || "type" === e4.node.exportKind) && e4.remove();
          }, ExportDefaultDeclaration(e4, t4) {
            c.has(t4.file.ast.program) || c.set(t4.file.ast.program, true), r3.isIdentifier(e4.node.declaration) && (0, l.isGlobalType)(e4, e4.node.declaration.name) ? e4.remove() : c.set(t4.file.ast.program, false);
          }, TSDeclareFunction(e4) {
            safeRemove(e4);
          }, TSDeclareMethod(e4) {
            safeRemove(e4);
          }, VariableDeclaration(e4) {
            e4.node.declare && safeRemove(e4);
          }, VariableDeclarator({ node: e4 }) {
            e4.definite && (e4.definite = null);
          }, TSIndexSignature(e4) {
            e4.remove();
          }, ClassDeclaration(e4) {
            const { node: t4 } = e4;
            t4.declare && safeRemove(e4);
          }, Class(e4) {
            const { node: t4 } = e4;
            t4.typeParameters && (t4.typeParameters = null), t4.superTypeParameters && (t4.superTypeParameters = null), t4.implements && (t4.implements = null), t4.abstract && (t4.abstract = null), e4.get("body.body").forEach((t5) => {
              t5.isClassMethod() || t5.isClassPrivateMethod() ? "constructor" === t5.node.kind ? x.constructor(t5, e4) : x.method(t5) : (t5.isClassProperty() || t5.isClassPrivateProperty() || t5.isClassAccessorProperty()) && x.field(t5);
            });
          }, Function(e4) {
            const { node: t4 } = e4;
            t4.typeParameters && (t4.typeParameters = null), t4.returnType && (t4.returnType = null);
            const n3 = t4.params;
            n3.length > 0 && r3.isIdentifier(n3[0], { name: "this" }) && n3.shift();
          }, TSModuleDeclaration(e4) {
            (0, p.default)(e4, h);
          }, TSInterfaceDeclaration(e4) {
            e4.remove();
          }, TSTypeAliasDeclaration(e4) {
            e4.remove();
          }, TSEnumDeclaration(e4) {
            b && e4.node.const ? (0, o.default)(e4, r3) : (0, a.default)(e4, r3);
          }, TSImportEqualsDeclaration(e4, t4) {
            const { id: n3, moduleReference: s2 } = e4.node;
            let i2, o2;
            r3.isTSExternalModuleReference(s2) ? (assertCjsTransformEnabled(e4, t4, `import ${n3.name} = require(...);`, `import ${n3.name} from '...';`, " alongside Typescript's --allowSyntheticDefaultImports option"), i2 = r3.callExpression(r3.identifier("require"), [s2.expression]), o2 = "const") : (i2 = entityNameToExpr(s2), o2 = "var");
            const a2 = r3.variableDeclaration(o2, [r3.variableDeclarator(n3, i2)]);
            e4.replaceWith(e4.node.isExport ? r3.exportNamedDeclaration(a2) : a2), e4.scope.registerDeclaration(e4);
          }, TSExportAssignment(e4, t4) {
            assertCjsTransformEnabled(e4, t4, "export = <value>;", "export default <value>;"), e4.replaceWith(n2.statement.ast`module.exports = ${e4.node.expression}`);
          }, TSTypeAssertion(e4) {
            e4.replaceWith(e4.node.expression);
          }, ["TSAsExpression" + (r3.tsSatisfiesExpression ? "|TSSatisfiesExpression" : "")](e4) {
            let { node: t4 } = e4;
            do {
              t4 = t4.expression;
            } while (r3.isTSAsExpression(t4) || null != r3.isTSSatisfiesExpression && r3.isTSSatisfiesExpression(t4));
            e4.replaceWith(t4);
          }, [e3.types.tsInstantiationExpression ? "TSNonNullExpression|TSInstantiationExpression" : "TSNonNullExpression"](e4) {
            e4.replaceWith(e4.node.expression);
          }, CallExpression(e4) {
            e4.node.typeParameters = null;
          }, OptionalCallExpression(e4) {
            e4.node.typeParameters = null;
          }, NewExpression(e4) {
            e4.node.typeParameters = null;
          }, JSXOpeningElement(e4) {
            e4.node.typeParameters = null;
          }, TaggedTemplateExpression(e4) {
            e4.node.typeParameters = null;
          } } };
          function entityNameToExpr(e4) {
            return r3.isTSQualifiedName(e4) ? r3.memberExpression(entityNameToExpr(e4.left), e4.right) : e4;
          }
          function visitPattern({ node: e4 }) {
            e4.typeAnnotation && (e4.typeAnnotation = null), r3.isIdentifier(e4) && e4.optional && (e4.optional = null);
          }
          function isImportTypeOnly({ binding: e4, programPath: t4, pragmaImportName: r4, pragmaFragImportName: n3 }) {
            for (const t5 of e4.referencePaths) if (!isInType(t5)) return false;
            if (e4.identifier.name !== r4 && e4.identifier.name !== n3) return true;
            let s2 = false;
            return t4.traverse({ "JSXElement|JSXFragment"(e5) {
              s2 = true, e5.stop();
            } }), !s2;
          }
        });
      }, "./node_modules/.pnpm/@babel+plugin-transform-typescript@7.28.0_@babel+core@7.28.4/node_modules/@babel/plugin-transform-typescript/lib/namespace.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
          if (e3.node.declare || "StringLiteral" === e3.node.id.type) return void e3.remove();
          if (!t3) throw e3.get("id").buildCodeFrameError("Namespace not marked type-only declare. Non-declarative namespaces are only supported experimentally in Babel. To enable and review caveats see: https://babeljs.io/docs/en/babel-plugin-transform-typescript");
          const r3 = getFirstIdentifier(e3.node.id).name, n2 = handleNested(e3, e3.node);
          if (null === n2) {
            const t4 = e3.findParent((e4) => e4.isProgram());
            (0, s.registerGlobalType)(t4.scope, r3), e3.remove();
          } else e3.scope.hasOwnBinding(r3) ? e3.replaceWith(n2) : e3.scope.registerDeclaration(e3.replaceWithMultiple([getDeclaration(r3), n2])[0]);
        }, t2.getFirstIdentifier = getFirstIdentifier;
        var n = r2("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/index.js"), s = r2("./node_modules/.pnpm/@babel+plugin-transform-typescript@7.28.0_@babel+core@7.28.4/node_modules/@babel/plugin-transform-typescript/lib/global-types.js"), i = r2("./node_modules/.pnpm/@babel+plugin-transform-typescript@7.28.0_@babel+core@7.28.4/node_modules/@babel/plugin-transform-typescript/lib/const-enum.js");
        function getFirstIdentifier(e3) {
          return n.types.isIdentifier(e3) ? e3 : getFirstIdentifier(e3.left);
        }
        function getDeclaration(e3) {
          return n.types.variableDeclaration("let", [n.types.variableDeclarator(n.types.identifier(e3))]);
        }
        function getMemberExpression(e3, t3) {
          return n.types.memberExpression(n.types.identifier(e3), n.types.identifier(t3));
        }
        function handleVariableDeclaration(e3, t3, r3) {
          if ("const" !== e3.kind) throw r3.file.buildCodeFrameError(e3, "Namespaces exporting non-const are not supported by Babel. Change to const or see: https://babeljs.io/docs/en/babel-plugin-transform-typescript");
          const { declarations: s2 } = e3;
          if (s2.every((e4) => n.types.isIdentifier(e4.id))) {
            for (const e4 of s2) e4.init = n.types.assignmentExpression("=", getMemberExpression(t3, e4.id.name), e4.init);
            return [e3];
          }
          const i2 = n.types.getBindingIdentifiers(e3), o = [];
          for (const e4 in i2) o.push(n.types.assignmentExpression("=", getMemberExpression(t3, e4), n.types.cloneNode(i2[e4])));
          return [e3, n.types.expressionStatement(n.types.sequenceExpression(o))];
        }
        function buildNestedAmbientModuleError(e3, t3) {
          return e3.hub.buildError(t3, "Ambient modules cannot be nested in other modules or namespaces.", Error);
        }
        function handleNested(e3, t3, r3) {
          const s2 = /* @__PURE__ */ new Set(), o = t3.id, a = e3.scope.generateUid(o.name), l = t3.body;
          let p;
          t3.id;
          p = n.types.isTSModuleBlock(l) ? l.body : [n.types.exportNamedDeclaration(l)];
          let c = true;
          for (let t4 = 0; t4 < p.length; t4++) {
            const r4 = p[t4];
            switch (r4.type) {
              case "TSModuleDeclaration": {
                if (!n.types.isIdentifier(r4.id)) throw buildNestedAmbientModuleError(e3, r4);
                const i2 = handleNested(e3, r4);
                if (null !== i2) {
                  c = false;
                  const e4 = r4.id.name;
                  s2.has(e4) ? p[t4] = i2 : (s2.add(e4), p.splice(t4++, 1, getDeclaration(e4), i2));
                }
                continue;
              }
              case "TSEnumDeclaration":
              case "FunctionDeclaration":
              case "ClassDeclaration":
                c = false, s2.add(r4.id.name);
                continue;
              case "VariableDeclaration":
                c = false;
                for (const e4 in n.types.getBindingIdentifiers(r4)) s2.add(e4);
                continue;
              default:
                c && (c = n.types.isTypeScript(r4));
                continue;
              case "ExportNamedDeclaration":
            }
            if (!("declare" in r4.declaration) || !r4.declaration.declare) switch (r4.declaration.type) {
              case "TSEnumDeclaration":
                i.EXPORTED_CONST_ENUMS_IN_NAMESPACE.add(r4.declaration);
              case "FunctionDeclaration":
              case "ClassDeclaration": {
                c = false;
                const e4 = r4.declaration.id.name;
                s2.add(e4), p.splice(t4++, 1, r4.declaration, n.types.expressionStatement(n.types.assignmentExpression("=", getMemberExpression(a, e4), n.types.identifier(e4))));
                break;
              }
              case "VariableDeclaration": {
                c = false;
                const n2 = handleVariableDeclaration(r4.declaration, a, e3.hub);
                p.splice(t4, n2.length, ...n2), t4 += n2.length - 1;
                break;
              }
              case "TSModuleDeclaration": {
                if (!n.types.isIdentifier(r4.declaration.id)) throw buildNestedAmbientModuleError(e3, r4.declaration);
                const i2 = handleNested(e3, r4.declaration, n.types.identifier(a));
                if (null !== i2) {
                  c = false;
                  const e4 = r4.declaration.id.name;
                  s2.has(e4) ? p[t4] = i2 : (s2.add(e4), p.splice(t4++, 1, getDeclaration(e4), i2));
                } else p.splice(t4, 1), t4--;
              }
            }
          }
          if (c) return null;
          let u = n.types.objectExpression([]);
          if (r3) {
            const e4 = n.types.memberExpression(r3, o);
            u = n.template.expression.ast`
      ${n.types.cloneNode(e4)} ||
        (${n.types.cloneNode(e4)} = ${u})
    `;
          }
          return n.template.statement.ast`
    (function (${n.types.identifier(a)}) {
      ${p}
    })(${o} || (${n.types.cloneNode(o)} = ${u}));
  `;
        }
      }, "./node_modules/.pnpm/@babel+preset-typescript@7.27.1_@babel+core@7.28.4/node_modules/@babel/preset-typescript/lib/index.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true });
        var n = r2("./node_modules/.pnpm/@babel+helper-plugin-utils@7.27.1/node_modules/@babel/helper-plugin-utils/lib/index.js"), s = r2("./node_modules/.pnpm/@babel+plugin-transform-typescript@7.28.0_@babel+core@7.28.4/node_modules/@babel/plugin-transform-typescript/lib/index.js");
        r2("./node_modules/.pnpm/@babel+plugin-syntax-jsx@7.27.1_@babel+core@7.28.4/node_modules/@babel/plugin-syntax-jsx/lib/index.js");
        var i = r2("./node_modules/.pnpm/@babel+plugin-transform-modules-commonjs@7.27.1_@babel+core@7.28.4/node_modules/@babel/plugin-transform-modules-commonjs/lib/index.js"), o = r2("./node_modules/.pnpm/@babel+helper-validator-option@7.27.1/node_modules/@babel/helper-validator-option/lib/index.js");
        function _interopDefault(e3) {
          return e3 && e3.__esModule ? e3 : { default: e3 };
        }
        var a = _interopDefault(s), l = _interopDefault(i);
        const p = new o.OptionValidator("@babel/preset-typescript");
        var c = n.declare(function({ types: e3, template: t3 }) {
          function maybeReplace(r3, n2, s2) {
            r3 && (e3.isStringLiteral(r3) ? /^\.\.?\//.test(r3.value) && (r3.value = r3.value.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+)?)\.([cm]?)ts$/i, function(e4, t4, r4, n3, s3) {
              return t4 ? ".js" : !r4 || n3 && s3 ? r4 + n3 + "." + s3.toLowerCase() + "js" : e4;
            })) : s2.availableHelper("tsRewriteRelativeImportExtensions") ? n2.replaceWith(e3.callExpression(s2.addHelper("tsRewriteRelativeImportExtensions"), [r3])) : n2.replaceWith(t3.expression.ast`(${r3} + "").replace(/([\\/].*\.[mc]?)tsx?$/, "$1js")`));
          }
          return { name: "preset-typescript/plugin-rewrite-ts-imports", visitor: { "ImportDeclaration|ExportAllDeclaration|ExportNamedDeclaration"(t4, r3) {
            const n2 = t4.node;
            "value" === (e3.isImportDeclaration(n2) ? n2.importKind : n2.exportKind) && maybeReplace(n2.source, t4.get("source"), r3);
          }, CallExpression(t4, r3) {
            e3.isImport(t4.node.callee) && maybeReplace(t4.node.arguments[0], t4.get("arguments.0"), r3);
          }, ImportExpression(e4, t4) {
            maybeReplace(e4.node.source, e4.get("source"), t4);
          } } };
        }), u = n.declarePreset((e3, t3) => {
          e3.assertVersion(7);
          const { allExtensions: r3, ignoreExtensions: n2, allowNamespaces: s2, disallowAmbiguousJSXLike: i2, isTSX: o2, jsxPragma: u2, jsxPragmaFrag: d, onlyRemoveTypeImports: h, optimizeConstEnums: m, rewriteImportExtensions: f } = (function(e4 = {}) {
            let { allowNamespaces: t4 = true, jsxPragma: r4, onlyRemoveTypeImports: n3 } = e4;
            const s3 = "ignoreExtensions", i3 = "disallowAmbiguousJSXLike", o3 = "jsxPragmaFrag", a2 = "optimizeConstEnums", l2 = "rewriteImportExtensions", c2 = "allExtensions", u3 = "isTSX", d2 = p.validateStringOption(o3, e4.jsxPragmaFrag, "React.Fragment");
            var h2 = p.validateBooleanOption(c2, e4.allExtensions, false), m2 = p.validateBooleanOption(u3, e4.isTSX, false);
            m2 && p.invariant(h2, "isTSX:true requires allExtensions:true");
            const f2 = p.validateBooleanOption(s3, e4.ignoreExtensions, false), y = p.validateBooleanOption(i3, e4.disallowAmbiguousJSXLike, false);
            y && p.invariant(h2, "disallowAmbiguousJSXLike:true requires allExtensions:true");
            const b = { ignoreExtensions: f2, allowNamespaces: t4, disallowAmbiguousJSXLike: y, jsxPragma: r4, jsxPragmaFrag: d2, onlyRemoveTypeImports: n3, optimizeConstEnums: p.validateBooleanOption(a2, e4.optimizeConstEnums, false), rewriteImportExtensions: p.validateBooleanOption(l2, e4.rewriteImportExtensions, false) };
            return b.allExtensions = h2, b.isTSX = m2, b;
          })(t3), pluginOptions = (e4) => ({ allowDeclareFields: t3.allowDeclareFields, allowNamespaces: s2, disallowAmbiguousJSXLike: e4, jsxPragma: u2, jsxPragmaFrag: d, onlyRemoveTypeImports: h, optimizeConstEnums: m }), getPlugins = (e4, t4) => [[a.default, Object.assign({ isTSX: e4 }, pluginOptions(t4))]];
          return { plugins: f ? [c] : [], overrides: r3 || n2 ? [{ plugins: getPlugins(o2, i2) }] : [{ test: /\.ts$/, plugins: getPlugins(false, false) }, { test: /\.mts$/, sourceType: "module", plugins: getPlugins(false, true) }, { test: /\.cts$/, sourceType: "unambiguous", plugins: [[l.default, { allowTopLevelThis: true }], [a.default, pluginOptions(true)]] }, { test: /\.tsx$/, plugins: getPlugins(true, false) }] };
        });
        t2.default = u;
      }, "./node_modules/.pnpm/@babel+template@7.27.2/node_modules/@babel/template/lib/builder.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function createTemplateBuilder(e3, t3) {
          const r3 = /* @__PURE__ */ new WeakMap(), a = /* @__PURE__ */ new WeakMap(), l = t3 || (0, n.validate)(null);
          return Object.assign((t4, ...o2) => {
            if ("string" == typeof t4) {
              if (o2.length > 1) throw new Error("Unexpected extra params.");
              return extendedTrace((0, s.default)(e3, t4, (0, n.merge)(l, (0, n.validate)(o2[0]))));
            }
            if (Array.isArray(t4)) {
              let n2 = r3.get(t4);
              return n2 || (n2 = (0, i.default)(e3, t4, l), r3.set(t4, n2)), extendedTrace(n2(o2));
            }
            if ("object" == typeof t4 && t4) {
              if (o2.length > 0) throw new Error("Unexpected extra params.");
              return createTemplateBuilder(e3, (0, n.merge)(l, (0, n.validate)(t4)));
            }
            throw new Error("Unexpected template param " + typeof t4);
          }, { ast: (t4, ...r4) => {
            if ("string" == typeof t4) {
              if (r4.length > 1) throw new Error("Unexpected extra params.");
              return (0, s.default)(e3, t4, (0, n.merge)((0, n.merge)(l, (0, n.validate)(r4[0])), o))();
            }
            if (Array.isArray(t4)) {
              let s2 = a.get(t4);
              return s2 || (s2 = (0, i.default)(e3, t4, (0, n.merge)(l, o)), a.set(t4, s2)), s2(r4)();
            }
            throw new Error("Unexpected template param " + typeof t4);
          } });
        };
        var n = r2("./node_modules/.pnpm/@babel+template@7.27.2/node_modules/@babel/template/lib/options.js"), s = r2("./node_modules/.pnpm/@babel+template@7.27.2/node_modules/@babel/template/lib/string.js"), i = r2("./node_modules/.pnpm/@babel+template@7.27.2/node_modules/@babel/template/lib/literal.js");
        const o = (0, n.validate)({ placeholderPattern: false });
        function extendedTrace(e3) {
          let t3 = "";
          try {
            throw new Error();
          } catch (e4) {
            e4.stack && (t3 = e4.stack.split("\n").slice(3).join("\n"));
          }
          return (r3) => {
            try {
              return e3(r3);
            } catch (e4) {
              throw e4.stack += `
    =============
${t3}`, e4;
            }
          };
        }
      }, "./node_modules/.pnpm/@babel+template@7.27.2/node_modules/@babel/template/lib/formatters.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.statements = t2.statement = t2.smart = t2.program = t2.expression = void 0;
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/index.js");
        const { assertExpressionStatement: s } = n;
        function makeStatementFormatter(e3) {
          return { code: (e4) => `/* @babel/template */;
${e4}`, validate: () => {
          }, unwrap: (t3) => e3(t3.program.body.slice(1)) };
        }
        t2.smart = makeStatementFormatter((e3) => e3.length > 1 ? e3 : e3[0]), t2.statements = makeStatementFormatter((e3) => e3), t2.statement = makeStatementFormatter((e3) => {
          if (0 === e3.length) throw new Error("Found nothing to return.");
          if (e3.length > 1) throw new Error("Found multiple statements but wanted one");
          return e3[0];
        });
        const i = t2.expression = { code: (e3) => `(
${e3}
)`, validate: (e3) => {
          if (e3.program.body.length > 1) throw new Error("Found multiple statements but wanted one");
          if (0 === i.unwrap(e3).start) throw new Error("Parse result included parens.");
        }, unwrap: ({ program: e3 }) => {
          const [t3] = e3.body;
          return s(t3), t3.expression;
        } };
        t2.program = { code: (e3) => e3, validate: () => {
        }, unwrap: (e3) => e3.program };
      }, "./node_modules/.pnpm/@babel+template@7.27.2/node_modules/@babel/template/lib/index.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.statements = t2.statement = t2.smart = t2.program = t2.expression = t2.default = void 0;
        var n = r2("./node_modules/.pnpm/@babel+template@7.27.2/node_modules/@babel/template/lib/formatters.js"), s = r2("./node_modules/.pnpm/@babel+template@7.27.2/node_modules/@babel/template/lib/builder.js");
        const i = t2.smart = (0, s.default)(n.smart), o = t2.statement = (0, s.default)(n.statement), a = t2.statements = (0, s.default)(n.statements), l = t2.expression = (0, s.default)(n.expression), p = t2.program = (0, s.default)(n.program);
        t2.default = Object.assign(i.bind(void 0), { smart: i, statement: o, statements: a, expression: l, program: p, ast: i.ast });
      }, "./node_modules/.pnpm/@babel+template@7.27.2/node_modules/@babel/template/lib/literal.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3) {
          const { metadata: o, names: a } = (function(e4, t4, r4) {
            let n2 = "BABEL_TPL$";
            const i2 = t4.join("");
            do {
              n2 = "$$" + n2;
            } while (i2.includes(n2));
            const { names: o2, code: a2 } = (function(e5, t5) {
              const r5 = [];
              let n3 = e5[0];
              for (let s2 = 1; s2 < e5.length; s2++) {
                const i3 = `${t5}${s2 - 1}`;
                r5.push(i3), n3 += i3 + e5[s2];
              }
              return { names: r5, code: n3 };
            })(t4, n2), l = (0, s.default)(e4, e4.code(a2), { parser: r4.parser, placeholderWhitelist: new Set(o2.concat(r4.placeholderWhitelist ? Array.from(r4.placeholderWhitelist) : [])), placeholderPattern: r4.placeholderPattern, preserveComments: r4.preserveComments, syntacticPlaceholders: r4.syntacticPlaceholders });
            return { metadata: l, names: o2 };
          })(e3, t3, r3);
          return (t4) => {
            const r4 = {};
            return t4.forEach((e4, t5) => {
              r4[a[t5]] = e4;
            }), (t5) => {
              const s2 = (0, n.normalizeReplacements)(t5);
              return s2 && Object.keys(s2).forEach((e4) => {
                if (hasOwnProperty.call(r4, e4)) throw new Error("Unexpected replacement overlap.");
              }), e3.unwrap((0, i.default)(o, s2 ? Object.assign(s2, r4) : r4));
            };
          };
        };
        var n = r2("./node_modules/.pnpm/@babel+template@7.27.2/node_modules/@babel/template/lib/options.js"), s = r2("./node_modules/.pnpm/@babel+template@7.27.2/node_modules/@babel/template/lib/parse.js"), i = r2("./node_modules/.pnpm/@babel+template@7.27.2/node_modules/@babel/template/lib/populate.js");
      }, "./node_modules/.pnpm/@babel+template@7.27.2/node_modules/@babel/template/lib/options.js": function(e2, t2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.merge = function(e3, t3) {
          const { placeholderWhitelist: r3 = e3.placeholderWhitelist, placeholderPattern: n = e3.placeholderPattern, preserveComments: s = e3.preserveComments, syntacticPlaceholders: i = e3.syntacticPlaceholders } = t3;
          return { parser: Object.assign({}, e3.parser, t3.parser), placeholderWhitelist: r3, placeholderPattern: n, preserveComments: s, syntacticPlaceholders: i };
        }, t2.normalizeReplacements = function(e3) {
          if (Array.isArray(e3)) return e3.reduce((e4, t3, r3) => (e4["$" + r3] = t3, e4), {});
          if ("object" == typeof e3 || null == e3) return e3 || void 0;
          throw new Error("Template replacements must be an array, object, null, or undefined");
        }, t2.validate = function(e3) {
          if (null != e3 && "object" != typeof e3) throw new Error("Unknown template options.");
          const t3 = e3 || {}, { placeholderWhitelist: n, placeholderPattern: s, preserveComments: i, syntacticPlaceholders: o } = t3, a = (function(e4, t4) {
            if (null == e4) return {};
            var r3 = {};
            for (var n2 in e4) if ({}.hasOwnProperty.call(e4, n2)) {
              if (-1 !== t4.indexOf(n2)) continue;
              r3[n2] = e4[n2];
            }
            return r3;
          })(t3, r2);
          if (null != n && !(n instanceof Set)) throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
          if (null != s && !(s instanceof RegExp) && false !== s) throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
          if (null != i && "boolean" != typeof i) throw new Error("'.preserveComments' must be a boolean, null, or undefined");
          if (null != o && "boolean" != typeof o) throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");
          if (true === o && (null != n || null != s)) throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
          return { parser: a, placeholderWhitelist: n || void 0, placeholderPattern: null == s ? void 0 : s, preserveComments: null == i ? void 0 : i, syntacticPlaceholders: null == o ? void 0 : o };
        };
        const r2 = ["placeholderWhitelist", "placeholderPattern", "preserveComments", "syntacticPlaceholders"];
      }, "./node_modules/.pnpm/@babel+template@7.27.2/node_modules/@babel/template/lib/parse.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3) {
          const { placeholderWhitelist: n2, placeholderPattern: o2, preserveComments: a2, syntacticPlaceholders: l2 } = r3, p2 = (function(e4, t4, r4) {
            const n3 = (t4.plugins || []).slice();
            false !== r4 && n3.push("placeholders");
            t4 = Object.assign({ allowAwaitOutsideFunction: true, allowReturnOutsideFunction: true, allowNewTargetOutsideFunction: true, allowSuperOutsideMethod: true, allowYieldOutsideFunction: true, sourceType: "module" }, t4, { plugins: n3 });
            try {
              return (0, s.parse)(e4, t4);
            } catch (t5) {
              const r5 = t5.loc;
              throw r5 && (t5.message += "\n" + (0, i.codeFrameColumns)(e4, { start: r5 }), t5.code = "BABEL_TEMPLATE_PARSE_ERROR"), t5;
            }
          })(t3, r3.parser, l2);
          f(p2, { preserveComments: a2 }), e3.validate(p2);
          const c2 = { syntactic: { placeholders: [], placeholderNames: /* @__PURE__ */ new Set() }, legacy: { placeholders: [], placeholderNames: /* @__PURE__ */ new Set() }, placeholderWhitelist: n2, placeholderPattern: o2, syntacticPlaceholders: l2 };
          return y(p2, placeholderVisitorHandler, c2), Object.assign({ ast: p2 }, c2.syntactic.placeholders.length ? c2.syntactic : c2.legacy);
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/index.js"), s = r2("./node_modules/.pnpm/@babel+parser@7.28.4/node_modules/@babel/parser/lib/index.js"), i = r2("./stubs/babel-codeframe.mjs");
        const { isCallExpression: o, isExpressionStatement: a, isFunction: l, isIdentifier: p, isJSXIdentifier: c, isNewExpression: u, isPlaceholder: d, isStatement: h, isStringLiteral: m, removePropertiesDeep: f, traverse: y } = n, b = /^[_$A-Z0-9]+$/;
        function placeholderVisitorHandler(e3, t3, r3) {
          var n2;
          let s2, i2 = r3.syntactic.placeholders.length > 0;
          if (d(e3)) {
            if (false === r3.syntacticPlaceholders) throw new Error("%%foo%%-style placeholders can't be used when '.syntacticPlaceholders' is false.");
            s2 = e3.name.name, i2 = true;
          } else {
            if (i2 || r3.syntacticPlaceholders) return;
            if (p(e3) || c(e3)) s2 = e3.name;
            else {
              if (!m(e3)) return;
              s2 = e3.value;
            }
          }
          if (i2 && (null != r3.placeholderPattern || null != r3.placeholderWhitelist)) throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
          if (!(i2 || false !== r3.placeholderPattern && (r3.placeholderPattern || b).test(s2) || null != (n2 = r3.placeholderWhitelist) && n2.has(s2))) return;
          t3 = t3.slice();
          const { node: f2, key: y2 } = t3[t3.length - 1];
          let g;
          m(e3) || d(e3, { expectedNode: "StringLiteral" }) ? g = "string" : u(f2) && "arguments" === y2 || o(f2) && "arguments" === y2 || l(f2) && "params" === y2 ? g = "param" : a(f2) && !d(e3) ? (g = "statement", t3 = t3.slice(0, -1)) : g = h(e3) && d(e3) ? "statement" : "other";
          const { placeholders: x, placeholderNames: v } = i2 ? r3.syntactic : r3.legacy;
          x.push({ name: s2, type: g, resolve: (e4) => (function(e5, t4) {
            let r4 = e5;
            for (let e6 = 0; e6 < t4.length - 1; e6++) {
              const { key: n4, index: s4 } = t4[e6];
              r4 = void 0 === s4 ? r4[n4] : r4[n4][s4];
            }
            const { key: n3, index: s3 } = t4[t4.length - 1];
            return { parent: r4, key: n3, index: s3 };
          })(e4, t3), isDuplicate: v.has(s2) }), v.add(s2);
        }
      }, "./node_modules/.pnpm/@babel+template@7.27.2/node_modules/@babel/template/lib/populate.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
          const r3 = i(e3.ast);
          t3 && (e3.placeholders.forEach((e4) => {
            if (!hasOwnProperty.call(t3, e4.name)) {
              const t4 = e4.name;
              throw new Error(`Error: No substitution given for "${t4}". If this is not meant to be a
            placeholder you may want to consider passing one of the following options to @babel/template:
            - { placeholderPattern: false, placeholderWhitelist: new Set(['${t4}'])}
            - { placeholderPattern: /^${t4}$/ }`);
            }
          }), Object.keys(t3).forEach((t4) => {
            if (!e3.placeholderNames.has(t4)) throw new Error(`Unknown substitution "${t4}" given`);
          }));
          return e3.placeholders.slice().reverse().forEach((e4) => {
            try {
              var n2;
              !(function(e5, t4, r4) {
                e5.isDuplicate && (Array.isArray(r4) ? r4 = r4.map((e6) => i(e6)) : "object" == typeof r4 && (r4 = i(r4)));
                const { parent: n3, key: h, index: m } = e5.resolve(t4);
                if ("string" === e5.type) {
                  if ("string" == typeof r4 && (r4 = u(r4)), !r4 || !c(r4)) throw new Error("Expected string substitution");
                } else if ("statement" === e5.type) void 0 === m ? r4 ? Array.isArray(r4) ? r4 = s(r4) : "string" == typeof r4 ? r4 = a(l(r4)) : p(r4) || (r4 = a(r4)) : r4 = o() : r4 && !Array.isArray(r4) && ("string" == typeof r4 && (r4 = l(r4)), p(r4) || (r4 = a(r4)));
                else if ("param" === e5.type) {
                  if ("string" == typeof r4 && (r4 = l(r4)), void 0 === m) throw new Error("Assertion failure.");
                } else if ("string" == typeof r4 && (r4 = l(r4)), Array.isArray(r4)) throw new Error("Cannot replace single expression with an array.");
                function set(e6, t5, r5) {
                  const n4 = e6[t5];
                  e6[t5] = r5, "Identifier" !== n4.type && "Placeholder" !== n4.type || (n4.typeAnnotation && (r5.typeAnnotation = n4.typeAnnotation), n4.optional && (r5.optional = n4.optional), n4.decorators && (r5.decorators = n4.decorators));
                }
                if (void 0 === m) d(n3, h, r4), set(n3, h, r4);
                else {
                  const t5 = n3[h].slice();
                  "statement" === e5.type || "param" === e5.type ? null == r4 ? t5.splice(m, 1) : Array.isArray(r4) ? t5.splice(m, 1, ...r4) : set(t5, m, r4) : set(t5, m, r4), d(n3, h, t5), n3[h] = t5;
                }
              })(e4, r3, null != (n2 = t3 && t3[e4.name]) ? n2 : null);
            } catch (t4) {
              throw t4.message = `@babel/template placeholder "${e4.name}": ${t4.message}`, t4;
            }
          }), r3;
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/index.js");
        const { blockStatement: s, cloneNode: i, emptyStatement: o, expressionStatement: a, identifier: l, isStatement: p, isStringLiteral: c, stringLiteral: u, validate: d } = n;
      }, "./node_modules/.pnpm/@babel+template@7.27.2/node_modules/@babel/template/lib/string.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3) {
          let o;
          return t3 = e3.code(t3), (a) => {
            const l = (0, n.normalizeReplacements)(a);
            return o || (o = (0, s.default)(e3, t3, r3)), e3.unwrap((0, i.default)(o, l));
          };
        };
        var n = r2("./node_modules/.pnpm/@babel+template@7.27.2/node_modules/@babel/template/lib/options.js"), s = r2("./node_modules/.pnpm/@babel+template@7.27.2/node_modules/@babel/template/lib/parse.js"), i = r2("./node_modules/.pnpm/@babel+template@7.27.2/node_modules/@babel/template/lib/populate.js");
      }, "./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/cache.js": function(e2, t2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.clear = function() {
          clearPath(), clearScope();
        }, t2.clearPath = clearPath, t2.clearScope = clearScope, t2.getCachedPaths = function(e3) {
          const { parent: t3, parentPath: n2 } = e3;
          return r2.get(t3);
        }, t2.getOrCreateCachedPaths = function(e3, t3) {
          let n2 = r2.get(e3);
          n2 || r2.set(e3, n2 = /* @__PURE__ */ new Map());
          return n2;
        }, t2.scope = t2.path = void 0;
        let r2 = t2.path = /* @__PURE__ */ new WeakMap(), n = t2.scope = /* @__PURE__ */ new WeakMap();
        function clearPath() {
          t2.path = r2 = /* @__PURE__ */ new WeakMap();
        }
        function clearScope() {
          t2.scope = n = /* @__PURE__ */ new WeakMap();
        }
      }, "./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/context.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var n = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/index.js"), s = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/index.js"), i = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/context.js");
        const { VISITOR_KEYS: o } = s;
        t2.default = class {
          constructor(e3, t3, r3, n2) {
            this.queue = null, this.priorityQueue = null, this.parentPath = n2, this.scope = e3, this.state = r3, this.opts = t3;
          }
          shouldVisit(e3) {
            const t3 = this.opts;
            if (t3.enter || t3.exit) return true;
            if (t3[e3.type]) return true;
            const r3 = o[e3.type];
            if (null == r3 || !r3.length) return false;
            for (const t4 of r3) if (e3[t4]) return true;
            return false;
          }
          create(e3, t3, r3, s2) {
            return n.default.get({ parentPath: this.parentPath, parent: e3, container: t3, key: r3, listKey: s2 });
          }
          maybeQueue(e3, t3) {
            this.queue && (t3 ? this.queue.push(e3) : this.priorityQueue.push(e3));
          }
          visitMultiple(e3, t3, r3) {
            if (0 === e3.length) return false;
            const n2 = [];
            for (let s2 = 0; s2 < e3.length; s2++) {
              const i2 = e3[s2];
              i2 && this.shouldVisit(i2) && n2.push(this.create(t3, e3, s2, r3));
            }
            return this.visitQueue(n2);
          }
          visitSingle(e3, t3) {
            return !!this.shouldVisit(e3[t3]) && this.visitQueue([this.create(e3, e3, t3)]);
          }
          visitQueue(e3) {
            this.queue = e3, this.priorityQueue = [];
            const t3 = /* @__PURE__ */ new WeakSet();
            let r3 = false, n2 = 0;
            for (; n2 < e3.length; ) {
              const s2 = e3[n2];
              if (n2++, i.resync.call(s2), 0 !== s2.contexts.length && s2.contexts[s2.contexts.length - 1] === this || i.pushContext.call(s2, this), null === s2.key) continue;
              const { node: o2 } = s2;
              if (!t3.has(o2)) {
                if (o2 && t3.add(o2), s2.visit()) {
                  r3 = true;
                  break;
                }
                if (this.priorityQueue.length && (r3 = this.visitQueue(this.priorityQueue), this.priorityQueue = [], this.queue = e3, r3)) break;
              }
            }
            for (let t4 = 0; t4 < n2; t4++) i.popContext.call(e3[t4]);
            return this.queue = null, r3;
          }
          visit(e3, t3) {
            const r3 = e3[t3];
            return !!r3 && (Array.isArray(r3) ? this.visitMultiple(r3, e3, t3) : this.visitSingle(e3, t3));
          }
        };
      }, "./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/hub.js": function(e2, t2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        t2.default = class {
          getCode() {
          }
          getScope() {
          }
          addHelper() {
            throw new Error("Helpers are not supported by the default hub.");
          }
          buildError(e3, t3, r2 = TypeError) {
            return new r2(t3);
          }
        };
      }, "./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/index.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), Object.defineProperty(t2, "Hub", { enumerable: true, get: function() {
          return p.default;
        } }), Object.defineProperty(t2, "NodePath", { enumerable: true, get: function() {
          return a.default;
        } }), Object.defineProperty(t2, "Scope", { enumerable: true, get: function() {
          return l.default;
        } }), t2.visitors = t2.default = void 0, r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/context.js");
        var n = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/visitors.js");
        t2.visitors = n;
        var s = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/index.js"), i = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/cache.js"), o = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/traverse-node.js"), a = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/index.js"), l = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/scope/index.js"), p = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/hub.js");
        const { VISITOR_KEYS: c, removeProperties: u, traverseFast: d } = s;
        function traverse(e3, t3 = {}, r3, s2, i2, a2) {
          if (e3) {
            if (!t3.noScope && !r3 && "Program" !== e3.type && "File" !== e3.type) throw new Error(`You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a ${e3.type} node without passing scope and parentPath.`);
            if (!i2 && a2) throw new Error("visitSelf can only be used when providing a NodePath.");
            c[e3.type] && (n.explode(t3), (0, o.traverseNode)(e3, t3, r3, s2, i2, null, a2));
          }
        }
        t2.default = traverse;
        traverse.visitors = n, traverse.verify = n.verify, traverse.explode = n.explode, traverse.cheap = function(e3, t3) {
          d(e3, t3);
        }, traverse.node = function(e3, t3, r3, n2, s2, i2) {
          (0, o.traverseNode)(e3, t3, r3, n2, s2, i2);
        }, traverse.clearNode = function(e3, t3) {
          u(e3, t3);
        }, traverse.removeProperties = function(e3, t3) {
          return d(e3, traverse.clearNode, t3), e3;
        }, traverse.hasType = function(e3, t3, r3) {
          return (null == r3 || !r3.includes(e3.type)) && (e3.type === t3 || d(e3, function(e4) {
            return null != r3 && r3.includes(e4.type) ? d.skip : e4.type === t3 ? d.stop : void 0;
          }));
        }, traverse.cache = i;
      }, "./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/ancestry.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.find = function(e3) {
          let t3 = this;
          do {
            if (e3(t3)) return t3;
          } while (t3 = t3.parentPath);
          return null;
        }, t2.findParent = function(e3) {
          let t3 = this;
          for (; t3 = t3.parentPath; ) if (e3(t3)) return t3;
          return null;
        }, t2.getAncestry = function() {
          let e3 = this;
          const t3 = [];
          do {
            t3.push(e3);
          } while (e3 = e3.parentPath);
          return t3;
        }, t2.getDeepestCommonAncestorFrom = function(e3, t3) {
          if (!e3.length) return this;
          if (1 === e3.length) return e3[0];
          let r3, n2, s2 = 1 / 0;
          const i = e3.map((e4) => {
            const t4 = [];
            do {
              t4.unshift(e4);
            } while ((e4 = e4.parentPath) && e4 !== this);
            return t4.length < s2 && (s2 = t4.length), t4;
          }), o = i[0];
          e: for (let e4 = 0; e4 < s2; e4++) {
            const t4 = o[e4];
            for (const r4 of i) if (r4[e4] !== t4) break e;
            r3 = e4, n2 = t4;
          }
          if (n2) return t3 ? t3(n2, r3, i) : n2;
          throw new Error("Couldn't find intersection");
        }, t2.getEarliestCommonAncestorFrom = function(e3) {
          return this.getDeepestCommonAncestorFrom(e3, function(e4, t3, r3) {
            let n2;
            const i = s[e4.type];
            for (const e5 of r3) {
              const r4 = e5[t3 + 1];
              if (!n2) {
                n2 = r4;
                continue;
              }
              if (r4.listKey && n2.listKey === r4.listKey && r4.key < n2.key) {
                n2 = r4;
                continue;
              }
              i.indexOf(n2.parentKey) > i.indexOf(r4.parentKey) && (n2 = r4);
            }
            return n2;
          });
        }, t2.getFunctionParent = function() {
          return this.findParent((e3) => e3.isFunction());
        }, t2.getStatementParent = function() {
          let e3 = this;
          do {
            if (!e3.parentPath || Array.isArray(e3.container) && e3.isStatement()) break;
            e3 = e3.parentPath;
          } while (e3);
          if (e3 && (e3.isProgram() || e3.isFile())) throw new Error("File/Program node, we can't possibly find a statement parent to this");
          return e3;
        }, t2.inType = function(...e3) {
          let t3 = this;
          for (; t3; ) {
            if (e3.includes(t3.node.type)) return true;
            t3 = t3.parentPath;
          }
          return false;
        }, t2.isAncestor = function(e3) {
          return e3.isDescendant(this);
        }, t2.isDescendant = function(e3) {
          return !!this.findParent((t3) => t3 === e3);
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/index.js");
        const { VISITOR_KEYS: s } = n;
      }, "./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/comments.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.addComment = function(e3, t3, r3) {
          s(this.node, e3, t3, r3);
        }, t2.addComments = function(e3, t3) {
          i(this.node, e3, t3);
        }, t2.shareCommentsWithSiblings = function() {
          if ("string" == typeof this.key) return;
          const e3 = this.node;
          if (!e3) return;
          const t3 = e3.trailingComments, r3 = e3.leadingComments;
          if (!t3 && !r3) return;
          const n2 = this.getSibling(this.key - 1), s2 = this.getSibling(this.key + 1), i2 = Boolean(n2.node), o = Boolean(s2.node);
          i2 && (r3 && n2.addComments("trailing", removeIfExisting(r3, n2.node.trailingComments)), t3 && !o && n2.addComments("trailing", t3));
          o && (t3 && s2.addComments("leading", removeIfExisting(t3, s2.node.leadingComments)), r3 && !i2 && s2.addComments("leading", r3));
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/index.js");
        const { addComment: s, addComments: i } = n;
        function removeIfExisting(e3, t3) {
          if (null == t3 || !t3.length) return e3;
          const r3 = new Set(t3);
          return e3.filter((e4) => !r3.has(e4));
        }
      }, "./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/context.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2._call = _call, t2._getQueueContexts = function() {
          let e3 = this, t3 = this.contexts;
          for (; !t3.length && (e3 = e3.parentPath, e3); ) t3 = e3.contexts;
          return t3;
        }, t2._resyncKey = _resyncKey, t2._resyncList = _resyncList, t2._resyncParent = _resyncParent, t2._resyncRemoved = function() {
          null != this.key && this.container && this.container[this.key] === this.node || i._markRemoved.call(this);
        }, t2.call = call, t2.isDenylisted = isDenylisted, t2.popContext = function() {
          this.contexts.pop(), this.contexts.length > 0 ? this.setContext(this.contexts[this.contexts.length - 1]) : this.setContext(void 0);
        }, t2.pushContext = function(e3) {
          this.contexts.push(e3), this.setContext(e3);
        }, t2.requeue = function(e3 = this) {
          if (e3.removed) return;
          const t3 = this.contexts;
          for (const r3 of t3) r3.maybeQueue(e3);
        }, t2.requeueComputedKeyAndDecorators = function() {
          const { context: e3, node: t3 } = this;
          !o.isPrivate(t3) && t3.computed && e3.maybeQueue(this.get("key"));
          if (t3.decorators) for (const t4 of this.get("decorators")) e3.maybeQueue(t4);
        }, t2.resync = function() {
          if (this.removed) return;
          _resyncParent.call(this), _resyncList.call(this), _resyncKey.call(this);
        }, t2.setContext = function(e3) {
          null != this.skipKeys && (this.skipKeys = {});
          this._traverseFlags = 0, e3 && (this.context = e3, this.state = e3.state, this.opts = e3.opts);
          return setScope.call(this), this;
        }, t2.setKey = setKey, t2.setScope = setScope, t2.setup = function(e3, t3, r3, n2) {
          this.listKey = r3, this.container = t3, this.parentPath = e3 || this.parentPath, setKey.call(this, n2);
        }, t2.skip = function() {
          this.shouldSkip = true;
        }, t2.skipKey = function(e3) {
          null == this.skipKeys && (this.skipKeys = {});
          this.skipKeys[e3] = true;
        }, t2.stop = function() {
          this._traverseFlags |= s.SHOULD_SKIP | s.SHOULD_STOP;
        }, t2.visit = function() {
          var e3, t3;
          if (!this.node) return false;
          if (this.isDenylisted()) return false;
          if (null != (e3 = (t3 = this.opts).shouldSkip) && e3.call(t3, this)) return false;
          const r3 = this.context;
          if (this.shouldSkip || call.call(this, "enter")) return this.debug("Skip..."), this.shouldStop;
          return restoreContext(this, r3), this.debug("Recursing into..."), this.shouldStop = (0, n.traverseNode)(this.node, this.opts, this.scope, this.state, this, this.skipKeys), restoreContext(this, r3), call.call(this, "exit"), this.shouldStop;
        };
        var n = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/traverse-node.js"), s = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/index.js"), i = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/removal.js"), o = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/index.js");
        function call(e3) {
          const t3 = this.opts;
          return this.debug(e3), !(!this.node || !_call.call(this, t3[e3])) || !!this.node && _call.call(this, null == (r3 = t3[this.node.type]) ? void 0 : r3[e3]);
          var r3;
        }
        function _call(e3) {
          if (!e3) return false;
          for (const t3 of e3) {
            if (!t3) continue;
            const e4 = this.node;
            if (!e4) return true;
            const r3 = t3.call(this.state, this, this.state);
            if (r3 && "object" == typeof r3 && "function" == typeof r3.then) throw new Error("You appear to be using a plugin with an async traversal visitor, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
            if (r3) throw new Error(`Unexpected return value from visitor method ${t3}`);
            if (this.node !== e4) return true;
            if (this._traverseFlags > 0) return true;
          }
          return false;
        }
        function isDenylisted() {
          var e3;
          const t3 = null != (e3 = this.opts.denylist) ? e3 : this.opts.blacklist;
          return null == t3 ? void 0 : t3.includes(this.node.type);
        }
        function restoreContext(e3, t3) {
          e3.context !== t3 && (e3.context = t3, e3.state = t3.state, e3.opts = t3.opts);
        }
        function setScope() {
          var e3, t3;
          if (null != (e3 = this.opts) && e3.noScope) return;
          let r3, n2 = this.parentPath;
          for ((("key" === this.key || "decorators" === this.listKey) && n2.isMethod() || "discriminant" === this.key && n2.isSwitchStatement()) && (n2 = n2.parentPath); n2 && !r3; ) {
            var s2;
            if (null != (s2 = n2.opts) && s2.noScope) return;
            r3 = n2.scope, n2 = n2.parentPath;
          }
          this.scope = this.getScope(r3), null == (t3 = this.scope) || t3.init();
        }
        function _resyncParent() {
          this.parentPath && (this.parent = this.parentPath.node);
        }
        function _resyncKey() {
          if (this.container && this.node !== this.container[this.key]) {
            if (Array.isArray(this.container)) {
              for (let e3 = 0; e3 < this.container.length; e3++) if (this.container[e3] === this.node) return void setKey.call(this, e3);
            } else for (const e3 of Object.keys(this.container)) if (this.container[e3] === this.node) return void setKey.call(this, e3);
            this.key = null;
          }
        }
        function _resyncList() {
          if (!this.parent || !this.inList) return;
          const e3 = this.parent[this.listKey];
          this.container !== e3 && (this.container = e3 || null);
        }
        function setKey(e3) {
          var t3;
          this.key = e3, this.node = this.container[this.key], this.type = null == (t3 = this.node) ? void 0 : t3.type;
        }
        t2.isBlacklisted = isDenylisted;
      }, "./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/conversion.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.arrowFunctionToExpression = function({ allowInsertArrow: e3 = true, allowInsertArrowWithRest: t3 = e3, noNewArrows: r3 = !((e4) => null == (e4 = arguments[0]) ? void 0 : e4.specCompliant)() } = {}) {
          if (!this.isArrowFunctionExpression()) throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
          let n2 = this;
          var s2;
          r3 || (n2 = null != (s2 = n2.ensureFunctionName(false)) ? s2 : n2);
          const { thisBinding: i2, fnPath: o2 } = hoistFunctionEnvironment(n2, r3, e3, t3);
          if (o2.ensureBlock(), (function(e4, t4) {
            e4.node.type = t4;
          })(o2, "FunctionExpression"), !r3) {
            const e4 = i2 ? null : o2.scope.generateUidIdentifier("arrowCheckId");
            return e4 && o2.parentPath.scope.push({ id: e4, init: T([]) }), o2.get("body").unshiftContainer("body", h(u(this.hub.addHelper("newArrowCheck"), [I(), m(e4 ? e4.name : i2)]))), o2.replaceWith(u(x(o2.node, m("bind")), [e4 ? m(e4.name) : I()])), o2.get("callee.object");
          }
          return o2;
        }, t2.ensureBlock = function() {
          const e3 = this.get("body"), t3 = e3.node;
          if (Array.isArray(e3)) throw new Error("Can't convert array path to a block statement");
          if (!t3) throw new Error("Can't convert node without a body");
          if (e3.isBlockStatement()) return t3;
          const r3 = [];
          let n2, s2, i2 = "body";
          e3.isStatement() ? (s2 = "body", n2 = 0, r3.push(e3.node)) : (i2 += ".body.0", this.isFunction() ? (n2 = "argument", r3.push(P(e3.node))) : (n2 = "expression", r3.push(h(e3.node))));
          this.node.body = c(r3);
          const a2 = this.get(i2);
          return o.setup.call(e3, a2, s2 ? a2.node[s2] : a2.node, s2, n2), this.node;
        }, t2.ensureFunctionName = function(e3) {
          if (this.node.id) return this;
          const t3 = L(this.node, this.parent);
          if (null == t3) return this;
          let { name: r3 } = t3;
          if (!e3 && /[\uD800-\uDFFF]/.test(r3)) return null;
          if (r3.startsWith("get ") || r3.startsWith("set ")) return null;
          r3 = N(r3.replace(/[/ ]/g, "_"));
          const n2 = m(r3);
          $(n2, t3.originalNode);
          const i2 = { needsRename: false, name: r3 }, { scope: o2 } = this, a2 = o2.getOwnBinding(r3);
          a2 ? "param" === a2.kind && (i2.needsRename = true) : (o2.parent.hasBinding(r3) || o2.hasGlobal(r3)) && this.traverse(H, i2);
          if (!i2.needsRename) return this.node.id = n2, o2.getProgramParent().references[n2.name] = true, this;
          if (o2.hasBinding(n2.name) && !o2.hasGlobal(n2.name)) return o2.rename(n2.name), this.node.id = n2, o2.getProgramParent().references[n2.name] = true, this;
          if (!O(this.node)) return null;
          const l2 = o2.generateUidIdentifier(n2.name), p2 = [];
          for (let e4 = 0, t4 = (function(e5) {
            const t5 = e5.params.findIndex((e6) => j(e6) || F(e6));
            return -1 === t5 ? e5.params.length : t5;
          })(this.node); e4 < t4; e4++) p2.push(o2.generateUidIdentifier("x"));
          const c2 = s.default.expression.ast`
    (function (${l2}) {
      function ${n2}(${p2}) {
        return ${M(l2)}.apply(this, arguments);
      }

      ${M(n2)}.toString = function () {
        return ${M(l2)}.toString();
      }

      return ${M(n2)};
    })(${D(this.node)})
  `;
          return this.replaceWith(c2)[0].get("arguments.0");
        }, t2.splitExportDeclaration = function() {
          if (!this.isExportDeclaration() || this.isExportAllDeclaration()) throw new Error("Only default and named export declarations can be split.");
          if (this.isExportNamedDeclaration() && this.get("specifiers").length > 0) throw new Error("It doesn't make sense to split exported specifiers.");
          const e3 = this.get("declaration");
          if (this.isExportDefaultDeclaration()) {
            const t4 = e3.isFunctionDeclaration() || e3.isClassDeclaration(), r4 = e3.isFunctionExpression() || e3.isClassExpression(), n3 = e3.isScope() ? e3.scope.parent : e3.scope;
            let s2 = e3.node.id, i2 = false;
            s2 ? r4 && n3.hasBinding(s2.name) && (i2 = true, s2 = n3.generateUidIdentifier(s2.name)) : (i2 = true, s2 = n3.generateUidIdentifier("default"), (t4 || r4) && (e3.node.id = M(s2)));
            const o2 = t4 ? e3.node : B("var", [R(M(s2), e3.node)]), a2 = U(null, [V(M(s2), m("default"))]);
            return this.insertAfter(a2), this.replaceWith(o2), i2 && n3.registerDeclaration(this), this;
          }
          if (this.get("specifiers").length > 0) throw new Error("It doesn't make sense to split exported specifiers.");
          const t3 = e3.getOuterBindingIdentifiers(), r3 = Object.keys(t3).map((e4) => V(m(e4), m(e4))), n2 = U(null, r3);
          return this.insertAfter(n2), this.replaceWith(e3.node), this;
        }, t2.toComputedKey = function() {
          let e3;
          if (this.isMemberExpression()) e3 = this.node.property;
          else {
            if (!this.isProperty() && !this.isMethod()) throw new ReferenceError("todo");
            e3 = this.node.key;
          }
          this.node.computed || f(e3) && (e3 = C(e3.name));
          return e3;
        }, t2.unwrapFunctionEnvironment = function() {
          if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
          hoistFunctionEnvironment(this);
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/index.js"), s = r2("./node_modules/.pnpm/@babel+template@7.27.2/node_modules/@babel/template/lib/index.js"), i = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/visitors.js"), o = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/context.js");
        const { arrowFunctionExpression: a, assignmentExpression: l, binaryExpression: p, blockStatement: c, callExpression: u, conditionalExpression: d, expressionStatement: h, identifier: m, isIdentifier: f, jsxIdentifier: y, logicalExpression: b, LOGICAL_OPERATORS: g, memberExpression: x, metaProperty: v, numericLiteral: E, objectExpression: T, restElement: S, returnStatement: P, sequenceExpression: _, spreadElement: A, stringLiteral: C, super: w, thisExpression: I, toExpression: D, unaryExpression: k, toBindingIdentifierName: N, isFunction: O, isAssignmentPattern: j, isRestElement: F, getFunctionName: L, cloneNode: M, variableDeclaration: B, variableDeclarator: R, exportNamedDeclaration: U, exportSpecifier: V, inherits: $ } = n;
        t2.arrowFunctionToShadowed = function() {
          this.isArrowFunctionExpression() && this.arrowFunctionToExpression();
        };
        const K = (0, i.environmentVisitor)({ CallExpression(e3, { allSuperCalls: t3 }) {
          e3.get("callee").isSuper() && t3.push(e3);
        } });
        function hoistFunctionEnvironment(e3, t3 = true, r3 = true, n2 = true) {
          let s2, i2 = e3.findParent((e4) => e4.isArrowFunctionExpression() ? (null != s2 || (s2 = e4), false) : e4.isFunction() || e4.isProgram() || e4.isClassProperty({ static: false }) || e4.isClassPrivateProperty({ static: false }));
          const o2 = i2.isClassMethod({ kind: "constructor" });
          if (i2.isClassProperty() || i2.isClassPrivateProperty()) if (s2) i2 = s2;
          else {
            if (!r3) throw e3.buildCodeFrameError("Unable to transform arrow inside class property");
            e3.replaceWith(u(a([], D(e3.node)), [])), i2 = e3.get("callee"), e3 = i2.get("body");
          }
          const { thisPaths: c2, argumentsPaths: h2, newTargetPaths: f2, superProps: T2, superCalls: P2 } = (function(e4) {
            const t4 = [], r4 = [], n3 = [], s3 = [], i3 = [];
            return e4.traverse(q, { thisPaths: t4, argumentsPaths: r4, newTargetPaths: n3, superProps: s3, superCalls: i3 }), { thisPaths: t4, argumentsPaths: r4, newTargetPaths: n3, superProps: s3, superCalls: i3 };
          })(e3);
          if (o2 && P2.length > 0) {
            if (!r3) throw P2[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super()` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
            if (!n2) throw P2[0].buildCodeFrameError("When using '@babel/plugin-transform-parameters', it's not possible to compile `super()` in an arrow function with default or rest parameters without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
            const e4 = [];
            i2.traverse(K, { allSuperCalls: e4 });
            const t4 = (function(e5) {
              return getBinding(e5, "supercall", () => {
                const t5 = e5.scope.generateUidIdentifier("args");
                return a([S(t5)], u(w(), [A(m(t5.name))]));
              });
            })(i2);
            e4.forEach((e5) => {
              const r4 = m(t4);
              r4.loc = e5.node.callee.loc, e5.get("callee").replaceWith(r4);
            });
          }
          if (h2.length > 0) {
            const e4 = getBinding(i2, "arguments", () => {
              const args = () => m("arguments");
              return i2.scope.path.isProgram() ? d(p("===", k("typeof", args()), C("undefined")), i2.scope.buildUndefinedNode(), args()) : args();
            });
            h2.forEach((t4) => {
              const r4 = m(e4);
              r4.loc = t4.node.loc, t4.replaceWith(r4);
            });
          }
          if (f2.length > 0) {
            const e4 = getBinding(i2, "newtarget", () => v(m("new"), m("target")));
            f2.forEach((t4) => {
              const r4 = m(e4);
              r4.loc = t4.node.loc, t4.replaceWith(r4);
            });
          }
          if (T2.length > 0) {
            if (!r3) throw T2[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super.prop` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
            T2.reduce((e4, t4) => e4.concat((function(e5) {
              if (e5.parentPath.isAssignmentExpression() && "=" !== e5.parentPath.node.operator) {
                const t5 = e5.parentPath, r4 = t5.node.operator.slice(0, -1), n3 = t5.node.right, s3 = (function(e6) {
                  return g.includes(e6);
                })(r4);
                if (e5.node.computed) {
                  const i3 = e5.scope.generateDeclaredUidIdentifier("tmp"), o3 = e5.node.object, a2 = e5.node.property;
                  t5.get("left").replaceWith(x(o3, l("=", i3, a2), true)), t5.get("right").replaceWith(rightExpression(s3 ? "=" : r4, x(o3, m(i3.name), true), n3));
                } else {
                  const i3 = e5.node.object, o3 = e5.node.property;
                  t5.get("left").replaceWith(x(i3, o3)), t5.get("right").replaceWith(rightExpression(s3 ? "=" : r4, x(i3, m(o3.name)), n3));
                }
                return s3 ? t5.replaceWith(b(r4, t5.node.left, t5.node.right)) : t5.node.operator = "=", [t5.get("left"), t5.get("right").get("left")];
              }
              if (e5.parentPath.isUpdateExpression()) {
                const t5 = e5.parentPath, r4 = e5.scope.generateDeclaredUidIdentifier("tmp"), n3 = e5.node.computed ? e5.scope.generateDeclaredUidIdentifier("prop") : null, s3 = [l("=", r4, x(e5.node.object, n3 ? l("=", n3, e5.node.property) : e5.node.property, e5.node.computed)), l("=", x(e5.node.object, n3 ? m(n3.name) : e5.node.property, e5.node.computed), p(e5.parentPath.node.operator[0], m(r4.name), E(1)))];
                e5.parentPath.node.prefix || s3.push(m(r4.name)), t5.replaceWith(_(s3));
                return [t5.get("expressions.0.right"), t5.get("expressions.1.left")];
              }
              return [e5];
              function rightExpression(e6, t5, r4) {
                return "=" === e6 ? l("=", t5, r4) : p(e6, t5, r4);
              }
            })(t4)), []).forEach((e4) => {
              const t4 = e4.node.computed ? "" : e4.get("property").node.name, r4 = e4.parentPath, n3 = r4.isAssignmentExpression({ left: e4.node }), s3 = r4.isCallExpression({ callee: e4.node }), o3 = r4.isTaggedTemplateExpression({ tag: e4.node }), p2 = (function(e5, t5, r5) {
                const n4 = t5 ? "set" : "get";
                return getBinding(e5, `superprop_${n4}:${r5 || ""}`, () => {
                  const n5 = [];
                  let s4;
                  if (r5) s4 = x(w(), m(r5));
                  else {
                    const t6 = e5.scope.generateUidIdentifier("prop");
                    n5.unshift(t6), s4 = x(w(), m(t6.name), true);
                  }
                  if (t5) {
                    const t6 = e5.scope.generateUidIdentifier("value");
                    n5.push(t6), s4 = l("=", s4, m(t6.name));
                  }
                  return a(n5, s4);
                });
              })(i2, n3, t4), d2 = [];
              if (e4.node.computed && d2.push(e4.get("property").node), n3) {
                const e5 = r4.node.right;
                d2.push(e5);
              }
              const h3 = u(m(p2), d2);
              s3 ? (r4.unshiftContainer("arguments", I()), e4.replaceWith(x(h3, m("call"))), c2.push(r4.get("arguments.0"))) : n3 ? r4.replaceWith(h3) : o3 ? (e4.replaceWith(u(x(h3, m("bind"), false), [I()])), c2.push(e4.get("arguments.0"))) : e4.replaceWith(h3);
            });
          }
          let N2;
          return (c2.length > 0 || !t3) && (N2 = (function(e4, t4) {
            return getBinding(e4, "this", (r4) => {
              if (!t4 || !hasSuperClass(e4)) return I();
              e4.traverse(W, { supers: /* @__PURE__ */ new WeakSet(), thisBinding: r4 });
            });
          })(i2, o2), (t3 || o2 && hasSuperClass(i2)) && (c2.forEach((e4) => {
            const t4 = e4.isJSX() ? y(N2) : m(N2);
            t4.loc = e4.node.loc, e4.replaceWith(t4);
          }), t3 || (N2 = null))), { thisBinding: N2, fnPath: e3 };
        }
        function hasSuperClass(e3) {
          return e3.isClassMethod() && !!e3.parentPath.parentPath.node.superClass;
        }
        const W = (0, i.environmentVisitor)({ CallExpression(e3, { supers: t3, thisBinding: r3 }) {
          e3.get("callee").isSuper() && (t3.has(e3.node) || (t3.add(e3.node), e3.replaceWithMultiple([e3.node, l("=", m(r3), m("this"))])));
        } });
        function getBinding(e3, t3, r3) {
          const n2 = "binding:" + t3;
          let s2 = e3.getData(n2);
          if (!s2) {
            const i2 = e3.scope.generateUidIdentifier(t3);
            s2 = i2.name, e3.setData(n2, s2), e3.scope.push({ id: i2, init: r3(s2) });
          }
          return s2;
        }
        const q = (0, i.environmentVisitor)({ ThisExpression(e3, { thisPaths: t3 }) {
          t3.push(e3);
        }, JSXIdentifier(e3, { thisPaths: t3 }) {
          "this" === e3.node.name && (e3.parentPath.isJSXMemberExpression({ object: e3.node }) || e3.parentPath.isJSXOpeningElement({ name: e3.node })) && t3.push(e3);
        }, CallExpression(e3, { superCalls: t3 }) {
          e3.get("callee").isSuper() && t3.push(e3);
        }, MemberExpression(e3, { superProps: t3 }) {
          e3.get("object").isSuper() && t3.push(e3);
        }, Identifier(e3, { argumentsPaths: t3 }) {
          if (!e3.isReferencedIdentifier({ name: "arguments" })) return;
          let r3 = e3.scope;
          do {
            if (r3.hasOwnBinding("arguments")) return void r3.rename("arguments");
            if (r3.path.isFunction() && !r3.path.isArrowFunctionExpression()) break;
          } while (r3 = r3.parent);
          t3.push(e3);
        }, MetaProperty(e3, { newTargetPaths: t3 }) {
          e3.get("meta").isIdentifier({ name: "new" }) && e3.get("property").isIdentifier({ name: "target" }) && t3.push(e3);
        } });
        const H = { "ReferencedIdentifier|BindingIdentifier"(e3, t3) {
          e3.node.name === t3.name && (t3.needsRename = true, e3.stop());
        }, Scope(e3, t3) {
          e3.scope.hasOwnBinding(t3.name) && e3.skip();
        } };
      }, "./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/evaluation.js": function(e2, t2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.evaluate = function() {
          const e3 = { confident: true, deoptPath: null, seen: /* @__PURE__ */ new Map() };
          let t3 = evaluateCached(this, e3);
          e3.confident || (t3 = void 0);
          return { confident: e3.confident, deopt: e3.deoptPath, value: t3 };
        }, t2.evaluateTruthy = function() {
          const e3 = this.evaluate();
          if (e3.confident) return !!e3.value;
        };
        const r2 = ["Number", "String", "Math"], n = ["isFinite", "isNaN", "parseFloat", "parseInt", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", null, null], s = ["random"];
        function isValidObjectCallee(e3) {
          return r2.includes(e3);
        }
        function deopt(e3, t3) {
          t3.confident && (t3.deoptPath = e3, t3.confident = false);
        }
        const i = /* @__PURE__ */ new Map([["undefined", void 0], ["Infinity", 1 / 0], ["NaN", NaN]]);
        function evaluateCached(e3, t3) {
          const { node: r3 } = e3, { seen: o } = t3;
          if (o.has(r3)) {
            const n2 = o.get(r3);
            return n2.resolved ? n2.value : void deopt(e3, t3);
          }
          {
            const a = { resolved: false };
            o.set(r3, a);
            const l = (function(e4, t4) {
              if (!t4.confident) return;
              if (e4.isSequenceExpression()) {
                const r5 = e4.get("expressions");
                return evaluateCached(r5[r5.length - 1], t4);
              }
              if (e4.isStringLiteral() || e4.isNumericLiteral() || e4.isBooleanLiteral()) return e4.node.value;
              if (e4.isNullLiteral()) return null;
              if (e4.isTemplateLiteral()) return evaluateQuasis(e4, e4.node.quasis, t4);
              if (e4.isTaggedTemplateExpression() && e4.get("tag").isMemberExpression()) {
                const r5 = e4.get("tag.object"), { node: { name: n2 } } = r5, s2 = e4.get("tag.property");
                if (r5.isIdentifier() && "String" === n2 && !e4.scope.getBinding(n2) && s2.isIdentifier() && "raw" === s2.node.name) return evaluateQuasis(e4, e4.node.quasi.quasis, t4, true);
              }
              if (e4.isConditionalExpression()) {
                const r5 = evaluateCached(e4.get("test"), t4);
                if (!t4.confident) return;
                return evaluateCached(r5 ? e4.get("consequent") : e4.get("alternate"), t4);
              }
              if (e4.isExpressionWrapper()) return evaluateCached(e4.get("expression"), t4);
              if (e4.isMemberExpression() && !e4.parentPath.isCallExpression({ callee: e4.node })) {
                const r5 = e4.get("property"), n2 = e4.get("object");
                if (n2.isLiteral()) {
                  const s2 = n2.node.value, i2 = typeof s2;
                  let o2 = null;
                  if (e4.node.computed) {
                    if (o2 = evaluateCached(r5, t4), !t4.confident) return;
                  } else r5.isIdentifier() && (o2 = r5.node.name);
                  if (!("number" !== i2 && "string" !== i2 || null == o2 || "number" != typeof o2 && "string" != typeof o2)) return s2[o2];
                }
              }
              if (e4.isReferencedIdentifier()) {
                const n2 = e4.scope.getBinding(e4.node.name);
                if (n2) {
                  if (n2.constantViolations.length > 0 || e4.node.start < n2.path.node.end) return void deopt(n2.path, t4);
                  const s3 = n2.path.scope;
                  if ("var" === n2.kind && s3 !== n2.scope) {
                    let i2 = !s3.path.parentPath.isBlockStatement();
                    for (let o3 = s3.parent; o3; o3 = o3.parent) {
                      var r4;
                      if (o3 === e4.scope) {
                        if (i2) return void deopt(n2.path, t4);
                        break;
                      }
                      null != (r4 = o3.path.parentPath) && r4.isBlockStatement() && (i2 = true);
                    }
                  }
                  if (n2.hasValue) return n2.value;
                }
                const s2 = e4.node.name;
                if (i.has(s2)) return n2 ? void deopt(n2.path, t4) : i.get(s2);
                const o2 = e4.resolve();
                if (o2 === e4) return void deopt(e4, t4);
                const a2 = evaluateCached(o2, t4);
                return "object" == typeof a2 && null !== a2 && n2.references > 1 ? void deopt(o2, t4) : a2;
              }
              if (e4.isUnaryExpression({ prefix: true })) {
                if ("void" === e4.node.operator) return;
                const r5 = e4.get("argument");
                if ("typeof" === e4.node.operator && (r5.isFunction() || r5.isClass())) return "function";
                const n2 = evaluateCached(r5, t4);
                if (!t4.confident) return;
                switch (e4.node.operator) {
                  case "!":
                    return !n2;
                  case "+":
                    return +n2;
                  case "-":
                    return -n2;
                  case "~":
                    return ~n2;
                  case "typeof":
                    return typeof n2;
                }
              }
              if (e4.isArrayExpression()) {
                const r5 = [], n2 = e4.get("elements");
                for (const e5 of n2) {
                  const n3 = e5.evaluate();
                  if (!n3.confident) return void deopt(n3.deopt, t4);
                  r5.push(n3.value);
                }
                return r5;
              }
              if (e4.isObjectExpression()) {
                const r5 = {}, n2 = e4.get("properties");
                for (const e5 of n2) {
                  if (e5.isObjectMethod() || e5.isSpreadElement()) return void deopt(e5, t4);
                  const n3 = e5.get("key");
                  let s2;
                  if (e5.node.computed) {
                    if (s2 = n3.evaluate(), !s2.confident) return void deopt(s2.deopt, t4);
                    s2 = s2.value;
                  } else s2 = n3.isIdentifier() ? n3.node.name : n3.node.value;
                  let i2 = e5.get("value").evaluate();
                  if (!i2.confident) return void deopt(i2.deopt, t4);
                  i2 = i2.value, r5[s2] = i2;
                }
                return r5;
              }
              if (e4.isLogicalExpression()) {
                const r5 = t4.confident, n2 = evaluateCached(e4.get("left"), t4), s2 = t4.confident;
                t4.confident = r5;
                const i2 = evaluateCached(e4.get("right"), t4), o2 = t4.confident;
                switch (e4.node.operator) {
                  case "||":
                    if (t4.confident = s2 && (!!n2 || o2), !t4.confident) return;
                    return n2 || i2;
                  case "&&":
                    if (t4.confident = s2 && (!n2 || o2), !t4.confident) return;
                    return n2 && i2;
                  case "??":
                    if (t4.confident = s2 && (null != n2 || o2), !t4.confident) return;
                    return null != n2 ? n2 : i2;
                }
              }
              if (e4.isBinaryExpression()) {
                const r5 = evaluateCached(e4.get("left"), t4);
                if (!t4.confident) return;
                const n2 = evaluateCached(e4.get("right"), t4);
                if (!t4.confident) return;
                switch (e4.node.operator) {
                  case "-":
                    return r5 - n2;
                  case "+":
                    return r5 + n2;
                  case "/":
                    return r5 / n2;
                  case "*":
                    return r5 * n2;
                  case "%":
                    return r5 % n2;
                  case "**":
                    return Math.pow(r5, n2);
                  case "<":
                    return r5 < n2;
                  case ">":
                    return r5 > n2;
                  case "<=":
                    return r5 <= n2;
                  case ">=":
                    return r5 >= n2;
                  case "==":
                    return r5 == n2;
                  case "!=":
                    return r5 != n2;
                  case "===":
                    return r5 === n2;
                  case "!==":
                    return r5 !== n2;
                  case "|":
                    return r5 | n2;
                  case "&":
                    return r5 & n2;
                  case "^":
                    return r5 ^ n2;
                  case "<<":
                    return r5 << n2;
                  case ">>":
                    return r5 >> n2;
                  case ">>>":
                    return r5 >>> n2;
                }
              }
              if (e4.isCallExpression()) {
                const r5 = e4.get("callee");
                let i2, o2;
                if (r5.isIdentifier() && !e4.scope.getBinding(r5.node.name) && (isValidObjectCallee(r5.node.name) || (function(e5) {
                  return n.includes(e5);
                })(r5.node.name)) && (o2 = global[r5.node.name]), r5.isMemberExpression()) {
                  const e5 = r5.get("object"), t5 = r5.get("property");
                  if (e5.isIdentifier() && t5.isIdentifier() && isValidObjectCallee(e5.node.name) && !(function(e6) {
                    return s.includes(e6);
                  })(t5.node.name)) {
                    i2 = global[e5.node.name];
                    const r6 = t5.node.name;
                    hasOwnProperty.call(i2, r6) && (o2 = i2[r6]);
                  }
                  if (e5.isLiteral() && t5.isIdentifier()) {
                    const r6 = typeof e5.node.value;
                    "string" !== r6 && "number" !== r6 || (i2 = e5.node.value, o2 = i2[t5.node.name]);
                  }
                }
                if (o2) {
                  const r6 = e4.get("arguments").map((e5) => evaluateCached(e5, t4));
                  if (!t4.confident) return;
                  return o2.apply(i2, r6);
                }
              }
              deopt(e4, t4);
            })(e3, t3);
            return t3.confident && (a.resolved = true, a.value = l), l;
          }
        }
        function evaluateQuasis(e3, t3, r3, n2 = false) {
          let s2 = "", i2 = 0;
          const o = e3.isTemplateLiteral() ? e3.get("expressions") : e3.get("quasi.expressions");
          for (const e4 of t3) {
            if (!r3.confident) break;
            s2 += n2 ? e4.value.raw : e4.value.cooked;
            const t4 = o[i2++];
            t4 && (s2 += String(evaluateCached(t4, r3)));
          }
          if (r3.confident) return s2;
        }
      }, "./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/family.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2._getKey = _getKey, t2._getPattern = _getPattern, t2.get = function(e3, t3 = true) {
          true === t3 && (t3 = this.context);
          const r3 = e3.split(".");
          return 1 === r3.length ? _getKey.call(this, e3, t3) : _getPattern.call(this, r3, t3);
        }, t2.getAllNextSiblings = function() {
          let e3 = this.key, t3 = this.getSibling(++e3);
          const r3 = [];
          for (; t3.node; ) r3.push(t3), t3 = this.getSibling(++e3);
          return r3;
        }, t2.getAllPrevSiblings = function() {
          let e3 = this.key, t3 = this.getSibling(--e3);
          const r3 = [];
          for (; t3.node; ) r3.push(t3), t3 = this.getSibling(--e3);
          return r3;
        }, t2.getAssignmentIdentifiers = function() {
          return i(this.node);
        }, t2.getBindingIdentifierPaths = function(e3 = false, t3 = false) {
          const r3 = [this], n2 = /* @__PURE__ */ Object.create(null);
          for (; r3.length; ) {
            const s2 = r3.shift();
            if (!s2) continue;
            if (!s2.node) continue;
            const i2 = o.keys[s2.node.type];
            if (s2.isIdentifier()) if (e3) {
              (n2[s2.node.name] = n2[s2.node.name] || []).push(s2);
            } else n2[s2.node.name] = s2;
            else {
              if (s2.isExportDeclaration()) {
                const e4 = s2.get("declaration");
                e4.isDeclaration() && r3.push(e4);
                continue;
              }
              if (t3) {
                if (s2.isFunctionDeclaration()) {
                  r3.push(s2.get("id"));
                  continue;
                }
                if (s2.isFunctionExpression()) continue;
              }
              if (i2) for (let e4 = 0; e4 < i2.length; e4++) {
                const t4 = i2[e4], n3 = s2.get(t4);
                Array.isArray(n3) ? r3.push(...n3) : n3.node && r3.push(n3);
              }
            }
          }
          return n2;
        }, t2.getBindingIdentifiers = function(e3) {
          return o(this.node, e3);
        }, t2.getCompletionRecords = function(e3 = false) {
          return _getCompletionRecords(this, { canHaveBreak: false, shouldPopulateBreak: false, inCaseClause: false, shouldPreserveBreak: e3 }).map((e4) => e4.path);
        }, t2.getNextSibling = function() {
          return this.getSibling(this.key + 1);
        }, t2.getOpposite = function() {
          if ("left" === this.key) return this.getSibling("right");
          if ("right" === this.key) return this.getSibling("left");
          return null;
        }, t2.getOuterBindingIdentifierPaths = function(e3 = false) {
          return this.getBindingIdentifierPaths(e3, true);
        }, t2.getOuterBindingIdentifiers = function(e3) {
          return a(this.node, e3);
        }, t2.getPrevSibling = function() {
          return this.getSibling(this.key - 1);
        }, t2.getSibling = function(e3) {
          return n.default.get({ parentPath: this.parentPath, parent: this.parent, container: this.container, listKey: this.listKey, key: e3 }).setContext(this.context);
        };
        var n = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/index.js"), s = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/index.js");
        const { getAssignmentIdentifiers: i, getBindingIdentifiers: o, getOuterBindingIdentifiers: a, numericLiteral: l, unaryExpression: p } = s, c = 0, u = 1;
        function addCompletionRecords(e3, t3, r3) {
          return e3 && t3.push(..._getCompletionRecords(e3, r3)), t3;
        }
        function normalCompletionToBreak(e3) {
          e3.forEach((e4) => {
            e4.type = u;
          });
        }
        function replaceBreakStatementInBreakCompletion(e3, t3) {
          e3.forEach((e4) => {
            e4.path.isBreakStatement({ label: null }) && (t3 ? e4.path.replaceWith(p("void", l(0))) : e4.path.remove());
          });
        }
        function getStatementListCompletion(e3, t3) {
          const r3 = [];
          if (t3.canHaveBreak) {
            let n2 = [];
            for (let s2 = 0; s2 < e3.length; s2++) {
              const i2 = e3[s2], o2 = Object.assign({}, t3, { inCaseClause: false });
              i2.isBlockStatement() && (t3.inCaseClause || t3.shouldPopulateBreak) ? o2.shouldPopulateBreak = true : o2.shouldPopulateBreak = false;
              const a2 = _getCompletionRecords(i2, o2);
              if (a2.length > 0 && a2.every((e4) => e4.type === u)) {
                n2.length > 0 && a2.every((e4) => e4.path.isBreakStatement({ label: null })) ? (normalCompletionToBreak(n2), r3.push(...n2), n2.some((e4) => e4.path.isDeclaration()) && (r3.push(...a2), t3.shouldPreserveBreak || replaceBreakStatementInBreakCompletion(a2, true)), t3.shouldPreserveBreak || replaceBreakStatementInBreakCompletion(a2, false)) : (r3.push(...a2), t3.shouldPopulateBreak || t3.shouldPreserveBreak || replaceBreakStatementInBreakCompletion(a2, true));
                break;
              }
              if (s2 === e3.length - 1) r3.push(...a2);
              else {
                n2 = [];
                for (let e4 = 0; e4 < a2.length; e4++) {
                  const t4 = a2[e4];
                  t4.type === u && r3.push(t4), t4.type === c && n2.push(t4);
                }
              }
            }
          } else if (e3.length) for (let n2 = e3.length - 1; n2 >= 0; n2--) {
            const s2 = _getCompletionRecords(e3[n2], t3);
            if (s2.length > 1 || 1 === s2.length && !s2[0].path.isVariableDeclaration() && !s2[0].path.isEmptyStatement()) {
              r3.push(...s2);
              break;
            }
          }
          return r3;
        }
        function _getCompletionRecords(e3, t3) {
          let r3 = [];
          if (e3.isIfStatement()) r3 = addCompletionRecords(e3.get("consequent"), r3, t3), r3 = addCompletionRecords(e3.get("alternate"), r3, t3);
          else {
            if (e3.isDoExpression() || e3.isFor() || e3.isWhile() || e3.isLabeledStatement()) return addCompletionRecords(e3.get("body"), r3, t3);
            if (e3.isProgram() || e3.isBlockStatement()) return getStatementListCompletion(e3.get("body"), t3);
            if (e3.isFunction()) return _getCompletionRecords(e3.get("body"), t3);
            if (e3.isTryStatement()) r3 = addCompletionRecords(e3.get("block"), r3, t3), r3 = addCompletionRecords(e3.get("handler"), r3, t3);
            else {
              if (e3.isCatchClause()) return addCompletionRecords(e3.get("body"), r3, t3);
              if (e3.isSwitchStatement()) return (function(e4, t4, r4) {
                let n2 = [];
                for (let s2 = 0; s2 < e4.length; s2++) {
                  const i2 = _getCompletionRecords(e4[s2], r4), o2 = [], a2 = [];
                  for (const e5 of i2) e5.type === c && o2.push(e5), e5.type === u && a2.push(e5);
                  o2.length && (n2 = o2), t4.push(...a2);
                }
                return t4.push(...n2), t4;
              })(e3.get("cases"), r3, t3);
              if (e3.isSwitchCase()) return getStatementListCompletion(e3.get("consequent"), { canHaveBreak: true, shouldPopulateBreak: false, inCaseClause: true, shouldPreserveBreak: t3.shouldPreserveBreak });
              e3.isBreakStatement() ? r3.push(/* @__PURE__ */ (function(e4) {
                return { type: u, path: e4 };
              })(e3)) : r3.push(/* @__PURE__ */ (function(e4) {
                return { type: c, path: e4 };
              })(e3));
            }
          }
          return r3;
        }
        function _getKey(e3, t3) {
          const r3 = this.node, s2 = r3[e3];
          return Array.isArray(s2) ? s2.map((i2, o2) => n.default.get({ listKey: e3, parentPath: this, parent: r3, container: s2, key: o2 }).setContext(t3)) : n.default.get({ parentPath: this, parent: r3, container: r3, key: e3 }).setContext(t3);
        }
        function _getPattern(e3, t3) {
          let r3 = this;
          for (const n2 of e3) r3 = "." === n2 ? r3.parentPath : Array.isArray(r3) ? r3[n2] : r3.get(n2, t3);
          return r3;
        }
      }, "./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/index.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = t2.SHOULD_STOP = t2.SHOULD_SKIP = t2.REMOVED = void 0;
        var n = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/lib/virtual-types.js"), s = r2("./node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/index.js"), i = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/index.js"), o = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/scope/index.js"), a = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/index.js"), l = a, p = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/cache.js"), c = r2("./node_modules/.pnpm/@babel+generator@7.28.3/node_modules/@babel/generator/lib/index.js"), u = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/ancestry.js"), d = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/inference/index.js"), h = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/replacement.js"), m = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/evaluation.js"), f = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/conversion.js"), y = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/introspection.js"), b = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/context.js"), g = b, x = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/removal.js"), v = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/modification.js"), E = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/family.js"), T = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/comments.js"), S = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/lib/virtual-types-validator.js");
        const { validate: P } = a, _ = s("babel"), A = (t2.REMOVED = 1, t2.SHOULD_STOP = 2, t2.SHOULD_SKIP = 4, t2.default = class NodePath {
          constructor(e3, t3) {
            this.contexts = [], this.state = null, this.opts = null, this._traverseFlags = 0, this.skipKeys = null, this.parentPath = null, this.container = null, this.listKey = null, this.key = null, this.node = null, this.type = null, this._store = null, this.parent = t3, this.hub = e3, this.data = null, this.context = null, this.scope = null;
          }
          get removed() {
            return (1 & this._traverseFlags) > 0;
          }
          set removed(e3) {
            e3 ? this._traverseFlags |= 1 : this._traverseFlags &= -2;
          }
          get shouldStop() {
            return (2 & this._traverseFlags) > 0;
          }
          set shouldStop(e3) {
            e3 ? this._traverseFlags |= 2 : this._traverseFlags &= -3;
          }
          get shouldSkip() {
            return (4 & this._traverseFlags) > 0;
          }
          set shouldSkip(e3) {
            e3 ? this._traverseFlags |= 4 : this._traverseFlags &= -5;
          }
          static get({ hub: e3, parentPath: t3, parent: r3, container: n2, listKey: s2, key: i2 }) {
            if (!e3 && t3 && (e3 = t3.hub), !r3) throw new Error("To get a node path the parent needs to exist");
            const o2 = n2[i2], a2 = p.getOrCreateCachedPaths(r3, t3);
            let l2 = a2.get(o2);
            return l2 || (l2 = new NodePath(e3, r3), o2 && a2.set(o2, l2)), b.setup.call(l2, t3, n2, s2, i2), l2;
          }
          getScope(e3) {
            return this.isScope() ? new o.default(this) : e3;
          }
          setData(e3, t3) {
            return null == this.data && (this.data = /* @__PURE__ */ Object.create(null)), this.data[e3] = t3;
          }
          getData(e3, t3) {
            null == this.data && (this.data = /* @__PURE__ */ Object.create(null));
            let r3 = this.data[e3];
            return void 0 === r3 && void 0 !== t3 && (r3 = this.data[e3] = t3), r3;
          }
          hasNode() {
            return null != this.node;
          }
          buildCodeFrameError(e3, t3 = SyntaxError) {
            return this.hub.buildError(this.node, e3, t3);
          }
          traverse(e3, t3) {
            (0, i.default)(this.node, e3, this.scope, t3, this);
          }
          set(e3, t3) {
            P(this.node, e3, t3), this.node[e3] = t3;
          }
          getPathLocation() {
            const e3 = [];
            let t3 = this;
            do {
              let r3 = t3.key;
              t3.inList && (r3 = `${t3.listKey}[${r3}]`), e3.unshift(r3);
            } while (t3 = t3.parentPath);
            return e3.join(".");
          }
          debug(e3) {
            _.enabled && _(`${this.getPathLocation()} ${this.type}: ${e3}`);
          }
          toString() {
            return (0, c.default)(this.node).code;
          }
          get inList() {
            return !!this.listKey;
          }
          set inList(e3) {
            e3 || (this.listKey = null);
          }
          get parentKey() {
            return this.listKey || this.key;
          }
        }), C = { findParent: u.findParent, find: u.find, getFunctionParent: u.getFunctionParent, getStatementParent: u.getStatementParent, getEarliestCommonAncestorFrom: u.getEarliestCommonAncestorFrom, getDeepestCommonAncestorFrom: u.getDeepestCommonAncestorFrom, getAncestry: u.getAncestry, isAncestor: u.isAncestor, isDescendant: u.isDescendant, inType: u.inType, getTypeAnnotation: d.getTypeAnnotation, isBaseType: d.isBaseType, couldBeBaseType: d.couldBeBaseType, baseTypeStrictlyMatches: d.baseTypeStrictlyMatches, isGenericType: d.isGenericType, replaceWithMultiple: h.replaceWithMultiple, replaceWithSourceString: h.replaceWithSourceString, replaceWith: h.replaceWith, replaceExpressionWithStatements: h.replaceExpressionWithStatements, replaceInline: h.replaceInline, evaluateTruthy: m.evaluateTruthy, evaluate: m.evaluate, toComputedKey: f.toComputedKey, ensureBlock: f.ensureBlock, unwrapFunctionEnvironment: f.unwrapFunctionEnvironment, arrowFunctionToExpression: f.arrowFunctionToExpression, splitExportDeclaration: f.splitExportDeclaration, ensureFunctionName: f.ensureFunctionName, matchesPattern: y.matchesPattern, isStatic: y.isStatic, isNodeType: y.isNodeType, canHaveVariableDeclarationOrExpression: y.canHaveVariableDeclarationOrExpression, canSwapBetweenExpressionAndStatement: y.canSwapBetweenExpressionAndStatement, isCompletionRecord: y.isCompletionRecord, isStatementOrBlock: y.isStatementOrBlock, referencesImport: y.referencesImport, getSource: y.getSource, willIMaybeExecuteBefore: y.willIMaybeExecuteBefore, _guessExecutionStatusRelativeTo: y._guessExecutionStatusRelativeTo, resolve: y.resolve, isConstantExpression: y.isConstantExpression, isInStrictMode: y.isInStrictMode, isDenylisted: g.isDenylisted, visit: g.visit, skip: g.skip, skipKey: g.skipKey, stop: g.stop, setContext: g.setContext, requeue: g.requeue, requeueComputedKeyAndDecorators: g.requeueComputedKeyAndDecorators, remove: x.remove, insertBefore: v.insertBefore, insertAfter: v.insertAfter, unshiftContainer: v.unshiftContainer, pushContainer: v.pushContainer, getOpposite: E.getOpposite, getCompletionRecords: E.getCompletionRecords, getSibling: E.getSibling, getPrevSibling: E.getPrevSibling, getNextSibling: E.getNextSibling, getAllNextSiblings: E.getAllNextSiblings, getAllPrevSiblings: E.getAllPrevSiblings, get: E.get, getAssignmentIdentifiers: E.getAssignmentIdentifiers, getBindingIdentifiers: E.getBindingIdentifiers, getOuterBindingIdentifiers: E.getOuterBindingIdentifiers, getBindingIdentifierPaths: E.getBindingIdentifierPaths, getOuterBindingIdentifierPaths: E.getOuterBindingIdentifierPaths, shareCommentsWithSiblings: T.shareCommentsWithSiblings, addComment: T.addComment, addComments: T.addComments };
        Object.assign(A.prototype, C), A.prototype.arrowFunctionToShadowed = f[String("arrowFunctionToShadowed")], Object.assign(A.prototype, { has: y[String("has")], is: y[String("is")], isnt: y[String("isnt")], equals: y[String("equals")], hoist: v[String("hoist")], updateSiblingKeys: v.updateSiblingKeys, call: g.call, isBlacklisted: g[String("isBlacklisted")], setScope: g.setScope, resync: g.resync, popContext: g.popContext, pushContext: g.pushContext, setup: g.setup, setKey: g.setKey }), A.prototype._guessExecutionStatusRelativeToDifferentFunctions = y._guessExecutionStatusRelativeTo, A.prototype._guessExecutionStatusRelativeToDifferentFunctions = y._guessExecutionStatusRelativeTo, Object.assign(A.prototype, { _getTypeAnnotation: d._getTypeAnnotation, _replaceWith: h._replaceWith, _resolve: y._resolve, _call: g._call, _resyncParent: g._resyncParent, _resyncKey: g._resyncKey, _resyncList: g._resyncList, _resyncRemoved: g._resyncRemoved, _getQueueContexts: g._getQueueContexts, _removeFromScope: x._removeFromScope, _callRemovalHooks: x._callRemovalHooks, _remove: x._remove, _markRemoved: x._markRemoved, _assertUnremoved: x._assertUnremoved, _containerInsert: v._containerInsert, _containerInsertBefore: v._containerInsertBefore, _containerInsertAfter: v._containerInsertAfter, _verifyNodeList: v._verifyNodeList, _getKey: E._getKey, _getPattern: E._getPattern });
        for (const e3 of l.TYPES) {
          const t3 = `is${e3}`, r3 = l[t3];
          A.prototype[t3] = function(e4) {
            return r3(this.node, e4);
          }, A.prototype[`assert${e3}`] = function(t4) {
            if (!r3(this.node, t4)) throw new TypeError(`Expected node path of type ${e3}`);
          };
        }
        Object.assign(A.prototype, S);
        for (const e3 of Object.keys(n)) "_" !== e3[0] && (l.TYPES.includes(e3) || l.TYPES.push(e3));
      }, "./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/inference/index.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2._getTypeAnnotation = _getTypeAnnotation, t2.baseTypeStrictlyMatches = function(e3) {
          const t3 = this.getTypeAnnotation(), r3 = e3.getTypeAnnotation();
          if (!o(t3) && c(t3)) return r3.type === t3.type;
          return false;
        }, t2.couldBeBaseType = function(e3) {
          const t3 = this.getTypeAnnotation();
          if (o(t3)) return true;
          if (E(t3)) {
            for (const r3 of t3.types) if (o(r3) || _isBaseType(e3, r3, true)) return true;
            return false;
          }
          return _isBaseType(e3, t3, true);
        }, t2.getTypeAnnotation = function() {
          let e3 = this.getData("typeAnnotation");
          if (null != e3) return e3;
          e3 = _getTypeAnnotation.call(this) || i(), (v(e3) || b(e3)) && (e3 = e3.typeAnnotation);
          return this.setData("typeAnnotation", e3), e3;
        }, t2.isBaseType = function(e3, t3) {
          return _isBaseType(e3, this.getTypeAnnotation(), t3);
        }, t2.isGenericType = function(e3) {
          const t3 = this.getTypeAnnotation();
          if ("Array" === e3 && (y(t3) || a(t3) || x(t3))) return true;
          return u(t3) && d(t3.id, { name: e3 }) || g(t3) && d(t3.typeName, { name: e3 });
        };
        var n = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/inference/inferers.js"), s = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/index.js");
        const { anyTypeAnnotation: i, isAnyTypeAnnotation: o, isArrayTypeAnnotation: a, isBooleanTypeAnnotation: l, isEmptyTypeAnnotation: p, isFlowBaseAnnotation: c, isGenericTypeAnnotation: u, isIdentifier: d, isMixedTypeAnnotation: h, isNumberTypeAnnotation: m, isStringTypeAnnotation: f, isTSArrayType: y, isTSTypeAnnotation: b, isTSTypeReference: g, isTupleTypeAnnotation: x, isTypeAnnotation: v, isUnionTypeAnnotation: E, isVoidTypeAnnotation: T, stringTypeAnnotation: S, voidTypeAnnotation: P } = s;
        const _ = /* @__PURE__ */ new WeakSet();
        function _getTypeAnnotation() {
          const e3 = this.node;
          if (e3) {
            if (e3.typeAnnotation) return e3.typeAnnotation;
            if (!_.has(e3)) {
              _.add(e3);
              try {
                var t3;
                let r3 = n[e3.type];
                if (r3) return r3.call(this, e3);
                if (r3 = n[this.parentPath.type], null != (t3 = r3) && t3.validParent) return this.parentPath.getTypeAnnotation();
              } finally {
                _.delete(e3);
              }
            }
          } else if ("init" === this.key && this.parentPath.isVariableDeclarator()) {
            const e4 = this.parentPath.parentPath, t4 = e4.parentPath;
            return "left" === e4.key && t4.isForInStatement() ? S() : "left" === e4.key && t4.isForOfStatement() ? i() : P();
          }
        }
        function _isBaseType(e3, t3, r3) {
          if ("string" === e3) return f(t3);
          if ("number" === e3) return m(t3);
          if ("boolean" === e3) return l(t3);
          if ("any" === e3) return o(t3);
          if ("mixed" === e3) return h(t3);
          if ("empty" === e3) return p(t3);
          if ("void" === e3) return T(t3);
          if (r3) return false;
          throw new Error(`Unknown base type ${e3}`);
        }
      }, "./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/inference/inferer-reference.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
          if (!this.isReferenced()) return;
          const t3 = this.scope.getBinding(e3.name);
          if (t3) return t3.identifier.typeAnnotation ? t3.identifier.typeAnnotation : (function(e4, t4, r3) {
            const n2 = [], i2 = [];
            let o2 = getConstantViolationsBefore(e4, t4, i2);
            const a2 = getConditionalAnnotation(e4, t4, r3);
            if (a2) {
              const t5 = getConstantViolationsBefore(e4, a2.ifStatement);
              o2 = o2.filter((e5) => !t5.includes(e5)), n2.push(a2.typeAnnotation);
            }
            if (o2.length) {
              o2.push(...i2);
              for (const e5 of o2) n2.push(e5.getTypeAnnotation());
            }
            if (!n2.length) return;
            return (0, s.createUnionType)(n2);
          })(t3, this, e3.name);
          if ("undefined" === e3.name) return l();
          if ("NaN" === e3.name || "Infinity" === e3.name) return a();
          e3.name;
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/index.js"), s = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/inference/util.js");
        const { BOOLEAN_NUMBER_BINARY_OPERATORS: i, createTypeAnnotationBasedOnTypeof: o, numberTypeAnnotation: a, voidTypeAnnotation: l } = n;
        function getConstantViolationsBefore(e3, t3, r3) {
          const n2 = e3.constantViolations.slice();
          return n2.unshift(e3.path), n2.filter((e4) => {
            const n3 = (e4 = e4.resolve())._guessExecutionStatusRelativeTo(t3);
            return r3 && "unknown" === n3 && r3.push(e4), "before" === n3;
          });
        }
        function inferAnnotationFromBinaryExpression(e3, t3) {
          const r3 = t3.node.operator, n2 = t3.get("right").resolve(), s2 = t3.get("left").resolve();
          let l2, p, c;
          if (s2.isIdentifier({ name: e3 }) ? l2 = n2 : n2.isIdentifier({ name: e3 }) && (l2 = s2), l2) return "===" === r3 ? l2.getTypeAnnotation() : i.includes(r3) ? a() : void 0;
          if ("===" !== r3 && "==" !== r3) return;
          if (s2.isUnaryExpression({ operator: "typeof" }) ? (p = s2, c = n2) : n2.isUnaryExpression({ operator: "typeof" }) && (p = n2, c = s2), !p) return;
          if (!p.get("argument").isIdentifier({ name: e3 })) return;
          if (c = c.resolve(), !c.isLiteral()) return;
          const u = c.node.value;
          return "string" == typeof u ? o(u) : void 0;
        }
        function getConditionalAnnotation(e3, t3, r3) {
          const n2 = (function(e4, t4, r4) {
            let n3;
            for (; n3 = t4.parentPath; ) {
              if (n3.isIfStatement() || n3.isConditionalExpression()) {
                if ("test" === t4.key) return;
                return n3;
              }
              if (n3.isFunction() && n3.parentPath.scope.getBinding(r4) !== e4) return;
              t4 = n3;
            }
          })(e3, t3, r3);
          if (!n2) return;
          const i2 = [n2.get("test")], o2 = [];
          for (let e4 = 0; e4 < i2.length; e4++) {
            const t4 = i2[e4];
            if (t4.isLogicalExpression()) "&&" === t4.node.operator && (i2.push(t4.get("left")), i2.push(t4.get("right")));
            else if (t4.isBinaryExpression()) {
              const e5 = inferAnnotationFromBinaryExpression(r3, t4);
              e5 && o2.push(e5);
            }
          }
          return o2.length ? { typeAnnotation: (0, s.createUnionType)(o2), ifStatement: n2 } : getConditionalAnnotation(e3, n2, r3);
        }
      }, "./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/inference/inferers.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.ArrayExpression = ArrayExpression, t2.AssignmentExpression = function() {
          return this.get("right").getTypeAnnotation();
        }, t2.BinaryExpression = function(e3) {
          const t3 = e3.operator;
          if (l.includes(t3)) return g();
          if (o.includes(t3)) return h();
          if ("+" === t3) {
            const e4 = this.get("right"), t4 = this.get("left");
            return t4.isBaseType("number") && e4.isBaseType("number") ? g() : t4.isBaseType("string") || e4.isBaseType("string") ? x() : E([x(), g()]);
          }
        }, t2.BooleanLiteral = function() {
          return h();
        }, t2.CallExpression = function() {
          const { callee: e3 } = this.node;
          if (_(e3)) return d(x());
          if (P(e3) || A(e3) || S(e3, { name: "Array" })) return d(u());
          if (C(e3)) return d(v([x(), u()]));
          return resolveCall(this.get("callee"));
        }, t2.ConditionalExpression = function() {
          const e3 = [this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()];
          return (0, i.createUnionType)(e3);
        }, t2.ClassDeclaration = t2.ClassExpression = t2.FunctionDeclaration = t2.ArrowFunctionExpression = t2.FunctionExpression = function() {
          return f(y("Function"));
        }, Object.defineProperty(t2, "Identifier", { enumerable: true, get: function() {
          return s.default;
        } }), t2.LogicalExpression = function() {
          const e3 = [this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()];
          return (0, i.createUnionType)(e3);
        }, t2.NewExpression = function(e3) {
          if ("Identifier" === e3.callee.type) return f(e3.callee);
        }, t2.NullLiteral = function() {
          return b();
        }, t2.NumericLiteral = function() {
          return g();
        }, t2.ObjectExpression = function() {
          return f(y("Object"));
        }, t2.ParenthesizedExpression = function() {
          return this.get("expression").getTypeAnnotation();
        }, t2.RegExpLiteral = function() {
          return f(y("RegExp"));
        }, t2.RestElement = RestElement, t2.SequenceExpression = function() {
          return this.get("expressions").pop().getTypeAnnotation();
        }, t2.StringLiteral = function() {
          return x();
        }, t2.TSAsExpression = TSAsExpression, t2.TSNonNullExpression = function() {
          return this.get("expression").getTypeAnnotation();
        }, t2.TaggedTemplateExpression = function() {
          return resolveCall(this.get("tag"));
        }, t2.TemplateLiteral = function() {
          return x();
        }, t2.TypeCastExpression = TypeCastExpression, t2.UnaryExpression = function(e3) {
          const t3 = e3.operator;
          if ("void" === t3) return T();
          if (p.includes(t3)) return g();
          if (c.includes(t3)) return x();
          if (a.includes(t3)) return h();
        }, t2.UpdateExpression = function(e3) {
          const t3 = e3.operator;
          if ("++" === t3 || "--" === t3) return g();
        }, t2.VariableDeclarator = function() {
          if (!this.get("id").isIdentifier()) return;
          return this.get("init").getTypeAnnotation();
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/index.js"), s = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/inference/inferer-reference.js"), i = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/inference/util.js");
        const { BOOLEAN_BINARY_OPERATORS: o, BOOLEAN_UNARY_OPERATORS: a, NUMBER_BINARY_OPERATORS: l, NUMBER_UNARY_OPERATORS: p, STRING_UNARY_OPERATORS: c, anyTypeAnnotation: u, arrayTypeAnnotation: d, booleanTypeAnnotation: h, buildMatchMemberExpression: m, genericTypeAnnotation: f, identifier: y, nullLiteralTypeAnnotation: b, numberTypeAnnotation: g, stringTypeAnnotation: x, tupleTypeAnnotation: v, unionTypeAnnotation: E, voidTypeAnnotation: T, isIdentifier: S } = n;
        function TypeCastExpression(e3) {
          return e3.typeAnnotation;
        }
        function TSAsExpression(e3) {
          return e3.typeAnnotation;
        }
        function ArrayExpression() {
          return f(y("Array"));
        }
        function RestElement() {
          return ArrayExpression();
        }
        TypeCastExpression.validParent = true, TSAsExpression.validParent = true, RestElement.validParent = true;
        const P = m("Array.from"), _ = m("Object.keys"), A = m("Object.values"), C = m("Object.entries");
        function resolveCall(e3) {
          if ((e3 = e3.resolve()).isFunction()) {
            const { node: t3 } = e3;
            if (t3.async) return t3.generator ? f(y("AsyncIterator")) : f(y("Promise"));
            if (t3.generator) return f(y("Iterator"));
            if (e3.node.returnType) return e3.node.returnType;
          }
        }
      }, "./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/inference/util.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.createUnionType = function(e3) {
          if (e3.every((e4) => a(e4))) return s ? s(e3) : o(e3);
          if (e3.every((e4) => l(e4)) && i) return i(e3);
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/index.js");
        const { createFlowUnionType: s, createTSUnionType: i, createUnionTypeAnnotation: o, isFlowType: a, isTSType: l } = n;
      }, "./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/introspection.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2._guessExecutionStatusRelativeTo = function(e3) {
          return _guessExecutionStatusRelativeToCached(this, e3, /* @__PURE__ */ new Map());
        }, t2._resolve = _resolve, t2.canHaveVariableDeclarationOrExpression = function() {
          return ("init" === this.key || "left" === this.key) && this.parentPath.isFor();
        }, t2.canSwapBetweenExpressionAndStatement = function(e3) {
          if ("body" !== this.key || !this.parentPath.isArrowFunctionExpression()) return false;
          if (this.isExpression()) return o(e3);
          if (this.isBlockStatement()) return a(e3);
          return false;
        }, t2.getSource = function() {
          const e3 = this.node;
          if (e3.end) {
            const t3 = this.hub.getCode();
            if (t3) return t3.slice(e3.start, e3.end);
          }
          return "";
        }, t2.isCompletionRecord = function(e3) {
          let t3 = this, r3 = true;
          do {
            const { type: n2, container: s2 } = t3;
            if (!r3 && (t3.isFunction() || "StaticBlock" === n2)) return !!e3;
            if (r3 = false, Array.isArray(s2) && t3.key !== s2.length - 1) return false;
          } while ((t3 = t3.parentPath) && !t3.isProgram() && !t3.isDoExpression());
          return true;
        }, t2.isConstantExpression = function() {
          if (this.isIdentifier()) {
            const e3 = this.scope.getBinding(this.node.name);
            return !!e3 && e3.constant;
          }
          if (this.isLiteral()) return !this.isRegExpLiteral() && (!this.isTemplateLiteral() || this.get("expressions").every((e3) => e3.isConstantExpression()));
          if (this.isUnaryExpression()) return "void" === this.node.operator && this.get("argument").isConstantExpression();
          if (this.isBinaryExpression()) {
            const { operator: e3 } = this.node;
            return "in" !== e3 && "instanceof" !== e3 && this.get("left").isConstantExpression() && this.get("right").isConstantExpression();
          }
          if (this.isMemberExpression()) return !this.node.computed && this.get("object").isIdentifier({ name: "Symbol" }) && !this.scope.hasBinding("Symbol", { noGlobals: true });
          if (this.isCallExpression()) return 1 === this.node.arguments.length && this.get("callee").matchesPattern("Symbol.for") && !this.scope.hasBinding("Symbol", { noGlobals: true }) && this.get("arguments")[0].isStringLiteral();
          return false;
        }, t2.isInStrictMode = function() {
          const e3 = this.isProgram() ? this : this.parentPath;
          return !!e3.find((e4) => {
            if (e4.isProgram({ sourceType: "module" })) return true;
            if (e4.isClass()) return true;
            if (e4.isArrowFunctionExpression() && !e4.get("body").isBlockStatement()) return false;
            let t3;
            if (e4.isFunction()) t3 = e4.node.body;
            else {
              if (!e4.isProgram()) return false;
              t3 = e4.node;
            }
            for (const e5 of t3.directives) if ("use strict" === e5.value.value) return true;
          });
        }, t2.isNodeType = function(e3) {
          return u(this.type, e3);
        }, t2.isStatementOrBlock = function() {
          return !this.parentPath.isLabeledStatement() && !o(this.container) && s.includes(this.key);
        }, t2.isStatic = function() {
          return this.scope.isStatic(this.node);
        }, t2.matchesPattern = function(e3, t3) {
          return d(this.node, e3, t3);
        }, t2.referencesImport = function(e3, t3) {
          if (!this.isReferencedIdentifier()) {
            if (this.isJSXMemberExpression() && this.node.property.name === t3 || (this.isMemberExpression() || this.isOptionalMemberExpression()) && (this.node.computed ? c(this.node.property, { value: t3 }) : this.node.property.name === t3)) {
              const t4 = this.get("object");
              return t4.isReferencedIdentifier() && t4.referencesImport(e3, "*");
            }
            return false;
          }
          const r3 = this.scope.getBinding(this.node.name);
          if (!r3 || "module" !== r3.kind) return false;
          const n2 = r3.path, s2 = n2.parentPath;
          if (!s2.isImportDeclaration()) return false;
          if (s2.node.source.value !== e3) return false;
          if (!t3) return true;
          if (n2.isImportDefaultSpecifier() && "default" === t3) return true;
          if (n2.isImportNamespaceSpecifier() && "*" === t3) return true;
          if (n2.isImportSpecifier() && l(n2.node.imported, { name: t3 })) return true;
          return false;
        }, t2.resolve = function(e3, t3) {
          return _resolve.call(this, e3, t3) || this;
        }, t2.willIMaybeExecuteBefore = function(e3) {
          return "after" !== this._guessExecutionStatusRelativeTo(e3);
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/index.js");
        const { STATEMENT_OR_BLOCK_KEYS: s, VISITOR_KEYS: i, isBlockStatement: o, isExpression: a, isIdentifier: l, isLiteral: p, isStringLiteral: c, isType: u, matchesPattern: d } = n;
        function getOuterFunction(e3) {
          return e3.isProgram() ? e3 : (e3.parentPath.scope.getFunctionParent() || e3.parentPath.scope.getProgramParent()).path;
        }
        function isExecutionUncertain(e3, t3) {
          switch (e3) {
            case "LogicalExpression":
            case "AssignmentPattern":
              return "right" === t3;
            case "ConditionalExpression":
            case "IfStatement":
              return "consequent" === t3 || "alternate" === t3;
            case "WhileStatement":
            case "DoWhileStatement":
            case "ForInStatement":
            case "ForOfStatement":
              return "body" === t3;
            case "ForStatement":
              return "body" === t3 || "update" === t3;
            case "SwitchStatement":
              return "cases" === t3;
            case "TryStatement":
              return "handler" === t3;
            case "OptionalMemberExpression":
              return "property" === t3;
            case "OptionalCallExpression":
              return "arguments" === t3;
            default:
              return false;
          }
        }
        function isExecutionUncertainInList(e3, t3) {
          for (let r3 = 0; r3 < t3; r3++) {
            const t4 = e3[r3];
            if (isExecutionUncertain(t4.parent.type, t4.parentKey)) return true;
          }
          return false;
        }
        t2.has = function(e3) {
          var t3;
          const r3 = null == (t3 = this.node) ? void 0 : t3[e3];
          return r3 && Array.isArray(r3) ? !!r3.length : !!r3;
        }, t2.is = t2.has, t2.isnt = function(e3) {
          return !this.has(e3);
        }, t2.equals = function(e3, t3) {
          return this.node[e3] === t3;
        };
        const h = /* @__PURE__ */ Symbol();
        function _guessExecutionStatusRelativeToCached(e3, t3, r3) {
          const n2 = { this: getOuterFunction(e3), target: getOuterFunction(t3) };
          if (n2.target.node !== n2.this.node) return (function(e4, t4, r4) {
            let n3, s3 = r4.get(e4.node);
            if (s3) {
              if (n3 = s3.get(t4.node)) return n3 === h ? "unknown" : n3;
            } else r4.set(e4.node, s3 = /* @__PURE__ */ new Map());
            s3.set(t4.node, h);
            const i2 = (function(e5, t5, r5) {
              if (!t5.isFunctionDeclaration()) return "before" === _guessExecutionStatusRelativeToCached(e5, t5, r5) ? "before" : "unknown";
              if (t5.parentPath.isExportDeclaration()) return "unknown";
              const n4 = t5.scope.getBinding(t5.node.id.name);
              if (!n4.references) return "before";
              const s4 = n4.referencePaths;
              let i3;
              for (const n5 of s4) {
                if (!!n5.find((e6) => e6.node === t5.node)) continue;
                if ("callee" !== n5.key || !n5.parentPath.isCallExpression()) return "unknown";
                const s5 = _guessExecutionStatusRelativeToCached(e5, n5, r5);
                if (i3 && i3 !== s5) return "unknown";
                i3 = s5;
              }
              return i3;
            })(e4, t4, r4);
            return s3.set(t4.node, i2), i2;
          })(e3, n2.target, r3);
          const s2 = { target: t3.getAncestry(), this: e3.getAncestry() };
          if (s2.target.includes(e3)) return "after";
          if (s2.this.includes(t3)) return "before";
          let o2;
          const a2 = { target: 0, this: 0 };
          for (; !o2 && a2.this < s2.this.length; ) {
            const e4 = s2.this[a2.this];
            a2.target = s2.target.indexOf(e4), a2.target >= 0 ? o2 = e4 : a2.this++;
          }
          if (!o2) throw new Error("Internal Babel error - The two compared nodes don't appear to belong to the same program.");
          if (isExecutionUncertainInList(s2.this, a2.this - 1) || isExecutionUncertainInList(s2.target, a2.target - 1)) return "unknown";
          const l2 = { this: s2.this[a2.this - 1], target: s2.target[a2.target - 1] };
          if (l2.target.listKey && l2.this.listKey && l2.target.container === l2.this.container) return l2.target.key > l2.this.key ? "before" : "after";
          const p2 = i[o2.type], c2 = p2.indexOf(l2.this.parentKey);
          return p2.indexOf(l2.target.parentKey) > c2 ? "before" : "after";
        }
        function _resolve(e3, t3) {
          var r3;
          if (null == (r3 = t3) || !r3.includes(this)) if ((t3 = t3 || []).push(this), this.isVariableDeclarator()) {
            if (this.get("id").isIdentifier()) return this.get("init").resolve(e3, t3);
          } else if (this.isReferencedIdentifier()) {
            const r4 = this.scope.getBinding(this.node.name);
            if (!r4) return;
            if (!r4.constant) return;
            if ("module" === r4.kind) return;
            if (r4.path !== this) {
              const n2 = r4.path.resolve(e3, t3);
              if (this.find((e4) => e4.node === n2.node)) return;
              return n2;
            }
          } else {
            if (this.isTypeCastExpression()) return this.get("expression").resolve(e3, t3);
            if (e3 && this.isMemberExpression()) {
              const r4 = this.toComputedKey();
              if (!p(r4)) return;
              const n2 = r4.value, s2 = this.get("object").resolve(e3, t3);
              if (s2.isObjectExpression()) {
                const r5 = s2.get("properties");
                for (const s3 of r5) {
                  if (!s3.isProperty()) continue;
                  const r6 = s3.get("key");
                  let i2 = s3.isnt("computed") && r6.isIdentifier({ name: n2 });
                  if (i2 = i2 || r6.isLiteral({ value: n2 }), i2) return s3.get("value").resolve(e3, t3);
                }
              } else if (s2.isArrayExpression() && !isNaN(+n2)) {
                const r5 = s2.get("elements")[n2];
                if (r5) return r5.resolve(e3, t3);
              }
            }
          }
        }
      }, "./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/lib/hoister.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/index.js"), s = n;
        const { react: i } = n, { cloneNode: o, jsxExpressionContainer: a, variableDeclaration: l, variableDeclarator: p } = s, c = { ReferencedIdentifier(e3, t3) {
          if (e3.isJSXIdentifier() && i.isCompatTag(e3.node.name) && !e3.parentPath.isJSXMemberExpression()) return;
          if ("this" === e3.node.name) {
            let r4 = e3.scope;
            do {
              if (r4.path.isFunction() && !r4.path.isArrowFunctionExpression()) break;
            } while (r4 = r4.parent);
            r4 && t3.breakOnScopePaths.push(r4.path);
          }
          const r3 = e3.scope.getBinding(e3.node.name);
          if (r3) {
            for (const n2 of r3.constantViolations) if (n2.scope !== r3.path.scope) return t3.mutableBinding = true, void e3.stop();
            r3 === t3.scope.getBinding(e3.node.name) && (t3.bindings[e3.node.name] = r3);
          }
        } };
        t2.default = class {
          constructor(e3, t3) {
            this.breakOnScopePaths = void 0, this.bindings = void 0, this.mutableBinding = void 0, this.scopes = void 0, this.scope = void 0, this.path = void 0, this.attachAfter = void 0, this.breakOnScopePaths = [], this.bindings = {}, this.mutableBinding = false, this.scopes = [], this.scope = t3, this.path = e3, this.attachAfter = false;
          }
          isCompatibleScope(e3) {
            for (const t3 of Object.keys(this.bindings)) {
              const r3 = this.bindings[t3];
              if (!e3.bindingIdentifierEquals(t3, r3.identifier)) return false;
            }
            return true;
          }
          getCompatibleScopes() {
            let e3 = this.path.scope;
            do {
              if (!this.isCompatibleScope(e3)) break;
              if (this.scopes.push(e3), this.breakOnScopePaths.includes(e3.path)) break;
            } while (e3 = e3.parent);
          }
          getAttachmentPath() {
            let e3 = this._getAttachmentPath();
            if (!e3) return;
            let t3 = e3.scope;
            if (t3.path === e3 && (t3 = e3.scope.parent), t3.path.isProgram() || t3.path.isFunction()) for (const r3 of Object.keys(this.bindings)) {
              if (!t3.hasOwnBinding(r3)) continue;
              const n2 = this.bindings[r3];
              if ("param" === n2.kind || "params" === n2.path.parentKey) continue;
              if (this.getAttachmentParentForPath(n2.path).key >= e3.key) {
                this.attachAfter = true, e3 = n2.path;
                for (const t4 of n2.constantViolations) this.getAttachmentParentForPath(t4).key > e3.key && (e3 = t4);
              }
            }
            return e3;
          }
          _getAttachmentPath() {
            const e3 = this.scopes.pop();
            if (e3) {
              if (e3.path.isFunction()) {
                if (!this.hasOwnParamBindings(e3)) return this.getNextScopeAttachmentParent();
                {
                  if (this.scope === e3) return;
                  const t3 = e3.path.get("body").get("body");
                  for (let e4 = 0; e4 < t3.length; e4++) if (!t3[e4].node._blockHoist) return t3[e4];
                }
              } else if (e3.path.isProgram()) return this.getNextScopeAttachmentParent();
            }
          }
          getNextScopeAttachmentParent() {
            const e3 = this.scopes.pop();
            if (e3) return this.getAttachmentParentForPath(e3.path);
          }
          getAttachmentParentForPath(e3) {
            do {
              if (!e3.parentPath || Array.isArray(e3.container) && e3.isStatement()) return e3;
            } while (e3 = e3.parentPath);
          }
          hasOwnParamBindings(e3) {
            for (const t3 of Object.keys(this.bindings)) {
              if (!e3.hasOwnBinding(t3)) continue;
              const r3 = this.bindings[t3];
              if ("param" === r3.kind && r3.constant) return true;
            }
            return false;
          }
          run() {
            if (this.path.traverse(c, this), this.mutableBinding) return;
            this.getCompatibleScopes();
            const e3 = this.getAttachmentPath();
            if (!e3) return;
            if (e3.getFunctionParent() === this.path.getFunctionParent()) return;
            let t3 = e3.scope.generateUidIdentifier("ref");
            const r3 = p(t3, this.path.node), n2 = this.attachAfter ? "insertAfter" : "insertBefore", [s2] = e3[n2]([e3.isVariableDeclarator() ? r3 : l("var", [r3])]), i2 = this.path.parentPath;
            return i2.isJSXElement() && this.path.container === i2.node.children && (t3 = a(t3)), this.path.replaceWith(o(t3)), s2.isVariableDeclarator() ? s2.get("init") : s2.get("declarations.0.init");
          }
        };
      }, "./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/lib/removal-hooks.js": function(e2, t2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.hooks = void 0;
        t2.hooks = [function(e3, t3) {
          if ("test" === e3.key && (t3.isWhile() || t3.isSwitchCase()) || "declaration" === e3.key && t3.isExportDeclaration() || "body" === e3.key && t3.isLabeledStatement() || "declarations" === e3.listKey && t3.isVariableDeclaration() && 1 === t3.node.declarations.length || "expression" === e3.key && t3.isExpressionStatement()) return t3.remove(), true;
        }, function(e3, t3) {
          if (t3.isSequenceExpression() && 1 === t3.node.expressions.length) return t3.replaceWith(t3.node.expressions[0]), true;
        }, function(e3, t3) {
          if (t3.isBinary()) return "left" === e3.key ? t3.replaceWith(t3.node.right) : t3.replaceWith(t3.node.left), true;
        }, function(e3, t3) {
          if (t3.isIfStatement() && "consequent" === e3.key || "body" === e3.key && (t3.isLoop() || t3.isArrowFunctionExpression())) return e3.replaceWith({ type: "BlockStatement", body: [] }), true;
        }];
      }, "./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/lib/virtual-types-validator.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.isBindingIdentifier = function() {
          const { node: e3, parent: t3 } = this, r3 = this.parentPath.parent;
          return u(e3) && s(e3, t3, r3);
        }, t2.isBlockScoped = function() {
          return i(this.node);
        }, t2.isExpression = function() {
          return this.isIdentifier() ? this.isReferencedIdentifier() : a(this.node);
        }, t2.isFlow = function() {
          const { node: e3 } = this;
          return !!l(e3) || (d(e3) ? "type" === e3.importKind || "typeof" === e3.importKind : o(e3) ? "type" === e3.exportKind : !!h(e3) && ("type" === e3.importKind || "typeof" === e3.importKind));
        }, t2.isForAwaitStatement = function() {
          return P(this.node, { await: true });
        }, t2.isGenerated = function() {
          return !this.isUser();
        }, t2.isPure = function(e3) {
          return this.scope.isPure(this.node, e3);
        }, t2.isReferenced = function() {
          return g(this.node, this.parent);
        }, t2.isReferencedIdentifier = function(e3) {
          const { node: t3, parent: r3 } = this;
          if (!u(t3, e3) && !f(r3, e3)) {
            if (!m(t3, e3)) return false;
            if (_(t3.name)) return false;
          }
          return g(t3, r3, this.parentPath.parent);
        }, t2.isReferencedMemberExpression = function() {
          const { node: e3, parent: t3 } = this;
          return y(e3) && g(e3, t3);
        }, t2.isRestProperty = function() {
          var e3;
          return b(this.node) && (null == (e3 = this.parentPath) ? void 0 : e3.isObjectPattern());
        }, t2.isScope = function() {
          return x(this.node, this.parent);
        }, t2.isSpreadProperty = function() {
          var e3;
          return b(this.node) && (null == (e3 = this.parentPath) ? void 0 : e3.isObjectExpression());
        }, t2.isStatement = function() {
          const { node: e3, parent: t3 } = this;
          if (v(e3)) {
            if (T(e3)) {
              if (c(t3, { left: e3 })) return false;
              if (p(t3, { init: e3 })) return false;
            }
            return true;
          }
          return false;
        }, t2.isUser = function() {
          return this.node && !!this.node.loc;
        }, t2.isVar = function() {
          return E(this.node);
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/index.js");
        const { isBinding: s, isBlockScoped: i, isExportDeclaration: o, isExpression: a, isFlow: l, isForStatement: p, isForXStatement: c, isIdentifier: u, isImportDeclaration: d, isImportSpecifier: h, isJSXIdentifier: m, isJSXMemberExpression: f, isMemberExpression: y, isRestElement: b, isReferenced: g, isScope: x, isStatement: v, isVar: E, isVariableDeclaration: T, react: S, isForOfStatement: P } = n, { isCompatTag: _ } = S;
        t2.isExistentialTypeParam = function() {
          throw new Error("`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7.");
        }, t2.isNumericLiteralTypeAnnotation = function() {
          throw new Error("`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7.");
        };
      }, "./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/lib/virtual-types.js": function(e2, t2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.Var = t2.User = t2.Statement = t2.SpreadProperty = t2.Scope = t2.RestProperty = t2.ReferencedMemberExpression = t2.ReferencedIdentifier = t2.Referenced = t2.Pure = t2.NumericLiteralTypeAnnotation = t2.Generated = t2.ForAwaitStatement = t2.Flow = t2.Expression = t2.ExistentialTypeParam = t2.BlockScoped = t2.BindingIdentifier = void 0;
        t2.ReferencedIdentifier = ["Identifier", "JSXIdentifier"], t2.ReferencedMemberExpression = ["MemberExpression"], t2.BindingIdentifier = ["Identifier"], t2.Statement = ["Statement"], t2.Expression = ["Expression"], t2.Scope = ["Scopable", "Pattern"], t2.Referenced = null, t2.BlockScoped = null, t2.Var = ["VariableDeclaration"], t2.User = null, t2.Generated = null, t2.Pure = null, t2.Flow = ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"], t2.RestProperty = ["RestElement"], t2.SpreadProperty = ["RestElement"], t2.ExistentialTypeParam = ["ExistsTypeAnnotation"], t2.NumericLiteralTypeAnnotation = ["NumberLiteralTypeAnnotation"], t2.ForAwaitStatement = ["ForOfStatement"];
      }, "./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/modification.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2._containerInsert = _containerInsert, t2._containerInsertAfter = _containerInsertAfter, t2._containerInsertBefore = _containerInsertBefore, t2._verifyNodeList = _verifyNodeList, t2.insertAfter = function(e3) {
          if (o._assertUnremoved.call(this), this.isSequenceExpression()) return last(this.get("expressions")).insertAfter(e3);
          const t3 = _verifyNodeList.call(this, e3), { parentPath: r3, parent: n2 } = this;
          if (r3.isExpressionStatement() || r3.isLabeledStatement() || g(n2) || r3.isExportDefaultDeclaration() && this.isDeclaration()) return r3.insertAfter(t3.map((e4) => x(e4) ? f(e4) : e4));
          if (this.isNodeType("Expression") && !this.isJSXElement() && !r3.isJSXElement() || r3.isForStatement() && "init" === this.key) {
            const e4 = this;
            if (e4.node) {
              const n3 = e4.node;
              let { scope: s2 } = this;
              if (s2.path.isPattern()) return c(n3), e4.replaceWith(h(p([], n3), [])), e4.get("callee.body").insertAfter(t3), [e4];
              if (isHiddenInSequenceExpression(e4)) t3.unshift(n3);
              else if (b(n3) && T(n3.callee)) t3.unshift(n3), t3.push(S());
              else if ((function(e5, t4) {
                if (!y(e5) || !v(e5.left)) return false;
                const r4 = t4.getBlockParent();
                return r4.hasOwnBinding(e5.left.name) && r4.getOwnBinding(e5.left.name).constantViolations.length <= 1;
              })(n3, s2)) t3.unshift(n3), t3.push(m(n3.left));
              else if (s2.isPure(n3, true)) t3.push(n3);
              else {
                r3.isMethod({ computed: true, key: n3 }) && (s2 = s2.parent);
                const e5 = s2.generateDeclaredUidIdentifier();
                t3.unshift(f(u("=", m(e5), n3))), t3.push(f(m(e5)));
              }
            }
            return this.replaceExpressionWithStatements(t3);
          }
          if (Array.isArray(this.container)) return _containerInsertAfter.call(this, t3);
          if (this.isStatementOrBlock()) {
            const e4 = this.node, r4 = e4 && (!this.isExpressionStatement() || null != e4.expression), [n3] = this.replaceWith(d(r4 ? [e4] : []));
            return n3.pushContainer("body", t3);
          }
          throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
        }, t2.insertBefore = function(e3) {
          o._assertUnremoved.call(this);
          const t3 = _verifyNodeList.call(this, e3), { parentPath: r3, parent: n2 } = this;
          if (r3.isExpressionStatement() || r3.isLabeledStatement() || g(n2) || r3.isExportDefaultDeclaration() && this.isDeclaration()) return r3.insertBefore(t3);
          if (this.isNodeType("Expression") && !this.isJSXElement() || r3.isForStatement() && "init" === this.key) return this.node && t3.push(this.node), this.replaceExpressionWithStatements(t3);
          if (Array.isArray(this.container)) return _containerInsertBefore.call(this, t3);
          if (this.isStatementOrBlock()) {
            const e4 = this.node, r4 = e4 && (!this.isExpressionStatement() || null != e4.expression), [n3] = this.replaceWith(d(r4 ? [e4] : []));
            return n3.unshiftContainer("body", t3);
          }
          throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
        }, t2.pushContainer = function(e3, t3) {
          o._assertUnremoved.call(this);
          const r3 = _verifyNodeList.call(this, t3), n2 = this.node[e3];
          return s.default.get({ parentPath: this, parent: this.node, container: n2, listKey: e3, key: n2.length }).setContext(this.context).replaceWithMultiple(r3);
        }, t2.unshiftContainer = function(e3, t3) {
          o._assertUnremoved.call(this);
          const r3 = _verifyNodeList.call(this, t3), n2 = this.node[e3], i2 = s.default.get({ parentPath: this, parent: this.node, container: n2, listKey: e3, key: 0 }).setContext(this.context);
          return _containerInsertBefore.call(i2, r3);
        }, t2.updateSiblingKeys = updateSiblingKeys;
        var n = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/cache.js"), s = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/index.js"), i = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/context.js"), o = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/removal.js"), a = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/index.js"), l = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/lib/hoister.js");
        const { arrowFunctionExpression: p, assertExpression: c, assignmentExpression: u, blockStatement: d, callExpression: h, cloneNode: m, expressionStatement: f, isAssignmentExpression: y, isCallExpression: b, isExportNamedDeclaration: g, isExpression: x, isIdentifier: v, isSequenceExpression: E, isSuper: T, thisExpression: S } = a;
        function _containerInsert(e3, t3) {
          updateSiblingKeys.call(this, e3, t3.length);
          const r3 = [];
          this.container.splice(e3, 0, ...t3);
          for (let s3 = 0; s3 < t3.length; s3++) {
            var n2;
            const t4 = e3 + s3, o2 = this.getSibling(t4);
            r3.push(o2), null != (n2 = this.context) && n2.queue && i.pushContext.call(o2, this.context);
          }
          const s2 = i._getQueueContexts.call(this);
          for (const e4 of r3) {
            i.setScope.call(e4), e4.debug("Inserted.");
            for (const t4 of s2) t4.maybeQueue(e4, true);
          }
          return r3;
        }
        function _containerInsertBefore(e3) {
          return _containerInsert.call(this, this.key, e3);
        }
        function _containerInsertAfter(e3) {
          return _containerInsert.call(this, this.key + 1, e3);
        }
        const last = (e3) => e3[e3.length - 1];
        function isHiddenInSequenceExpression(e3) {
          return E(e3.parent) && (last(e3.parent.expressions) !== e3.node || isHiddenInSequenceExpression(e3.parentPath));
        }
        function updateSiblingKeys(e3, t3) {
          if (!this.parent) return;
          const r3 = (0, n.getCachedPaths)(this);
          if (r3) for (const [, n2] of r3) "number" == typeof n2.key && n2.container === this.container && n2.key >= e3 && (n2.key += t3);
        }
        function _verifyNodeList(e3) {
          if (!e3) return [];
          Array.isArray(e3) || (e3 = [e3]);
          for (let t3 = 0; t3 < e3.length; t3++) {
            const r3 = e3[t3];
            let n2;
            if (r3 ? "object" != typeof r3 ? n2 = "contains a non-object node" : r3.type ? r3 instanceof s.default && (n2 = "has a NodePath when it expected a raw object") : n2 = "without a type" : n2 = "has falsy node", n2) {
              const e4 = Array.isArray(r3) ? "array" : typeof r3;
              throw new Error(`Node list ${n2} with the index of ${t3} and type of ${e4}`);
            }
          }
          return e3;
        }
        t2.hoist = function(e3 = this.scope) {
          return new l.default(this, e3).run();
        };
      }, "./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/removal.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2._assertUnremoved = _assertUnremoved, t2._callRemovalHooks = _callRemovalHooks, t2._markRemoved = _markRemoved, t2._remove = _remove, t2._removeFromScope = _removeFromScope, t2.remove = function() {
          var e3;
          if (_assertUnremoved.call(this), p.resync.call(this), _callRemovalHooks.call(this)) return void _markRemoved.call(this);
          null != (e3 = this.opts) && e3.noScope || _removeFromScope.call(this);
          this.shareCommentsWithSiblings(), _remove.call(this), _markRemoved.call(this);
        };
        var n = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/lib/removal-hooks.js"), s = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/cache.js"), i = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/replacement.js"), o = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/index.js"), a = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/index.js"), l = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/modification.js"), p = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/context.js");
        const { getBindingIdentifiers: c } = a;
        function _removeFromScope() {
          const e3 = c(this.node, false, false, true);
          Object.keys(e3).forEach((e4) => this.scope.removeBinding(e4));
        }
        function _callRemovalHooks() {
          if (this.parentPath) {
            for (const e3 of n.hooks) if (e3(this, this.parentPath)) return true;
          }
        }
        function _remove() {
          Array.isArray(this.container) ? (this.container.splice(this.key, 1), l.updateSiblingKeys.call(this, this.key, -1)) : i._replaceWith.call(this, null);
        }
        function _markRemoved() {
          var e3;
          (this._traverseFlags |= o.SHOULD_SKIP | o.REMOVED, this.parent) && (null == (e3 = (0, s.getCachedPaths)(this)) || e3.delete(this.node));
          this.node = null;
        }
        function _assertUnremoved() {
          if (this.removed) throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
        }
      }, "./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/replacement.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2._replaceWith = _replaceWith, t2.replaceExpressionWithStatements = function(e3) {
          c.resync.call(this);
          const t3 = [], r3 = gatherSequenceExpressions(e3, t3);
          if (r3) {
            for (const e4 of t3) this.scope.push({ id: e4 });
            return this.replaceWith(r3)[0].get("expressions");
          }
          const n2 = this.getFunctionParent(), i2 = null == n2 ? void 0 : n2.node.async, o2 = null == n2 ? void 0 : n2.node.generator, a2 = d([], f(e3));
          this.replaceWith(b(a2, []));
          const l2 = this.get("callee");
          l2.get("body").scope.hoistVariables((e4) => this.scope.push({ id: e4 }));
          const p2 = l2.getCompletionRecords();
          for (const e4 of p2) {
            if (!e4.isExpressionStatement()) continue;
            const t4 = e4.findParent((e5) => e5.isLoop());
            if (t4) {
              let r4 = t4.getData("expressionReplacementReturnUid");
              r4 ? r4 = T(r4.name) : (r4 = l2.scope.generateDeclaredUidIdentifier("ret"), l2.get("body").pushContainer("body", F(g(r4))), t4.setData("expressionReplacementReturnUid", r4)), e4.get("expression").replaceWith(h("=", g(r4), e4.node.expression));
            } else e4.replaceWith(F(e4.node.expression));
          }
          l2.arrowFunctionToExpression();
          const y2 = l2, x2 = i2 && s.default.hasType(this.get("callee.body").node, "AwaitExpression", u), v2 = o2 && s.default.hasType(this.get("callee.body").node, "YieldExpression", u);
          x2 && (y2.set("async", true), v2 || this.replaceWith(m(this.node)));
          v2 && (y2.set("generator", true), this.replaceWith(B(this.node, true)));
          return y2.get("body.body");
        }, t2.replaceInline = function(e3) {
          if (c.resync.call(this), Array.isArray(e3)) {
            if (Array.isArray(this.container)) {
              e3 = a._verifyNodeList.call(this, e3);
              const t3 = a._containerInsertAfter.call(this, e3);
              return this.remove(), t3;
            }
            return this.replaceWithMultiple(e3);
          }
          return this.replaceWith(e3);
        }, t2.replaceWith = function(e3) {
          if (c.resync.call(this), this.removed) throw new Error("You can't replace this node, we've already removed it");
          let t3 = e3 instanceof i.default ? e3.node : e3;
          if (!t3) throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
          if (this.node === t3) return [this];
          if (this.isProgram() && !k(t3)) throw new Error("You can only replace a Program root node with another Program node");
          if (Array.isArray(t3)) throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
          if ("string" == typeof t3) throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
          let r3 = "";
          this.isNodeType("Statement") && w(t3) && (this.canHaveVariableDeclarationOrExpression() || this.canSwapBetweenExpressionAndStatement(t3) || this.parentPath.isExportDefaultDeclaration() || (t3 = v(t3), r3 = "expression"));
          if (this.isNodeType("Expression") && N(t3) && !this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(t3)) return this.replaceExpressionWithStatements([t3]);
          const n2 = this.node;
          n2 && (_(t3, n2), j(n2));
          return _replaceWith.call(this, t3), this.type = t3.type, c.setScope.call(this), this.requeue(), [r3 ? this.get(r3) : this];
        }, t2.replaceWithMultiple = function(e3) {
          var t3;
          c.resync.call(this);
          const r3 = a._verifyNodeList.call(this, e3);
          S(r3[0], this.node), P(r3[r3.length - 1], this.node), null == (t3 = (0, o.getCachedPaths)(this)) || t3.delete(this.node), this.node = this.container[this.key] = null;
          const n2 = this.insertAfter(e3);
          this.node ? this.requeue() : this.remove();
          return n2;
        }, t2.replaceWithSourceString = function(e3) {
          let t3;
          c.resync.call(this);
          try {
            e3 = `(${e3})`, t3 = (0, l.parse)(e3);
          } catch (t4) {
            const r4 = t4.loc;
            throw r4 && (t4.message += " - make sure this is an expression.\n" + (0, n.codeFrameColumns)(e3, { start: { line: r4.line, column: r4.column + 1 } }), t4.code = "BABEL_REPLACE_SOURCE_ERROR"), t4;
          }
          const r3 = t3.program.body[0].expression;
          return s.default.removeProperties(r3), this.replaceWith(r3);
        };
        var n = r2("./stubs/babel-codeframe.mjs"), s = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/index.js"), i = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/index.js"), o = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/cache.js"), a = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/modification.js"), l = r2("./node_modules/.pnpm/@babel+parser@7.28.4/node_modules/@babel/parser/lib/index.js"), p = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/index.js"), c = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/context.js");
        const { FUNCTION_TYPES: u, arrowFunctionExpression: d, assignmentExpression: h, awaitExpression: m, blockStatement: f, buildUndefinedNode: y, callExpression: b, cloneNode: g, conditionalExpression: x, expressionStatement: v, getBindingIdentifiers: E, identifier: T, inheritLeadingComments: S, inheritTrailingComments: P, inheritsComments: _, isBlockStatement: A, isEmptyStatement: C, isExpression: w, isExpressionStatement: I, isIfStatement: D, isProgram: k, isStatement: N, isVariableDeclaration: O, removeComments: j, returnStatement: F, sequenceExpression: L, validate: M, yieldExpression: B } = p;
        function _replaceWith(e3) {
          var t3;
          if (!this.container) throw new ReferenceError("Container is falsy");
          this.inList ? M(this.parent, this.key, [e3]) : M(this.parent, this.key, e3), this.debug(`Replace with ${null == e3 ? void 0 : e3.type}`), null == (t3 = (0, o.getCachedPaths)(this)) || t3.set(e3, this).delete(this.node), this.node = this.container[this.key] = e3;
        }
        function gatherSequenceExpressions(e3, t3) {
          const r3 = [];
          let n2 = true;
          for (const s2 of e3) if (C(s2) || (n2 = false), w(s2)) r3.push(s2);
          else if (I(s2)) r3.push(s2.expression);
          else if (O(s2)) {
            if ("var" !== s2.kind) return;
            for (const e4 of s2.declarations) {
              const n3 = E(e4);
              for (const e5 of Object.keys(n3)) t3.push(g(n3[e5]));
              e4.init && r3.push(h("=", e4.id, e4.init));
            }
            n2 = true;
          } else if (D(s2)) {
            const e4 = s2.consequent ? gatherSequenceExpressions([s2.consequent], t3) : y(), n3 = s2.alternate ? gatherSequenceExpressions([s2.alternate], t3) : y();
            if (!e4 || !n3) return;
            r3.push(x(s2.test, e4, n3));
          } else if (A(s2)) {
            const e4 = gatherSequenceExpressions(s2.body, t3);
            if (!e4) return;
            r3.push(e4);
          } else {
            if (!C(s2)) return;
            0 === e3.indexOf(s2) && (n2 = true);
          }
          return n2 && r3.push(y()), 1 === r3.length ? r3[0] : L(r3);
        }
      }, "./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/scope/binding.js": function(e2, t2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        t2.default = class {
          constructor({ identifier: e3, scope: t3, path: r2, kind: n }) {
            this.identifier = void 0, this.scope = void 0, this.path = void 0, this.kind = void 0, this.constantViolations = [], this.constant = true, this.referencePaths = [], this.referenced = false, this.references = 0, this.identifier = e3, this.scope = t3, this.path = r2, this.kind = n, "var" !== n && "hoisted" !== n || !(function(e4) {
              const t4 = !e4.isVariableDeclarator() || e4.node.init;
              for (let { parentPath: r3, key: n2 } = e4; r3; { parentPath: r3, key: n2 } = r3) {
                if (r3.isFunctionParent()) return false;
                if ("left" === n2 && r3.isForXStatement() || t4 && "body" === n2 && r3.isLoop()) return true;
              }
              return false;
            })(r2) || this.reassign(r2), this.clearValue();
          }
          deoptValue() {
            this.clearValue(), this.hasDeoptedValue = true;
          }
          setValue(e3) {
            this.hasDeoptedValue || (this.hasValue = true, this.value = e3);
          }
          clearValue() {
            this.hasDeoptedValue = false, this.hasValue = false, this.value = null;
          }
          reassign(e3) {
            this.constant = false, this.constantViolations.includes(e3) || this.constantViolations.push(e3);
          }
          reference(e3) {
            this.referencePaths.includes(e3) || (this.referenced = true, this.references++, this.referencePaths.push(e3));
          }
          dereference() {
            this.references--, this.referenced = !!this.references;
          }
        };
      }, "./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/scope/index.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var n = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/scope/lib/renamer.js"), s = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/index.js"), i = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/scope/binding.js"), o = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/index.js"), a = o, l = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/cache.js");
        const p = r2("./node_modules/.pnpm/@babel+helper-globals@7.28.0/node_modules/@babel/helper-globals/data/builtin-lower.json"), c = r2("./node_modules/.pnpm/@babel+helper-globals@7.28.0/node_modules/@babel/helper-globals/data/builtin-upper.json"), { assignmentExpression: u, callExpression: d, cloneNode: h, getBindingIdentifiers: m, identifier: f, isArrayExpression: y, isBinary: b, isCallExpression: g, isClass: x, isClassBody: v, isClassDeclaration: E, isExportAllDeclaration: T, isExportDefaultDeclaration: S, isExportNamedDeclaration: P, isFunctionDeclaration: _, isIdentifier: A, isImportDeclaration: C, isLiteral: w, isMemberExpression: I, isMethod: D, isModuleSpecifier: k, isNullLiteral: N, isObjectExpression: O, isProperty: j, isPureish: F, isRegExpLiteral: L, isSuper: M, isTaggedTemplateExpression: B, isTemplateLiteral: R, isThisExpression: U, isUnaryExpression: V, isVariableDeclaration: $, expressionStatement: K, matchesPattern: W, memberExpression: q, numericLiteral: H, toIdentifier: z, variableDeclaration: G, variableDeclarator: X, isRecordExpression: J, isTupleExpression: Y, isObjectProperty: Q, isTopicReference: Z, isMetaProperty: ee, isPrivateName: te, isExportDeclaration: re, buildUndefinedNode: ne, sequenceExpression: se } = o;
        function gatherNodeParts(e3, t3) {
          switch (null == e3 ? void 0 : e3.type) {
            default:
              var r3;
              if (C(e3) || re(e3)) if ((T(e3) || P(e3) || C(e3)) && e3.source) gatherNodeParts(e3.source, t3);
              else if ((P(e3) || C(e3)) && null != (r3 = e3.specifiers) && r3.length) for (const r4 of e3.specifiers) gatherNodeParts(r4, t3);
              else (S(e3) || P(e3)) && e3.declaration && gatherNodeParts(e3.declaration, t3);
              else k(e3) ? gatherNodeParts(e3.local, t3) : !w(e3) || N(e3) || L(e3) || R(e3) || t3.push(e3.value);
              break;
            case "MemberExpression":
            case "OptionalMemberExpression":
            case "JSXMemberExpression":
              gatherNodeParts(e3.object, t3), gatherNodeParts(e3.property, t3);
              break;
            case "Identifier":
            case "JSXIdentifier":
              t3.push(e3.name);
              break;
            case "CallExpression":
            case "OptionalCallExpression":
            case "NewExpression":
              gatherNodeParts(e3.callee, t3);
              break;
            case "ObjectExpression":
            case "ObjectPattern":
              for (const r4 of e3.properties) gatherNodeParts(r4, t3);
              break;
            case "SpreadElement":
            case "RestElement":
            case "UnaryExpression":
            case "UpdateExpression":
              gatherNodeParts(e3.argument, t3);
              break;
            case "ObjectProperty":
            case "ObjectMethod":
            case "ClassProperty":
            case "ClassMethod":
            case "ClassPrivateProperty":
            case "ClassPrivateMethod":
              gatherNodeParts(e3.key, t3);
              break;
            case "ThisExpression":
              t3.push("this");
              break;
            case "Super":
              t3.push("super");
              break;
            case "Import":
            case "ImportExpression":
              t3.push("import");
              break;
            case "DoExpression":
              t3.push("do");
              break;
            case "YieldExpression":
              t3.push("yield"), gatherNodeParts(e3.argument, t3);
              break;
            case "AwaitExpression":
              t3.push("await"), gatherNodeParts(e3.argument, t3);
              break;
            case "AssignmentExpression":
              gatherNodeParts(e3.left, t3);
              break;
            case "VariableDeclarator":
            case "FunctionExpression":
            case "FunctionDeclaration":
            case "ClassExpression":
            case "ClassDeclaration":
            case "PrivateName":
              gatherNodeParts(e3.id, t3);
              break;
            case "ParenthesizedExpression":
              gatherNodeParts(e3.expression, t3);
              break;
            case "MetaProperty":
              gatherNodeParts(e3.meta, t3), gatherNodeParts(e3.property, t3);
              break;
            case "JSXElement":
              gatherNodeParts(e3.openingElement, t3);
              break;
            case "JSXOpeningElement":
              gatherNodeParts(e3.name, t3);
              break;
            case "JSXFragment":
              gatherNodeParts(e3.openingFragment, t3);
              break;
            case "JSXOpeningFragment":
              t3.push("Fragment");
              break;
            case "JSXNamespacedName":
              gatherNodeParts(e3.namespace, t3), gatherNodeParts(e3.name, t3);
          }
        }
        function resetScope(e3) {
          e3.references = /* @__PURE__ */ Object.create(null), e3.uids = /* @__PURE__ */ Object.create(null), e3.bindings = /* @__PURE__ */ Object.create(null), e3.globals = /* @__PURE__ */ Object.create(null);
        }
        var ie = /* @__PURE__ */ Symbol.for("should not be considered a local binding");
        const oe = { ForStatement(e3) {
          const t3 = e3.get("init");
          if (t3.isVar()) {
            const { scope: r3 } = e3;
            (r3.getFunctionParent() || r3.getProgramParent()).registerBinding("var", t3);
          }
        }, Declaration(e3) {
          if (e3.isBlockScoped()) return;
          if (e3.isImportDeclaration()) return;
          if (e3.isExportDeclaration()) return;
          (e3.scope.getFunctionParent() || e3.scope.getProgramParent()).registerDeclaration(e3);
        }, ImportDeclaration(e3) {
          e3.scope.getBlockParent().registerDeclaration(e3);
        }, TSImportEqualsDeclaration(e3) {
          e3.scope.getBlockParent().registerDeclaration(e3);
        }, ReferencedIdentifier(e3, t3) {
          a.isTSQualifiedName(e3.parent) && e3.parent.right === e3.node || e3.parentPath.isTSImportEqualsDeclaration() || t3.references.push(e3);
        }, ForXStatement(e3, t3) {
          const r3 = e3.get("left");
          if (r3.isPattern() || r3.isIdentifier()) t3.constantViolations.push(e3);
          else if (r3.isVar()) {
            const { scope: t4 } = e3;
            (t4.getFunctionParent() || t4.getProgramParent()).registerBinding("var", r3);
          }
        }, ExportDeclaration: { exit(e3) {
          const { node: t3, scope: r3 } = e3;
          if (T(t3)) return;
          const n2 = t3.declaration;
          if (E(n2) || _(n2)) {
            const t4 = n2.id;
            if (!t4) return;
            const s2 = r3.getBinding(t4.name);
            null == s2 || s2.reference(e3);
          } else if ($(n2)) for (const t4 of n2.declarations) for (const n3 of Object.keys(m(t4))) {
            const t5 = r3.getBinding(n3);
            null == t5 || t5.reference(e3);
          }
        } }, LabeledStatement(e3) {
          e3.scope.getBlockParent().registerDeclaration(e3);
        }, AssignmentExpression(e3, t3) {
          t3.assignments.push(e3);
        }, UpdateExpression(e3, t3) {
          t3.constantViolations.push(e3);
        }, UnaryExpression(e3, t3) {
          "delete" === e3.node.operator && t3.constantViolations.push(e3);
        }, BlockScoped(e3) {
          let t3 = e3.scope;
          t3.path === e3 && (t3 = t3.parent);
          if (t3.getBlockParent().registerDeclaration(e3), e3.isClassDeclaration() && e3.node.id) {
            const t4 = e3.node.id.name;
            e3.scope.bindings[t4] = e3.scope.parent.getBinding(t4);
          }
        }, CatchClause(e3) {
          e3.scope.registerBinding("let", e3);
        }, Function(e3) {
          const t3 = e3.get("params");
          for (const r3 of t3) e3.scope.registerBinding("param", r3);
          e3.isFunctionExpression() && e3.node.id && !e3.node.id[ie] && e3.scope.registerBinding("local", e3.get("id"), e3);
        }, ClassExpression(e3) {
          e3.node.id && !e3.node.id[ie] && e3.scope.registerBinding("local", e3.get("id"), e3);
        }, TSTypeAnnotation(e3) {
          e3.skip();
        } };
        let ae, le = 0;
        class Scope {
          constructor(e3) {
            this.uid = void 0, this.path = void 0, this.block = void 0, this.inited = void 0, this.labels = void 0, this.bindings = void 0, this.referencesSet = void 0, this.globals = void 0, this.uidsSet = void 0, this.data = void 0, this.crawling = void 0;
            const { node: t3 } = e3, r3 = l.scope.get(t3);
            if ((null == r3 ? void 0 : r3.path) === e3) return r3;
            l.scope.set(t3, this), this.uid = le++, this.block = t3, this.path = e3, this.labels = /* @__PURE__ */ new Map(), this.inited = false, Object.defineProperties(this, { references: { enumerable: true, configurable: true, writable: true, value: /* @__PURE__ */ Object.create(null) }, uids: { enumerable: true, configurable: true, writable: true, value: /* @__PURE__ */ Object.create(null) } });
          }
          get parent() {
            var e3;
            let t3, r3 = this.path;
            do {
              var n2;
              const e4 = "key" === r3.key || "decorators" === r3.listKey;
              r3 = r3.parentPath, e4 && r3.isMethod() && (r3 = r3.parentPath), null != (n2 = r3) && n2.isScope() && (t3 = r3);
            } while (r3 && !t3);
            return null == (e3 = t3) ? void 0 : e3.scope;
          }
          get references() {
            throw new Error("Scope#references is not available in Babel 8. Use Scope#referencesSet instead.");
          }
          get uids() {
            throw new Error("Scope#uids is not available in Babel 8. Use Scope#uidsSet instead.");
          }
          generateDeclaredUidIdentifier(e3) {
            const t3 = this.generateUidIdentifier(e3);
            return this.push({ id: t3 }), h(t3);
          }
          generateUidIdentifier(e3) {
            return f(this.generateUid(e3));
          }
          generateUid(e3 = "temp") {
            let t3;
            e3 = z(e3).replace(/^_+/, "").replace(/\d+$/g, "");
            let r3 = 0;
            do {
              t3 = `_${e3}`, r3 >= 11 ? t3 += r3 - 1 : r3 >= 9 ? t3 += r3 - 9 : r3 >= 1 && (t3 += r3 + 1), r3++;
            } while (this.hasLabel(t3) || this.hasBinding(t3) || this.hasGlobal(t3) || this.hasReference(t3));
            const n2 = this.getProgramParent();
            return n2.references[t3] = true, n2.uids[t3] = true, t3;
          }
          generateUidBasedOnNode(e3, t3) {
            const r3 = [];
            gatherNodeParts(e3, r3);
            let n2 = r3.join("$");
            return n2 = n2.replace(/^_/, "") || t3 || "ref", this.generateUid(n2.slice(0, 20));
          }
          generateUidIdentifierBasedOnNode(e3, t3) {
            return f(this.generateUidBasedOnNode(e3, t3));
          }
          isStatic(e3) {
            if (U(e3) || M(e3) || Z(e3)) return true;
            if (A(e3)) {
              const t3 = this.getBinding(e3.name);
              return t3 ? t3.constant : this.hasBinding(e3.name);
            }
            return false;
          }
          maybeGenerateMemoised(e3, t3) {
            if (this.isStatic(e3)) return null;
            {
              const r3 = this.generateUidIdentifierBasedOnNode(e3);
              return t3 ? r3 : (this.push({ id: r3 }), h(r3));
            }
          }
          checkBlockScopedCollisions(e3, t3, r3, n2) {
            if ("param" === t3) return;
            if ("local" === e3.kind) return;
            if ("let" === t3 || "let" === e3.kind || "const" === e3.kind || "module" === e3.kind || "param" === e3.kind && "const" === t3) throw this.path.hub.buildError(n2, `Duplicate declaration "${r3}"`, TypeError);
          }
          rename(e3, t3) {
            const r3 = this.getBinding(e3);
            if (r3) {
              t3 || (t3 = this.generateUidIdentifier(e3).name);
              new n.default(r3, e3, t3).rename(arguments[2]);
            }
          }
          dump() {
            const e3 = "-".repeat(60);
            console.log(e3);
            let t3 = this;
            do {
              console.log("#", t3.block.type);
              for (const e4 of Object.keys(t3.bindings)) {
                const r3 = t3.bindings[e4];
                console.log(" -", e4, { constant: r3.constant, references: r3.references, violations: r3.constantViolations.length, kind: r3.kind });
              }
            } while (t3 = t3.parent);
            console.log(e3);
          }
          hasLabel(e3) {
            return !!this.getLabel(e3);
          }
          getLabel(e3) {
            return this.labels.get(e3);
          }
          registerLabel(e3) {
            this.labels.set(e3.node.label.name, e3);
          }
          registerDeclaration(e3) {
            if (e3.isLabeledStatement()) this.registerLabel(e3);
            else if (e3.isFunctionDeclaration()) this.registerBinding("hoisted", e3.get("id"), e3);
            else if (e3.isVariableDeclaration()) {
              const t3 = e3.get("declarations"), { kind: r3 } = e3.node;
              for (const e4 of t3) this.registerBinding("using" === r3 || "await using" === r3 ? "const" : r3, e4);
            } else if (e3.isClassDeclaration()) {
              if (e3.node.declare) return;
              this.registerBinding("let", e3);
            } else if (e3.isImportDeclaration()) {
              const t3 = "type" === e3.node.importKind || "typeof" === e3.node.importKind, r3 = e3.get("specifiers");
              for (const e4 of r3) {
                const r4 = t3 || e4.isImportSpecifier() && ("type" === e4.node.importKind || "typeof" === e4.node.importKind);
                this.registerBinding(r4 ? "unknown" : "module", e4);
              }
            } else if (e3.isExportDeclaration()) {
              const t3 = e3.get("declaration");
              (t3.isClassDeclaration() || t3.isFunctionDeclaration() || t3.isVariableDeclaration()) && this.registerDeclaration(t3);
            } else this.registerBinding("unknown", e3);
          }
          buildUndefinedNode() {
            return ne();
          }
          registerConstantViolation(e3) {
            const t3 = e3.getAssignmentIdentifiers();
            for (const n2 of Object.keys(t3)) {
              var r3;
              null == (r3 = this.getBinding(n2)) || r3.reassign(e3);
            }
          }
          registerBinding(e3, t3, r3 = t3) {
            if (!e3) throw new ReferenceError("no `kind`");
            if (t3.isVariableDeclaration()) {
              const r4 = t3.get("declarations");
              for (const t4 of r4) this.registerBinding(e3, t4);
              return;
            }
            const n2 = this.getProgramParent(), s2 = t3.getOuterBindingIdentifiers(true);
            for (const t4 of Object.keys(s2)) {
              n2.references[t4] = true;
              for (const n3 of s2[t4]) {
                const s3 = this.getOwnBinding(t4);
                if (s3) {
                  if (s3.identifier === n3) continue;
                  this.checkBlockScopedCollisions(s3, e3, t4, n3);
                }
                s3 ? s3.reassign(r3) : this.bindings[t4] = new i.default({ identifier: n3, scope: this, path: r3, kind: e3 });
              }
            }
          }
          addGlobal(e3) {
            this.globals[e3.name] = e3;
          }
          hasUid(e3) {
            {
              let t3 = this;
              do {
                if (t3.uids[e3]) return true;
              } while (t3 = t3.parent);
              return false;
            }
          }
          hasGlobal(e3) {
            let t3 = this;
            do {
              if (t3.globals[e3]) return true;
            } while (t3 = t3.parent);
            return false;
          }
          hasReference(e3) {
            return !!this.getProgramParent().references[e3];
          }
          isPure(e3, t3) {
            if (A(e3)) {
              const r4 = this.getBinding(e3.name);
              return !!r4 && (!t3 || r4.constant);
            }
            if (U(e3) || ee(e3) || Z(e3) || te(e3)) return true;
            var r3, n2, s2;
            if (x(e3)) return !(e3.superClass && !this.isPure(e3.superClass, t3)) && (!((null == (r3 = e3.decorators) ? void 0 : r3.length) > 0) && this.isPure(e3.body, t3));
            if (v(e3)) {
              for (const r4 of e3.body) if (!this.isPure(r4, t3)) return false;
              return true;
            }
            if (b(e3)) return this.isPure(e3.left, t3) && this.isPure(e3.right, t3);
            if (y(e3) || Y(e3)) {
              for (const r4 of e3.elements) if (null !== r4 && !this.isPure(r4, t3)) return false;
              return true;
            }
            if (O(e3) || J(e3)) {
              for (const r4 of e3.properties) if (!this.isPure(r4, t3)) return false;
              return true;
            }
            if (D(e3)) return !(e3.computed && !this.isPure(e3.key, t3)) && !((null == (n2 = e3.decorators) ? void 0 : n2.length) > 0);
            if (j(e3)) return !(e3.computed && !this.isPure(e3.key, t3)) && (!((null == (s2 = e3.decorators) ? void 0 : s2.length) > 0) && !((Q(e3) || e3.static) && null !== e3.value && !this.isPure(e3.value, t3)));
            if (V(e3)) return this.isPure(e3.argument, t3);
            if (R(e3)) {
              for (const r4 of e3.expressions) if (!this.isPure(r4, t3)) return false;
              return true;
            }
            return B(e3) ? W(e3.tag, "String.raw") && !this.hasBinding("String", { noGlobals: true }) && this.isPure(e3.quasi, t3) : I(e3) ? !e3.computed && A(e3.object) && "Symbol" === e3.object.name && A(e3.property) && "for" !== e3.property.name && !this.hasBinding("Symbol", { noGlobals: true }) : g(e3) ? W(e3.callee, "Symbol.for") && !this.hasBinding("Symbol", { noGlobals: true }) && 1 === e3.arguments.length && a.isStringLiteral(e3.arguments[0]) : F(e3);
          }
          setData(e3, t3) {
            return this.data[e3] = t3;
          }
          getData(e3) {
            let t3 = this;
            do {
              const r3 = t3.data[e3];
              if (null != r3) return r3;
            } while (t3 = t3.parent);
          }
          removeData(e3) {
            let t3 = this;
            do {
              null != t3.data[e3] && (t3.data[e3] = null);
            } while (t3 = t3.parent);
          }
          init() {
            this.inited || (this.inited = true, this.crawl());
          }
          crawl() {
            const e3 = this.path;
            resetScope(this), this.data = /* @__PURE__ */ Object.create(null);
            let t3 = this;
            do {
              if (t3.crawling) return;
              if (t3.path.isProgram()) break;
            } while (t3 = t3.parent);
            const r3 = t3, n2 = { references: [], constantViolations: [], assignments: [] };
            if (this.crawling = true, ae || (ae = s.default.visitors.merge([{ Scope(e4) {
              resetScope(e4.scope);
            } }, oe])), "Program" !== e3.type) {
              for (const t5 of ae.enter) t5.call(n2, e3, n2);
              const t4 = ae[e3.type];
              if (t4) for (const r4 of t4.enter) r4.call(n2, e3, n2);
            }
            e3.traverse(ae, n2), this.crawling = false;
            for (const e4 of n2.assignments) {
              const t4 = e4.getAssignmentIdentifiers();
              for (const n3 of Object.keys(t4)) e4.scope.getBinding(n3) || r3.addGlobal(t4[n3]);
              e4.scope.registerConstantViolation(e4);
            }
            for (const e4 of n2.references) {
              const t4 = e4.scope.getBinding(e4.node.name);
              t4 ? t4.reference(e4) : r3.addGlobal(e4.node);
            }
            for (const e4 of n2.constantViolations) e4.scope.registerConstantViolation(e4);
          }
          push(e3) {
            let t3 = this.path;
            t3.isPattern() ? t3 = this.getPatternParent().path : t3.isBlockStatement() || t3.isProgram() || (t3 = this.getBlockParent().path), t3.isSwitchStatement() && (t3 = (this.getFunctionParent() || this.getProgramParent()).path);
            const { init: r3, unique: n2, kind: s2 = "var", id: i2 } = e3;
            if (!r3 && !n2 && ("var" === s2 || "let" === s2) && t3.isFunction() && !t3.node.name && g(t3.parent, { callee: t3.node }) && t3.parent.arguments.length <= t3.node.params.length && A(i2)) return t3.pushContainer("params", i2), void t3.scope.registerBinding("param", t3.get("params")[t3.node.params.length - 1]);
            (t3.isLoop() || t3.isCatchClause() || t3.isFunction()) && (t3.ensureBlock(), t3 = t3.get("body"));
            const o2 = null == e3._blockHoist ? 2 : e3._blockHoist, a2 = `declaration:${s2}:${o2}`;
            let l2 = !n2 && t3.getData(a2);
            if (!l2) {
              const e4 = G(s2, []);
              e4._blockHoist = o2, [l2] = t3.unshiftContainer("body", [e4]), n2 || t3.setData(a2, l2);
            }
            const p2 = X(i2, r3), c2 = l2.node.declarations.push(p2);
            t3.scope.registerBinding(s2, l2.get("declarations")[c2 - 1]);
          }
          getProgramParent() {
            let e3 = this;
            do {
              if (e3.path.isProgram()) return e3;
            } while (e3 = e3.parent);
            throw new Error("Couldn't find a Program");
          }
          getFunctionParent() {
            let e3 = this;
            do {
              if (e3.path.isFunctionParent()) return e3;
            } while (e3 = e3.parent);
            return null;
          }
          getBlockParent() {
            let e3 = this;
            do {
              if (e3.path.isBlockParent()) return e3;
            } while (e3 = e3.parent);
            throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
          }
          getPatternParent() {
            let e3 = this;
            do {
              if (!e3.path.isPattern()) return e3.getBlockParent();
            } while (e3 = e3.parent.parent);
            throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
          }
          getAllBindings() {
            const e3 = /* @__PURE__ */ Object.create(null);
            let t3 = this;
            do {
              for (const r3 of Object.keys(t3.bindings)) r3 in e3 == false && (e3[r3] = t3.bindings[r3]);
              t3 = t3.parent;
            } while (t3);
            return e3;
          }
          bindingIdentifierEquals(e3, t3) {
            return this.getBindingIdentifier(e3) === t3;
          }
          getBinding(e3) {
            let t3, r3 = this;
            do {
              const s2 = r3.getOwnBinding(e3);
              var n2;
              if (s2) {
                if (null == (n2 = t3) || !n2.isPattern() || "param" === s2.kind || "local" === s2.kind) return s2;
              } else if (!s2 && "arguments" === e3 && r3.path.isFunction() && !r3.path.isArrowFunctionExpression()) break;
              t3 = r3.path;
            } while (r3 = r3.parent);
          }
          getOwnBinding(e3) {
            return this.bindings[e3];
          }
          getBindingIdentifier(e3) {
            var t3;
            return null == (t3 = this.getBinding(e3)) ? void 0 : t3.identifier;
          }
          getOwnBindingIdentifier(e3) {
            const t3 = this.bindings[e3];
            return null == t3 ? void 0 : t3.identifier;
          }
          hasOwnBinding(e3) {
            return !!this.getOwnBinding(e3);
          }
          hasBinding(e3, t3) {
            if (!e3) return false;
            let r3, n2, s2;
            "object" == typeof t3 ? (r3 = t3.noGlobals, n2 = t3.noUids, s2 = t3.upToScope) : "boolean" == typeof t3 && (r3 = t3);
            let i2 = this;
            do {
              if (s2 === i2) break;
              if (i2.hasOwnBinding(e3)) return true;
            } while (i2 = i2.parent);
            return !(n2 || !this.hasUid(e3)) || (!(r3 || !Scope.globals.includes(e3)) || !(r3 || !Scope.contextVariables.includes(e3)));
          }
          parentHasBinding(e3, t3) {
            var r3;
            return null == (r3 = this.parent) ? void 0 : r3.hasBinding(e3, t3);
          }
          moveBindingTo(e3, t3) {
            const r3 = this.getBinding(e3);
            r3 && (r3.scope.removeOwnBinding(e3), r3.scope = t3, t3.bindings[e3] = r3);
          }
          removeOwnBinding(e3) {
            delete this.bindings[e3];
          }
          removeBinding(e3) {
            var t3;
            null == (t3 = this.getBinding(e3)) || t3.scope.removeOwnBinding(e3);
            {
              let t4 = this;
              do {
                t4.uids[e3] && (t4.uids[e3] = false);
              } while (t4 = t4.parent);
            }
          }
          hoistVariables(e3 = (e4) => this.push({ id: e4 })) {
            this.crawl();
            const t3 = /* @__PURE__ */ new Set();
            for (const r3 of Object.keys(this.bindings)) {
              const n2 = this.bindings[r3];
              if (!n2) continue;
              const { path: s2 } = n2;
              if (!s2.isVariableDeclarator()) continue;
              const { parent: i2, parentPath: o2 } = s2;
              if ("var" !== i2.kind || t3.has(i2)) continue;
              let a2;
              t3.add(s2.parent);
              const l2 = [];
              for (const t4 of i2.declarations) {
                null != a2 || (a2 = t4.id), t4.init && l2.push(u("=", t4.id, t4.init));
                const r4 = Object.keys(m(t4, false, true, true));
                for (const n3 of r4) e3(f(n3), null != t4.init);
              }
              if (o2.parentPath.isFor({ left: i2 })) o2.replaceWith(a2);
              else if (0 === l2.length) o2.remove();
              else {
                const e4 = 1 === l2.length ? l2[0] : se(l2);
                o2.parentPath.isForStatement({ init: i2 }) ? o2.replaceWith(e4) : o2.replaceWith(K(e4));
              }
            }
          }
        }
        t2.default = Scope, Scope.globals = [...p, ...c], Scope.contextVariables = ["arguments", "undefined", "Infinity", "NaN"], Scope.prototype._renameFromMap = function(e3, t3, r3, n2) {
          e3[t3] && (e3[r3] = n2, e3[t3] = null);
        }, Scope.prototype.traverse = function(e3, t3, r3) {
          (0, s.default)(e3, t3, this, r3, this.path);
        }, Scope.prototype._generateUid = function(e3, t3) {
          let r3 = e3;
          return t3 > 1 && (r3 += t3), `_${r3}`;
        }, Scope.prototype.toArray = function(e3, t3, r3) {
          if (A(e3)) {
            const t4 = this.getBinding(e3.name);
            if (null != t4 && t4.constant && t4.path.isGenericType("Array")) return e3;
          }
          if (y(e3)) return e3;
          if (A(e3, { name: "arguments" })) return d(q(q(q(f("Array"), f("prototype")), f("slice")), f("call")), [e3]);
          let n2;
          const s2 = [e3];
          return true === t3 ? n2 = "toConsumableArray" : "number" == typeof t3 ? (s2.push(H(t3)), n2 = "slicedToArray") : n2 = "toArray", r3 && (s2.unshift(this.path.hub.addHelper(n2)), n2 = "maybeArrayLike"), d(this.path.hub.addHelper(n2), s2);
        }, Scope.prototype.getAllBindingsOfKind = function(...e3) {
          const t3 = /* @__PURE__ */ Object.create(null);
          for (const r3 of e3) {
            let e4 = this;
            do {
              for (const n2 of Object.keys(e4.bindings)) {
                const s2 = e4.bindings[n2];
                s2.kind === r3 && (t3[n2] = s2);
              }
              e4 = e4.parent;
            } while (e4);
          }
          return t3;
        }, Object.defineProperties(Scope.prototype, { parentBlock: { configurable: true, enumerable: true, get() {
          return this.path.parent;
        } }, hub: { configurable: true, enumerable: true, get() {
          return this.path.hub;
        } } });
      }, "./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/scope/lib/renamer.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/index.js"), s = n, i = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/traverse-node.js"), o = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/visitors.js"), a = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/context.js");
        const { getAssignmentIdentifiers: l } = s, p = { ReferencedIdentifier({ node: e3 }, t3) {
          e3.name === t3.oldName && (e3.name = t3.newName);
        }, Scope(e3, t3) {
          e3.scope.bindingIdentifierEquals(t3.oldName, t3.binding.identifier) || (e3.skip(), e3.isMethod() && (e3.requeueComputedKeyAndDecorators ? e3.requeueComputedKeyAndDecorators() : a.requeueComputedKeyAndDecorators.call(e3)));
        }, ObjectProperty({ node: e3, scope: t3 }, r3) {
          const { name: n2 } = e3.key;
          var s2;
          !e3.shorthand || n2 !== r3.oldName && n2 !== r3.newName || t3.getBindingIdentifier(n2) !== r3.binding.identifier || (e3.shorthand = false, null != (s2 = e3.extra) && s2.shorthand && (e3.extra.shorthand = false));
        }, "AssignmentExpression|Declaration|VariableDeclarator"(e3, t3) {
          if (e3.isVariableDeclaration()) return;
          const r3 = e3.isAssignmentExpression() ? l(e3.node) : e3.getOuterBindingIdentifiers();
          for (const e4 in r3) e4 === t3.oldName && (r3[e4].name = t3.newName);
        } };
        t2.default = class {
          constructor(e3, t3, r3) {
            this.newName = r3, this.oldName = t3, this.binding = e3;
          }
          maybeConvertFromExportDeclaration(e3) {
            const t3 = e3.parentPath;
            if (t3.isExportDeclaration()) {
              if (t3.isExportDefaultDeclaration()) {
                const { declaration: e4 } = t3.node;
                if (n.isDeclaration(e4) && !e4.id) return;
              }
              t3.isExportAllDeclaration() || t3.splitExportDeclaration();
            }
          }
          maybeConvertFromClassFunctionDeclaration(e3) {
            return e3;
          }
          maybeConvertFromClassFunctionExpression(e3) {
            return e3;
          }
          rename() {
            const { binding: e3, oldName: t3, newName: r3 } = this, { scope: s2, path: a2 } = e3, l2 = a2.find((e4) => e4.isDeclaration() || e4.isFunctionExpression() || e4.isClassExpression());
            if (l2) {
              l2.getOuterBindingIdentifiers()[t3] === e3.identifier && this.maybeConvertFromExportDeclaration(l2);
            }
            const c = arguments[0] || s2.block, u = { discriminant: true };
            n.isMethod(c) && (c.computed && (u.key = true), n.isObjectMethod(c) || (u.decorators = true)), (0, i.traverseNode)(c, (0, o.explode)(p), s2, this, s2.path, u), arguments[0] || (s2.removeOwnBinding(t3), s2.bindings[r3] = e3, this.binding.identifier.name = r3), l2 && (this.maybeConvertFromClassFunctionDeclaration(a2), this.maybeConvertFromClassFunctionExpression(a2));
          }
        };
      }, "./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/traverse-node.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.traverseNode = function(e3, t3, r3, s2, o, a, l) {
          const p = i[e3.type];
          if (!p) return false;
          const c = new n.default(r3, t3, s2, o);
          if (l) return (null == a || !a[o.parentKey]) && c.visitQueue([o]);
          for (const t4 of p) if ((null == a || !a[t4]) && c.visit(e3, t4)) return true;
          return false;
        };
        var n = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/context.js"), s = (r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/index.js"), r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/index.js"));
        r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/context.js");
        const { VISITOR_KEYS: i } = s;
      }, "./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/visitors.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.environmentVisitor = function(e3) {
          return merge([d, e3]);
        }, t2.explode = explode$1, t2.isExplodedVisitor = isExplodedVisitor, t2.merge = merge, t2.verify = verify$1;
        var n = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/lib/virtual-types.js"), s = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/lib/virtual-types-validator.js"), i = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/index.js"), o = r2("./node_modules/.pnpm/@babel+traverse@7.28.4/node_modules/@babel/traverse/lib/path/context.js");
        const { DEPRECATED_KEYS: a, DEPRECATED_ALIASES: l, FLIPPED_ALIAS_KEYS: p, TYPES: c, __internal__deprecationWarning: u } = i;
        function isVirtualType(e3) {
          return e3 in n;
        }
        function isExplodedVisitor(e3) {
          return null == e3 ? void 0 : e3._exploded;
        }
        function explode$1(e3) {
          if (isExplodedVisitor(e3)) return e3;
          e3._exploded = true;
          for (const t3 of Object.keys(e3)) {
            if (shouldIgnoreKey(t3)) continue;
            const r3 = t3.split("|");
            if (1 === r3.length) continue;
            const n2 = e3[t3];
            delete e3[t3];
            for (const t4 of r3) e3[t4] = n2;
          }
          verify$1(e3), delete e3.__esModule, (function(e4) {
            for (const t3 of Object.keys(e4)) {
              if (shouldIgnoreKey(t3)) continue;
              const r3 = e4[t3];
              "function" == typeof r3 && (e4[t3] = { enter: r3 });
            }
          })(e3), ensureCallbackArrays(e3);
          for (const t3 of Object.keys(e3)) {
            if (shouldIgnoreKey(t3)) continue;
            if (!isVirtualType(t3)) continue;
            const r3 = e3[t3];
            for (const e4 of Object.keys(r3)) r3[e4] = wrapCheck(t3, r3[e4]);
            delete e3[t3];
            const s2 = n[t3];
            if (null !== s2) for (const t4 of s2) e3[t4] ? mergePair(e3[t4], r3) : e3[t4] = r3;
            else mergePair(e3, r3);
          }
          for (const t3 of Object.keys(e3)) {
            if (shouldIgnoreKey(t3)) continue;
            let r3 = p[t3];
            if (t3 in a) {
              const e4 = a[t3];
              u(t3, e4, "Visitor "), r3 = [e4];
            } else if (t3 in l) {
              const e4 = l[t3];
              u(t3, e4, "Visitor "), r3 = p[e4];
            }
            if (!r3) continue;
            const n2 = e3[t3];
            delete e3[t3];
            for (const t4 of r3) {
              const r4 = e3[t4];
              r4 ? mergePair(r4, n2) : e3[t4] = Object.assign({}, n2);
            }
          }
          for (const t3 of Object.keys(e3)) shouldIgnoreKey(t3) || ensureCallbackArrays(e3[t3]);
          return e3;
        }
        function verify$1(e3) {
          if (!e3._verified) {
            if ("function" == typeof e3) throw new Error("You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Function }`?");
            for (const t3 of Object.keys(e3)) {
              if ("enter" !== t3 && "exit" !== t3 || validateVisitorMethods(t3, e3[t3]), shouldIgnoreKey(t3)) continue;
              if (!c.includes(t3)) throw new Error(`You gave us a visitor for the node type ${t3} but it's not a valid type in @babel/traverse 7.28.4`);
              const r3 = e3[t3];
              if ("object" == typeof r3) for (const e4 of Object.keys(r3)) {
                if ("enter" !== e4 && "exit" !== e4) throw new Error(`You passed \`traverse()\` a visitor object with the property ${t3} that has the invalid property ${e4}`);
                validateVisitorMethods(`${t3}.${e4}`, r3[e4]);
              }
            }
            e3._verified = true;
          }
        }
        function validateVisitorMethods(e3, t3) {
          const r3 = [].concat(t3);
          for (const t4 of r3) if ("function" != typeof t4) throw new TypeError(`Non-function found defined in ${e3} with type ${typeof t4}`);
        }
        function merge(e3, t3 = [], r3) {
          const n2 = { _verified: true, _exploded: true };
          Object.defineProperty(n2, "_exploded", { enumerable: false }), Object.defineProperty(n2, "_verified", { enumerable: false });
          for (let s2 = 0; s2 < e3.length; s2++) {
            const i2 = explode$1(e3[s2]), o2 = t3[s2];
            let a2 = i2;
            (o2 || r3) && (a2 = wrapWithStateOrWrapper(a2, o2, r3)), mergePair(n2, a2);
            for (const e4 of Object.keys(i2)) {
              if (shouldIgnoreKey(e4)) continue;
              let t4 = i2[e4];
              (o2 || r3) && (t4 = wrapWithStateOrWrapper(t4, o2, r3));
              mergePair(n2[e4] || (n2[e4] = {}), t4);
            }
          }
          return n2;
        }
        function wrapWithStateOrWrapper(e3, t3, r3) {
          const n2 = {};
          for (const s2 of ["enter", "exit"]) {
            let i2 = e3[s2];
            Array.isArray(i2) && (i2 = i2.map(function(e4) {
              let n3 = e4;
              return t3 && (n3 = function(r4) {
                e4.call(t3, r4, t3);
              }), r3 && (n3 = r3(null == t3 ? void 0 : t3.key, s2, n3)), n3 !== e4 && (n3.toString = () => e4.toString()), n3;
            }), n2[s2] = i2);
          }
          return n2;
        }
        function ensureCallbackArrays(e3) {
          e3.enter && !Array.isArray(e3.enter) && (e3.enter = [e3.enter]), e3.exit && !Array.isArray(e3.exit) && (e3.exit = [e3.exit]);
        }
        function wrapCheck(e3, t3) {
          const r3 = s[`is${e3}`], newFn = function(e4) {
            if (r3.call(e4)) return t3.apply(this, arguments);
          };
          return newFn.toString = () => t3.toString(), newFn;
        }
        function shouldIgnoreKey(e3) {
          return "_" === e3[0] || ("enter" === e3 || "exit" === e3 || "shouldSkip" === e3 || ("denylist" === e3 || "noScope" === e3 || "skipKeys" === e3 || "blacklist" === e3));
        }
        function mergePair(e3, t3) {
          for (const r3 of ["enter", "exit"]) t3[r3] && (e3[r3] = [].concat(e3[r3] || [], t3[r3]));
        }
        const d = { FunctionParent(e3) {
          e3.isArrowFunctionExpression() || (e3.skip(), e3.isMethod() && (e3.requeueComputedKeyAndDecorators ? e3.requeueComputedKeyAndDecorators() : o.requeueComputedKeyAndDecorators.call(e3)));
        }, Property(e3) {
          e3.isObjectProperty() || (e3.skip(), e3.requeueComputedKeyAndDecorators ? e3.requeueComputedKeyAndDecorators() : o.requeueComputedKeyAndDecorators.call(e3));
        } };
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/asserts/assertNode.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
          if (!(0, n.default)(e3)) {
            var t3;
            const r3 = null != (t3 = null == e3 ? void 0 : e3.type) ? t3 : JSON.stringify(e3);
            throw new TypeError(`Not a valid node of type "${r3}"`);
          }
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/isNode.js");
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/asserts/generated/index.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.assertAccessor = function(e3, t3) {
          assert("Accessor", e3, t3);
        }, t2.assertAnyTypeAnnotation = function(e3, t3) {
          assert("AnyTypeAnnotation", e3, t3);
        }, t2.assertArgumentPlaceholder = function(e3, t3) {
          assert("ArgumentPlaceholder", e3, t3);
        }, t2.assertArrayExpression = function(e3, t3) {
          assert("ArrayExpression", e3, t3);
        }, t2.assertArrayPattern = function(e3, t3) {
          assert("ArrayPattern", e3, t3);
        }, t2.assertArrayTypeAnnotation = function(e3, t3) {
          assert("ArrayTypeAnnotation", e3, t3);
        }, t2.assertArrowFunctionExpression = function(e3, t3) {
          assert("ArrowFunctionExpression", e3, t3);
        }, t2.assertAssignmentExpression = function(e3, t3) {
          assert("AssignmentExpression", e3, t3);
        }, t2.assertAssignmentPattern = function(e3, t3) {
          assert("AssignmentPattern", e3, t3);
        }, t2.assertAwaitExpression = function(e3, t3) {
          assert("AwaitExpression", e3, t3);
        }, t2.assertBigIntLiteral = function(e3, t3) {
          assert("BigIntLiteral", e3, t3);
        }, t2.assertBinary = function(e3, t3) {
          assert("Binary", e3, t3);
        }, t2.assertBinaryExpression = function(e3, t3) {
          assert("BinaryExpression", e3, t3);
        }, t2.assertBindExpression = function(e3, t3) {
          assert("BindExpression", e3, t3);
        }, t2.assertBlock = function(e3, t3) {
          assert("Block", e3, t3);
        }, t2.assertBlockParent = function(e3, t3) {
          assert("BlockParent", e3, t3);
        }, t2.assertBlockStatement = function(e3, t3) {
          assert("BlockStatement", e3, t3);
        }, t2.assertBooleanLiteral = function(e3, t3) {
          assert("BooleanLiteral", e3, t3);
        }, t2.assertBooleanLiteralTypeAnnotation = function(e3, t3) {
          assert("BooleanLiteralTypeAnnotation", e3, t3);
        }, t2.assertBooleanTypeAnnotation = function(e3, t3) {
          assert("BooleanTypeAnnotation", e3, t3);
        }, t2.assertBreakStatement = function(e3, t3) {
          assert("BreakStatement", e3, t3);
        }, t2.assertCallExpression = function(e3, t3) {
          assert("CallExpression", e3, t3);
        }, t2.assertCatchClause = function(e3, t3) {
          assert("CatchClause", e3, t3);
        }, t2.assertClass = function(e3, t3) {
          assert("Class", e3, t3);
        }, t2.assertClassAccessorProperty = function(e3, t3) {
          assert("ClassAccessorProperty", e3, t3);
        }, t2.assertClassBody = function(e3, t3) {
          assert("ClassBody", e3, t3);
        }, t2.assertClassDeclaration = function(e3, t3) {
          assert("ClassDeclaration", e3, t3);
        }, t2.assertClassExpression = function(e3, t3) {
          assert("ClassExpression", e3, t3);
        }, t2.assertClassImplements = function(e3, t3) {
          assert("ClassImplements", e3, t3);
        }, t2.assertClassMethod = function(e3, t3) {
          assert("ClassMethod", e3, t3);
        }, t2.assertClassPrivateMethod = function(e3, t3) {
          assert("ClassPrivateMethod", e3, t3);
        }, t2.assertClassPrivateProperty = function(e3, t3) {
          assert("ClassPrivateProperty", e3, t3);
        }, t2.assertClassProperty = function(e3, t3) {
          assert("ClassProperty", e3, t3);
        }, t2.assertCompletionStatement = function(e3, t3) {
          assert("CompletionStatement", e3, t3);
        }, t2.assertConditional = function(e3, t3) {
          assert("Conditional", e3, t3);
        }, t2.assertConditionalExpression = function(e3, t3) {
          assert("ConditionalExpression", e3, t3);
        }, t2.assertContinueStatement = function(e3, t3) {
          assert("ContinueStatement", e3, t3);
        }, t2.assertDebuggerStatement = function(e3, t3) {
          assert("DebuggerStatement", e3, t3);
        }, t2.assertDecimalLiteral = function(e3, t3) {
          assert("DecimalLiteral", e3, t3);
        }, t2.assertDeclaration = function(e3, t3) {
          assert("Declaration", e3, t3);
        }, t2.assertDeclareClass = function(e3, t3) {
          assert("DeclareClass", e3, t3);
        }, t2.assertDeclareExportAllDeclaration = function(e3, t3) {
          assert("DeclareExportAllDeclaration", e3, t3);
        }, t2.assertDeclareExportDeclaration = function(e3, t3) {
          assert("DeclareExportDeclaration", e3, t3);
        }, t2.assertDeclareFunction = function(e3, t3) {
          assert("DeclareFunction", e3, t3);
        }, t2.assertDeclareInterface = function(e3, t3) {
          assert("DeclareInterface", e3, t3);
        }, t2.assertDeclareModule = function(e3, t3) {
          assert("DeclareModule", e3, t3);
        }, t2.assertDeclareModuleExports = function(e3, t3) {
          assert("DeclareModuleExports", e3, t3);
        }, t2.assertDeclareOpaqueType = function(e3, t3) {
          assert("DeclareOpaqueType", e3, t3);
        }, t2.assertDeclareTypeAlias = function(e3, t3) {
          assert("DeclareTypeAlias", e3, t3);
        }, t2.assertDeclareVariable = function(e3, t3) {
          assert("DeclareVariable", e3, t3);
        }, t2.assertDeclaredPredicate = function(e3, t3) {
          assert("DeclaredPredicate", e3, t3);
        }, t2.assertDecorator = function(e3, t3) {
          assert("Decorator", e3, t3);
        }, t2.assertDirective = function(e3, t3) {
          assert("Directive", e3, t3);
        }, t2.assertDirectiveLiteral = function(e3, t3) {
          assert("DirectiveLiteral", e3, t3);
        }, t2.assertDoExpression = function(e3, t3) {
          assert("DoExpression", e3, t3);
        }, t2.assertDoWhileStatement = function(e3, t3) {
          assert("DoWhileStatement", e3, t3);
        }, t2.assertEmptyStatement = function(e3, t3) {
          assert("EmptyStatement", e3, t3);
        }, t2.assertEmptyTypeAnnotation = function(e3, t3) {
          assert("EmptyTypeAnnotation", e3, t3);
        }, t2.assertEnumBody = function(e3, t3) {
          assert("EnumBody", e3, t3);
        }, t2.assertEnumBooleanBody = function(e3, t3) {
          assert("EnumBooleanBody", e3, t3);
        }, t2.assertEnumBooleanMember = function(e3, t3) {
          assert("EnumBooleanMember", e3, t3);
        }, t2.assertEnumDeclaration = function(e3, t3) {
          assert("EnumDeclaration", e3, t3);
        }, t2.assertEnumDefaultedMember = function(e3, t3) {
          assert("EnumDefaultedMember", e3, t3);
        }, t2.assertEnumMember = function(e3, t3) {
          assert("EnumMember", e3, t3);
        }, t2.assertEnumNumberBody = function(e3, t3) {
          assert("EnumNumberBody", e3, t3);
        }, t2.assertEnumNumberMember = function(e3, t3) {
          assert("EnumNumberMember", e3, t3);
        }, t2.assertEnumStringBody = function(e3, t3) {
          assert("EnumStringBody", e3, t3);
        }, t2.assertEnumStringMember = function(e3, t3) {
          assert("EnumStringMember", e3, t3);
        }, t2.assertEnumSymbolBody = function(e3, t3) {
          assert("EnumSymbolBody", e3, t3);
        }, t2.assertExistsTypeAnnotation = function(e3, t3) {
          assert("ExistsTypeAnnotation", e3, t3);
        }, t2.assertExportAllDeclaration = function(e3, t3) {
          assert("ExportAllDeclaration", e3, t3);
        }, t2.assertExportDeclaration = function(e3, t3) {
          assert("ExportDeclaration", e3, t3);
        }, t2.assertExportDefaultDeclaration = function(e3, t3) {
          assert("ExportDefaultDeclaration", e3, t3);
        }, t2.assertExportDefaultSpecifier = function(e3, t3) {
          assert("ExportDefaultSpecifier", e3, t3);
        }, t2.assertExportNamedDeclaration = function(e3, t3) {
          assert("ExportNamedDeclaration", e3, t3);
        }, t2.assertExportNamespaceSpecifier = function(e3, t3) {
          assert("ExportNamespaceSpecifier", e3, t3);
        }, t2.assertExportSpecifier = function(e3, t3) {
          assert("ExportSpecifier", e3, t3);
        }, t2.assertExpression = function(e3, t3) {
          assert("Expression", e3, t3);
        }, t2.assertExpressionStatement = function(e3, t3) {
          assert("ExpressionStatement", e3, t3);
        }, t2.assertExpressionWrapper = function(e3, t3) {
          assert("ExpressionWrapper", e3, t3);
        }, t2.assertFile = function(e3, t3) {
          assert("File", e3, t3);
        }, t2.assertFlow = function(e3, t3) {
          assert("Flow", e3, t3);
        }, t2.assertFlowBaseAnnotation = function(e3, t3) {
          assert("FlowBaseAnnotation", e3, t3);
        }, t2.assertFlowDeclaration = function(e3, t3) {
          assert("FlowDeclaration", e3, t3);
        }, t2.assertFlowPredicate = function(e3, t3) {
          assert("FlowPredicate", e3, t3);
        }, t2.assertFlowType = function(e3, t3) {
          assert("FlowType", e3, t3);
        }, t2.assertFor = function(e3, t3) {
          assert("For", e3, t3);
        }, t2.assertForInStatement = function(e3, t3) {
          assert("ForInStatement", e3, t3);
        }, t2.assertForOfStatement = function(e3, t3) {
          assert("ForOfStatement", e3, t3);
        }, t2.assertForStatement = function(e3, t3) {
          assert("ForStatement", e3, t3);
        }, t2.assertForXStatement = function(e3, t3) {
          assert("ForXStatement", e3, t3);
        }, t2.assertFunction = function(e3, t3) {
          assert("Function", e3, t3);
        }, t2.assertFunctionDeclaration = function(e3, t3) {
          assert("FunctionDeclaration", e3, t3);
        }, t2.assertFunctionExpression = function(e3, t3) {
          assert("FunctionExpression", e3, t3);
        }, t2.assertFunctionParameter = function(e3, t3) {
          assert("FunctionParameter", e3, t3);
        }, t2.assertFunctionParent = function(e3, t3) {
          assert("FunctionParent", e3, t3);
        }, t2.assertFunctionTypeAnnotation = function(e3, t3) {
          assert("FunctionTypeAnnotation", e3, t3);
        }, t2.assertFunctionTypeParam = function(e3, t3) {
          assert("FunctionTypeParam", e3, t3);
        }, t2.assertGenericTypeAnnotation = function(e3, t3) {
          assert("GenericTypeAnnotation", e3, t3);
        }, t2.assertIdentifier = function(e3, t3) {
          assert("Identifier", e3, t3);
        }, t2.assertIfStatement = function(e3, t3) {
          assert("IfStatement", e3, t3);
        }, t2.assertImmutable = function(e3, t3) {
          assert("Immutable", e3, t3);
        }, t2.assertImport = function(e3, t3) {
          assert("Import", e3, t3);
        }, t2.assertImportAttribute = function(e3, t3) {
          assert("ImportAttribute", e3, t3);
        }, t2.assertImportDeclaration = function(e3, t3) {
          assert("ImportDeclaration", e3, t3);
        }, t2.assertImportDefaultSpecifier = function(e3, t3) {
          assert("ImportDefaultSpecifier", e3, t3);
        }, t2.assertImportExpression = function(e3, t3) {
          assert("ImportExpression", e3, t3);
        }, t2.assertImportNamespaceSpecifier = function(e3, t3) {
          assert("ImportNamespaceSpecifier", e3, t3);
        }, t2.assertImportOrExportDeclaration = function(e3, t3) {
          assert("ImportOrExportDeclaration", e3, t3);
        }, t2.assertImportSpecifier = function(e3, t3) {
          assert("ImportSpecifier", e3, t3);
        }, t2.assertIndexedAccessType = function(e3, t3) {
          assert("IndexedAccessType", e3, t3);
        }, t2.assertInferredPredicate = function(e3, t3) {
          assert("InferredPredicate", e3, t3);
        }, t2.assertInterfaceDeclaration = function(e3, t3) {
          assert("InterfaceDeclaration", e3, t3);
        }, t2.assertInterfaceExtends = function(e3, t3) {
          assert("InterfaceExtends", e3, t3);
        }, t2.assertInterfaceTypeAnnotation = function(e3, t3) {
          assert("InterfaceTypeAnnotation", e3, t3);
        }, t2.assertInterpreterDirective = function(e3, t3) {
          assert("InterpreterDirective", e3, t3);
        }, t2.assertIntersectionTypeAnnotation = function(e3, t3) {
          assert("IntersectionTypeAnnotation", e3, t3);
        }, t2.assertJSX = function(e3, t3) {
          assert("JSX", e3, t3);
        }, t2.assertJSXAttribute = function(e3, t3) {
          assert("JSXAttribute", e3, t3);
        }, t2.assertJSXClosingElement = function(e3, t3) {
          assert("JSXClosingElement", e3, t3);
        }, t2.assertJSXClosingFragment = function(e3, t3) {
          assert("JSXClosingFragment", e3, t3);
        }, t2.assertJSXElement = function(e3, t3) {
          assert("JSXElement", e3, t3);
        }, t2.assertJSXEmptyExpression = function(e3, t3) {
          assert("JSXEmptyExpression", e3, t3);
        }, t2.assertJSXExpressionContainer = function(e3, t3) {
          assert("JSXExpressionContainer", e3, t3);
        }, t2.assertJSXFragment = function(e3, t3) {
          assert("JSXFragment", e3, t3);
        }, t2.assertJSXIdentifier = function(e3, t3) {
          assert("JSXIdentifier", e3, t3);
        }, t2.assertJSXMemberExpression = function(e3, t3) {
          assert("JSXMemberExpression", e3, t3);
        }, t2.assertJSXNamespacedName = function(e3, t3) {
          assert("JSXNamespacedName", e3, t3);
        }, t2.assertJSXOpeningElement = function(e3, t3) {
          assert("JSXOpeningElement", e3, t3);
        }, t2.assertJSXOpeningFragment = function(e3, t3) {
          assert("JSXOpeningFragment", e3, t3);
        }, t2.assertJSXSpreadAttribute = function(e3, t3) {
          assert("JSXSpreadAttribute", e3, t3);
        }, t2.assertJSXSpreadChild = function(e3, t3) {
          assert("JSXSpreadChild", e3, t3);
        }, t2.assertJSXText = function(e3, t3) {
          assert("JSXText", e3, t3);
        }, t2.assertLVal = function(e3, t3) {
          assert("LVal", e3, t3);
        }, t2.assertLabeledStatement = function(e3, t3) {
          assert("LabeledStatement", e3, t3);
        }, t2.assertLiteral = function(e3, t3) {
          assert("Literal", e3, t3);
        }, t2.assertLogicalExpression = function(e3, t3) {
          assert("LogicalExpression", e3, t3);
        }, t2.assertLoop = function(e3, t3) {
          assert("Loop", e3, t3);
        }, t2.assertMemberExpression = function(e3, t3) {
          assert("MemberExpression", e3, t3);
        }, t2.assertMetaProperty = function(e3, t3) {
          assert("MetaProperty", e3, t3);
        }, t2.assertMethod = function(e3, t3) {
          assert("Method", e3, t3);
        }, t2.assertMiscellaneous = function(e3, t3) {
          assert("Miscellaneous", e3, t3);
        }, t2.assertMixedTypeAnnotation = function(e3, t3) {
          assert("MixedTypeAnnotation", e3, t3);
        }, t2.assertModuleDeclaration = function(e3, t3) {
          (0, s.default)("assertModuleDeclaration", "assertImportOrExportDeclaration"), assert("ModuleDeclaration", e3, t3);
        }, t2.assertModuleExpression = function(e3, t3) {
          assert("ModuleExpression", e3, t3);
        }, t2.assertModuleSpecifier = function(e3, t3) {
          assert("ModuleSpecifier", e3, t3);
        }, t2.assertNewExpression = function(e3, t3) {
          assert("NewExpression", e3, t3);
        }, t2.assertNoop = function(e3, t3) {
          assert("Noop", e3, t3);
        }, t2.assertNullLiteral = function(e3, t3) {
          assert("NullLiteral", e3, t3);
        }, t2.assertNullLiteralTypeAnnotation = function(e3, t3) {
          assert("NullLiteralTypeAnnotation", e3, t3);
        }, t2.assertNullableTypeAnnotation = function(e3, t3) {
          assert("NullableTypeAnnotation", e3, t3);
        }, t2.assertNumberLiteral = function(e3, t3) {
          (0, s.default)("assertNumberLiteral", "assertNumericLiteral"), assert("NumberLiteral", e3, t3);
        }, t2.assertNumberLiteralTypeAnnotation = function(e3, t3) {
          assert("NumberLiteralTypeAnnotation", e3, t3);
        }, t2.assertNumberTypeAnnotation = function(e3, t3) {
          assert("NumberTypeAnnotation", e3, t3);
        }, t2.assertNumericLiteral = function(e3, t3) {
          assert("NumericLiteral", e3, t3);
        }, t2.assertObjectExpression = function(e3, t3) {
          assert("ObjectExpression", e3, t3);
        }, t2.assertObjectMember = function(e3, t3) {
          assert("ObjectMember", e3, t3);
        }, t2.assertObjectMethod = function(e3, t3) {
          assert("ObjectMethod", e3, t3);
        }, t2.assertObjectPattern = function(e3, t3) {
          assert("ObjectPattern", e3, t3);
        }, t2.assertObjectProperty = function(e3, t3) {
          assert("ObjectProperty", e3, t3);
        }, t2.assertObjectTypeAnnotation = function(e3, t3) {
          assert("ObjectTypeAnnotation", e3, t3);
        }, t2.assertObjectTypeCallProperty = function(e3, t3) {
          assert("ObjectTypeCallProperty", e3, t3);
        }, t2.assertObjectTypeIndexer = function(e3, t3) {
          assert("ObjectTypeIndexer", e3, t3);
        }, t2.assertObjectTypeInternalSlot = function(e3, t3) {
          assert("ObjectTypeInternalSlot", e3, t3);
        }, t2.assertObjectTypeProperty = function(e3, t3) {
          assert("ObjectTypeProperty", e3, t3);
        }, t2.assertObjectTypeSpreadProperty = function(e3, t3) {
          assert("ObjectTypeSpreadProperty", e3, t3);
        }, t2.assertOpaqueType = function(e3, t3) {
          assert("OpaqueType", e3, t3);
        }, t2.assertOptionalCallExpression = function(e3, t3) {
          assert("OptionalCallExpression", e3, t3);
        }, t2.assertOptionalIndexedAccessType = function(e3, t3) {
          assert("OptionalIndexedAccessType", e3, t3);
        }, t2.assertOptionalMemberExpression = function(e3, t3) {
          assert("OptionalMemberExpression", e3, t3);
        }, t2.assertParenthesizedExpression = function(e3, t3) {
          assert("ParenthesizedExpression", e3, t3);
        }, t2.assertPattern = function(e3, t3) {
          assert("Pattern", e3, t3);
        }, t2.assertPatternLike = function(e3, t3) {
          assert("PatternLike", e3, t3);
        }, t2.assertPipelineBareFunction = function(e3, t3) {
          assert("PipelineBareFunction", e3, t3);
        }, t2.assertPipelinePrimaryTopicReference = function(e3, t3) {
          assert("PipelinePrimaryTopicReference", e3, t3);
        }, t2.assertPipelineTopicExpression = function(e3, t3) {
          assert("PipelineTopicExpression", e3, t3);
        }, t2.assertPlaceholder = function(e3, t3) {
          assert("Placeholder", e3, t3);
        }, t2.assertPrivate = function(e3, t3) {
          assert("Private", e3, t3);
        }, t2.assertPrivateName = function(e3, t3) {
          assert("PrivateName", e3, t3);
        }, t2.assertProgram = function(e3, t3) {
          assert("Program", e3, t3);
        }, t2.assertProperty = function(e3, t3) {
          assert("Property", e3, t3);
        }, t2.assertPureish = function(e3, t3) {
          assert("Pureish", e3, t3);
        }, t2.assertQualifiedTypeIdentifier = function(e3, t3) {
          assert("QualifiedTypeIdentifier", e3, t3);
        }, t2.assertRecordExpression = function(e3, t3) {
          assert("RecordExpression", e3, t3);
        }, t2.assertRegExpLiteral = function(e3, t3) {
          assert("RegExpLiteral", e3, t3);
        }, t2.assertRegexLiteral = function(e3, t3) {
          (0, s.default)("assertRegexLiteral", "assertRegExpLiteral"), assert("RegexLiteral", e3, t3);
        }, t2.assertRestElement = function(e3, t3) {
          assert("RestElement", e3, t3);
        }, t2.assertRestProperty = function(e3, t3) {
          (0, s.default)("assertRestProperty", "assertRestElement"), assert("RestProperty", e3, t3);
        }, t2.assertReturnStatement = function(e3, t3) {
          assert("ReturnStatement", e3, t3);
        }, t2.assertScopable = function(e3, t3) {
          assert("Scopable", e3, t3);
        }, t2.assertSequenceExpression = function(e3, t3) {
          assert("SequenceExpression", e3, t3);
        }, t2.assertSpreadElement = function(e3, t3) {
          assert("SpreadElement", e3, t3);
        }, t2.assertSpreadProperty = function(e3, t3) {
          (0, s.default)("assertSpreadProperty", "assertSpreadElement"), assert("SpreadProperty", e3, t3);
        }, t2.assertStandardized = function(e3, t3) {
          assert("Standardized", e3, t3);
        }, t2.assertStatement = function(e3, t3) {
          assert("Statement", e3, t3);
        }, t2.assertStaticBlock = function(e3, t3) {
          assert("StaticBlock", e3, t3);
        }, t2.assertStringLiteral = function(e3, t3) {
          assert("StringLiteral", e3, t3);
        }, t2.assertStringLiteralTypeAnnotation = function(e3, t3) {
          assert("StringLiteralTypeAnnotation", e3, t3);
        }, t2.assertStringTypeAnnotation = function(e3, t3) {
          assert("StringTypeAnnotation", e3, t3);
        }, t2.assertSuper = function(e3, t3) {
          assert("Super", e3, t3);
        }, t2.assertSwitchCase = function(e3, t3) {
          assert("SwitchCase", e3, t3);
        }, t2.assertSwitchStatement = function(e3, t3) {
          assert("SwitchStatement", e3, t3);
        }, t2.assertSymbolTypeAnnotation = function(e3, t3) {
          assert("SymbolTypeAnnotation", e3, t3);
        }, t2.assertTSAnyKeyword = function(e3, t3) {
          assert("TSAnyKeyword", e3, t3);
        }, t2.assertTSArrayType = function(e3, t3) {
          assert("TSArrayType", e3, t3);
        }, t2.assertTSAsExpression = function(e3, t3) {
          assert("TSAsExpression", e3, t3);
        }, t2.assertTSBaseType = function(e3, t3) {
          assert("TSBaseType", e3, t3);
        }, t2.assertTSBigIntKeyword = function(e3, t3) {
          assert("TSBigIntKeyword", e3, t3);
        }, t2.assertTSBooleanKeyword = function(e3, t3) {
          assert("TSBooleanKeyword", e3, t3);
        }, t2.assertTSCallSignatureDeclaration = function(e3, t3) {
          assert("TSCallSignatureDeclaration", e3, t3);
        }, t2.assertTSConditionalType = function(e3, t3) {
          assert("TSConditionalType", e3, t3);
        }, t2.assertTSConstructSignatureDeclaration = function(e3, t3) {
          assert("TSConstructSignatureDeclaration", e3, t3);
        }, t2.assertTSConstructorType = function(e3, t3) {
          assert("TSConstructorType", e3, t3);
        }, t2.assertTSDeclareFunction = function(e3, t3) {
          assert("TSDeclareFunction", e3, t3);
        }, t2.assertTSDeclareMethod = function(e3, t3) {
          assert("TSDeclareMethod", e3, t3);
        }, t2.assertTSEntityName = function(e3, t3) {
          assert("TSEntityName", e3, t3);
        }, t2.assertTSEnumBody = function(e3, t3) {
          assert("TSEnumBody", e3, t3);
        }, t2.assertTSEnumDeclaration = function(e3, t3) {
          assert("TSEnumDeclaration", e3, t3);
        }, t2.assertTSEnumMember = function(e3, t3) {
          assert("TSEnumMember", e3, t3);
        }, t2.assertTSExportAssignment = function(e3, t3) {
          assert("TSExportAssignment", e3, t3);
        }, t2.assertTSExpressionWithTypeArguments = function(e3, t3) {
          assert("TSExpressionWithTypeArguments", e3, t3);
        }, t2.assertTSExternalModuleReference = function(e3, t3) {
          assert("TSExternalModuleReference", e3, t3);
        }, t2.assertTSFunctionType = function(e3, t3) {
          assert("TSFunctionType", e3, t3);
        }, t2.assertTSImportEqualsDeclaration = function(e3, t3) {
          assert("TSImportEqualsDeclaration", e3, t3);
        }, t2.assertTSImportType = function(e3, t3) {
          assert("TSImportType", e3, t3);
        }, t2.assertTSIndexSignature = function(e3, t3) {
          assert("TSIndexSignature", e3, t3);
        }, t2.assertTSIndexedAccessType = function(e3, t3) {
          assert("TSIndexedAccessType", e3, t3);
        }, t2.assertTSInferType = function(e3, t3) {
          assert("TSInferType", e3, t3);
        }, t2.assertTSInstantiationExpression = function(e3, t3) {
          assert("TSInstantiationExpression", e3, t3);
        }, t2.assertTSInterfaceBody = function(e3, t3) {
          assert("TSInterfaceBody", e3, t3);
        }, t2.assertTSInterfaceDeclaration = function(e3, t3) {
          assert("TSInterfaceDeclaration", e3, t3);
        }, t2.assertTSIntersectionType = function(e3, t3) {
          assert("TSIntersectionType", e3, t3);
        }, t2.assertTSIntrinsicKeyword = function(e3, t3) {
          assert("TSIntrinsicKeyword", e3, t3);
        }, t2.assertTSLiteralType = function(e3, t3) {
          assert("TSLiteralType", e3, t3);
        }, t2.assertTSMappedType = function(e3, t3) {
          assert("TSMappedType", e3, t3);
        }, t2.assertTSMethodSignature = function(e3, t3) {
          assert("TSMethodSignature", e3, t3);
        }, t2.assertTSModuleBlock = function(e3, t3) {
          assert("TSModuleBlock", e3, t3);
        }, t2.assertTSModuleDeclaration = function(e3, t3) {
          assert("TSModuleDeclaration", e3, t3);
        }, t2.assertTSNamedTupleMember = function(e3, t3) {
          assert("TSNamedTupleMember", e3, t3);
        }, t2.assertTSNamespaceExportDeclaration = function(e3, t3) {
          assert("TSNamespaceExportDeclaration", e3, t3);
        }, t2.assertTSNeverKeyword = function(e3, t3) {
          assert("TSNeverKeyword", e3, t3);
        }, t2.assertTSNonNullExpression = function(e3, t3) {
          assert("TSNonNullExpression", e3, t3);
        }, t2.assertTSNullKeyword = function(e3, t3) {
          assert("TSNullKeyword", e3, t3);
        }, t2.assertTSNumberKeyword = function(e3, t3) {
          assert("TSNumberKeyword", e3, t3);
        }, t2.assertTSObjectKeyword = function(e3, t3) {
          assert("TSObjectKeyword", e3, t3);
        }, t2.assertTSOptionalType = function(e3, t3) {
          assert("TSOptionalType", e3, t3);
        }, t2.assertTSParameterProperty = function(e3, t3) {
          assert("TSParameterProperty", e3, t3);
        }, t2.assertTSParenthesizedType = function(e3, t3) {
          assert("TSParenthesizedType", e3, t3);
        }, t2.assertTSPropertySignature = function(e3, t3) {
          assert("TSPropertySignature", e3, t3);
        }, t2.assertTSQualifiedName = function(e3, t3) {
          assert("TSQualifiedName", e3, t3);
        }, t2.assertTSRestType = function(e3, t3) {
          assert("TSRestType", e3, t3);
        }, t2.assertTSSatisfiesExpression = function(e3, t3) {
          assert("TSSatisfiesExpression", e3, t3);
        }, t2.assertTSStringKeyword = function(e3, t3) {
          assert("TSStringKeyword", e3, t3);
        }, t2.assertTSSymbolKeyword = function(e3, t3) {
          assert("TSSymbolKeyword", e3, t3);
        }, t2.assertTSTemplateLiteralType = function(e3, t3) {
          assert("TSTemplateLiteralType", e3, t3);
        }, t2.assertTSThisType = function(e3, t3) {
          assert("TSThisType", e3, t3);
        }, t2.assertTSTupleType = function(e3, t3) {
          assert("TSTupleType", e3, t3);
        }, t2.assertTSType = function(e3, t3) {
          assert("TSType", e3, t3);
        }, t2.assertTSTypeAliasDeclaration = function(e3, t3) {
          assert("TSTypeAliasDeclaration", e3, t3);
        }, t2.assertTSTypeAnnotation = function(e3, t3) {
          assert("TSTypeAnnotation", e3, t3);
        }, t2.assertTSTypeAssertion = function(e3, t3) {
          assert("TSTypeAssertion", e3, t3);
        }, t2.assertTSTypeElement = function(e3, t3) {
          assert("TSTypeElement", e3, t3);
        }, t2.assertTSTypeLiteral = function(e3, t3) {
          assert("TSTypeLiteral", e3, t3);
        }, t2.assertTSTypeOperator = function(e3, t3) {
          assert("TSTypeOperator", e3, t3);
        }, t2.assertTSTypeParameter = function(e3, t3) {
          assert("TSTypeParameter", e3, t3);
        }, t2.assertTSTypeParameterDeclaration = function(e3, t3) {
          assert("TSTypeParameterDeclaration", e3, t3);
        }, t2.assertTSTypeParameterInstantiation = function(e3, t3) {
          assert("TSTypeParameterInstantiation", e3, t3);
        }, t2.assertTSTypePredicate = function(e3, t3) {
          assert("TSTypePredicate", e3, t3);
        }, t2.assertTSTypeQuery = function(e3, t3) {
          assert("TSTypeQuery", e3, t3);
        }, t2.assertTSTypeReference = function(e3, t3) {
          assert("TSTypeReference", e3, t3);
        }, t2.assertTSUndefinedKeyword = function(e3, t3) {
          assert("TSUndefinedKeyword", e3, t3);
        }, t2.assertTSUnionType = function(e3, t3) {
          assert("TSUnionType", e3, t3);
        }, t2.assertTSUnknownKeyword = function(e3, t3) {
          assert("TSUnknownKeyword", e3, t3);
        }, t2.assertTSVoidKeyword = function(e3, t3) {
          assert("TSVoidKeyword", e3, t3);
        }, t2.assertTaggedTemplateExpression = function(e3, t3) {
          assert("TaggedTemplateExpression", e3, t3);
        }, t2.assertTemplateElement = function(e3, t3) {
          assert("TemplateElement", e3, t3);
        }, t2.assertTemplateLiteral = function(e3, t3) {
          assert("TemplateLiteral", e3, t3);
        }, t2.assertTerminatorless = function(e3, t3) {
          assert("Terminatorless", e3, t3);
        }, t2.assertThisExpression = function(e3, t3) {
          assert("ThisExpression", e3, t3);
        }, t2.assertThisTypeAnnotation = function(e3, t3) {
          assert("ThisTypeAnnotation", e3, t3);
        }, t2.assertThrowStatement = function(e3, t3) {
          assert("ThrowStatement", e3, t3);
        }, t2.assertTopicReference = function(e3, t3) {
          assert("TopicReference", e3, t3);
        }, t2.assertTryStatement = function(e3, t3) {
          assert("TryStatement", e3, t3);
        }, t2.assertTupleExpression = function(e3, t3) {
          assert("TupleExpression", e3, t3);
        }, t2.assertTupleTypeAnnotation = function(e3, t3) {
          assert("TupleTypeAnnotation", e3, t3);
        }, t2.assertTypeAlias = function(e3, t3) {
          assert("TypeAlias", e3, t3);
        }, t2.assertTypeAnnotation = function(e3, t3) {
          assert("TypeAnnotation", e3, t3);
        }, t2.assertTypeCastExpression = function(e3, t3) {
          assert("TypeCastExpression", e3, t3);
        }, t2.assertTypeParameter = function(e3, t3) {
          assert("TypeParameter", e3, t3);
        }, t2.assertTypeParameterDeclaration = function(e3, t3) {
          assert("TypeParameterDeclaration", e3, t3);
        }, t2.assertTypeParameterInstantiation = function(e3, t3) {
          assert("TypeParameterInstantiation", e3, t3);
        }, t2.assertTypeScript = function(e3, t3) {
          assert("TypeScript", e3, t3);
        }, t2.assertTypeofTypeAnnotation = function(e3, t3) {
          assert("TypeofTypeAnnotation", e3, t3);
        }, t2.assertUnaryExpression = function(e3, t3) {
          assert("UnaryExpression", e3, t3);
        }, t2.assertUnaryLike = function(e3, t3) {
          assert("UnaryLike", e3, t3);
        }, t2.assertUnionTypeAnnotation = function(e3, t3) {
          assert("UnionTypeAnnotation", e3, t3);
        }, t2.assertUpdateExpression = function(e3, t3) {
          assert("UpdateExpression", e3, t3);
        }, t2.assertUserWhitespacable = function(e3, t3) {
          assert("UserWhitespacable", e3, t3);
        }, t2.assertV8IntrinsicIdentifier = function(e3, t3) {
          assert("V8IntrinsicIdentifier", e3, t3);
        }, t2.assertVariableDeclaration = function(e3, t3) {
          assert("VariableDeclaration", e3, t3);
        }, t2.assertVariableDeclarator = function(e3, t3) {
          assert("VariableDeclarator", e3, t3);
        }, t2.assertVariance = function(e3, t3) {
          assert("Variance", e3, t3);
        }, t2.assertVoidPattern = function(e3, t3) {
          assert("VoidPattern", e3, t3);
        }, t2.assertVoidTypeAnnotation = function(e3, t3) {
          assert("VoidTypeAnnotation", e3, t3);
        }, t2.assertWhile = function(e3, t3) {
          assert("While", e3, t3);
        }, t2.assertWhileStatement = function(e3, t3) {
          assert("WhileStatement", e3, t3);
        }, t2.assertWithStatement = function(e3, t3) {
          assert("WithStatement", e3, t3);
        }, t2.assertYieldExpression = function(e3, t3) {
          assert("YieldExpression", e3, t3);
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/is.js"), s = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/utils/deprecationWarning.js");
        function assert(e3, t3, r3) {
          if (!(0, n.default)(e3, t3, r3)) throw new Error(`Expected type "${e3}" with option ${JSON.stringify(r3)}, but instead got "${t3.type}".`);
        }
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
          const t3 = (0, s.default)(e3);
          return 1 === t3.length ? t3[0] : (0, n.unionTypeAnnotation)(t3);
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/builders/generated/index.js"), s = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js");
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/builders/generated/index.js");
        t2.default = function(e3) {
          switch (e3) {
            case "string":
              return (0, n.stringTypeAnnotation)();
            case "number":
              return (0, n.numberTypeAnnotation)();
            case "undefined":
              return (0, n.voidTypeAnnotation)();
            case "boolean":
              return (0, n.booleanTypeAnnotation)();
            case "function":
              return (0, n.genericTypeAnnotation)((0, n.identifier)("Function"));
            case "object":
              return (0, n.genericTypeAnnotation)((0, n.identifier)("Object"));
            case "symbol":
              return (0, n.genericTypeAnnotation)((0, n.identifier)("Symbol"));
            case "bigint":
              return (0, n.anyTypeAnnotation)();
          }
          throw new Error("Invalid typeof value: " + e3);
        };
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/builders/generated/index.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true });
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/builders/generated/lowercase.js");
        Object.keys(n).forEach(function(e3) {
          "default" !== e3 && "__esModule" !== e3 && (e3 in t2 && t2[e3] === n[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
            return n[e3];
          } }));
        });
        var s = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/builders/generated/uppercase.js");
        Object.keys(s).forEach(function(e3) {
          "default" !== e3 && "__esModule" !== e3 && (e3 in t2 && t2[e3] === s[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
            return s[e3];
          } }));
        });
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/builders/generated/lowercase.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.anyTypeAnnotation = function() {
          return { type: "AnyTypeAnnotation" };
        }, t2.argumentPlaceholder = function() {
          return { type: "ArgumentPlaceholder" };
        }, t2.arrayExpression = function(e3 = []) {
          const t3 = { type: "ArrayExpression", elements: e3 }, r3 = a.ArrayExpression;
          return o(r3.elements, t3, "elements", e3, 1), t3;
        }, t2.arrayPattern = function(e3) {
          const t3 = { type: "ArrayPattern", elements: e3 }, r3 = a.ArrayPattern;
          return o(r3.elements, t3, "elements", e3, 1), t3;
        }, t2.arrayTypeAnnotation = function(e3) {
          const t3 = { type: "ArrayTypeAnnotation", elementType: e3 }, r3 = a.ArrayTypeAnnotation;
          return o(r3.elementType, t3, "elementType", e3, 1), t3;
        }, t2.arrowFunctionExpression = function(e3, t3, r3 = false) {
          const n2 = { type: "ArrowFunctionExpression", params: e3, body: t3, async: r3, expression: null }, s2 = a.ArrowFunctionExpression;
          return o(s2.params, n2, "params", e3, 1), o(s2.body, n2, "body", t3, 1), o(s2.async, n2, "async", r3), n2;
        }, t2.assignmentExpression = function(e3, t3, r3) {
          const n2 = { type: "AssignmentExpression", operator: e3, left: t3, right: r3 }, s2 = a.AssignmentExpression;
          return o(s2.operator, n2, "operator", e3), o(s2.left, n2, "left", t3, 1), o(s2.right, n2, "right", r3, 1), n2;
        }, t2.assignmentPattern = function(e3, t3) {
          const r3 = { type: "AssignmentPattern", left: e3, right: t3 }, n2 = a.AssignmentPattern;
          return o(n2.left, r3, "left", e3, 1), o(n2.right, r3, "right", t3, 1), r3;
        }, t2.awaitExpression = function(e3) {
          const t3 = { type: "AwaitExpression", argument: e3 }, r3 = a.AwaitExpression;
          return o(r3.argument, t3, "argument", e3, 1), t3;
        }, t2.bigIntLiteral = function(e3) {
          "bigint" == typeof e3 && (e3 = e3.toString());
          const t3 = { type: "BigIntLiteral", value: e3 }, r3 = a.BigIntLiteral;
          return o(r3.value, t3, "value", e3), t3;
        }, t2.binaryExpression = function(e3, t3, r3) {
          const n2 = { type: "BinaryExpression", operator: e3, left: t3, right: r3 }, s2 = a.BinaryExpression;
          return o(s2.operator, n2, "operator", e3), o(s2.left, n2, "left", t3, 1), o(s2.right, n2, "right", r3, 1), n2;
        }, t2.bindExpression = function(e3, t3) {
          const r3 = { type: "BindExpression", object: e3, callee: t3 }, n2 = a.BindExpression;
          return o(n2.object, r3, "object", e3, 1), o(n2.callee, r3, "callee", t3, 1), r3;
        }, t2.blockStatement = function(e3, t3 = []) {
          const r3 = { type: "BlockStatement", body: e3, directives: t3 }, n2 = a.BlockStatement;
          return o(n2.body, r3, "body", e3, 1), o(n2.directives, r3, "directives", t3, 1), r3;
        }, t2.booleanLiteral = function(e3) {
          const t3 = { type: "BooleanLiteral", value: e3 }, r3 = a.BooleanLiteral;
          return o(r3.value, t3, "value", e3), t3;
        }, t2.booleanLiteralTypeAnnotation = function(e3) {
          const t3 = { type: "BooleanLiteralTypeAnnotation", value: e3 }, r3 = a.BooleanLiteralTypeAnnotation;
          return o(r3.value, t3, "value", e3), t3;
        }, t2.booleanTypeAnnotation = function() {
          return { type: "BooleanTypeAnnotation" };
        }, t2.breakStatement = function(e3 = null) {
          const t3 = { type: "BreakStatement", label: e3 }, r3 = a.BreakStatement;
          return o(r3.label, t3, "label", e3, 1), t3;
        }, t2.callExpression = function(e3, t3) {
          const r3 = { type: "CallExpression", callee: e3, arguments: t3 }, n2 = a.CallExpression;
          return o(n2.callee, r3, "callee", e3, 1), o(n2.arguments, r3, "arguments", t3, 1), r3;
        }, t2.catchClause = function(e3 = null, t3) {
          const r3 = { type: "CatchClause", param: e3, body: t3 }, n2 = a.CatchClause;
          return o(n2.param, r3, "param", e3, 1), o(n2.body, r3, "body", t3, 1), r3;
        }, t2.classAccessorProperty = function(e3, t3 = null, r3 = null, n2 = null, s2 = false, i2 = false) {
          const l = { type: "ClassAccessorProperty", key: e3, value: t3, typeAnnotation: r3, decorators: n2, computed: s2, static: i2 }, p = a.ClassAccessorProperty;
          return o(p.key, l, "key", e3, 1), o(p.value, l, "value", t3, 1), o(p.typeAnnotation, l, "typeAnnotation", r3, 1), o(p.decorators, l, "decorators", n2, 1), o(p.computed, l, "computed", s2), o(p.static, l, "static", i2), l;
        }, t2.classBody = function(e3) {
          const t3 = { type: "ClassBody", body: e3 }, r3 = a.ClassBody;
          return o(r3.body, t3, "body", e3, 1), t3;
        }, t2.classDeclaration = function(e3 = null, t3 = null, r3, n2 = null) {
          const s2 = { type: "ClassDeclaration", id: e3, superClass: t3, body: r3, decorators: n2 }, i2 = a.ClassDeclaration;
          return o(i2.id, s2, "id", e3, 1), o(i2.superClass, s2, "superClass", t3, 1), o(i2.body, s2, "body", r3, 1), o(i2.decorators, s2, "decorators", n2, 1), s2;
        }, t2.classExpression = function(e3 = null, t3 = null, r3, n2 = null) {
          const s2 = { type: "ClassExpression", id: e3, superClass: t3, body: r3, decorators: n2 }, i2 = a.ClassExpression;
          return o(i2.id, s2, "id", e3, 1), o(i2.superClass, s2, "superClass", t3, 1), o(i2.body, s2, "body", r3, 1), o(i2.decorators, s2, "decorators", n2, 1), s2;
        }, t2.classImplements = function(e3, t3 = null) {
          const r3 = { type: "ClassImplements", id: e3, typeParameters: t3 }, n2 = a.ClassImplements;
          return o(n2.id, r3, "id", e3, 1), o(n2.typeParameters, r3, "typeParameters", t3, 1), r3;
        }, t2.classMethod = function(e3 = "method", t3, r3, n2, s2 = false, i2 = false, l = false, p = false) {
          const c = { type: "ClassMethod", kind: e3, key: t3, params: r3, body: n2, computed: s2, static: i2, generator: l, async: p }, u = a.ClassMethod;
          return o(u.kind, c, "kind", e3), o(u.key, c, "key", t3, 1), o(u.params, c, "params", r3, 1), o(u.body, c, "body", n2, 1), o(u.computed, c, "computed", s2), o(u.static, c, "static", i2), o(u.generator, c, "generator", l), o(u.async, c, "async", p), c;
        }, t2.classPrivateMethod = function(e3 = "method", t3, r3, n2, s2 = false) {
          const i2 = { type: "ClassPrivateMethod", kind: e3, key: t3, params: r3, body: n2, static: s2 }, l = a.ClassPrivateMethod;
          return o(l.kind, i2, "kind", e3), o(l.key, i2, "key", t3, 1), o(l.params, i2, "params", r3, 1), o(l.body, i2, "body", n2, 1), o(l.static, i2, "static", s2), i2;
        }, t2.classPrivateProperty = function(e3, t3 = null, r3 = null, n2 = false) {
          const s2 = { type: "ClassPrivateProperty", key: e3, value: t3, decorators: r3, static: n2 }, i2 = a.ClassPrivateProperty;
          return o(i2.key, s2, "key", e3, 1), o(i2.value, s2, "value", t3, 1), o(i2.decorators, s2, "decorators", r3, 1), o(i2.static, s2, "static", n2), s2;
        }, t2.classProperty = function(e3, t3 = null, r3 = null, n2 = null, s2 = false, i2 = false) {
          const l = { type: "ClassProperty", key: e3, value: t3, typeAnnotation: r3, decorators: n2, computed: s2, static: i2 }, p = a.ClassProperty;
          return o(p.key, l, "key", e3, 1), o(p.value, l, "value", t3, 1), o(p.typeAnnotation, l, "typeAnnotation", r3, 1), o(p.decorators, l, "decorators", n2, 1), o(p.computed, l, "computed", s2), o(p.static, l, "static", i2), l;
        }, t2.conditionalExpression = function(e3, t3, r3) {
          const n2 = { type: "ConditionalExpression", test: e3, consequent: t3, alternate: r3 }, s2 = a.ConditionalExpression;
          return o(s2.test, n2, "test", e3, 1), o(s2.consequent, n2, "consequent", t3, 1), o(s2.alternate, n2, "alternate", r3, 1), n2;
        }, t2.continueStatement = function(e3 = null) {
          const t3 = { type: "ContinueStatement", label: e3 }, r3 = a.ContinueStatement;
          return o(r3.label, t3, "label", e3, 1), t3;
        }, t2.debuggerStatement = function() {
          return { type: "DebuggerStatement" };
        }, t2.decimalLiteral = function(e3) {
          const t3 = { type: "DecimalLiteral", value: e3 }, r3 = a.DecimalLiteral;
          return o(r3.value, t3, "value", e3), t3;
        }, t2.declareClass = function(e3, t3 = null, r3 = null, n2) {
          const s2 = { type: "DeclareClass", id: e3, typeParameters: t3, extends: r3, body: n2 }, i2 = a.DeclareClass;
          return o(i2.id, s2, "id", e3, 1), o(i2.typeParameters, s2, "typeParameters", t3, 1), o(i2.extends, s2, "extends", r3, 1), o(i2.body, s2, "body", n2, 1), s2;
        }, t2.declareExportAllDeclaration = function(e3, t3 = null) {
          const r3 = { type: "DeclareExportAllDeclaration", source: e3, attributes: t3 }, n2 = a.DeclareExportAllDeclaration;
          return o(n2.source, r3, "source", e3, 1), o(n2.attributes, r3, "attributes", t3, 1), r3;
        }, t2.declareExportDeclaration = function(e3 = null, t3 = null, r3 = null, n2 = null) {
          const s2 = { type: "DeclareExportDeclaration", declaration: e3, specifiers: t3, source: r3, attributes: n2 }, i2 = a.DeclareExportDeclaration;
          return o(i2.declaration, s2, "declaration", e3, 1), o(i2.specifiers, s2, "specifiers", t3, 1), o(i2.source, s2, "source", r3, 1), o(i2.attributes, s2, "attributes", n2, 1), s2;
        }, t2.declareFunction = function(e3) {
          const t3 = { type: "DeclareFunction", id: e3 }, r3 = a.DeclareFunction;
          return o(r3.id, t3, "id", e3, 1), t3;
        }, t2.declareInterface = function(e3, t3 = null, r3 = null, n2) {
          const s2 = { type: "DeclareInterface", id: e3, typeParameters: t3, extends: r3, body: n2 }, i2 = a.DeclareInterface;
          return o(i2.id, s2, "id", e3, 1), o(i2.typeParameters, s2, "typeParameters", t3, 1), o(i2.extends, s2, "extends", r3, 1), o(i2.body, s2, "body", n2, 1), s2;
        }, t2.declareModule = function(e3, t3, r3 = null) {
          const n2 = { type: "DeclareModule", id: e3, body: t3, kind: r3 }, s2 = a.DeclareModule;
          return o(s2.id, n2, "id", e3, 1), o(s2.body, n2, "body", t3, 1), o(s2.kind, n2, "kind", r3), n2;
        }, t2.declareModuleExports = function(e3) {
          const t3 = { type: "DeclareModuleExports", typeAnnotation: e3 }, r3 = a.DeclareModuleExports;
          return o(r3.typeAnnotation, t3, "typeAnnotation", e3, 1), t3;
        }, t2.declareOpaqueType = function(e3, t3 = null, r3 = null) {
          const n2 = { type: "DeclareOpaqueType", id: e3, typeParameters: t3, supertype: r3 }, s2 = a.DeclareOpaqueType;
          return o(s2.id, n2, "id", e3, 1), o(s2.typeParameters, n2, "typeParameters", t3, 1), o(s2.supertype, n2, "supertype", r3, 1), n2;
        }, t2.declareTypeAlias = function(e3, t3 = null, r3) {
          const n2 = { type: "DeclareTypeAlias", id: e3, typeParameters: t3, right: r3 }, s2 = a.DeclareTypeAlias;
          return o(s2.id, n2, "id", e3, 1), o(s2.typeParameters, n2, "typeParameters", t3, 1), o(s2.right, n2, "right", r3, 1), n2;
        }, t2.declareVariable = function(e3) {
          const t3 = { type: "DeclareVariable", id: e3 }, r3 = a.DeclareVariable;
          return o(r3.id, t3, "id", e3, 1), t3;
        }, t2.declaredPredicate = function(e3) {
          const t3 = { type: "DeclaredPredicate", value: e3 }, r3 = a.DeclaredPredicate;
          return o(r3.value, t3, "value", e3, 1), t3;
        }, t2.decorator = function(e3) {
          const t3 = { type: "Decorator", expression: e3 }, r3 = a.Decorator;
          return o(r3.expression, t3, "expression", e3, 1), t3;
        }, t2.directive = function(e3) {
          const t3 = { type: "Directive", value: e3 }, r3 = a.Directive;
          return o(r3.value, t3, "value", e3, 1), t3;
        }, t2.directiveLiteral = function(e3) {
          const t3 = { type: "DirectiveLiteral", value: e3 }, r3 = a.DirectiveLiteral;
          return o(r3.value, t3, "value", e3), t3;
        }, t2.doExpression = function(e3, t3 = false) {
          const r3 = { type: "DoExpression", body: e3, async: t3 }, n2 = a.DoExpression;
          return o(n2.body, r3, "body", e3, 1), o(n2.async, r3, "async", t3), r3;
        }, t2.doWhileStatement = function(e3, t3) {
          const r3 = { type: "DoWhileStatement", test: e3, body: t3 }, n2 = a.DoWhileStatement;
          return o(n2.test, r3, "test", e3, 1), o(n2.body, r3, "body", t3, 1), r3;
        }, t2.emptyStatement = function() {
          return { type: "EmptyStatement" };
        }, t2.emptyTypeAnnotation = function() {
          return { type: "EmptyTypeAnnotation" };
        }, t2.enumBooleanBody = function(e3) {
          const t3 = { type: "EnumBooleanBody", members: e3, explicitType: null, hasUnknownMembers: null }, r3 = a.EnumBooleanBody;
          return o(r3.members, t3, "members", e3, 1), t3;
        }, t2.enumBooleanMember = function(e3) {
          const t3 = { type: "EnumBooleanMember", id: e3, init: null }, r3 = a.EnumBooleanMember;
          return o(r3.id, t3, "id", e3, 1), t3;
        }, t2.enumDeclaration = function(e3, t3) {
          const r3 = { type: "EnumDeclaration", id: e3, body: t3 }, n2 = a.EnumDeclaration;
          return o(n2.id, r3, "id", e3, 1), o(n2.body, r3, "body", t3, 1), r3;
        }, t2.enumDefaultedMember = function(e3) {
          const t3 = { type: "EnumDefaultedMember", id: e3 }, r3 = a.EnumDefaultedMember;
          return o(r3.id, t3, "id", e3, 1), t3;
        }, t2.enumNumberBody = function(e3) {
          const t3 = { type: "EnumNumberBody", members: e3, explicitType: null, hasUnknownMembers: null }, r3 = a.EnumNumberBody;
          return o(r3.members, t3, "members", e3, 1), t3;
        }, t2.enumNumberMember = function(e3, t3) {
          const r3 = { type: "EnumNumberMember", id: e3, init: t3 }, n2 = a.EnumNumberMember;
          return o(n2.id, r3, "id", e3, 1), o(n2.init, r3, "init", t3, 1), r3;
        }, t2.enumStringBody = function(e3) {
          const t3 = { type: "EnumStringBody", members: e3, explicitType: null, hasUnknownMembers: null }, r3 = a.EnumStringBody;
          return o(r3.members, t3, "members", e3, 1), t3;
        }, t2.enumStringMember = function(e3, t3) {
          const r3 = { type: "EnumStringMember", id: e3, init: t3 }, n2 = a.EnumStringMember;
          return o(n2.id, r3, "id", e3, 1), o(n2.init, r3, "init", t3, 1), r3;
        }, t2.enumSymbolBody = function(e3) {
          const t3 = { type: "EnumSymbolBody", members: e3, hasUnknownMembers: null }, r3 = a.EnumSymbolBody;
          return o(r3.members, t3, "members", e3, 1), t3;
        }, t2.existsTypeAnnotation = function() {
          return { type: "ExistsTypeAnnotation" };
        }, t2.exportAllDeclaration = function(e3) {
          const t3 = { type: "ExportAllDeclaration", source: e3 }, r3 = a.ExportAllDeclaration;
          return o(r3.source, t3, "source", e3, 1), t3;
        }, t2.exportDefaultDeclaration = function(e3) {
          const t3 = { type: "ExportDefaultDeclaration", declaration: e3 }, r3 = a.ExportDefaultDeclaration;
          return o(r3.declaration, t3, "declaration", e3, 1), t3;
        }, t2.exportDefaultSpecifier = function(e3) {
          const t3 = { type: "ExportDefaultSpecifier", exported: e3 }, r3 = a.ExportDefaultSpecifier;
          return o(r3.exported, t3, "exported", e3, 1), t3;
        }, t2.exportNamedDeclaration = function(e3 = null, t3 = [], r3 = null) {
          const n2 = { type: "ExportNamedDeclaration", declaration: e3, specifiers: t3, source: r3 }, s2 = a.ExportNamedDeclaration;
          return o(s2.declaration, n2, "declaration", e3, 1), o(s2.specifiers, n2, "specifiers", t3, 1), o(s2.source, n2, "source", r3, 1), n2;
        }, t2.exportNamespaceSpecifier = function(e3) {
          const t3 = { type: "ExportNamespaceSpecifier", exported: e3 }, r3 = a.ExportNamespaceSpecifier;
          return o(r3.exported, t3, "exported", e3, 1), t3;
        }, t2.exportSpecifier = function(e3, t3) {
          const r3 = { type: "ExportSpecifier", local: e3, exported: t3 }, n2 = a.ExportSpecifier;
          return o(n2.local, r3, "local", e3, 1), o(n2.exported, r3, "exported", t3, 1), r3;
        }, t2.expressionStatement = function(e3) {
          const t3 = { type: "ExpressionStatement", expression: e3 }, r3 = a.ExpressionStatement;
          return o(r3.expression, t3, "expression", e3, 1), t3;
        }, t2.file = function(e3, t3 = null, r3 = null) {
          const n2 = { type: "File", program: e3, comments: t3, tokens: r3 }, s2 = a.File;
          return o(s2.program, n2, "program", e3, 1), o(s2.comments, n2, "comments", t3, 1), o(s2.tokens, n2, "tokens", r3), n2;
        }, t2.forInStatement = function(e3, t3, r3) {
          const n2 = { type: "ForInStatement", left: e3, right: t3, body: r3 }, s2 = a.ForInStatement;
          return o(s2.left, n2, "left", e3, 1), o(s2.right, n2, "right", t3, 1), o(s2.body, n2, "body", r3, 1), n2;
        }, t2.forOfStatement = function(e3, t3, r3, n2 = false) {
          const s2 = { type: "ForOfStatement", left: e3, right: t3, body: r3, await: n2 }, i2 = a.ForOfStatement;
          return o(i2.left, s2, "left", e3, 1), o(i2.right, s2, "right", t3, 1), o(i2.body, s2, "body", r3, 1), o(i2.await, s2, "await", n2), s2;
        }, t2.forStatement = function(e3 = null, t3 = null, r3 = null, n2) {
          const s2 = { type: "ForStatement", init: e3, test: t3, update: r3, body: n2 }, i2 = a.ForStatement;
          return o(i2.init, s2, "init", e3, 1), o(i2.test, s2, "test", t3, 1), o(i2.update, s2, "update", r3, 1), o(i2.body, s2, "body", n2, 1), s2;
        }, t2.functionDeclaration = function(e3 = null, t3, r3, n2 = false, s2 = false) {
          const i2 = { type: "FunctionDeclaration", id: e3, params: t3, body: r3, generator: n2, async: s2 }, l = a.FunctionDeclaration;
          return o(l.id, i2, "id", e3, 1), o(l.params, i2, "params", t3, 1), o(l.body, i2, "body", r3, 1), o(l.generator, i2, "generator", n2), o(l.async, i2, "async", s2), i2;
        }, t2.functionExpression = function(e3 = null, t3, r3, n2 = false, s2 = false) {
          const i2 = { type: "FunctionExpression", id: e3, params: t3, body: r3, generator: n2, async: s2 }, l = a.FunctionExpression;
          return o(l.id, i2, "id", e3, 1), o(l.params, i2, "params", t3, 1), o(l.body, i2, "body", r3, 1), o(l.generator, i2, "generator", n2), o(l.async, i2, "async", s2), i2;
        }, t2.functionTypeAnnotation = function(e3 = null, t3, r3 = null, n2) {
          const s2 = { type: "FunctionTypeAnnotation", typeParameters: e3, params: t3, rest: r3, returnType: n2 }, i2 = a.FunctionTypeAnnotation;
          return o(i2.typeParameters, s2, "typeParameters", e3, 1), o(i2.params, s2, "params", t3, 1), o(i2.rest, s2, "rest", r3, 1), o(i2.returnType, s2, "returnType", n2, 1), s2;
        }, t2.functionTypeParam = function(e3 = null, t3) {
          const r3 = { type: "FunctionTypeParam", name: e3, typeAnnotation: t3 }, n2 = a.FunctionTypeParam;
          return o(n2.name, r3, "name", e3, 1), o(n2.typeAnnotation, r3, "typeAnnotation", t3, 1), r3;
        }, t2.genericTypeAnnotation = function(e3, t3 = null) {
          const r3 = { type: "GenericTypeAnnotation", id: e3, typeParameters: t3 }, n2 = a.GenericTypeAnnotation;
          return o(n2.id, r3, "id", e3, 1), o(n2.typeParameters, r3, "typeParameters", t3, 1), r3;
        }, t2.identifier = function(e3) {
          const t3 = { type: "Identifier", name: e3 }, r3 = a.Identifier;
          return o(r3.name, t3, "name", e3), t3;
        }, t2.ifStatement = function(e3, t3, r3 = null) {
          const n2 = { type: "IfStatement", test: e3, consequent: t3, alternate: r3 }, s2 = a.IfStatement;
          return o(s2.test, n2, "test", e3, 1), o(s2.consequent, n2, "consequent", t3, 1), o(s2.alternate, n2, "alternate", r3, 1), n2;
        }, t2.import = function() {
          return { type: "Import" };
        }, t2.importAttribute = function(e3, t3) {
          const r3 = { type: "ImportAttribute", key: e3, value: t3 }, n2 = a.ImportAttribute;
          return o(n2.key, r3, "key", e3, 1), o(n2.value, r3, "value", t3, 1), r3;
        }, t2.importDeclaration = function(e3, t3) {
          const r3 = { type: "ImportDeclaration", specifiers: e3, source: t3 }, n2 = a.ImportDeclaration;
          return o(n2.specifiers, r3, "specifiers", e3, 1), o(n2.source, r3, "source", t3, 1), r3;
        }, t2.importDefaultSpecifier = function(e3) {
          const t3 = { type: "ImportDefaultSpecifier", local: e3 }, r3 = a.ImportDefaultSpecifier;
          return o(r3.local, t3, "local", e3, 1), t3;
        }, t2.importExpression = function(e3, t3 = null) {
          const r3 = { type: "ImportExpression", source: e3, options: t3 }, n2 = a.ImportExpression;
          return o(n2.source, r3, "source", e3, 1), o(n2.options, r3, "options", t3, 1), r3;
        }, t2.importNamespaceSpecifier = function(e3) {
          const t3 = { type: "ImportNamespaceSpecifier", local: e3 }, r3 = a.ImportNamespaceSpecifier;
          return o(r3.local, t3, "local", e3, 1), t3;
        }, t2.importSpecifier = function(e3, t3) {
          const r3 = { type: "ImportSpecifier", local: e3, imported: t3 }, n2 = a.ImportSpecifier;
          return o(n2.local, r3, "local", e3, 1), o(n2.imported, r3, "imported", t3, 1), r3;
        }, t2.indexedAccessType = function(e3, t3) {
          const r3 = { type: "IndexedAccessType", objectType: e3, indexType: t3 }, n2 = a.IndexedAccessType;
          return o(n2.objectType, r3, "objectType", e3, 1), o(n2.indexType, r3, "indexType", t3, 1), r3;
        }, t2.inferredPredicate = function() {
          return { type: "InferredPredicate" };
        }, t2.interfaceDeclaration = function(e3, t3 = null, r3 = null, n2) {
          const s2 = { type: "InterfaceDeclaration", id: e3, typeParameters: t3, extends: r3, body: n2 }, i2 = a.InterfaceDeclaration;
          return o(i2.id, s2, "id", e3, 1), o(i2.typeParameters, s2, "typeParameters", t3, 1), o(i2.extends, s2, "extends", r3, 1), o(i2.body, s2, "body", n2, 1), s2;
        }, t2.interfaceExtends = function(e3, t3 = null) {
          const r3 = { type: "InterfaceExtends", id: e3, typeParameters: t3 }, n2 = a.InterfaceExtends;
          return o(n2.id, r3, "id", e3, 1), o(n2.typeParameters, r3, "typeParameters", t3, 1), r3;
        }, t2.interfaceTypeAnnotation = function(e3 = null, t3) {
          const r3 = { type: "InterfaceTypeAnnotation", extends: e3, body: t3 }, n2 = a.InterfaceTypeAnnotation;
          return o(n2.extends, r3, "extends", e3, 1), o(n2.body, r3, "body", t3, 1), r3;
        }, t2.interpreterDirective = function(e3) {
          const t3 = { type: "InterpreterDirective", value: e3 }, r3 = a.InterpreterDirective;
          return o(r3.value, t3, "value", e3), t3;
        }, t2.intersectionTypeAnnotation = function(e3) {
          const t3 = { type: "IntersectionTypeAnnotation", types: e3 }, r3 = a.IntersectionTypeAnnotation;
          return o(r3.types, t3, "types", e3, 1), t3;
        }, t2.jSXAttribute = t2.jsxAttribute = function(e3, t3 = null) {
          const r3 = { type: "JSXAttribute", name: e3, value: t3 }, n2 = a.JSXAttribute;
          return o(n2.name, r3, "name", e3, 1), o(n2.value, r3, "value", t3, 1), r3;
        }, t2.jSXClosingElement = t2.jsxClosingElement = function(e3) {
          const t3 = { type: "JSXClosingElement", name: e3 }, r3 = a.JSXClosingElement;
          return o(r3.name, t3, "name", e3, 1), t3;
        }, t2.jSXClosingFragment = t2.jsxClosingFragment = function() {
          return { type: "JSXClosingFragment" };
        }, t2.jSXElement = t2.jsxElement = function(e3, t3 = null, r3, n2 = null) {
          const s2 = { type: "JSXElement", openingElement: e3, closingElement: t3, children: r3, selfClosing: n2 }, i2 = a.JSXElement;
          return o(i2.openingElement, s2, "openingElement", e3, 1), o(i2.closingElement, s2, "closingElement", t3, 1), o(i2.children, s2, "children", r3, 1), o(i2.selfClosing, s2, "selfClosing", n2), s2;
        }, t2.jSXEmptyExpression = t2.jsxEmptyExpression = function() {
          return { type: "JSXEmptyExpression" };
        }, t2.jSXExpressionContainer = t2.jsxExpressionContainer = function(e3) {
          const t3 = { type: "JSXExpressionContainer", expression: e3 }, r3 = a.JSXExpressionContainer;
          return o(r3.expression, t3, "expression", e3, 1), t3;
        }, t2.jSXFragment = t2.jsxFragment = function(e3, t3, r3) {
          const n2 = { type: "JSXFragment", openingFragment: e3, closingFragment: t3, children: r3 }, s2 = a.JSXFragment;
          return o(s2.openingFragment, n2, "openingFragment", e3, 1), o(s2.closingFragment, n2, "closingFragment", t3, 1), o(s2.children, n2, "children", r3, 1), n2;
        }, t2.jSXIdentifier = t2.jsxIdentifier = function(e3) {
          const t3 = { type: "JSXIdentifier", name: e3 }, r3 = a.JSXIdentifier;
          return o(r3.name, t3, "name", e3), t3;
        }, t2.jSXMemberExpression = t2.jsxMemberExpression = function(e3, t3) {
          const r3 = { type: "JSXMemberExpression", object: e3, property: t3 }, n2 = a.JSXMemberExpression;
          return o(n2.object, r3, "object", e3, 1), o(n2.property, r3, "property", t3, 1), r3;
        }, t2.jSXNamespacedName = t2.jsxNamespacedName = function(e3, t3) {
          const r3 = { type: "JSXNamespacedName", namespace: e3, name: t3 }, n2 = a.JSXNamespacedName;
          return o(n2.namespace, r3, "namespace", e3, 1), o(n2.name, r3, "name", t3, 1), r3;
        }, t2.jSXOpeningElement = t2.jsxOpeningElement = function(e3, t3, r3 = false) {
          const n2 = { type: "JSXOpeningElement", name: e3, attributes: t3, selfClosing: r3 }, s2 = a.JSXOpeningElement;
          return o(s2.name, n2, "name", e3, 1), o(s2.attributes, n2, "attributes", t3, 1), o(s2.selfClosing, n2, "selfClosing", r3), n2;
        }, t2.jSXOpeningFragment = t2.jsxOpeningFragment = function() {
          return { type: "JSXOpeningFragment" };
        }, t2.jSXSpreadAttribute = t2.jsxSpreadAttribute = function(e3) {
          const t3 = { type: "JSXSpreadAttribute", argument: e3 }, r3 = a.JSXSpreadAttribute;
          return o(r3.argument, t3, "argument", e3, 1), t3;
        }, t2.jSXSpreadChild = t2.jsxSpreadChild = function(e3) {
          const t3 = { type: "JSXSpreadChild", expression: e3 }, r3 = a.JSXSpreadChild;
          return o(r3.expression, t3, "expression", e3, 1), t3;
        }, t2.jSXText = t2.jsxText = function(e3) {
          const t3 = { type: "JSXText", value: e3 }, r3 = a.JSXText;
          return o(r3.value, t3, "value", e3), t3;
        }, t2.labeledStatement = function(e3, t3) {
          const r3 = { type: "LabeledStatement", label: e3, body: t3 }, n2 = a.LabeledStatement;
          return o(n2.label, r3, "label", e3, 1), o(n2.body, r3, "body", t3, 1), r3;
        }, t2.logicalExpression = function(e3, t3, r3) {
          const n2 = { type: "LogicalExpression", operator: e3, left: t3, right: r3 }, s2 = a.LogicalExpression;
          return o(s2.operator, n2, "operator", e3), o(s2.left, n2, "left", t3, 1), o(s2.right, n2, "right", r3, 1), n2;
        }, t2.memberExpression = function(e3, t3, r3 = false, n2 = null) {
          const s2 = { type: "MemberExpression", object: e3, property: t3, computed: r3, optional: n2 }, i2 = a.MemberExpression;
          return o(i2.object, s2, "object", e3, 1), o(i2.property, s2, "property", t3, 1), o(i2.computed, s2, "computed", r3), o(i2.optional, s2, "optional", n2), s2;
        }, t2.metaProperty = function(e3, t3) {
          const r3 = { type: "MetaProperty", meta: e3, property: t3 }, n2 = a.MetaProperty;
          return o(n2.meta, r3, "meta", e3, 1), o(n2.property, r3, "property", t3, 1), r3;
        }, t2.mixedTypeAnnotation = function() {
          return { type: "MixedTypeAnnotation" };
        }, t2.moduleExpression = function(e3) {
          const t3 = { type: "ModuleExpression", body: e3 }, r3 = a.ModuleExpression;
          return o(r3.body, t3, "body", e3, 1), t3;
        }, t2.newExpression = function(e3, t3) {
          const r3 = { type: "NewExpression", callee: e3, arguments: t3 }, n2 = a.NewExpression;
          return o(n2.callee, r3, "callee", e3, 1), o(n2.arguments, r3, "arguments", t3, 1), r3;
        }, t2.noop = function() {
          return { type: "Noop" };
        }, t2.nullLiteral = function() {
          return { type: "NullLiteral" };
        }, t2.nullLiteralTypeAnnotation = function() {
          return { type: "NullLiteralTypeAnnotation" };
        }, t2.nullableTypeAnnotation = function(e3) {
          const t3 = { type: "NullableTypeAnnotation", typeAnnotation: e3 }, r3 = a.NullableTypeAnnotation;
          return o(r3.typeAnnotation, t3, "typeAnnotation", e3, 1), t3;
        }, t2.numberLiteral = function(e3) {
          return (0, s.default)("NumberLiteral", "NumericLiteral", "The node type "), numericLiteral(e3);
        }, t2.numberLiteralTypeAnnotation = function(e3) {
          const t3 = { type: "NumberLiteralTypeAnnotation", value: e3 }, r3 = a.NumberLiteralTypeAnnotation;
          return o(r3.value, t3, "value", e3), t3;
        }, t2.numberTypeAnnotation = function() {
          return { type: "NumberTypeAnnotation" };
        }, t2.numericLiteral = numericLiteral, t2.objectExpression = function(e3) {
          const t3 = { type: "ObjectExpression", properties: e3 }, r3 = a.ObjectExpression;
          return o(r3.properties, t3, "properties", e3, 1), t3;
        }, t2.objectMethod = function(e3 = "method", t3, r3, n2, s2 = false, i2 = false, l = false) {
          const p = { type: "ObjectMethod", kind: e3, key: t3, params: r3, body: n2, computed: s2, generator: i2, async: l }, c = a.ObjectMethod;
          return o(c.kind, p, "kind", e3), o(c.key, p, "key", t3, 1), o(c.params, p, "params", r3, 1), o(c.body, p, "body", n2, 1), o(c.computed, p, "computed", s2), o(c.generator, p, "generator", i2), o(c.async, p, "async", l), p;
        }, t2.objectPattern = function(e3) {
          const t3 = { type: "ObjectPattern", properties: e3 }, r3 = a.ObjectPattern;
          return o(r3.properties, t3, "properties", e3, 1), t3;
        }, t2.objectProperty = function(e3, t3, r3 = false, n2 = false, s2 = null) {
          const i2 = { type: "ObjectProperty", key: e3, value: t3, computed: r3, shorthand: n2, decorators: s2 }, l = a.ObjectProperty;
          return o(l.key, i2, "key", e3, 1), o(l.value, i2, "value", t3, 1), o(l.computed, i2, "computed", r3), o(l.shorthand, i2, "shorthand", n2), o(l.decorators, i2, "decorators", s2, 1), i2;
        }, t2.objectTypeAnnotation = function(e3, t3 = [], r3 = [], n2 = [], s2 = false) {
          const i2 = { type: "ObjectTypeAnnotation", properties: e3, indexers: t3, callProperties: r3, internalSlots: n2, exact: s2 }, l = a.ObjectTypeAnnotation;
          return o(l.properties, i2, "properties", e3, 1), o(l.indexers, i2, "indexers", t3, 1), o(l.callProperties, i2, "callProperties", r3, 1), o(l.internalSlots, i2, "internalSlots", n2, 1), o(l.exact, i2, "exact", s2), i2;
        }, t2.objectTypeCallProperty = function(e3) {
          const t3 = { type: "ObjectTypeCallProperty", value: e3, static: null }, r3 = a.ObjectTypeCallProperty;
          return o(r3.value, t3, "value", e3, 1), t3;
        }, t2.objectTypeIndexer = function(e3 = null, t3, r3, n2 = null) {
          const s2 = { type: "ObjectTypeIndexer", id: e3, key: t3, value: r3, variance: n2, static: null }, i2 = a.ObjectTypeIndexer;
          return o(i2.id, s2, "id", e3, 1), o(i2.key, s2, "key", t3, 1), o(i2.value, s2, "value", r3, 1), o(i2.variance, s2, "variance", n2, 1), s2;
        }, t2.objectTypeInternalSlot = function(e3, t3, r3, n2, s2) {
          const i2 = { type: "ObjectTypeInternalSlot", id: e3, value: t3, optional: r3, static: n2, method: s2 }, l = a.ObjectTypeInternalSlot;
          return o(l.id, i2, "id", e3, 1), o(l.value, i2, "value", t3, 1), o(l.optional, i2, "optional", r3), o(l.static, i2, "static", n2), o(l.method, i2, "method", s2), i2;
        }, t2.objectTypeProperty = function(e3, t3, r3 = null) {
          const n2 = { type: "ObjectTypeProperty", key: e3, value: t3, variance: r3, kind: null, method: null, optional: null, proto: null, static: null }, s2 = a.ObjectTypeProperty;
          return o(s2.key, n2, "key", e3, 1), o(s2.value, n2, "value", t3, 1), o(s2.variance, n2, "variance", r3, 1), n2;
        }, t2.objectTypeSpreadProperty = function(e3) {
          const t3 = { type: "ObjectTypeSpreadProperty", argument: e3 }, r3 = a.ObjectTypeSpreadProperty;
          return o(r3.argument, t3, "argument", e3, 1), t3;
        }, t2.opaqueType = function(e3, t3 = null, r3 = null, n2) {
          const s2 = { type: "OpaqueType", id: e3, typeParameters: t3, supertype: r3, impltype: n2 }, i2 = a.OpaqueType;
          return o(i2.id, s2, "id", e3, 1), o(i2.typeParameters, s2, "typeParameters", t3, 1), o(i2.supertype, s2, "supertype", r3, 1), o(i2.impltype, s2, "impltype", n2, 1), s2;
        }, t2.optionalCallExpression = function(e3, t3, r3) {
          const n2 = { type: "OptionalCallExpression", callee: e3, arguments: t3, optional: r3 }, s2 = a.OptionalCallExpression;
          return o(s2.callee, n2, "callee", e3, 1), o(s2.arguments, n2, "arguments", t3, 1), o(s2.optional, n2, "optional", r3), n2;
        }, t2.optionalIndexedAccessType = function(e3, t3) {
          const r3 = { type: "OptionalIndexedAccessType", objectType: e3, indexType: t3, optional: null }, n2 = a.OptionalIndexedAccessType;
          return o(n2.objectType, r3, "objectType", e3, 1), o(n2.indexType, r3, "indexType", t3, 1), r3;
        }, t2.optionalMemberExpression = function(e3, t3, r3 = false, n2) {
          const s2 = { type: "OptionalMemberExpression", object: e3, property: t3, computed: r3, optional: n2 }, i2 = a.OptionalMemberExpression;
          return o(i2.object, s2, "object", e3, 1), o(i2.property, s2, "property", t3, 1), o(i2.computed, s2, "computed", r3), o(i2.optional, s2, "optional", n2), s2;
        }, t2.parenthesizedExpression = function(e3) {
          const t3 = { type: "ParenthesizedExpression", expression: e3 }, r3 = a.ParenthesizedExpression;
          return o(r3.expression, t3, "expression", e3, 1), t3;
        }, t2.pipelineBareFunction = function(e3) {
          const t3 = { type: "PipelineBareFunction", callee: e3 }, r3 = a.PipelineBareFunction;
          return o(r3.callee, t3, "callee", e3, 1), t3;
        }, t2.pipelinePrimaryTopicReference = function() {
          return { type: "PipelinePrimaryTopicReference" };
        }, t2.pipelineTopicExpression = function(e3) {
          const t3 = { type: "PipelineTopicExpression", expression: e3 }, r3 = a.PipelineTopicExpression;
          return o(r3.expression, t3, "expression", e3, 1), t3;
        }, t2.placeholder = function(e3, t3) {
          const r3 = { type: "Placeholder", expectedNode: e3, name: t3 }, n2 = a.Placeholder;
          return o(n2.expectedNode, r3, "expectedNode", e3), o(n2.name, r3, "name", t3, 1), r3;
        }, t2.privateName = function(e3) {
          const t3 = { type: "PrivateName", id: e3 }, r3 = a.PrivateName;
          return o(r3.id, t3, "id", e3, 1), t3;
        }, t2.program = function(e3, t3 = [], r3 = "script", n2 = null) {
          const s2 = { type: "Program", body: e3, directives: t3, sourceType: r3, interpreter: n2 }, i2 = a.Program;
          return o(i2.body, s2, "body", e3, 1), o(i2.directives, s2, "directives", t3, 1), o(i2.sourceType, s2, "sourceType", r3), o(i2.interpreter, s2, "interpreter", n2, 1), s2;
        }, t2.qualifiedTypeIdentifier = function(e3, t3) {
          const r3 = { type: "QualifiedTypeIdentifier", id: e3, qualification: t3 }, n2 = a.QualifiedTypeIdentifier;
          return o(n2.id, r3, "id", e3, 1), o(n2.qualification, r3, "qualification", t3, 1), r3;
        }, t2.recordExpression = function(e3) {
          const t3 = { type: "RecordExpression", properties: e3 }, r3 = a.RecordExpression;
          return o(r3.properties, t3, "properties", e3, 1), t3;
        }, t2.regExpLiteral = regExpLiteral, t2.regexLiteral = function(e3, t3 = "") {
          return (0, s.default)("RegexLiteral", "RegExpLiteral", "The node type "), regExpLiteral(e3, t3);
        }, t2.restElement = restElement, t2.restProperty = function(e3) {
          return (0, s.default)("RestProperty", "RestElement", "The node type "), restElement(e3);
        }, t2.returnStatement = function(e3 = null) {
          const t3 = { type: "ReturnStatement", argument: e3 }, r3 = a.ReturnStatement;
          return o(r3.argument, t3, "argument", e3, 1), t3;
        }, t2.sequenceExpression = function(e3) {
          const t3 = { type: "SequenceExpression", expressions: e3 }, r3 = a.SequenceExpression;
          return o(r3.expressions, t3, "expressions", e3, 1), t3;
        }, t2.spreadElement = spreadElement, t2.spreadProperty = function(e3) {
          return (0, s.default)("SpreadProperty", "SpreadElement", "The node type "), spreadElement(e3);
        }, t2.staticBlock = function(e3) {
          const t3 = { type: "StaticBlock", body: e3 }, r3 = a.StaticBlock;
          return o(r3.body, t3, "body", e3, 1), t3;
        }, t2.stringLiteral = function(e3) {
          const t3 = { type: "StringLiteral", value: e3 }, r3 = a.StringLiteral;
          return o(r3.value, t3, "value", e3), t3;
        }, t2.stringLiteralTypeAnnotation = function(e3) {
          const t3 = { type: "StringLiteralTypeAnnotation", value: e3 }, r3 = a.StringLiteralTypeAnnotation;
          return o(r3.value, t3, "value", e3), t3;
        }, t2.stringTypeAnnotation = function() {
          return { type: "StringTypeAnnotation" };
        }, t2.super = function() {
          return { type: "Super" };
        }, t2.switchCase = function(e3 = null, t3) {
          const r3 = { type: "SwitchCase", test: e3, consequent: t3 }, n2 = a.SwitchCase;
          return o(n2.test, r3, "test", e3, 1), o(n2.consequent, r3, "consequent", t3, 1), r3;
        }, t2.switchStatement = function(e3, t3) {
          const r3 = { type: "SwitchStatement", discriminant: e3, cases: t3 }, n2 = a.SwitchStatement;
          return o(n2.discriminant, r3, "discriminant", e3, 1), o(n2.cases, r3, "cases", t3, 1), r3;
        }, t2.symbolTypeAnnotation = function() {
          return { type: "SymbolTypeAnnotation" };
        }, t2.taggedTemplateExpression = function(e3, t3) {
          const r3 = { type: "TaggedTemplateExpression", tag: e3, quasi: t3 }, n2 = a.TaggedTemplateExpression;
          return o(n2.tag, r3, "tag", e3, 1), o(n2.quasi, r3, "quasi", t3, 1), r3;
        }, t2.templateElement = function(e3, t3 = false) {
          const r3 = { type: "TemplateElement", value: e3, tail: t3 }, n2 = a.TemplateElement;
          return o(n2.value, r3, "value", e3), o(n2.tail, r3, "tail", t3), r3;
        }, t2.templateLiteral = function(e3, t3) {
          const r3 = { type: "TemplateLiteral", quasis: e3, expressions: t3 }, n2 = a.TemplateLiteral;
          return o(n2.quasis, r3, "quasis", e3, 1), o(n2.expressions, r3, "expressions", t3, 1), r3;
        }, t2.thisExpression = function() {
          return { type: "ThisExpression" };
        }, t2.thisTypeAnnotation = function() {
          return { type: "ThisTypeAnnotation" };
        }, t2.throwStatement = function(e3) {
          const t3 = { type: "ThrowStatement", argument: e3 }, r3 = a.ThrowStatement;
          return o(r3.argument, t3, "argument", e3, 1), t3;
        }, t2.topicReference = function() {
          return { type: "TopicReference" };
        }, t2.tryStatement = function(e3, t3 = null, r3 = null) {
          const n2 = { type: "TryStatement", block: e3, handler: t3, finalizer: r3 }, s2 = a.TryStatement;
          return o(s2.block, n2, "block", e3, 1), o(s2.handler, n2, "handler", t3, 1), o(s2.finalizer, n2, "finalizer", r3, 1), n2;
        }, t2.tSAnyKeyword = t2.tsAnyKeyword = function() {
          return { type: "TSAnyKeyword" };
        }, t2.tSArrayType = t2.tsArrayType = function(e3) {
          const t3 = { type: "TSArrayType", elementType: e3 }, r3 = a.TSArrayType;
          return o(r3.elementType, t3, "elementType", e3, 1), t3;
        }, t2.tSAsExpression = t2.tsAsExpression = function(e3, t3) {
          const r3 = { type: "TSAsExpression", expression: e3, typeAnnotation: t3 }, n2 = a.TSAsExpression;
          return o(n2.expression, r3, "expression", e3, 1), o(n2.typeAnnotation, r3, "typeAnnotation", t3, 1), r3;
        }, t2.tSBigIntKeyword = t2.tsBigIntKeyword = function() {
          return { type: "TSBigIntKeyword" };
        }, t2.tSBooleanKeyword = t2.tsBooleanKeyword = function() {
          return { type: "TSBooleanKeyword" };
        }, t2.tSCallSignatureDeclaration = t2.tsCallSignatureDeclaration = function(e3 = null, t3, r3 = null) {
          const n2 = { type: "TSCallSignatureDeclaration", typeParameters: e3, parameters: t3, typeAnnotation: r3 }, s2 = a.TSCallSignatureDeclaration;
          return o(s2.typeParameters, n2, "typeParameters", e3, 1), o(s2.parameters, n2, "parameters", t3, 1), o(s2.typeAnnotation, n2, "typeAnnotation", r3, 1), n2;
        }, t2.tSConditionalType = t2.tsConditionalType = function(e3, t3, r3, n2) {
          const s2 = { type: "TSConditionalType", checkType: e3, extendsType: t3, trueType: r3, falseType: n2 }, i2 = a.TSConditionalType;
          return o(i2.checkType, s2, "checkType", e3, 1), o(i2.extendsType, s2, "extendsType", t3, 1), o(i2.trueType, s2, "trueType", r3, 1), o(i2.falseType, s2, "falseType", n2, 1), s2;
        }, t2.tSConstructSignatureDeclaration = t2.tsConstructSignatureDeclaration = function(e3 = null, t3, r3 = null) {
          const n2 = { type: "TSConstructSignatureDeclaration", typeParameters: e3, parameters: t3, typeAnnotation: r3 }, s2 = a.TSConstructSignatureDeclaration;
          return o(s2.typeParameters, n2, "typeParameters", e3, 1), o(s2.parameters, n2, "parameters", t3, 1), o(s2.typeAnnotation, n2, "typeAnnotation", r3, 1), n2;
        }, t2.tSConstructorType = t2.tsConstructorType = function(e3 = null, t3, r3 = null) {
          const n2 = { type: "TSConstructorType", typeParameters: e3, parameters: t3, typeAnnotation: r3 }, s2 = a.TSConstructorType;
          return o(s2.typeParameters, n2, "typeParameters", e3, 1), o(s2.parameters, n2, "parameters", t3, 1), o(s2.typeAnnotation, n2, "typeAnnotation", r3, 1), n2;
        }, t2.tSDeclareFunction = t2.tsDeclareFunction = function(e3 = null, t3 = null, r3, n2 = null) {
          const s2 = { type: "TSDeclareFunction", id: e3, typeParameters: t3, params: r3, returnType: n2 }, i2 = a.TSDeclareFunction;
          return o(i2.id, s2, "id", e3, 1), o(i2.typeParameters, s2, "typeParameters", t3, 1), o(i2.params, s2, "params", r3, 1), o(i2.returnType, s2, "returnType", n2, 1), s2;
        }, t2.tSDeclareMethod = t2.tsDeclareMethod = function(e3 = null, t3, r3 = null, n2, s2 = null) {
          const i2 = { type: "TSDeclareMethod", decorators: e3, key: t3, typeParameters: r3, params: n2, returnType: s2 }, l = a.TSDeclareMethod;
          return o(l.decorators, i2, "decorators", e3, 1), o(l.key, i2, "key", t3, 1), o(l.typeParameters, i2, "typeParameters", r3, 1), o(l.params, i2, "params", n2, 1), o(l.returnType, i2, "returnType", s2, 1), i2;
        }, t2.tSEnumBody = t2.tsEnumBody = function(e3) {
          const t3 = { type: "TSEnumBody", members: e3 }, r3 = a.TSEnumBody;
          return o(r3.members, t3, "members", e3, 1), t3;
        }, t2.tSEnumDeclaration = t2.tsEnumDeclaration = function(e3, t3) {
          const r3 = { type: "TSEnumDeclaration", id: e3, members: t3 }, n2 = a.TSEnumDeclaration;
          return o(n2.id, r3, "id", e3, 1), o(n2.members, r3, "members", t3, 1), r3;
        }, t2.tSEnumMember = t2.tsEnumMember = function(e3, t3 = null) {
          const r3 = { type: "TSEnumMember", id: e3, initializer: t3 }, n2 = a.TSEnumMember;
          return o(n2.id, r3, "id", e3, 1), o(n2.initializer, r3, "initializer", t3, 1), r3;
        }, t2.tSExportAssignment = t2.tsExportAssignment = function(e3) {
          const t3 = { type: "TSExportAssignment", expression: e3 }, r3 = a.TSExportAssignment;
          return o(r3.expression, t3, "expression", e3, 1), t3;
        }, t2.tSExpressionWithTypeArguments = t2.tsExpressionWithTypeArguments = function(e3, t3 = null) {
          const r3 = { type: "TSExpressionWithTypeArguments", expression: e3, typeParameters: t3 }, n2 = a.TSExpressionWithTypeArguments;
          return o(n2.expression, r3, "expression", e3, 1), o(n2.typeParameters, r3, "typeParameters", t3, 1), r3;
        }, t2.tSExternalModuleReference = t2.tsExternalModuleReference = function(e3) {
          const t3 = { type: "TSExternalModuleReference", expression: e3 }, r3 = a.TSExternalModuleReference;
          return o(r3.expression, t3, "expression", e3, 1), t3;
        }, t2.tSFunctionType = t2.tsFunctionType = function(e3 = null, t3, r3 = null) {
          const n2 = { type: "TSFunctionType", typeParameters: e3, parameters: t3, typeAnnotation: r3 }, s2 = a.TSFunctionType;
          return o(s2.typeParameters, n2, "typeParameters", e3, 1), o(s2.parameters, n2, "parameters", t3, 1), o(s2.typeAnnotation, n2, "typeAnnotation", r3, 1), n2;
        }, t2.tSImportEqualsDeclaration = t2.tsImportEqualsDeclaration = function(e3, t3) {
          const r3 = { type: "TSImportEqualsDeclaration", id: e3, moduleReference: t3, isExport: null }, n2 = a.TSImportEqualsDeclaration;
          return o(n2.id, r3, "id", e3, 1), o(n2.moduleReference, r3, "moduleReference", t3, 1), r3;
        }, t2.tSImportType = t2.tsImportType = function(e3, t3 = null, r3 = null) {
          const n2 = { type: "TSImportType", argument: e3, qualifier: t3, typeParameters: r3 }, s2 = a.TSImportType;
          return o(s2.argument, n2, "argument", e3, 1), o(s2.qualifier, n2, "qualifier", t3, 1), o(s2.typeParameters, n2, "typeParameters", r3, 1), n2;
        }, t2.tSIndexSignature = t2.tsIndexSignature = function(e3, t3 = null) {
          const r3 = { type: "TSIndexSignature", parameters: e3, typeAnnotation: t3 }, n2 = a.TSIndexSignature;
          return o(n2.parameters, r3, "parameters", e3, 1), o(n2.typeAnnotation, r3, "typeAnnotation", t3, 1), r3;
        }, t2.tSIndexedAccessType = t2.tsIndexedAccessType = function(e3, t3) {
          const r3 = { type: "TSIndexedAccessType", objectType: e3, indexType: t3 }, n2 = a.TSIndexedAccessType;
          return o(n2.objectType, r3, "objectType", e3, 1), o(n2.indexType, r3, "indexType", t3, 1), r3;
        }, t2.tSInferType = t2.tsInferType = function(e3) {
          const t3 = { type: "TSInferType", typeParameter: e3 }, r3 = a.TSInferType;
          return o(r3.typeParameter, t3, "typeParameter", e3, 1), t3;
        }, t2.tSInstantiationExpression = t2.tsInstantiationExpression = function(e3, t3 = null) {
          const r3 = { type: "TSInstantiationExpression", expression: e3, typeParameters: t3 }, n2 = a.TSInstantiationExpression;
          return o(n2.expression, r3, "expression", e3, 1), o(n2.typeParameters, r3, "typeParameters", t3, 1), r3;
        }, t2.tSInterfaceBody = t2.tsInterfaceBody = function(e3) {
          const t3 = { type: "TSInterfaceBody", body: e3 }, r3 = a.TSInterfaceBody;
          return o(r3.body, t3, "body", e3, 1), t3;
        }, t2.tSInterfaceDeclaration = t2.tsInterfaceDeclaration = function(e3, t3 = null, r3 = null, n2) {
          const s2 = { type: "TSInterfaceDeclaration", id: e3, typeParameters: t3, extends: r3, body: n2 }, i2 = a.TSInterfaceDeclaration;
          return o(i2.id, s2, "id", e3, 1), o(i2.typeParameters, s2, "typeParameters", t3, 1), o(i2.extends, s2, "extends", r3, 1), o(i2.body, s2, "body", n2, 1), s2;
        }, t2.tSIntersectionType = t2.tsIntersectionType = function(e3) {
          const t3 = { type: "TSIntersectionType", types: e3 }, r3 = a.TSIntersectionType;
          return o(r3.types, t3, "types", e3, 1), t3;
        }, t2.tSIntrinsicKeyword = t2.tsIntrinsicKeyword = function() {
          return { type: "TSIntrinsicKeyword" };
        }, t2.tSLiteralType = t2.tsLiteralType = function(e3) {
          const t3 = { type: "TSLiteralType", literal: e3 }, r3 = a.TSLiteralType;
          return o(r3.literal, t3, "literal", e3, 1), t3;
        }, t2.tSMappedType = t2.tsMappedType = function(e3, t3 = null, r3 = null) {
          const n2 = { type: "TSMappedType", typeParameter: e3, typeAnnotation: t3, nameType: r3 }, s2 = a.TSMappedType;
          return o(s2.typeParameter, n2, "typeParameter", e3, 1), o(s2.typeAnnotation, n2, "typeAnnotation", t3, 1), o(s2.nameType, n2, "nameType", r3, 1), n2;
        }, t2.tSMethodSignature = t2.tsMethodSignature = function(e3, t3 = null, r3, n2 = null) {
          const s2 = { type: "TSMethodSignature", key: e3, typeParameters: t3, parameters: r3, typeAnnotation: n2, kind: null }, i2 = a.TSMethodSignature;
          return o(i2.key, s2, "key", e3, 1), o(i2.typeParameters, s2, "typeParameters", t3, 1), o(i2.parameters, s2, "parameters", r3, 1), o(i2.typeAnnotation, s2, "typeAnnotation", n2, 1), s2;
        }, t2.tSModuleBlock = t2.tsModuleBlock = function(e3) {
          const t3 = { type: "TSModuleBlock", body: e3 }, r3 = a.TSModuleBlock;
          return o(r3.body, t3, "body", e3, 1), t3;
        }, t2.tSModuleDeclaration = t2.tsModuleDeclaration = function(e3, t3) {
          const r3 = { type: "TSModuleDeclaration", id: e3, body: t3, kind: null }, n2 = a.TSModuleDeclaration;
          return o(n2.id, r3, "id", e3, 1), o(n2.body, r3, "body", t3, 1), r3;
        }, t2.tSNamedTupleMember = t2.tsNamedTupleMember = function(e3, t3, r3 = false) {
          const n2 = { type: "TSNamedTupleMember", label: e3, elementType: t3, optional: r3 }, s2 = a.TSNamedTupleMember;
          return o(s2.label, n2, "label", e3, 1), o(s2.elementType, n2, "elementType", t3, 1), o(s2.optional, n2, "optional", r3), n2;
        }, t2.tSNamespaceExportDeclaration = t2.tsNamespaceExportDeclaration = function(e3) {
          const t3 = { type: "TSNamespaceExportDeclaration", id: e3 }, r3 = a.TSNamespaceExportDeclaration;
          return o(r3.id, t3, "id", e3, 1), t3;
        }, t2.tSNeverKeyword = t2.tsNeverKeyword = function() {
          return { type: "TSNeverKeyword" };
        }, t2.tSNonNullExpression = t2.tsNonNullExpression = function(e3) {
          const t3 = { type: "TSNonNullExpression", expression: e3 }, r3 = a.TSNonNullExpression;
          return o(r3.expression, t3, "expression", e3, 1), t3;
        }, t2.tSNullKeyword = t2.tsNullKeyword = function() {
          return { type: "TSNullKeyword" };
        }, t2.tSNumberKeyword = t2.tsNumberKeyword = function() {
          return { type: "TSNumberKeyword" };
        }, t2.tSObjectKeyword = t2.tsObjectKeyword = function() {
          return { type: "TSObjectKeyword" };
        }, t2.tSOptionalType = t2.tsOptionalType = function(e3) {
          const t3 = { type: "TSOptionalType", typeAnnotation: e3 }, r3 = a.TSOptionalType;
          return o(r3.typeAnnotation, t3, "typeAnnotation", e3, 1), t3;
        }, t2.tSParameterProperty = t2.tsParameterProperty = function(e3) {
          const t3 = { type: "TSParameterProperty", parameter: e3 }, r3 = a.TSParameterProperty;
          return o(r3.parameter, t3, "parameter", e3, 1), t3;
        }, t2.tSParenthesizedType = t2.tsParenthesizedType = function(e3) {
          const t3 = { type: "TSParenthesizedType", typeAnnotation: e3 }, r3 = a.TSParenthesizedType;
          return o(r3.typeAnnotation, t3, "typeAnnotation", e3, 1), t3;
        }, t2.tSPropertySignature = t2.tsPropertySignature = function(e3, t3 = null) {
          const r3 = { type: "TSPropertySignature", key: e3, typeAnnotation: t3 }, n2 = a.TSPropertySignature;
          return o(n2.key, r3, "key", e3, 1), o(n2.typeAnnotation, r3, "typeAnnotation", t3, 1), r3;
        }, t2.tSQualifiedName = t2.tsQualifiedName = function(e3, t3) {
          const r3 = { type: "TSQualifiedName", left: e3, right: t3 }, n2 = a.TSQualifiedName;
          return o(n2.left, r3, "left", e3, 1), o(n2.right, r3, "right", t3, 1), r3;
        }, t2.tSRestType = t2.tsRestType = function(e3) {
          const t3 = { type: "TSRestType", typeAnnotation: e3 }, r3 = a.TSRestType;
          return o(r3.typeAnnotation, t3, "typeAnnotation", e3, 1), t3;
        }, t2.tSSatisfiesExpression = t2.tsSatisfiesExpression = function(e3, t3) {
          const r3 = { type: "TSSatisfiesExpression", expression: e3, typeAnnotation: t3 }, n2 = a.TSSatisfiesExpression;
          return o(n2.expression, r3, "expression", e3, 1), o(n2.typeAnnotation, r3, "typeAnnotation", t3, 1), r3;
        }, t2.tSStringKeyword = t2.tsStringKeyword = function() {
          return { type: "TSStringKeyword" };
        }, t2.tSSymbolKeyword = t2.tsSymbolKeyword = function() {
          return { type: "TSSymbolKeyword" };
        }, t2.tSTemplateLiteralType = t2.tsTemplateLiteralType = function(e3, t3) {
          const r3 = { type: "TSTemplateLiteralType", quasis: e3, types: t3 }, n2 = a.TSTemplateLiteralType;
          return o(n2.quasis, r3, "quasis", e3, 1), o(n2.types, r3, "types", t3, 1), r3;
        }, t2.tSThisType = t2.tsThisType = function() {
          return { type: "TSThisType" };
        }, t2.tSTupleType = t2.tsTupleType = function(e3) {
          const t3 = { type: "TSTupleType", elementTypes: e3 }, r3 = a.TSTupleType;
          return o(r3.elementTypes, t3, "elementTypes", e3, 1), t3;
        }, t2.tSTypeAliasDeclaration = t2.tsTypeAliasDeclaration = function(e3, t3 = null, r3) {
          const n2 = { type: "TSTypeAliasDeclaration", id: e3, typeParameters: t3, typeAnnotation: r3 }, s2 = a.TSTypeAliasDeclaration;
          return o(s2.id, n2, "id", e3, 1), o(s2.typeParameters, n2, "typeParameters", t3, 1), o(s2.typeAnnotation, n2, "typeAnnotation", r3, 1), n2;
        }, t2.tSTypeAnnotation = t2.tsTypeAnnotation = function(e3) {
          const t3 = { type: "TSTypeAnnotation", typeAnnotation: e3 }, r3 = a.TSTypeAnnotation;
          return o(r3.typeAnnotation, t3, "typeAnnotation", e3, 1), t3;
        }, t2.tSTypeAssertion = t2.tsTypeAssertion = function(e3, t3) {
          const r3 = { type: "TSTypeAssertion", typeAnnotation: e3, expression: t3 }, n2 = a.TSTypeAssertion;
          return o(n2.typeAnnotation, r3, "typeAnnotation", e3, 1), o(n2.expression, r3, "expression", t3, 1), r3;
        }, t2.tSTypeLiteral = t2.tsTypeLiteral = function(e3) {
          const t3 = { type: "TSTypeLiteral", members: e3 }, r3 = a.TSTypeLiteral;
          return o(r3.members, t3, "members", e3, 1), t3;
        }, t2.tSTypeOperator = t2.tsTypeOperator = function(e3, t3 = "keyof") {
          const r3 = { type: "TSTypeOperator", typeAnnotation: e3, operator: t3 }, n2 = a.TSTypeOperator;
          return o(n2.typeAnnotation, r3, "typeAnnotation", e3, 1), o(n2.operator, r3, "operator", t3), r3;
        }, t2.tSTypeParameter = t2.tsTypeParameter = function(e3 = null, t3 = null, r3) {
          const n2 = { type: "TSTypeParameter", constraint: e3, default: t3, name: r3 }, s2 = a.TSTypeParameter;
          return o(s2.constraint, n2, "constraint", e3, 1), o(s2.default, n2, "default", t3, 1), o(s2.name, n2, "name", r3), n2;
        }, t2.tSTypeParameterDeclaration = t2.tsTypeParameterDeclaration = function(e3) {
          const t3 = { type: "TSTypeParameterDeclaration", params: e3 }, r3 = a.TSTypeParameterDeclaration;
          return o(r3.params, t3, "params", e3, 1), t3;
        }, t2.tSTypeParameterInstantiation = t2.tsTypeParameterInstantiation = function(e3) {
          const t3 = { type: "TSTypeParameterInstantiation", params: e3 }, r3 = a.TSTypeParameterInstantiation;
          return o(r3.params, t3, "params", e3, 1), t3;
        }, t2.tSTypePredicate = t2.tsTypePredicate = function(e3, t3 = null, r3 = null) {
          const n2 = { type: "TSTypePredicate", parameterName: e3, typeAnnotation: t3, asserts: r3 }, s2 = a.TSTypePredicate;
          return o(s2.parameterName, n2, "parameterName", e3, 1), o(s2.typeAnnotation, n2, "typeAnnotation", t3, 1), o(s2.asserts, n2, "asserts", r3), n2;
        }, t2.tSTypeQuery = t2.tsTypeQuery = function(e3, t3 = null) {
          const r3 = { type: "TSTypeQuery", exprName: e3, typeParameters: t3 }, n2 = a.TSTypeQuery;
          return o(n2.exprName, r3, "exprName", e3, 1), o(n2.typeParameters, r3, "typeParameters", t3, 1), r3;
        }, t2.tSTypeReference = t2.tsTypeReference = function(e3, t3 = null) {
          const r3 = { type: "TSTypeReference", typeName: e3, typeParameters: t3 }, n2 = a.TSTypeReference;
          return o(n2.typeName, r3, "typeName", e3, 1), o(n2.typeParameters, r3, "typeParameters", t3, 1), r3;
        }, t2.tSUndefinedKeyword = t2.tsUndefinedKeyword = function() {
          return { type: "TSUndefinedKeyword" };
        }, t2.tSUnionType = t2.tsUnionType = function(e3) {
          const t3 = { type: "TSUnionType", types: e3 }, r3 = a.TSUnionType;
          return o(r3.types, t3, "types", e3, 1), t3;
        }, t2.tSUnknownKeyword = t2.tsUnknownKeyword = function() {
          return { type: "TSUnknownKeyword" };
        }, t2.tSVoidKeyword = t2.tsVoidKeyword = function() {
          return { type: "TSVoidKeyword" };
        }, t2.tupleExpression = function(e3 = []) {
          const t3 = { type: "TupleExpression", elements: e3 }, r3 = a.TupleExpression;
          return o(r3.elements, t3, "elements", e3, 1), t3;
        }, t2.tupleTypeAnnotation = function(e3) {
          const t3 = { type: "TupleTypeAnnotation", types: e3 }, r3 = a.TupleTypeAnnotation;
          return o(r3.types, t3, "types", e3, 1), t3;
        }, t2.typeAlias = function(e3, t3 = null, r3) {
          const n2 = { type: "TypeAlias", id: e3, typeParameters: t3, right: r3 }, s2 = a.TypeAlias;
          return o(s2.id, n2, "id", e3, 1), o(s2.typeParameters, n2, "typeParameters", t3, 1), o(s2.right, n2, "right", r3, 1), n2;
        }, t2.typeAnnotation = function(e3) {
          const t3 = { type: "TypeAnnotation", typeAnnotation: e3 }, r3 = a.TypeAnnotation;
          return o(r3.typeAnnotation, t3, "typeAnnotation", e3, 1), t3;
        }, t2.typeCastExpression = function(e3, t3) {
          const r3 = { type: "TypeCastExpression", expression: e3, typeAnnotation: t3 }, n2 = a.TypeCastExpression;
          return o(n2.expression, r3, "expression", e3, 1), o(n2.typeAnnotation, r3, "typeAnnotation", t3, 1), r3;
        }, t2.typeParameter = function(e3 = null, t3 = null, r3 = null) {
          const n2 = { type: "TypeParameter", bound: e3, default: t3, variance: r3, name: null }, s2 = a.TypeParameter;
          return o(s2.bound, n2, "bound", e3, 1), o(s2.default, n2, "default", t3, 1), o(s2.variance, n2, "variance", r3, 1), n2;
        }, t2.typeParameterDeclaration = function(e3) {
          const t3 = { type: "TypeParameterDeclaration", params: e3 }, r3 = a.TypeParameterDeclaration;
          return o(r3.params, t3, "params", e3, 1), t3;
        }, t2.typeParameterInstantiation = function(e3) {
          const t3 = { type: "TypeParameterInstantiation", params: e3 }, r3 = a.TypeParameterInstantiation;
          return o(r3.params, t3, "params", e3, 1), t3;
        }, t2.typeofTypeAnnotation = function(e3) {
          const t3 = { type: "TypeofTypeAnnotation", argument: e3 }, r3 = a.TypeofTypeAnnotation;
          return o(r3.argument, t3, "argument", e3, 1), t3;
        }, t2.unaryExpression = function(e3, t3, r3 = true) {
          const n2 = { type: "UnaryExpression", operator: e3, argument: t3, prefix: r3 }, s2 = a.UnaryExpression;
          return o(s2.operator, n2, "operator", e3), o(s2.argument, n2, "argument", t3, 1), o(s2.prefix, n2, "prefix", r3), n2;
        }, t2.unionTypeAnnotation = function(e3) {
          const t3 = { type: "UnionTypeAnnotation", types: e3 }, r3 = a.UnionTypeAnnotation;
          return o(r3.types, t3, "types", e3, 1), t3;
        }, t2.updateExpression = function(e3, t3, r3 = false) {
          const n2 = { type: "UpdateExpression", operator: e3, argument: t3, prefix: r3 }, s2 = a.UpdateExpression;
          return o(s2.operator, n2, "operator", e3), o(s2.argument, n2, "argument", t3, 1), o(s2.prefix, n2, "prefix", r3), n2;
        }, t2.v8IntrinsicIdentifier = function(e3) {
          const t3 = { type: "V8IntrinsicIdentifier", name: e3 }, r3 = a.V8IntrinsicIdentifier;
          return o(r3.name, t3, "name", e3), t3;
        }, t2.variableDeclaration = function(e3, t3) {
          const r3 = { type: "VariableDeclaration", kind: e3, declarations: t3 }, n2 = a.VariableDeclaration;
          return o(n2.kind, r3, "kind", e3), o(n2.declarations, r3, "declarations", t3, 1), r3;
        }, t2.variableDeclarator = function(e3, t3 = null) {
          const r3 = { type: "VariableDeclarator", id: e3, init: t3 }, n2 = a.VariableDeclarator;
          return o(n2.id, r3, "id", e3, 1), o(n2.init, r3, "init", t3, 1), r3;
        }, t2.variance = function(e3) {
          const t3 = { type: "Variance", kind: e3 }, r3 = a.Variance;
          return o(r3.kind, t3, "kind", e3), t3;
        }, t2.voidPattern = function() {
          return { type: "VoidPattern" };
        }, t2.voidTypeAnnotation = function() {
          return { type: "VoidTypeAnnotation" };
        }, t2.whileStatement = function(e3, t3) {
          const r3 = { type: "WhileStatement", test: e3, body: t3 }, n2 = a.WhileStatement;
          return o(n2.test, r3, "test", e3, 1), o(n2.body, r3, "body", t3, 1), r3;
        }, t2.withStatement = function(e3, t3) {
          const r3 = { type: "WithStatement", object: e3, body: t3 }, n2 = a.WithStatement;
          return o(n2.object, r3, "object", e3, 1), o(n2.body, r3, "body", t3, 1), r3;
        }, t2.yieldExpression = function(e3 = null, t3 = false) {
          const r3 = { type: "YieldExpression", argument: e3, delegate: t3 }, n2 = a.YieldExpression;
          return o(n2.argument, r3, "argument", e3, 1), o(n2.delegate, r3, "delegate", t3), r3;
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/validate.js"), s = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/utils/deprecationWarning.js"), i = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/definitions/utils.js");
        const { validateInternal: o } = n, { NODE_FIELDS: a } = i;
        function numericLiteral(e3) {
          const t3 = { type: "NumericLiteral", value: e3 }, r3 = a.NumericLiteral;
          return o(r3.value, t3, "value", e3), t3;
        }
        function regExpLiteral(e3, t3 = "") {
          const r3 = { type: "RegExpLiteral", pattern: e3, flags: t3 }, n2 = a.RegExpLiteral;
          return o(n2.pattern, r3, "pattern", e3), o(n2.flags, r3, "flags", t3), r3;
        }
        function restElement(e3) {
          const t3 = { type: "RestElement", argument: e3 }, r3 = a.RestElement;
          return o(r3.argument, t3, "argument", e3, 1), t3;
        }
        function spreadElement(e3) {
          const t3 = { type: "SpreadElement", argument: e3 }, r3 = a.SpreadElement;
          return o(r3.argument, t3, "argument", e3, 1), t3;
        }
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/builders/generated/uppercase.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.JSXIdentifier = t2.JSXFragment = t2.JSXExpressionContainer = t2.JSXEmptyExpression = t2.JSXElement = t2.JSXClosingFragment = t2.JSXClosingElement = t2.JSXAttribute = t2.IntersectionTypeAnnotation = t2.InterpreterDirective = t2.InterfaceTypeAnnotation = t2.InterfaceExtends = t2.InterfaceDeclaration = t2.InferredPredicate = t2.IndexedAccessType = t2.ImportSpecifier = t2.ImportNamespaceSpecifier = t2.ImportExpression = t2.ImportDefaultSpecifier = t2.ImportDeclaration = t2.ImportAttribute = t2.Import = t2.IfStatement = t2.Identifier = t2.GenericTypeAnnotation = t2.FunctionTypeParam = t2.FunctionTypeAnnotation = t2.FunctionExpression = t2.FunctionDeclaration = t2.ForStatement = t2.ForOfStatement = t2.ForInStatement = t2.File = t2.ExpressionStatement = t2.ExportSpecifier = t2.ExportNamespaceSpecifier = t2.ExportNamedDeclaration = t2.ExportDefaultSpecifier = t2.ExportDefaultDeclaration = t2.ExportAllDeclaration = t2.ExistsTypeAnnotation = t2.EnumSymbolBody = t2.EnumStringMember = t2.EnumStringBody = t2.EnumNumberMember = t2.EnumNumberBody = t2.EnumDefaultedMember = t2.EnumDeclaration = t2.EnumBooleanMember = t2.EnumBooleanBody = t2.EmptyTypeAnnotation = t2.EmptyStatement = t2.DoWhileStatement = t2.DoExpression = t2.DirectiveLiteral = t2.Directive = t2.Decorator = t2.DeclaredPredicate = t2.DeclareVariable = t2.DeclareTypeAlias = t2.DeclareOpaqueType = t2.DeclareModuleExports = t2.DeclareModule = t2.DeclareInterface = t2.DeclareFunction = t2.DeclareExportDeclaration = t2.DeclareExportAllDeclaration = t2.DeclareClass = t2.DecimalLiteral = t2.DebuggerStatement = t2.ContinueStatement = t2.ConditionalExpression = t2.ClassProperty = t2.ClassPrivateProperty = t2.ClassPrivateMethod = t2.ClassMethod = t2.ClassImplements = t2.ClassExpression = t2.ClassDeclaration = t2.ClassBody = t2.ClassAccessorProperty = t2.CatchClause = t2.CallExpression = t2.BreakStatement = t2.BooleanTypeAnnotation = t2.BooleanLiteralTypeAnnotation = t2.BooleanLiteral = t2.BlockStatement = t2.BindExpression = t2.BinaryExpression = t2.BigIntLiteral = t2.AwaitExpression = t2.AssignmentPattern = t2.AssignmentExpression = t2.ArrowFunctionExpression = t2.ArrayTypeAnnotation = t2.ArrayPattern = t2.ArrayExpression = t2.ArgumentPlaceholder = t2.AnyTypeAnnotation = void 0, t2.TSNumberKeyword = t2.TSNullKeyword = t2.TSNonNullExpression = t2.TSNeverKeyword = t2.TSNamespaceExportDeclaration = t2.TSNamedTupleMember = t2.TSModuleDeclaration = t2.TSModuleBlock = t2.TSMethodSignature = t2.TSMappedType = t2.TSLiteralType = t2.TSIntrinsicKeyword = t2.TSIntersectionType = t2.TSInterfaceDeclaration = t2.TSInterfaceBody = t2.TSInstantiationExpression = t2.TSInferType = t2.TSIndexedAccessType = t2.TSIndexSignature = t2.TSImportType = t2.TSImportEqualsDeclaration = t2.TSFunctionType = t2.TSExternalModuleReference = t2.TSExpressionWithTypeArguments = t2.TSExportAssignment = t2.TSEnumMember = t2.TSEnumDeclaration = t2.TSEnumBody = t2.TSDeclareMethod = t2.TSDeclareFunction = t2.TSConstructorType = t2.TSConstructSignatureDeclaration = t2.TSConditionalType = t2.TSCallSignatureDeclaration = t2.TSBooleanKeyword = t2.TSBigIntKeyword = t2.TSAsExpression = t2.TSArrayType = t2.TSAnyKeyword = t2.SymbolTypeAnnotation = t2.SwitchStatement = t2.SwitchCase = t2.Super = t2.StringTypeAnnotation = t2.StringLiteralTypeAnnotation = t2.StringLiteral = t2.StaticBlock = t2.SpreadProperty = t2.SpreadElement = t2.SequenceExpression = t2.ReturnStatement = t2.RestProperty = t2.RestElement = t2.RegexLiteral = t2.RegExpLiteral = t2.RecordExpression = t2.QualifiedTypeIdentifier = t2.Program = t2.PrivateName = t2.Placeholder = t2.PipelineTopicExpression = t2.PipelinePrimaryTopicReference = t2.PipelineBareFunction = t2.ParenthesizedExpression = t2.OptionalMemberExpression = t2.OptionalIndexedAccessType = t2.OptionalCallExpression = t2.OpaqueType = t2.ObjectTypeSpreadProperty = t2.ObjectTypeProperty = t2.ObjectTypeInternalSlot = t2.ObjectTypeIndexer = t2.ObjectTypeCallProperty = t2.ObjectTypeAnnotation = t2.ObjectProperty = t2.ObjectPattern = t2.ObjectMethod = t2.ObjectExpression = t2.NumericLiteral = t2.NumberTypeAnnotation = t2.NumberLiteralTypeAnnotation = t2.NumberLiteral = t2.NullableTypeAnnotation = t2.NullLiteralTypeAnnotation = t2.NullLiteral = t2.Noop = t2.NewExpression = t2.ModuleExpression = t2.MixedTypeAnnotation = t2.MetaProperty = t2.MemberExpression = t2.LogicalExpression = t2.LabeledStatement = t2.JSXText = t2.JSXSpreadChild = t2.JSXSpreadAttribute = t2.JSXOpeningFragment = t2.JSXOpeningElement = t2.JSXNamespacedName = t2.JSXMemberExpression = void 0, t2.YieldExpression = t2.WithStatement = t2.WhileStatement = t2.VoidTypeAnnotation = t2.VoidPattern = t2.Variance = t2.VariableDeclarator = t2.VariableDeclaration = t2.V8IntrinsicIdentifier = t2.UpdateExpression = t2.UnionTypeAnnotation = t2.UnaryExpression = t2.TypeofTypeAnnotation = t2.TypeParameterInstantiation = t2.TypeParameterDeclaration = t2.TypeParameter = t2.TypeCastExpression = t2.TypeAnnotation = t2.TypeAlias = t2.TupleTypeAnnotation = t2.TupleExpression = t2.TryStatement = t2.TopicReference = t2.ThrowStatement = t2.ThisTypeAnnotation = t2.ThisExpression = t2.TemplateLiteral = t2.TemplateElement = t2.TaggedTemplateExpression = t2.TSVoidKeyword = t2.TSUnknownKeyword = t2.TSUnionType = t2.TSUndefinedKeyword = t2.TSTypeReference = t2.TSTypeQuery = t2.TSTypePredicate = t2.TSTypeParameterInstantiation = t2.TSTypeParameterDeclaration = t2.TSTypeParameter = t2.TSTypeOperator = t2.TSTypeLiteral = t2.TSTypeAssertion = t2.TSTypeAnnotation = t2.TSTypeAliasDeclaration = t2.TSTupleType = t2.TSThisType = t2.TSTemplateLiteralType = t2.TSSymbolKeyword = t2.TSStringKeyword = t2.TSSatisfiesExpression = t2.TSRestType = t2.TSQualifiedName = t2.TSPropertySignature = t2.TSParenthesizedType = t2.TSParameterProperty = t2.TSOptionalType = t2.TSObjectKeyword = void 0;
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/builders/generated/lowercase.js");
        r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/utils/deprecationWarning.js");
        function alias(e3) {
          return n[e3];
        }
        t2.ArrayExpression = alias("arrayExpression"), t2.AssignmentExpression = alias("assignmentExpression"), t2.BinaryExpression = alias("binaryExpression"), t2.InterpreterDirective = alias("interpreterDirective"), t2.Directive = alias("directive"), t2.DirectiveLiteral = alias("directiveLiteral"), t2.BlockStatement = alias("blockStatement"), t2.BreakStatement = alias("breakStatement"), t2.CallExpression = alias("callExpression"), t2.CatchClause = alias("catchClause"), t2.ConditionalExpression = alias("conditionalExpression"), t2.ContinueStatement = alias("continueStatement"), t2.DebuggerStatement = alias("debuggerStatement"), t2.DoWhileStatement = alias("doWhileStatement"), t2.EmptyStatement = alias("emptyStatement"), t2.ExpressionStatement = alias("expressionStatement"), t2.File = alias("file"), t2.ForInStatement = alias("forInStatement"), t2.ForStatement = alias("forStatement"), t2.FunctionDeclaration = alias("functionDeclaration"), t2.FunctionExpression = alias("functionExpression"), t2.Identifier = alias("identifier"), t2.IfStatement = alias("ifStatement"), t2.LabeledStatement = alias("labeledStatement"), t2.StringLiteral = alias("stringLiteral"), t2.NumericLiteral = alias("numericLiteral"), t2.NullLiteral = alias("nullLiteral"), t2.BooleanLiteral = alias("booleanLiteral"), t2.RegExpLiteral = alias("regExpLiteral"), t2.LogicalExpression = alias("logicalExpression"), t2.MemberExpression = alias("memberExpression"), t2.NewExpression = alias("newExpression"), t2.Program = alias("program"), t2.ObjectExpression = alias("objectExpression"), t2.ObjectMethod = alias("objectMethod"), t2.ObjectProperty = alias("objectProperty"), t2.RestElement = alias("restElement"), t2.ReturnStatement = alias("returnStatement"), t2.SequenceExpression = alias("sequenceExpression"), t2.ParenthesizedExpression = alias("parenthesizedExpression"), t2.SwitchCase = alias("switchCase"), t2.SwitchStatement = alias("switchStatement"), t2.ThisExpression = alias("thisExpression"), t2.ThrowStatement = alias("throwStatement"), t2.TryStatement = alias("tryStatement"), t2.UnaryExpression = alias("unaryExpression"), t2.UpdateExpression = alias("updateExpression"), t2.VariableDeclaration = alias("variableDeclaration"), t2.VariableDeclarator = alias("variableDeclarator"), t2.WhileStatement = alias("whileStatement"), t2.WithStatement = alias("withStatement"), t2.AssignmentPattern = alias("assignmentPattern"), t2.ArrayPattern = alias("arrayPattern"), t2.ArrowFunctionExpression = alias("arrowFunctionExpression"), t2.ClassBody = alias("classBody"), t2.ClassExpression = alias("classExpression"), t2.ClassDeclaration = alias("classDeclaration"), t2.ExportAllDeclaration = alias("exportAllDeclaration"), t2.ExportDefaultDeclaration = alias("exportDefaultDeclaration"), t2.ExportNamedDeclaration = alias("exportNamedDeclaration"), t2.ExportSpecifier = alias("exportSpecifier"), t2.ForOfStatement = alias("forOfStatement"), t2.ImportDeclaration = alias("importDeclaration"), t2.ImportDefaultSpecifier = alias("importDefaultSpecifier"), t2.ImportNamespaceSpecifier = alias("importNamespaceSpecifier"), t2.ImportSpecifier = alias("importSpecifier"), t2.ImportExpression = alias("importExpression"), t2.MetaProperty = alias("metaProperty"), t2.ClassMethod = alias("classMethod"), t2.ObjectPattern = alias("objectPattern"), t2.SpreadElement = alias("spreadElement"), t2.Super = alias("super"), t2.TaggedTemplateExpression = alias("taggedTemplateExpression"), t2.TemplateElement = alias("templateElement"), t2.TemplateLiteral = alias("templateLiteral"), t2.YieldExpression = alias("yieldExpression"), t2.AwaitExpression = alias("awaitExpression"), t2.Import = alias("import"), t2.BigIntLiteral = alias("bigIntLiteral"), t2.ExportNamespaceSpecifier = alias("exportNamespaceSpecifier"), t2.OptionalMemberExpression = alias("optionalMemberExpression"), t2.OptionalCallExpression = alias("optionalCallExpression"), t2.ClassProperty = alias("classProperty"), t2.ClassAccessorProperty = alias("classAccessorProperty"), t2.ClassPrivateProperty = alias("classPrivateProperty"), t2.ClassPrivateMethod = alias("classPrivateMethod"), t2.PrivateName = alias("privateName"), t2.StaticBlock = alias("staticBlock"), t2.ImportAttribute = alias("importAttribute"), t2.AnyTypeAnnotation = alias("anyTypeAnnotation"), t2.ArrayTypeAnnotation = alias("arrayTypeAnnotation"), t2.BooleanTypeAnnotation = alias("booleanTypeAnnotation"), t2.BooleanLiteralTypeAnnotation = alias("booleanLiteralTypeAnnotation"), t2.NullLiteralTypeAnnotation = alias("nullLiteralTypeAnnotation"), t2.ClassImplements = alias("classImplements"), t2.DeclareClass = alias("declareClass"), t2.DeclareFunction = alias("declareFunction"), t2.DeclareInterface = alias("declareInterface"), t2.DeclareModule = alias("declareModule"), t2.DeclareModuleExports = alias("declareModuleExports"), t2.DeclareTypeAlias = alias("declareTypeAlias"), t2.DeclareOpaqueType = alias("declareOpaqueType"), t2.DeclareVariable = alias("declareVariable"), t2.DeclareExportDeclaration = alias("declareExportDeclaration"), t2.DeclareExportAllDeclaration = alias("declareExportAllDeclaration"), t2.DeclaredPredicate = alias("declaredPredicate"), t2.ExistsTypeAnnotation = alias("existsTypeAnnotation"), t2.FunctionTypeAnnotation = alias("functionTypeAnnotation"), t2.FunctionTypeParam = alias("functionTypeParam"), t2.GenericTypeAnnotation = alias("genericTypeAnnotation"), t2.InferredPredicate = alias("inferredPredicate"), t2.InterfaceExtends = alias("interfaceExtends"), t2.InterfaceDeclaration = alias("interfaceDeclaration"), t2.InterfaceTypeAnnotation = alias("interfaceTypeAnnotation"), t2.IntersectionTypeAnnotation = alias("intersectionTypeAnnotation"), t2.MixedTypeAnnotation = alias("mixedTypeAnnotation"), t2.EmptyTypeAnnotation = alias("emptyTypeAnnotation"), t2.NullableTypeAnnotation = alias("nullableTypeAnnotation"), t2.NumberLiteralTypeAnnotation = alias("numberLiteralTypeAnnotation"), t2.NumberTypeAnnotation = alias("numberTypeAnnotation"), t2.ObjectTypeAnnotation = alias("objectTypeAnnotation"), t2.ObjectTypeInternalSlot = alias("objectTypeInternalSlot"), t2.ObjectTypeCallProperty = alias("objectTypeCallProperty"), t2.ObjectTypeIndexer = alias("objectTypeIndexer"), t2.ObjectTypeProperty = alias("objectTypeProperty"), t2.ObjectTypeSpreadProperty = alias("objectTypeSpreadProperty"), t2.OpaqueType = alias("opaqueType"), t2.QualifiedTypeIdentifier = alias("qualifiedTypeIdentifier"), t2.StringLiteralTypeAnnotation = alias("stringLiteralTypeAnnotation"), t2.StringTypeAnnotation = alias("stringTypeAnnotation"), t2.SymbolTypeAnnotation = alias("symbolTypeAnnotation"), t2.ThisTypeAnnotation = alias("thisTypeAnnotation"), t2.TupleTypeAnnotation = alias("tupleTypeAnnotation"), t2.TypeofTypeAnnotation = alias("typeofTypeAnnotation"), t2.TypeAlias = alias("typeAlias"), t2.TypeAnnotation = alias("typeAnnotation"), t2.TypeCastExpression = alias("typeCastExpression"), t2.TypeParameter = alias("typeParameter"), t2.TypeParameterDeclaration = alias("typeParameterDeclaration"), t2.TypeParameterInstantiation = alias("typeParameterInstantiation"), t2.UnionTypeAnnotation = alias("unionTypeAnnotation"), t2.Variance = alias("variance"), t2.VoidTypeAnnotation = alias("voidTypeAnnotation"), t2.EnumDeclaration = alias("enumDeclaration"), t2.EnumBooleanBody = alias("enumBooleanBody"), t2.EnumNumberBody = alias("enumNumberBody"), t2.EnumStringBody = alias("enumStringBody"), t2.EnumSymbolBody = alias("enumSymbolBody"), t2.EnumBooleanMember = alias("enumBooleanMember"), t2.EnumNumberMember = alias("enumNumberMember"), t2.EnumStringMember = alias("enumStringMember"), t2.EnumDefaultedMember = alias("enumDefaultedMember"), t2.IndexedAccessType = alias("indexedAccessType"), t2.OptionalIndexedAccessType = alias("optionalIndexedAccessType"), t2.JSXAttribute = alias("jsxAttribute"), t2.JSXClosingElement = alias("jsxClosingElement"), t2.JSXElement = alias("jsxElement"), t2.JSXEmptyExpression = alias("jsxEmptyExpression"), t2.JSXExpressionContainer = alias("jsxExpressionContainer"), t2.JSXSpreadChild = alias("jsxSpreadChild"), t2.JSXIdentifier = alias("jsxIdentifier"), t2.JSXMemberExpression = alias("jsxMemberExpression"), t2.JSXNamespacedName = alias("jsxNamespacedName"), t2.JSXOpeningElement = alias("jsxOpeningElement"), t2.JSXSpreadAttribute = alias("jsxSpreadAttribute"), t2.JSXText = alias("jsxText"), t2.JSXFragment = alias("jsxFragment"), t2.JSXOpeningFragment = alias("jsxOpeningFragment"), t2.JSXClosingFragment = alias("jsxClosingFragment"), t2.Noop = alias("noop"), t2.Placeholder = alias("placeholder"), t2.V8IntrinsicIdentifier = alias("v8IntrinsicIdentifier"), t2.ArgumentPlaceholder = alias("argumentPlaceholder"), t2.BindExpression = alias("bindExpression"), t2.Decorator = alias("decorator"), t2.DoExpression = alias("doExpression"), t2.ExportDefaultSpecifier = alias("exportDefaultSpecifier"), t2.RecordExpression = alias("recordExpression"), t2.TupleExpression = alias("tupleExpression"), t2.DecimalLiteral = alias("decimalLiteral"), t2.ModuleExpression = alias("moduleExpression"), t2.TopicReference = alias("topicReference"), t2.PipelineTopicExpression = alias("pipelineTopicExpression"), t2.PipelineBareFunction = alias("pipelineBareFunction"), t2.PipelinePrimaryTopicReference = alias("pipelinePrimaryTopicReference"), t2.VoidPattern = alias("voidPattern"), t2.TSParameterProperty = alias("tsParameterProperty"), t2.TSDeclareFunction = alias("tsDeclareFunction"), t2.TSDeclareMethod = alias("tsDeclareMethod"), t2.TSQualifiedName = alias("tsQualifiedName"), t2.TSCallSignatureDeclaration = alias("tsCallSignatureDeclaration"), t2.TSConstructSignatureDeclaration = alias("tsConstructSignatureDeclaration"), t2.TSPropertySignature = alias("tsPropertySignature"), t2.TSMethodSignature = alias("tsMethodSignature"), t2.TSIndexSignature = alias("tsIndexSignature"), t2.TSAnyKeyword = alias("tsAnyKeyword"), t2.TSBooleanKeyword = alias("tsBooleanKeyword"), t2.TSBigIntKeyword = alias("tsBigIntKeyword"), t2.TSIntrinsicKeyword = alias("tsIntrinsicKeyword"), t2.TSNeverKeyword = alias("tsNeverKeyword"), t2.TSNullKeyword = alias("tsNullKeyword"), t2.TSNumberKeyword = alias("tsNumberKeyword"), t2.TSObjectKeyword = alias("tsObjectKeyword"), t2.TSStringKeyword = alias("tsStringKeyword"), t2.TSSymbolKeyword = alias("tsSymbolKeyword"), t2.TSUndefinedKeyword = alias("tsUndefinedKeyword"), t2.TSUnknownKeyword = alias("tsUnknownKeyword"), t2.TSVoidKeyword = alias("tsVoidKeyword"), t2.TSThisType = alias("tsThisType"), t2.TSFunctionType = alias("tsFunctionType"), t2.TSConstructorType = alias("tsConstructorType"), t2.TSTypeReference = alias("tsTypeReference"), t2.TSTypePredicate = alias("tsTypePredicate"), t2.TSTypeQuery = alias("tsTypeQuery"), t2.TSTypeLiteral = alias("tsTypeLiteral"), t2.TSArrayType = alias("tsArrayType"), t2.TSTupleType = alias("tsTupleType"), t2.TSOptionalType = alias("tsOptionalType"), t2.TSRestType = alias("tsRestType"), t2.TSNamedTupleMember = alias("tsNamedTupleMember"), t2.TSUnionType = alias("tsUnionType"), t2.TSIntersectionType = alias("tsIntersectionType"), t2.TSConditionalType = alias("tsConditionalType"), t2.TSInferType = alias("tsInferType"), t2.TSParenthesizedType = alias("tsParenthesizedType"), t2.TSTypeOperator = alias("tsTypeOperator"), t2.TSIndexedAccessType = alias("tsIndexedAccessType"), t2.TSMappedType = alias("tsMappedType"), t2.TSTemplateLiteralType = alias("tsTemplateLiteralType"), t2.TSLiteralType = alias("tsLiteralType"), t2.TSExpressionWithTypeArguments = alias("tsExpressionWithTypeArguments"), t2.TSInterfaceDeclaration = alias("tsInterfaceDeclaration"), t2.TSInterfaceBody = alias("tsInterfaceBody"), t2.TSTypeAliasDeclaration = alias("tsTypeAliasDeclaration"), t2.TSInstantiationExpression = alias("tsInstantiationExpression"), t2.TSAsExpression = alias("tsAsExpression"), t2.TSSatisfiesExpression = alias("tsSatisfiesExpression"), t2.TSTypeAssertion = alias("tsTypeAssertion"), t2.TSEnumBody = alias("tsEnumBody"), t2.TSEnumDeclaration = alias("tsEnumDeclaration"), t2.TSEnumMember = alias("tsEnumMember"), t2.TSModuleDeclaration = alias("tsModuleDeclaration"), t2.TSModuleBlock = alias("tsModuleBlock"), t2.TSImportType = alias("tsImportType"), t2.TSImportEqualsDeclaration = alias("tsImportEqualsDeclaration"), t2.TSExternalModuleReference = alias("tsExternalModuleReference"), t2.TSNonNullExpression = alias("tsNonNullExpression"), t2.TSExportAssignment = alias("tsExportAssignment"), t2.TSNamespaceExportDeclaration = alias("tsNamespaceExportDeclaration"), t2.TSTypeAnnotation = alias("tsTypeAnnotation"), t2.TSTypeParameterInstantiation = alias("tsTypeParameterInstantiation"), t2.TSTypeParameterDeclaration = alias("tsTypeParameterDeclaration"), t2.TSTypeParameter = alias("tsTypeParameter"), t2.NumberLiteral = n.numberLiteral, t2.RegexLiteral = n.regexLiteral, t2.RestProperty = n.restProperty, t2.SpreadProperty = n.spreadProperty;
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/builders/productions.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.buildUndefinedNode = function() {
          return (0, n.unaryExpression)("void", (0, n.numericLiteral)(0), true);
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/builders/generated/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/builders/react/buildChildren.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
          const t3 = [];
          for (let r3 = 0; r3 < e3.children.length; r3++) {
            let i = e3.children[r3];
            (0, n.isJSXText)(i) ? (0, s.default)(i, t3) : ((0, n.isJSXExpressionContainer)(i) && (i = i.expression), (0, n.isJSXEmptyExpression)(i) || t3.push(i));
          }
          return t3;
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/generated/index.js"), s = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js");
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
          const t3 = e3.map((e4) => (0, i.isTSTypeAnnotation)(e4) ? e4.typeAnnotation : e4), r3 = (0, s.default)(t3);
          return 1 === r3.length ? r3[0] : (0, n.tsUnionType)(r3);
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/builders/generated/index.js"), s = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js"), i = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/generated/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/clone/clone.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
          return (0, n.default)(e3, false);
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/clone/cloneNode.js");
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/clone/cloneDeep.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
          return (0, n.default)(e3);
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/clone/cloneNode.js");
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
          return (0, n.default)(e3, true, true);
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/clone/cloneNode.js");
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/clone/cloneNode.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3 = true, r3 = false) {
          return cloneNodeInternal(e3, t3, r3, /* @__PURE__ */ new Map());
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/definitions/index.js"), s = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/generated/index.js");
        const { hasOwn: i } = { hasOwn: Function.call.bind(Object.prototype.hasOwnProperty) };
        function cloneIfNode(e3, t3, r3, n2) {
          return e3 && "string" == typeof e3.type ? cloneNodeInternal(e3, t3, r3, n2) : e3;
        }
        function cloneIfNodeOrArray(e3, t3, r3, n2) {
          return Array.isArray(e3) ? e3.map((e4) => cloneIfNode(e4, t3, r3, n2)) : cloneIfNode(e3, t3, r3, n2);
        }
        function cloneNodeInternal(e3, t3 = true, r3 = false, o) {
          if (!e3) return e3;
          const { type: a } = e3, l = { type: e3.type };
          if ((0, s.isIdentifier)(e3)) l.name = e3.name, i(e3, "optional") && "boolean" == typeof e3.optional && (l.optional = e3.optional), i(e3, "typeAnnotation") && (l.typeAnnotation = t3 ? cloneIfNodeOrArray(e3.typeAnnotation, true, r3, o) : e3.typeAnnotation), i(e3, "decorators") && (l.decorators = t3 ? cloneIfNodeOrArray(e3.decorators, true, r3, o) : e3.decorators);
          else {
            if (!i(n.NODE_FIELDS, a)) throw new Error(`Unknown node type: "${a}"`);
            for (const p of Object.keys(n.NODE_FIELDS[a])) i(e3, p) && (l[p] = t3 ? (0, s.isFile)(e3) && "comments" === p ? maybeCloneComments(e3.comments, t3, r3, o) : cloneIfNodeOrArray(e3[p], true, r3, o) : e3[p]);
          }
          return i(e3, "loc") && (l.loc = r3 ? null : e3.loc), i(e3, "leadingComments") && (l.leadingComments = maybeCloneComments(e3.leadingComments, t3, r3, o)), i(e3, "innerComments") && (l.innerComments = maybeCloneComments(e3.innerComments, t3, r3, o)), i(e3, "trailingComments") && (l.trailingComments = maybeCloneComments(e3.trailingComments, t3, r3, o)), i(e3, "extra") && (l.extra = Object.assign({}, e3.extra)), l;
        }
        function maybeCloneComments(e3, t3, r3, n2) {
          return e3 && t3 ? e3.map((e4) => {
            const t4 = n2.get(e4);
            if (t4) return t4;
            const { type: s2, value: i2, loc: o } = e4, a = { type: s2, value: i2, loc: o };
            return r3 && (a.loc = null), n2.set(e4, a), a;
          }) : e3;
        }
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/clone/cloneWithoutLoc.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
          return (0, n.default)(e3, false, true);
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/clone/cloneNode.js");
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/comments/addComment.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3, s) {
          return (0, n.default)(e3, t3, [{ type: s ? "CommentLine" : "CommentBlock", value: r3 }]);
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/comments/addComments.js");
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/comments/addComments.js": function(e2, t2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r2) {
          if (!r2 || !e3) return e3;
          const n = `${t3}Comments`;
          e3[n] ? "leading" === t3 ? e3[n] = r2.concat(e3[n]) : e3[n].push(...r2) : e3[n] = r2;
          return e3;
        };
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/comments/inheritInnerComments.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
          (0, n.default)("innerComments", e3, t3);
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/utils/inherit.js");
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/comments/inheritLeadingComments.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
          (0, n.default)("leadingComments", e3, t3);
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/utils/inherit.js");
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/comments/inheritTrailingComments.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
          (0, n.default)("trailingComments", e3, t3);
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/utils/inherit.js");
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/comments/inheritsComments.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
          return (0, n.default)(e3, t3), (0, s.default)(e3, t3), (0, i.default)(e3, t3), e3;
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/comments/inheritTrailingComments.js"), s = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/comments/inheritLeadingComments.js"), i = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/comments/inheritInnerComments.js");
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/comments/removeComments.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
          return n.COMMENT_KEYS.forEach((t3) => {
            e3[t3] = null;
          }), e3;
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/constants/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/constants/generated/index.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.WHILE_TYPES = t2.USERWHITESPACABLE_TYPES = t2.UNARYLIKE_TYPES = t2.TYPESCRIPT_TYPES = t2.TSTYPE_TYPES = t2.TSTYPEELEMENT_TYPES = t2.TSENTITYNAME_TYPES = t2.TSBASETYPE_TYPES = t2.TERMINATORLESS_TYPES = t2.STATEMENT_TYPES = t2.STANDARDIZED_TYPES = t2.SCOPABLE_TYPES = t2.PUREISH_TYPES = t2.PROPERTY_TYPES = t2.PRIVATE_TYPES = t2.PATTERN_TYPES = t2.PATTERNLIKE_TYPES = t2.OBJECTMEMBER_TYPES = t2.MODULESPECIFIER_TYPES = t2.MODULEDECLARATION_TYPES = t2.MISCELLANEOUS_TYPES = t2.METHOD_TYPES = t2.LVAL_TYPES = t2.LOOP_TYPES = t2.LITERAL_TYPES = t2.JSX_TYPES = t2.IMPORTOREXPORTDECLARATION_TYPES = t2.IMMUTABLE_TYPES = t2.FUNCTION_TYPES = t2.FUNCTIONPARENT_TYPES = t2.FUNCTIONPARAMETER_TYPES = t2.FOR_TYPES = t2.FORXSTATEMENT_TYPES = t2.FLOW_TYPES = t2.FLOWTYPE_TYPES = t2.FLOWPREDICATE_TYPES = t2.FLOWDECLARATION_TYPES = t2.FLOWBASEANNOTATION_TYPES = t2.EXPRESSION_TYPES = t2.EXPRESSIONWRAPPER_TYPES = t2.EXPORTDECLARATION_TYPES = t2.ENUMMEMBER_TYPES = t2.ENUMBODY_TYPES = t2.DECLARATION_TYPES = t2.CONDITIONAL_TYPES = t2.COMPLETIONSTATEMENT_TYPES = t2.CLASS_TYPES = t2.BLOCK_TYPES = t2.BLOCKPARENT_TYPES = t2.BINARY_TYPES = t2.ACCESSOR_TYPES = void 0;
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/definitions/index.js");
        t2.STANDARDIZED_TYPES = n.FLIPPED_ALIAS_KEYS.Standardized, t2.EXPRESSION_TYPES = n.FLIPPED_ALIAS_KEYS.Expression, t2.BINARY_TYPES = n.FLIPPED_ALIAS_KEYS.Binary, t2.SCOPABLE_TYPES = n.FLIPPED_ALIAS_KEYS.Scopable, t2.BLOCKPARENT_TYPES = n.FLIPPED_ALIAS_KEYS.BlockParent, t2.BLOCK_TYPES = n.FLIPPED_ALIAS_KEYS.Block, t2.STATEMENT_TYPES = n.FLIPPED_ALIAS_KEYS.Statement, t2.TERMINATORLESS_TYPES = n.FLIPPED_ALIAS_KEYS.Terminatorless, t2.COMPLETIONSTATEMENT_TYPES = n.FLIPPED_ALIAS_KEYS.CompletionStatement, t2.CONDITIONAL_TYPES = n.FLIPPED_ALIAS_KEYS.Conditional, t2.LOOP_TYPES = n.FLIPPED_ALIAS_KEYS.Loop, t2.WHILE_TYPES = n.FLIPPED_ALIAS_KEYS.While, t2.EXPRESSIONWRAPPER_TYPES = n.FLIPPED_ALIAS_KEYS.ExpressionWrapper, t2.FOR_TYPES = n.FLIPPED_ALIAS_KEYS.For, t2.FORXSTATEMENT_TYPES = n.FLIPPED_ALIAS_KEYS.ForXStatement, t2.FUNCTION_TYPES = n.FLIPPED_ALIAS_KEYS.Function, t2.FUNCTIONPARENT_TYPES = n.FLIPPED_ALIAS_KEYS.FunctionParent, t2.PUREISH_TYPES = n.FLIPPED_ALIAS_KEYS.Pureish, t2.DECLARATION_TYPES = n.FLIPPED_ALIAS_KEYS.Declaration, t2.FUNCTIONPARAMETER_TYPES = n.FLIPPED_ALIAS_KEYS.FunctionParameter, t2.PATTERNLIKE_TYPES = n.FLIPPED_ALIAS_KEYS.PatternLike, t2.LVAL_TYPES = n.FLIPPED_ALIAS_KEYS.LVal, t2.TSENTITYNAME_TYPES = n.FLIPPED_ALIAS_KEYS.TSEntityName, t2.LITERAL_TYPES = n.FLIPPED_ALIAS_KEYS.Literal, t2.IMMUTABLE_TYPES = n.FLIPPED_ALIAS_KEYS.Immutable, t2.USERWHITESPACABLE_TYPES = n.FLIPPED_ALIAS_KEYS.UserWhitespacable, t2.METHOD_TYPES = n.FLIPPED_ALIAS_KEYS.Method, t2.OBJECTMEMBER_TYPES = n.FLIPPED_ALIAS_KEYS.ObjectMember, t2.PROPERTY_TYPES = n.FLIPPED_ALIAS_KEYS.Property, t2.UNARYLIKE_TYPES = n.FLIPPED_ALIAS_KEYS.UnaryLike, t2.PATTERN_TYPES = n.FLIPPED_ALIAS_KEYS.Pattern, t2.CLASS_TYPES = n.FLIPPED_ALIAS_KEYS.Class;
        const s = t2.IMPORTOREXPORTDECLARATION_TYPES = n.FLIPPED_ALIAS_KEYS.ImportOrExportDeclaration;
        t2.EXPORTDECLARATION_TYPES = n.FLIPPED_ALIAS_KEYS.ExportDeclaration, t2.MODULESPECIFIER_TYPES = n.FLIPPED_ALIAS_KEYS.ModuleSpecifier, t2.ACCESSOR_TYPES = n.FLIPPED_ALIAS_KEYS.Accessor, t2.PRIVATE_TYPES = n.FLIPPED_ALIAS_KEYS.Private, t2.FLOW_TYPES = n.FLIPPED_ALIAS_KEYS.Flow, t2.FLOWTYPE_TYPES = n.FLIPPED_ALIAS_KEYS.FlowType, t2.FLOWBASEANNOTATION_TYPES = n.FLIPPED_ALIAS_KEYS.FlowBaseAnnotation, t2.FLOWDECLARATION_TYPES = n.FLIPPED_ALIAS_KEYS.FlowDeclaration, t2.FLOWPREDICATE_TYPES = n.FLIPPED_ALIAS_KEYS.FlowPredicate, t2.ENUMBODY_TYPES = n.FLIPPED_ALIAS_KEYS.EnumBody, t2.ENUMMEMBER_TYPES = n.FLIPPED_ALIAS_KEYS.EnumMember, t2.JSX_TYPES = n.FLIPPED_ALIAS_KEYS.JSX, t2.MISCELLANEOUS_TYPES = n.FLIPPED_ALIAS_KEYS.Miscellaneous, t2.TYPESCRIPT_TYPES = n.FLIPPED_ALIAS_KEYS.TypeScript, t2.TSTYPEELEMENT_TYPES = n.FLIPPED_ALIAS_KEYS.TSTypeElement, t2.TSTYPE_TYPES = n.FLIPPED_ALIAS_KEYS.TSType, t2.TSBASETYPE_TYPES = n.FLIPPED_ALIAS_KEYS.TSBaseType, t2.MODULEDECLARATION_TYPES = s;
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/constants/index.js": function(e2, t2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.UPDATE_OPERATORS = t2.UNARY_OPERATORS = t2.STRING_UNARY_OPERATORS = t2.STATEMENT_OR_BLOCK_KEYS = t2.NUMBER_UNARY_OPERATORS = t2.NUMBER_BINARY_OPERATORS = t2.LOGICAL_OPERATORS = t2.INHERIT_KEYS = t2.FOR_INIT_KEYS = t2.FLATTENABLE_KEYS = t2.EQUALITY_BINARY_OPERATORS = t2.COMPARISON_BINARY_OPERATORS = t2.COMMENT_KEYS = t2.BOOLEAN_UNARY_OPERATORS = t2.BOOLEAN_NUMBER_BINARY_OPERATORS = t2.BOOLEAN_BINARY_OPERATORS = t2.BINARY_OPERATORS = t2.ASSIGNMENT_OPERATORS = void 0;
        t2.STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"], t2.FLATTENABLE_KEYS = ["body", "expressions"], t2.FOR_INIT_KEYS = ["left", "init"], t2.COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];
        const r2 = t2.LOGICAL_OPERATORS = ["||", "&&", "??"], n = (t2.UPDATE_OPERATORS = ["++", "--"], t2.BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="]), s = t2.EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="], i = t2.COMPARISON_BINARY_OPERATORS = [...s, "in", "instanceof"], o = t2.BOOLEAN_BINARY_OPERATORS = [...i, ...n], a = t2.NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"], l = (t2.BINARY_OPERATORS = ["+", ...a, ...o, "|>"], t2.ASSIGNMENT_OPERATORS = ["=", "+=", ...a.map((e3) => e3 + "="), ...r2.map((e3) => e3 + "=")], t2.BOOLEAN_UNARY_OPERATORS = ["delete", "!"]), p = t2.NUMBER_UNARY_OPERATORS = ["+", "-", "~"], c = t2.STRING_UNARY_OPERATORS = ["typeof"];
        t2.UNARY_OPERATORS = ["void", "throw", ...l, ...p, ...c], t2.INHERIT_KEYS = { optional: ["typeAnnotation", "typeParameters", "returnType"], force: ["start", "loc", "end"] };
        t2.BLOCK_SCOPED_SYMBOL = /* @__PURE__ */ Symbol.for("var used to be block scoped"), t2.NOT_LOCAL_BINDING = /* @__PURE__ */ Symbol.for("should not be considered a local binding");
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/converters/ensureBlock.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3 = "body") {
          const r3 = (0, n.default)(e3[t3], e3);
          return e3[t3] = r3, r3;
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/converters/toBlock.js");
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function gatherSequenceExpressions(e3, t3) {
          const r3 = [];
          let l = true;
          for (const p of e3) if ((0, s.isEmptyStatement)(p) || (l = false), (0, s.isExpression)(p)) r3.push(p);
          else if ((0, s.isExpressionStatement)(p)) r3.push(p.expression);
          else if ((0, s.isVariableDeclaration)(p)) {
            if ("var" !== p.kind) return;
            for (const e4 of p.declarations) {
              const s2 = (0, n.default)(e4);
              for (const e5 of Object.keys(s2)) t3.push({ kind: p.kind, id: (0, a.default)(s2[e5]) });
              e4.init && r3.push((0, i.assignmentExpression)("=", e4.id, e4.init));
            }
            l = true;
          } else if ((0, s.isIfStatement)(p)) {
            const e4 = p.consequent ? gatherSequenceExpressions([p.consequent], t3) : (0, o.buildUndefinedNode)(), n2 = p.alternate ? gatherSequenceExpressions([p.alternate], t3) : (0, o.buildUndefinedNode)();
            if (!e4 || !n2) return;
            r3.push((0, i.conditionalExpression)(p.test, e4, n2));
          } else if ((0, s.isBlockStatement)(p)) {
            const e4 = gatherSequenceExpressions(p.body, t3);
            if (!e4) return;
            r3.push(e4);
          } else {
            if (!(0, s.isEmptyStatement)(p)) return;
            0 === e3.indexOf(p) && (l = true);
          }
          l && r3.push((0, o.buildUndefinedNode)());
          return 1 === r3.length ? r3[0] : (0, i.sequenceExpression)(r3);
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js"), s = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/generated/index.js"), i = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/builders/generated/index.js"), o = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/builders/productions.js"), a = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/clone/cloneNode.js");
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/converters/toBindingIdentifierName.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
          "eval" !== (e3 = (0, n.default)(e3)) && "arguments" !== e3 || (e3 = "_" + e3);
          return e3;
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/converters/toIdentifier.js");
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/converters/toBlock.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
          if ((0, n.isBlockStatement)(e3)) return e3;
          let r3 = [];
          (0, n.isEmptyStatement)(e3) ? r3 = [] : ((0, n.isStatement)(e3) || (e3 = (0, n.isFunction)(t3) ? (0, s.returnStatement)(e3) : (0, s.expressionStatement)(e3)), r3 = [e3]);
          return (0, s.blockStatement)(r3);
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/generated/index.js"), s = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/builders/generated/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/converters/toComputedKey.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3 = e3.key || e3.property) {
          !e3.computed && (0, n.isIdentifier)(t3) && (t3 = (0, s.stringLiteral)(t3.name));
          return t3;
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/generated/index.js"), s = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/builders/generated/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/converters/toExpression.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/generated/index.js");
        t2.default = function(e3) {
          (0, n.isExpressionStatement)(e3) && (e3 = e3.expression);
          if ((0, n.isExpression)(e3)) return e3;
          (0, n.isClass)(e3) ? (e3.type = "ClassExpression", e3.abstract = false) : (0, n.isFunction)(e3) && (e3.type = "FunctionExpression");
          if (!(0, n.isExpression)(e3)) throw new Error(`cannot turn ${e3.type} to an expression`);
          return e3;
        };
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/converters/toIdentifier.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
          e3 += "";
          let t3 = "";
          for (const r3 of e3) t3 += (0, s.isIdentifierChar)(r3.codePointAt(0)) ? r3 : "-";
          t3 = t3.replace(/^[-0-9]+/, ""), t3 = t3.replace(/[-\s]+(.)?/g, function(e4, t4) {
            return t4 ? t4.toUpperCase() : "";
          }), (0, n.default)(t3) || (t3 = `_${t3}`);
          return t3 || "_";
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/isValidIdentifier.js"), s = r2("./node_modules/.pnpm/@babel+helper-validator-identifier@7.27.1/node_modules/@babel/helper-validator-identifier/lib/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/converters/toKeyAlias.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = toKeyAlias;
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/generated/index.js"), s = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/clone/cloneNode.js"), i = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/modifications/removePropertiesDeep.js");
        function toKeyAlias(e3, t3 = e3.key) {
          let r3;
          return "method" === e3.kind ? toKeyAlias.increment() + "" : (r3 = (0, n.isIdentifier)(t3) ? t3.name : (0, n.isStringLiteral)(t3) ? JSON.stringify(t3.value) : JSON.stringify((0, i.default)((0, s.default)(t3))), e3.computed && (r3 = `[${r3}]`), e3.static && (r3 = `static:${r3}`), r3);
        }
        toKeyAlias.uid = 0, toKeyAlias.increment = function() {
          return toKeyAlias.uid >= Number.MAX_SAFE_INTEGER ? toKeyAlias.uid = 0 : toKeyAlias.uid++;
        };
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/converters/toSequenceExpression.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
          if (null == e3 || !e3.length) return;
          const r3 = [], s = (0, n.default)(e3, r3);
          if (!s) return;
          for (const e4 of r3) t3.push(e4);
          return s;
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js");
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/converters/toStatement.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/generated/index.js"), s = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/builders/generated/index.js");
        t2.default = function(e3, t3) {
          if ((0, n.isStatement)(e3)) return e3;
          let r3, i = false;
          if ((0, n.isClass)(e3)) i = true, r3 = "ClassDeclaration";
          else if ((0, n.isFunction)(e3)) i = true, r3 = "FunctionDeclaration";
          else if ((0, n.isAssignmentExpression)(e3)) return (0, s.expressionStatement)(e3);
          i && !e3.id && (r3 = false);
          if (!r3) {
            if (t3) return false;
            throw new Error(`cannot turn ${e3.type} to a statement`);
          }
          return e3.type = r3, e3;
        };
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/converters/valueToNode.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/isValidIdentifier.js"), s = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/builders/generated/index.js");
        t2.default = function valueToNode(e3) {
          if (void 0 === e3) return (0, s.identifier)("undefined");
          if (true === e3 || false === e3) return (0, s.booleanLiteral)(e3);
          if (null === e3) return (0, s.nullLiteral)();
          if ("string" == typeof e3) return (0, s.stringLiteral)(e3);
          if ("number" == typeof e3) {
            let t3;
            if (Number.isFinite(e3)) t3 = (0, s.numericLiteral)(Math.abs(e3));
            else {
              let r3;
              r3 = Number.isNaN(e3) ? (0, s.numericLiteral)(0) : (0, s.numericLiteral)(1), t3 = (0, s.binaryExpression)("/", r3, (0, s.numericLiteral)(0));
            }
            return (e3 < 0 || Object.is(e3, -0)) && (t3 = (0, s.unaryExpression)("-", t3)), t3;
          }
          if ("bigint" == typeof e3) return e3 < 0 ? (0, s.unaryExpression)("-", (0, s.bigIntLiteral)(-e3)) : (0, s.bigIntLiteral)(e3);
          if ((function(e4) {
            return "[object RegExp]" === i(e4);
          })(e3)) {
            const t3 = e3.source, r3 = /\/([a-z]*)$/.exec(e3.toString())[1];
            return (0, s.regExpLiteral)(t3, r3);
          }
          if (Array.isArray(e3)) return (0, s.arrayExpression)(e3.map(valueToNode));
          if ((function(e4) {
            if ("object" != typeof e4 || null === e4 || "[object Object]" !== Object.prototype.toString.call(e4)) return false;
            const t3 = Object.getPrototypeOf(e4);
            return null === t3 || null === Object.getPrototypeOf(t3);
          })(e3)) {
            const t3 = [];
            for (const r3 of Object.keys(e3)) {
              let i2, o = false;
              (0, n.default)(r3) ? "__proto__" === r3 ? (o = true, i2 = (0, s.stringLiteral)(r3)) : i2 = (0, s.identifier)(r3) : i2 = (0, s.stringLiteral)(r3), t3.push((0, s.objectProperty)(i2, valueToNode(e3[r3]), o));
            }
            return (0, s.objectExpression)(t3);
          }
          throw new Error("don't know how to turn this value into a node");
        };
        const i = Function.call.bind(Object.prototype.toString);
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/definitions/core.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.patternLikeCommon = t2.importAttributes = t2.functionTypeAnnotationCommon = t2.functionDeclarationCommon = t2.functionCommon = t2.classMethodOrPropertyCommon = t2.classMethodOrDeclareMethodCommon = void 0;
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/is.js"), s = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/isValidIdentifier.js"), i = r2("./node_modules/.pnpm/@babel+helper-validator-identifier@7.27.1/node_modules/@babel/helper-validator-identifier/lib/index.js"), o = r2("./node_modules/.pnpm/@babel+helper-string-parser@7.27.1/node_modules/@babel/helper-string-parser/lib/index.js"), a = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/constants/index.js"), l = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/definitions/utils.js");
        const p = (0, l.defineAliasedType)("Standardized");
        p("ArrayExpression", { fields: { elements: { validate: (0, l.arrayOf)((0, l.assertNodeOrValueType)("null", "Expression", "SpreadElement")), default: process.env.BABEL_TYPES_8_BREAKING ? void 0 : [] } }, visitor: ["elements"], aliases: ["Expression"] }), p("AssignmentExpression", { fields: { operator: { validate: process.env.BABEL_TYPES_8_BREAKING ? Object.assign((function() {
          const e3 = (0, l.assertOneOf)(...a.ASSIGNMENT_OPERATORS), t3 = (0, l.assertOneOf)("=");
          return function(r3, s2, i2) {
            ((0, n.default)("Pattern", r3.left) ? t3 : e3)(r3, s2, i2);
          };
        })(), { oneOf: a.ASSIGNMENT_OPERATORS }) : (0, l.assertValueType)("string") }, left: { validate: process.env.BABEL_TYPES_8_BREAKING ? (0, l.assertNodeType)("Identifier", "MemberExpression", "OptionalMemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, l.assertNodeType)("LVal", "OptionalMemberExpression") }, right: { validate: (0, l.assertNodeType)("Expression") } }, builder: ["operator", "left", "right"], visitor: ["left", "right"], aliases: ["Expression"] }), p("BinaryExpression", { builder: ["operator", "left", "right"], fields: { operator: { validate: (0, l.assertOneOf)(...a.BINARY_OPERATORS) }, left: { validate: (function() {
          const e3 = (0, l.assertNodeType)("Expression"), t3 = (0, l.assertNodeType)("Expression", "PrivateName");
          return Object.assign(function(r3, n2, s2) {
            ("in" === r3.operator ? t3 : e3)(r3, n2, s2);
          }, { oneOfNodeTypes: ["Expression", "PrivateName"] });
        })() }, right: { validate: (0, l.assertNodeType)("Expression") } }, visitor: ["left", "right"], aliases: ["Binary", "Expression"] }), p("InterpreterDirective", { builder: ["value"], fields: { value: { validate: (0, l.assertValueType)("string") } } }), p("Directive", { visitor: ["value"], fields: { value: { validate: (0, l.assertNodeType)("DirectiveLiteral") } } }), p("DirectiveLiteral", { builder: ["value"], fields: { value: { validate: (0, l.assertValueType)("string") } } }), p("BlockStatement", { builder: ["body", "directives"], visitor: ["directives", "body"], fields: { directives: { validate: (0, l.arrayOfType)("Directive"), default: [] }, body: (0, l.validateArrayOfType)("Statement") }, aliases: ["Scopable", "BlockParent", "Block", "Statement"] }), p("BreakStatement", { visitor: ["label"], fields: { label: { validate: (0, l.assertNodeType)("Identifier"), optional: true } }, aliases: ["Statement", "Terminatorless", "CompletionStatement"] }), p("CallExpression", { visitor: ["callee", "typeParameters", "typeArguments", "arguments"], builder: ["callee", "arguments"], aliases: ["Expression"], fields: Object.assign({ callee: { validate: (0, l.assertNodeType)("Expression", "Super", "V8IntrinsicIdentifier") }, arguments: (0, l.validateArrayOfType)("Expression", "SpreadElement", "ArgumentPlaceholder"), typeArguments: { validate: (0, l.assertNodeType)("TypeParameterInstantiation"), optional: true } }, process.env.BABEL_TYPES_8_BREAKING ? {} : { optional: { validate: (0, l.assertValueType)("boolean"), optional: true }, typeParameters: { validate: (0, l.assertNodeType)("TSTypeParameterInstantiation"), optional: true } }) }), p("CatchClause", { visitor: ["param", "body"], fields: { param: { validate: (0, l.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"), optional: true }, body: { validate: (0, l.assertNodeType)("BlockStatement") } }, aliases: ["Scopable", "BlockParent"] }), p("ConditionalExpression", { visitor: ["test", "consequent", "alternate"], fields: { test: { validate: (0, l.assertNodeType)("Expression") }, consequent: { validate: (0, l.assertNodeType)("Expression") }, alternate: { validate: (0, l.assertNodeType)("Expression") } }, aliases: ["Expression", "Conditional"] }), p("ContinueStatement", { visitor: ["label"], fields: { label: { validate: (0, l.assertNodeType)("Identifier"), optional: true } }, aliases: ["Statement", "Terminatorless", "CompletionStatement"] }), p("DebuggerStatement", { aliases: ["Statement"] }), p("DoWhileStatement", { builder: ["test", "body"], visitor: ["body", "test"], fields: { test: { validate: (0, l.assertNodeType)("Expression") }, body: { validate: (0, l.assertNodeType)("Statement") } }, aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"] }), p("EmptyStatement", { aliases: ["Statement"] }), p("ExpressionStatement", { visitor: ["expression"], fields: { expression: { validate: (0, l.assertNodeType)("Expression") } }, aliases: ["Statement", "ExpressionWrapper"] }), p("File", { builder: ["program", "comments", "tokens"], visitor: ["program"], fields: { program: { validate: (0, l.assertNodeType)("Program") }, comments: { validate: process.env.BABEL_TYPES_8_BREAKING ? (0, l.assertEach)((0, l.assertNodeType)("CommentBlock", "CommentLine")) : Object.assign(() => {
        }, { each: { oneOfNodeTypes: ["CommentBlock", "CommentLine"] } }), optional: true }, tokens: { validate: (0, l.assertEach)(Object.assign(() => {
        }, { type: "any" })), optional: true } } }), p("ForInStatement", { visitor: ["left", "right", "body"], aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"], fields: { left: { validate: process.env.BABEL_TYPES_8_BREAKING ? (0, l.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, l.assertNodeType)("VariableDeclaration", "LVal") }, right: { validate: (0, l.assertNodeType)("Expression") }, body: { validate: (0, l.assertNodeType)("Statement") } } }), p("ForStatement", { visitor: ["init", "test", "update", "body"], aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"], fields: { init: { validate: (0, l.assertNodeType)("VariableDeclaration", "Expression"), optional: true }, test: { validate: (0, l.assertNodeType)("Expression"), optional: true }, update: { validate: (0, l.assertNodeType)("Expression"), optional: true }, body: { validate: (0, l.assertNodeType)("Statement") } } });
        const functionCommon = () => ({ params: (0, l.validateArrayOfType)("FunctionParameter"), generator: { default: false }, async: { default: false } });
        t2.functionCommon = functionCommon;
        const functionTypeAnnotationCommon = () => ({ returnType: { validate: (0, l.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"), optional: true }, typeParameters: { validate: (0, l.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"), optional: true } });
        t2.functionTypeAnnotationCommon = functionTypeAnnotationCommon;
        const functionDeclarationCommon = () => Object.assign({}, functionCommon(), { declare: { validate: (0, l.assertValueType)("boolean"), optional: true }, id: { validate: (0, l.assertNodeType)("Identifier"), optional: true } });
        t2.functionDeclarationCommon = functionDeclarationCommon, p("FunctionDeclaration", { builder: ["id", "params", "body", "generator", "async"], visitor: ["id", "typeParameters", "params", "predicate", "returnType", "body"], fields: Object.assign({}, functionDeclarationCommon(), functionTypeAnnotationCommon(), { body: { validate: (0, l.assertNodeType)("BlockStatement") }, predicate: { validate: (0, l.assertNodeType)("DeclaredPredicate", "InferredPredicate"), optional: true } }), aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"], validate: process.env.BABEL_TYPES_8_BREAKING ? (function() {
          const e3 = (0, l.assertNodeType)("Identifier");
          return function(t3, r3, s2) {
            (0, n.default)("ExportDefaultDeclaration", t3) || e3(s2, "id", s2.id);
          };
        })() : void 0 }), p("FunctionExpression", { inherits: "FunctionDeclaration", aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"], fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), { id: { validate: (0, l.assertNodeType)("Identifier"), optional: true }, body: { validate: (0, l.assertNodeType)("BlockStatement") }, predicate: { validate: (0, l.assertNodeType)("DeclaredPredicate", "InferredPredicate"), optional: true } }) });
        const patternLikeCommon = () => ({ typeAnnotation: { validate: (0, l.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"), optional: true }, optional: { validate: (0, l.assertValueType)("boolean"), optional: true }, decorators: { validate: (0, l.arrayOfType)("Decorator"), optional: true } });
        t2.patternLikeCommon = patternLikeCommon, p("Identifier", { builder: ["name"], visitor: ["typeAnnotation", "decorators"], aliases: ["Expression", "FunctionParameter", "PatternLike", "LVal", "TSEntityName"], fields: Object.assign({}, patternLikeCommon(), { name: { validate: process.env.BABEL_TYPES_8_BREAKING ? (0, l.chain)((0, l.assertValueType)("string"), Object.assign(function(e3, t3, r3) {
          if (!(0, s.default)(r3, false)) throw new TypeError(`"${r3}" is not a valid identifier name`);
        }, { type: "string" })) : (0, l.assertValueType)("string") } }), validate: process.env.BABEL_TYPES_8_BREAKING ? function(e3, t3, r3) {
          const s2 = /\.(\w+)$/.exec(t3.toString());
          if (!s2) return;
          const [, o2] = s2, a2 = { computed: false };
          if ("property" === o2) {
            if ((0, n.default)("MemberExpression", e3, a2)) return;
            if ((0, n.default)("OptionalMemberExpression", e3, a2)) return;
          } else if ("key" === o2) {
            if ((0, n.default)("Property", e3, a2)) return;
            if ((0, n.default)("Method", e3, a2)) return;
          } else if ("exported" === o2) {
            if ((0, n.default)("ExportSpecifier", e3)) return;
          } else if ("imported" === o2) {
            if ((0, n.default)("ImportSpecifier", e3, { imported: r3 })) return;
          } else if ("meta" === o2 && (0, n.default)("MetaProperty", e3, { meta: r3 })) return;
          if (((0, i.isKeyword)(r3.name) || (0, i.isReservedWord)(r3.name, false)) && "this" !== r3.name) throw new TypeError(`"${r3.name}" is not a valid identifier`);
        } : void 0 }), p("IfStatement", { visitor: ["test", "consequent", "alternate"], aliases: ["Statement", "Conditional"], fields: { test: { validate: (0, l.assertNodeType)("Expression") }, consequent: { validate: (0, l.assertNodeType)("Statement") }, alternate: { optional: true, validate: (0, l.assertNodeType)("Statement") } } }), p("LabeledStatement", { visitor: ["label", "body"], aliases: ["Statement"], fields: { label: { validate: (0, l.assertNodeType)("Identifier") }, body: { validate: (0, l.assertNodeType)("Statement") } } }), p("StringLiteral", { builder: ["value"], fields: { value: { validate: (0, l.assertValueType)("string") } }, aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), p("NumericLiteral", { builder: ["value"], deprecatedAlias: "NumberLiteral", fields: { value: { validate: (0, l.chain)((0, l.assertValueType)("number"), Object.assign(function(e3, t3, r3) {
          if (1 / r3 < 0 || !Number.isFinite(r3)) {
            new Error(`NumericLiterals must be non-negative finite numbers. You can use t.valueToNode(${r3}) instead.`);
          }
        }, { type: "number" })) } }, aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), p("NullLiteral", { aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), p("BooleanLiteral", { builder: ["value"], fields: { value: { validate: (0, l.assertValueType)("boolean") } }, aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), p("RegExpLiteral", { builder: ["pattern", "flags"], deprecatedAlias: "RegexLiteral", aliases: ["Expression", "Pureish", "Literal"], fields: { pattern: { validate: (0, l.assertValueType)("string") }, flags: { validate: process.env.BABEL_TYPES_8_BREAKING ? (0, l.chain)((0, l.assertValueType)("string"), Object.assign(function(e3, t3, r3) {
          const n2 = /[^dgimsuvy]/.exec(r3);
          if (n2) throw new TypeError(`"${n2[0]}" is not a valid RegExp flag`);
        }, { type: "string" })) : (0, l.assertValueType)("string"), default: "" } } }), p("LogicalExpression", { builder: ["operator", "left", "right"], visitor: ["left", "right"], aliases: ["Binary", "Expression"], fields: { operator: { validate: (0, l.assertOneOf)(...a.LOGICAL_OPERATORS) }, left: { validate: (0, l.assertNodeType)("Expression") }, right: { validate: (0, l.assertNodeType)("Expression") } } }), p("MemberExpression", { builder: ["object", "property", "computed", ...process.env.BABEL_TYPES_8_BREAKING ? [] : ["optional"]], visitor: ["object", "property"], aliases: ["Expression", "LVal", "PatternLike"], fields: Object.assign({ object: { validate: (0, l.assertNodeType)("Expression", "Super") }, property: { validate: (function() {
          const e3 = (0, l.assertNodeType)("Identifier", "PrivateName"), t3 = (0, l.assertNodeType)("Expression"), validator = function(r3, n2, s2) {
            (r3.computed ? t3 : e3)(r3, n2, s2);
          };
          return validator.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"], validator;
        })() }, computed: { default: false } }, process.env.BABEL_TYPES_8_BREAKING ? {} : { optional: { validate: (0, l.assertValueType)("boolean"), optional: true } }) }), p("NewExpression", { inherits: "CallExpression" }), p("Program", { visitor: ["directives", "body"], builder: ["body", "directives", "sourceType", "interpreter"], fields: { sourceType: { validate: (0, l.assertOneOf)("script", "module"), default: "script" }, interpreter: { validate: (0, l.assertNodeType)("InterpreterDirective"), default: null, optional: true }, directives: { validate: (0, l.arrayOfType)("Directive"), default: [] }, body: (0, l.validateArrayOfType)("Statement") }, aliases: ["Scopable", "BlockParent", "Block"] }), p("ObjectExpression", { visitor: ["properties"], aliases: ["Expression"], fields: { properties: (0, l.validateArrayOfType)("ObjectMethod", "ObjectProperty", "SpreadElement") } }), p("ObjectMethod", { builder: ["kind", "key", "params", "body", "computed", "generator", "async"], visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"], fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), { kind: Object.assign({ validate: (0, l.assertOneOf)("method", "get", "set") }, process.env.BABEL_TYPES_8_BREAKING ? {} : { default: "method" }), computed: { default: false }, key: { validate: (function() {
          const e3 = (0, l.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"), t3 = (0, l.assertNodeType)("Expression"), validator = function(r3, n2, s2) {
            (r3.computed ? t3 : e3)(r3, n2, s2);
          };
          return validator.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"], validator;
        })() }, decorators: { validate: (0, l.arrayOfType)("Decorator"), optional: true }, body: { validate: (0, l.assertNodeType)("BlockStatement") } }), aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"] }), p("ObjectProperty", { builder: ["key", "value", "computed", "shorthand", ...process.env.BABEL_TYPES_8_BREAKING ? [] : ["decorators"]], fields: { computed: { default: false }, key: { validate: (function() {
          const e3 = (0, l.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"), t3 = (0, l.assertNodeType)("Expression");
          return Object.assign(function(r3, n2, s2) {
            (r3.computed ? t3 : e3)(r3, n2, s2);
          }, { oneOfNodeTypes: ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"] });
        })() }, value: { validate: (0, l.assertNodeType)("Expression", "PatternLike") }, shorthand: { validate: process.env.BABEL_TYPES_8_BREAKING ? (0, l.chain)((0, l.assertValueType)("boolean"), Object.assign(function(e3, t3, r3) {
          if (r3) {
            if (e3.computed) throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
            if (!(0, n.default)("Identifier", e3.key)) throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
          }
        }, { type: "boolean" })) : (0, l.assertValueType)("boolean"), default: false }, decorators: { validate: (0, l.arrayOfType)("Decorator"), optional: true } }, visitor: ["decorators", "key", "value"], aliases: ["UserWhitespacable", "Property", "ObjectMember"], validate: process.env.BABEL_TYPES_8_BREAKING ? (function() {
          const e3 = (0, l.assertNodeType)("Identifier", "Pattern", "TSAsExpression", "TSSatisfiesExpression", "TSNonNullExpression", "TSTypeAssertion"), t3 = (0, l.assertNodeType)("Expression");
          return function(r3, s2, i2) {
            ((0, n.default)("ObjectPattern", r3) ? e3 : t3)(i2, "value", i2.value);
          };
        })() : void 0 }), p("RestElement", { visitor: ["argument", "typeAnnotation"], builder: ["argument"], aliases: ["FunctionParameter", "PatternLike", "LVal"], deprecatedAlias: "RestProperty", fields: Object.assign({}, patternLikeCommon(), { argument: { validate: process.env.BABEL_TYPES_8_BREAKING ? (0, l.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, l.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression", "RestElement", "AssignmentPattern") } }), validate: process.env.BABEL_TYPES_8_BREAKING ? function(e3, t3) {
          const r3 = /(\w+)\[(\d+)\]/.exec(t3.toString());
          if (!r3) throw new Error("Internal Babel error: malformed key.");
          const [, n2, s2] = r3;
          if (e3[n2].length > +s2 + 1) throw new TypeError(`RestElement must be last element of ${n2}`);
        } : void 0 }), p("ReturnStatement", { visitor: ["argument"], aliases: ["Statement", "Terminatorless", "CompletionStatement"], fields: { argument: { validate: (0, l.assertNodeType)("Expression"), optional: true } } }), p("SequenceExpression", { visitor: ["expressions"], fields: { expressions: (0, l.validateArrayOfType)("Expression") }, aliases: ["Expression"] }), p("ParenthesizedExpression", { visitor: ["expression"], aliases: ["Expression", "ExpressionWrapper"], fields: { expression: { validate: (0, l.assertNodeType)("Expression") } } }), p("SwitchCase", { visitor: ["test", "consequent"], fields: { test: { validate: (0, l.assertNodeType)("Expression"), optional: true }, consequent: (0, l.validateArrayOfType)("Statement") } }), p("SwitchStatement", { visitor: ["discriminant", "cases"], aliases: ["Statement", "BlockParent", "Scopable"], fields: { discriminant: { validate: (0, l.assertNodeType)("Expression") }, cases: (0, l.validateArrayOfType)("SwitchCase") } }), p("ThisExpression", { aliases: ["Expression"] }), p("ThrowStatement", { visitor: ["argument"], aliases: ["Statement", "Terminatorless", "CompletionStatement"], fields: { argument: { validate: (0, l.assertNodeType)("Expression") } } }), p("TryStatement", { visitor: ["block", "handler", "finalizer"], aliases: ["Statement"], fields: { block: { validate: process.env.BABEL_TYPES_8_BREAKING ? (0, l.chain)((0, l.assertNodeType)("BlockStatement"), Object.assign(function(e3) {
          if (!e3.handler && !e3.finalizer) throw new TypeError("TryStatement expects either a handler or finalizer, or both");
        }, { oneOfNodeTypes: ["BlockStatement"] })) : (0, l.assertNodeType)("BlockStatement") }, handler: { optional: true, validate: (0, l.assertNodeType)("CatchClause") }, finalizer: { optional: true, validate: (0, l.assertNodeType)("BlockStatement") } } }), p("UnaryExpression", { builder: ["operator", "argument", "prefix"], fields: { prefix: { default: true }, argument: { validate: (0, l.assertNodeType)("Expression") }, operator: { validate: (0, l.assertOneOf)(...a.UNARY_OPERATORS) } }, visitor: ["argument"], aliases: ["UnaryLike", "Expression"] }), p("UpdateExpression", { builder: ["operator", "argument", "prefix"], fields: { prefix: { default: false }, argument: { validate: process.env.BABEL_TYPES_8_BREAKING ? (0, l.assertNodeType)("Identifier", "MemberExpression") : (0, l.assertNodeType)("Expression") }, operator: { validate: (0, l.assertOneOf)(...a.UPDATE_OPERATORS) } }, visitor: ["argument"], aliases: ["Expression"] }), p("VariableDeclaration", { builder: ["kind", "declarations"], visitor: ["declarations"], aliases: ["Statement", "Declaration"], fields: { declare: { validate: (0, l.assertValueType)("boolean"), optional: true }, kind: { validate: (0, l.assertOneOf)("var", "let", "const", "using", "await using") }, declarations: (0, l.validateArrayOfType)("VariableDeclarator") }, validate: process.env.BABEL_TYPES_8_BREAKING ? (() => {
          const e3 = (0, l.assertNodeType)("Identifier", "Placeholder"), t3 = (0, l.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "Placeholder"), r3 = (0, l.assertNodeType)("Identifier", "VoidPattern", "Placeholder");
          return function(s2, i2, o2) {
            const { kind: a2, declarations: l2 } = o2, p2 = (0, n.default)("ForXStatement", s2, { left: o2 });
            if (p2 && 1 !== l2.length) throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${s2.type}`);
            for (const n2 of l2) "const" === a2 || "let" === a2 || "var" === a2 ? p2 || n2.init ? t3(n2, "id", n2.id) : e3(n2, "id", n2.id) : r3(n2, "id", n2.id);
          };
        })() : void 0 }), p("VariableDeclarator", { visitor: ["id", "init"], fields: { id: { validate: process.env.BABEL_TYPES_8_BREAKING ? (0, l.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "VoidPattern") : (0, l.assertNodeType)("LVal", "VoidPattern") }, definite: { optional: true, validate: (0, l.assertValueType)("boolean") }, init: { optional: true, validate: (0, l.assertNodeType)("Expression") } } }), p("WhileStatement", { visitor: ["test", "body"], aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"], fields: { test: { validate: (0, l.assertNodeType)("Expression") }, body: { validate: (0, l.assertNodeType)("Statement") } } }), p("WithStatement", { visitor: ["object", "body"], aliases: ["Statement"], fields: { object: { validate: (0, l.assertNodeType)("Expression") }, body: { validate: (0, l.assertNodeType)("Statement") } } }), p("AssignmentPattern", { visitor: ["left", "right", "decorators"], builder: ["left", "right"], aliases: ["FunctionParameter", "Pattern", "PatternLike", "LVal"], fields: Object.assign({}, patternLikeCommon(), { left: { validate: (0, l.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") }, right: { validate: (0, l.assertNodeType)("Expression") }, decorators: { validate: (0, l.arrayOfType)("Decorator"), optional: true } }) }), p("ArrayPattern", { visitor: ["elements", "typeAnnotation"], builder: ["elements"], aliases: ["FunctionParameter", "Pattern", "PatternLike", "LVal"], fields: Object.assign({}, patternLikeCommon(), { elements: { validate: (0, l.chain)((0, l.assertValueType)("array"), (0, l.assertEach)((0, l.assertNodeOrValueType)("null", "PatternLike"))) } }) }), p("ArrowFunctionExpression", { builder: ["params", "body", "async"], visitor: ["typeParameters", "params", "predicate", "returnType", "body"], aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"], fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), { expression: { validate: (0, l.assertValueType)("boolean") }, body: { validate: (0, l.assertNodeType)("BlockStatement", "Expression") }, predicate: { validate: (0, l.assertNodeType)("DeclaredPredicate", "InferredPredicate"), optional: true } }) }), p("ClassBody", { visitor: ["body"], fields: { body: (0, l.validateArrayOfType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty", "TSDeclareMethod", "TSIndexSignature", "StaticBlock") } }), p("ClassExpression", { builder: ["id", "superClass", "body", "decorators"], visitor: ["decorators", "id", "typeParameters", "superClass", "superTypeParameters", "mixins", "implements", "body"], aliases: ["Scopable", "Class", "Expression"], fields: { id: { validate: (0, l.assertNodeType)("Identifier"), optional: true }, typeParameters: { validate: (0, l.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"), optional: true }, body: { validate: (0, l.assertNodeType)("ClassBody") }, superClass: { optional: true, validate: (0, l.assertNodeType)("Expression") }, superTypeParameters: { validate: (0, l.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"), optional: true }, implements: { validate: (0, l.arrayOfType)("TSExpressionWithTypeArguments", "ClassImplements"), optional: true }, decorators: { validate: (0, l.arrayOfType)("Decorator"), optional: true }, mixins: { validate: (0, l.assertNodeType)("InterfaceExtends"), optional: true } } }), p("ClassDeclaration", { inherits: "ClassExpression", aliases: ["Scopable", "Class", "Statement", "Declaration"], fields: { id: { validate: (0, l.assertNodeType)("Identifier"), optional: true }, typeParameters: { validate: (0, l.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"), optional: true }, body: { validate: (0, l.assertNodeType)("ClassBody") }, superClass: { optional: true, validate: (0, l.assertNodeType)("Expression") }, superTypeParameters: { validate: (0, l.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"), optional: true }, implements: { validate: (0, l.arrayOfType)("TSExpressionWithTypeArguments", "ClassImplements"), optional: true }, decorators: { validate: (0, l.arrayOfType)("Decorator"), optional: true }, mixins: { validate: (0, l.assertNodeType)("InterfaceExtends"), optional: true }, declare: { validate: (0, l.assertValueType)("boolean"), optional: true }, abstract: { validate: (0, l.assertValueType)("boolean"), optional: true } }, validate: process.env.BABEL_TYPES_8_BREAKING ? (function() {
          const e3 = (0, l.assertNodeType)("Identifier");
          return function(t3, r3, s2) {
            (0, n.default)("ExportDefaultDeclaration", t3) || e3(s2, "id", s2.id);
          };
        })() : void 0 });
        const c = t2.importAttributes = { attributes: { optional: true, validate: (0, l.arrayOfType)("ImportAttribute") }, assertions: { deprecated: true, optional: true, validate: (0, l.arrayOfType)("ImportAttribute") } };
        p("ExportAllDeclaration", { builder: ["source"], visitor: ["source", "attributes", "assertions"], aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"], fields: Object.assign({ source: { validate: (0, l.assertNodeType)("StringLiteral") }, exportKind: (0, l.validateOptional)((0, l.assertOneOf)("type", "value")) }, c) }), p("ExportDefaultDeclaration", { visitor: ["declaration"], aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"], fields: { declaration: (0, l.validateType)("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression"), exportKind: (0, l.validateOptional)((0, l.assertOneOf)("value")) } }), p("ExportNamedDeclaration", { builder: ["declaration", "specifiers", "source"], visitor: ["declaration", "specifiers", "source", "attributes", "assertions"], aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"], fields: Object.assign({ declaration: { optional: true, validate: process.env.BABEL_TYPES_8_BREAKING ? (0, l.chain)((0, l.assertNodeType)("Declaration"), Object.assign(function(e3, t3, r3) {
          if (r3 && e3.specifiers.length) throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
          if (r3 && e3.source) throw new TypeError("Cannot export a declaration from a source");
        }, { oneOfNodeTypes: ["Declaration"] })) : (0, l.assertNodeType)("Declaration") } }, c, { specifiers: { default: [], validate: (0, l.arrayOf)((function() {
          const e3 = (0, l.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier"), t3 = (0, l.assertNodeType)("ExportSpecifier");
          return process.env.BABEL_TYPES_8_BREAKING ? Object.assign(function(r3, n2, s2) {
            (r3.source ? e3 : t3)(r3, n2, s2);
          }, { oneOfNodeTypes: ["ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier"] }) : e3;
        })()) }, source: { validate: (0, l.assertNodeType)("StringLiteral"), optional: true }, exportKind: (0, l.validateOptional)((0, l.assertOneOf)("type", "value")) }) }), p("ExportSpecifier", { visitor: ["local", "exported"], aliases: ["ModuleSpecifier"], fields: { local: { validate: (0, l.assertNodeType)("Identifier") }, exported: { validate: (0, l.assertNodeType)("Identifier", "StringLiteral") }, exportKind: { validate: (0, l.assertOneOf)("type", "value"), optional: true } } }), p("ForOfStatement", { visitor: ["left", "right", "body"], builder: ["left", "right", "body", "await"], aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"], fields: { left: { validate: (function() {
          if (!process.env.BABEL_TYPES_8_BREAKING) return (0, l.assertNodeType)("VariableDeclaration", "LVal");
          const e3 = (0, l.assertNodeType)("VariableDeclaration"), t3 = (0, l.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression");
          return Object.assign(function(r3, s2, i2) {
            (0, n.default)("VariableDeclaration", i2) ? e3(r3, s2, i2) : t3(r3, s2, i2);
          }, { oneOfNodeTypes: ["VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression"] });
        })() }, right: { validate: (0, l.assertNodeType)("Expression") }, body: { validate: (0, l.assertNodeType)("Statement") }, await: { default: false } } }), p("ImportDeclaration", { builder: ["specifiers", "source"], visitor: ["specifiers", "source", "attributes", "assertions"], aliases: ["Statement", "Declaration", "ImportOrExportDeclaration"], fields: Object.assign({}, c, { module: { optional: true, validate: (0, l.assertValueType)("boolean") }, phase: { default: null, validate: (0, l.assertOneOf)("source", "defer") }, specifiers: (0, l.validateArrayOfType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier"), source: { validate: (0, l.assertNodeType)("StringLiteral") }, importKind: { validate: (0, l.assertOneOf)("type", "typeof", "value"), optional: true } }) }), p("ImportDefaultSpecifier", { visitor: ["local"], aliases: ["ModuleSpecifier"], fields: { local: { validate: (0, l.assertNodeType)("Identifier") } } }), p("ImportNamespaceSpecifier", { visitor: ["local"], aliases: ["ModuleSpecifier"], fields: { local: { validate: (0, l.assertNodeType)("Identifier") } } }), p("ImportSpecifier", { visitor: ["imported", "local"], builder: ["local", "imported"], aliases: ["ModuleSpecifier"], fields: { local: { validate: (0, l.assertNodeType)("Identifier") }, imported: { validate: (0, l.assertNodeType)("Identifier", "StringLiteral") }, importKind: { validate: (0, l.assertOneOf)("type", "typeof", "value"), optional: true } } }), p("ImportExpression", { visitor: ["source", "options"], aliases: ["Expression"], fields: { phase: { default: null, validate: (0, l.assertOneOf)("source", "defer") }, source: { validate: (0, l.assertNodeType)("Expression") }, options: { validate: (0, l.assertNodeType)("Expression"), optional: true } } }), p("MetaProperty", { visitor: ["meta", "property"], aliases: ["Expression"], fields: { meta: { validate: process.env.BABEL_TYPES_8_BREAKING ? (0, l.chain)((0, l.assertNodeType)("Identifier"), Object.assign(function(e3, t3, r3) {
          let s2;
          switch (r3.name) {
            case "function":
              s2 = "sent";
              break;
            case "new":
              s2 = "target";
              break;
            case "import":
              s2 = "meta";
          }
          if (!(0, n.default)("Identifier", e3.property, { name: s2 })) throw new TypeError("Unrecognised MetaProperty");
        }, { oneOfNodeTypes: ["Identifier"] })) : (0, l.assertNodeType)("Identifier") }, property: { validate: (0, l.assertNodeType)("Identifier") } } });
        const classMethodOrPropertyCommon = () => ({ abstract: { validate: (0, l.assertValueType)("boolean"), optional: true }, accessibility: { validate: (0, l.assertOneOf)("public", "private", "protected"), optional: true }, static: { default: false }, override: { default: false }, computed: { default: false }, optional: { validate: (0, l.assertValueType)("boolean"), optional: true }, key: { validate: (0, l.chain)((function() {
          const e3 = (0, l.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"), t3 = (0, l.assertNodeType)("Expression");
          return function(r3, n2, s2) {
            (r3.computed ? t3 : e3)(r3, n2, s2);
          };
        })(), (0, l.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression")) } });
        t2.classMethodOrPropertyCommon = classMethodOrPropertyCommon;
        const classMethodOrDeclareMethodCommon = () => Object.assign({}, functionCommon(), classMethodOrPropertyCommon(), { params: (0, l.validateArrayOfType)("FunctionParameter", "TSParameterProperty"), kind: { validate: (0, l.assertOneOf)("get", "set", "method", "constructor"), default: "method" }, access: { validate: (0, l.chain)((0, l.assertValueType)("string"), (0, l.assertOneOf)("public", "private", "protected")), optional: true }, decorators: { validate: (0, l.arrayOfType)("Decorator"), optional: true } });
        t2.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon, p("ClassMethod", { aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"], builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"], visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"], fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), { body: { validate: (0, l.assertNodeType)("BlockStatement") } }) }), p("ObjectPattern", { visitor: ["decorators", "properties", "typeAnnotation"], builder: ["properties"], aliases: ["FunctionParameter", "Pattern", "PatternLike", "LVal"], fields: Object.assign({}, patternLikeCommon(), { properties: (0, l.validateArrayOfType)("RestElement", "ObjectProperty") }) }), p("SpreadElement", { visitor: ["argument"], aliases: ["UnaryLike"], deprecatedAlias: "SpreadProperty", fields: { argument: { validate: (0, l.assertNodeType)("Expression") } } }), p("Super", { aliases: ["Expression"] }), p("TaggedTemplateExpression", { visitor: ["tag", "typeParameters", "quasi"], builder: ["tag", "quasi"], aliases: ["Expression"], fields: { tag: { validate: (0, l.assertNodeType)("Expression") }, quasi: { validate: (0, l.assertNodeType)("TemplateLiteral") }, typeParameters: { validate: (0, l.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"), optional: true } } }), p("TemplateElement", { builder: ["value", "tail"], fields: { value: { validate: (0, l.chain)((0, l.assertShape)({ raw: { validate: (0, l.assertValueType)("string") }, cooked: { validate: (0, l.assertValueType)("string"), optional: true } }), function(e3) {
          const t3 = e3.value.raw;
          let r3 = false;
          const error = () => {
            throw new Error("Internal @babel/types error.");
          }, { str: n2, firstInvalidLoc: s2 } = (0, o.readStringContents)("template", t3, 0, 0, 0, { unterminated() {
            r3 = true;
          }, strictNumericEscape: error, invalidEscapeSequence: error, numericSeparatorInEscapeSequence: error, unexpectedNumericSeparator: error, invalidDigit: error, invalidCodePoint: error });
          if (!r3) throw new Error("Invalid raw");
          e3.value.cooked = s2 ? null : n2;
        }) }, tail: { default: false } } }), p("TemplateLiteral", { visitor: ["quasis", "expressions"], aliases: ["Expression", "Literal"], fields: { quasis: (0, l.validateArrayOfType)("TemplateElement"), expressions: { validate: (0, l.chain)((0, l.assertValueType)("array"), (0, l.assertEach)((0, l.assertNodeType)("Expression", "TSType")), function(e3, t3, r3) {
          if (e3.quasis.length !== r3.length + 1) throw new TypeError(`Number of ${e3.type} quasis should be exactly one more than the number of expressions.
Expected ${r3.length + 1} quasis but got ${e3.quasis.length}`);
        }) } } }), p("YieldExpression", { builder: ["argument", "delegate"], visitor: ["argument"], aliases: ["Expression", "Terminatorless"], fields: { delegate: { validate: process.env.BABEL_TYPES_8_BREAKING ? (0, l.chain)((0, l.assertValueType)("boolean"), Object.assign(function(e3, t3, r3) {
          if (r3 && !e3.argument) throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
        }, { type: "boolean" })) : (0, l.assertValueType)("boolean"), default: false }, argument: { optional: true, validate: (0, l.assertNodeType)("Expression") } } }), p("AwaitExpression", { builder: ["argument"], visitor: ["argument"], aliases: ["Expression", "Terminatorless"], fields: { argument: { validate: (0, l.assertNodeType)("Expression") } } }), p("Import", { aliases: ["Expression"] }), p("BigIntLiteral", { builder: ["value"], fields: { value: { validate: (0, l.assertValueType)("string") } }, aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), p("ExportNamespaceSpecifier", { visitor: ["exported"], aliases: ["ModuleSpecifier"], fields: { exported: { validate: (0, l.assertNodeType)("Identifier") } } }), p("OptionalMemberExpression", { builder: ["object", "property", "computed", "optional"], visitor: ["object", "property"], aliases: ["Expression"], fields: { object: { validate: (0, l.assertNodeType)("Expression") }, property: { validate: (function() {
          const e3 = (0, l.assertNodeType)("Identifier"), t3 = (0, l.assertNodeType)("Expression");
          return Object.assign(function(r3, n2, s2) {
            (r3.computed ? t3 : e3)(r3, n2, s2);
          }, { oneOfNodeTypes: ["Expression", "Identifier"] });
        })() }, computed: { default: false }, optional: { validate: process.env.BABEL_TYPES_8_BREAKING ? (0, l.chain)((0, l.assertValueType)("boolean"), (0, l.assertOptionalChainStart)()) : (0, l.assertValueType)("boolean") } } }), p("OptionalCallExpression", { visitor: ["callee", "typeParameters", "typeArguments", "arguments"], builder: ["callee", "arguments", "optional"], aliases: ["Expression"], fields: Object.assign({ callee: { validate: (0, l.assertNodeType)("Expression") }, arguments: (0, l.validateArrayOfType)("Expression", "SpreadElement", "ArgumentPlaceholder"), optional: { validate: process.env.BABEL_TYPES_8_BREAKING ? (0, l.chain)((0, l.assertValueType)("boolean"), (0, l.assertOptionalChainStart)()) : (0, l.assertValueType)("boolean") }, typeArguments: { validate: (0, l.assertNodeType)("TypeParameterInstantiation"), optional: true } }, { typeParameters: { validate: (0, l.assertNodeType)("TSTypeParameterInstantiation"), optional: true } }) }), p("ClassProperty", { visitor: ["decorators", "variance", "key", "typeAnnotation", "value"], builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"], aliases: ["Property"], fields: Object.assign({}, classMethodOrPropertyCommon(), { value: { validate: (0, l.assertNodeType)("Expression"), optional: true }, definite: { validate: (0, l.assertValueType)("boolean"), optional: true }, typeAnnotation: { validate: (0, l.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"), optional: true }, decorators: { validate: (0, l.arrayOfType)("Decorator"), optional: true }, readonly: { validate: (0, l.assertValueType)("boolean"), optional: true }, declare: { validate: (0, l.assertValueType)("boolean"), optional: true }, variance: { validate: (0, l.assertNodeType)("Variance"), optional: true } }) }), p("ClassAccessorProperty", { visitor: ["decorators", "key", "typeAnnotation", "value"], builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"], aliases: ["Property", "Accessor"], fields: Object.assign({}, classMethodOrPropertyCommon(), { key: { validate: (0, l.chain)((function() {
          const e3 = (0, l.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName"), t3 = (0, l.assertNodeType)("Expression");
          return function(r3, n2, s2) {
            (r3.computed ? t3 : e3)(r3, n2, s2);
          };
        })(), (0, l.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName")) }, value: { validate: (0, l.assertNodeType)("Expression"), optional: true }, definite: { validate: (0, l.assertValueType)("boolean"), optional: true }, typeAnnotation: { validate: (0, l.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"), optional: true }, decorators: { validate: (0, l.arrayOfType)("Decorator"), optional: true }, readonly: { validate: (0, l.assertValueType)("boolean"), optional: true }, declare: { validate: (0, l.assertValueType)("boolean"), optional: true }, variance: { validate: (0, l.assertNodeType)("Variance"), optional: true } }) }), p("ClassPrivateProperty", { visitor: ["decorators", "variance", "key", "typeAnnotation", "value"], builder: ["key", "value", "decorators", "static"], aliases: ["Property", "Private"], fields: { key: { validate: (0, l.assertNodeType)("PrivateName") }, value: { validate: (0, l.assertNodeType)("Expression"), optional: true }, typeAnnotation: { validate: (0, l.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"), optional: true }, decorators: { validate: (0, l.arrayOfType)("Decorator"), optional: true }, static: { validate: (0, l.assertValueType)("boolean"), default: false }, readonly: { validate: (0, l.assertValueType)("boolean"), optional: true }, optional: { validate: (0, l.assertValueType)("boolean"), optional: true }, definite: { validate: (0, l.assertValueType)("boolean"), optional: true }, variance: { validate: (0, l.assertNodeType)("Variance"), optional: true } } }), p("ClassPrivateMethod", { builder: ["kind", "key", "params", "body", "static"], visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"], aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"], fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), { kind: { validate: (0, l.assertOneOf)("get", "set", "method"), default: "method" }, key: { validate: (0, l.assertNodeType)("PrivateName") }, body: { validate: (0, l.assertNodeType)("BlockStatement") } }) }), p("PrivateName", { visitor: ["id"], aliases: ["Private"], fields: { id: { validate: (0, l.assertNodeType)("Identifier") } } }), p("StaticBlock", { visitor: ["body"], fields: { body: (0, l.validateArrayOfType)("Statement") }, aliases: ["Scopable", "BlockParent", "FunctionParent"] }), p("ImportAttribute", { visitor: ["key", "value"], fields: { key: { validate: (0, l.assertNodeType)("Identifier", "StringLiteral") }, value: { validate: (0, l.assertNodeType)("StringLiteral") } } });
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/definitions/deprecated-aliases.js": function(e2, t2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.DEPRECATED_ALIASES = void 0;
        t2.DEPRECATED_ALIASES = { ModuleDeclaration: "ImportOrExportDeclaration" };
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/definitions/experimental.js": function(e2, t2, r2) {
        "use strict";
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/definitions/utils.js");
        (0, n.default)("ArgumentPlaceholder", {}), (0, n.default)("BindExpression", { visitor: ["object", "callee"], aliases: ["Expression"], fields: process.env.BABEL_TYPES_8_BREAKING ? { object: { validate: (0, n.assertNodeType)("Expression") }, callee: { validate: (0, n.assertNodeType)("Expression") } } : { object: { validate: Object.assign(() => {
        }, { oneOfNodeTypes: ["Expression"] }) }, callee: { validate: Object.assign(() => {
        }, { oneOfNodeTypes: ["Expression"] }) } } }), (0, n.default)("Decorator", { visitor: ["expression"], fields: { expression: { validate: (0, n.assertNodeType)("Expression") } } }), (0, n.default)("DoExpression", { visitor: ["body"], builder: ["body", "async"], aliases: ["Expression"], fields: { body: { validate: (0, n.assertNodeType)("BlockStatement") }, async: { validate: (0, n.assertValueType)("boolean"), default: false } } }), (0, n.default)("ExportDefaultSpecifier", { visitor: ["exported"], aliases: ["ModuleSpecifier"], fields: { exported: { validate: (0, n.assertNodeType)("Identifier") } } }), (0, n.default)("RecordExpression", { visitor: ["properties"], aliases: ["Expression"], fields: { properties: (0, n.validateArrayOfType)("ObjectProperty", "SpreadElement") } }), (0, n.default)("TupleExpression", { fields: { elements: { validate: (0, n.arrayOfType)("Expression", "SpreadElement"), default: [] } }, visitor: ["elements"], aliases: ["Expression"] }), (0, n.default)("DecimalLiteral", { builder: ["value"], fields: { value: { validate: (0, n.assertValueType)("string") } }, aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), (0, n.default)("ModuleExpression", { visitor: ["body"], fields: { body: { validate: (0, n.assertNodeType)("Program") } }, aliases: ["Expression"] }), (0, n.default)("TopicReference", { aliases: ["Expression"] }), (0, n.default)("PipelineTopicExpression", { builder: ["expression"], visitor: ["expression"], fields: { expression: { validate: (0, n.assertNodeType)("Expression") } }, aliases: ["Expression"] }), (0, n.default)("PipelineBareFunction", { builder: ["callee"], visitor: ["callee"], fields: { callee: { validate: (0, n.assertNodeType)("Expression") } }, aliases: ["Expression"] }), (0, n.default)("PipelinePrimaryTopicReference", { aliases: ["Expression"] }), (0, n.default)("VoidPattern", { aliases: ["Pattern", "PatternLike", "FunctionParameter"] });
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/definitions/flow.js": function(e2, t2, r2) {
        "use strict";
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/definitions/core.js"), s = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/definitions/utils.js");
        const i = (0, s.defineAliasedType)("Flow"), defineInterfaceishType = (e3) => {
          const t3 = "DeclareClass" === e3;
          i(e3, { builder: ["id", "typeParameters", "extends", "body"], visitor: ["id", "typeParameters", "extends", ...t3 ? ["mixins", "implements"] : [], "body"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: Object.assign({ id: (0, s.validateType)("Identifier"), typeParameters: (0, s.validateOptionalType)("TypeParameterDeclaration"), extends: (0, s.validateOptional)((0, s.arrayOfType)("InterfaceExtends")) }, t3 ? { mixins: (0, s.validateOptional)((0, s.arrayOfType)("InterfaceExtends")), implements: (0, s.validateOptional)((0, s.arrayOfType)("ClassImplements")) } : {}, { body: (0, s.validateType)("ObjectTypeAnnotation") }) });
        };
        i("AnyTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), i("ArrayTypeAnnotation", { visitor: ["elementType"], aliases: ["FlowType"], fields: { elementType: (0, s.validateType)("FlowType") } }), i("BooleanTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), i("BooleanLiteralTypeAnnotation", { builder: ["value"], aliases: ["FlowType"], fields: { value: (0, s.validate)((0, s.assertValueType)("boolean")) } }), i("NullLiteralTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), i("ClassImplements", { visitor: ["id", "typeParameters"], fields: { id: (0, s.validateType)("Identifier"), typeParameters: (0, s.validateOptionalType)("TypeParameterInstantiation") } }), defineInterfaceishType("DeclareClass"), i("DeclareFunction", { builder: ["id"], visitor: ["id", "predicate"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, s.validateType)("Identifier"), predicate: (0, s.validateOptionalType)("DeclaredPredicate") } }), defineInterfaceishType("DeclareInterface"), i("DeclareModule", { builder: ["id", "body", "kind"], visitor: ["id", "body"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, s.validateType)("Identifier", "StringLiteral"), body: (0, s.validateType)("BlockStatement"), kind: (0, s.validateOptional)((0, s.assertOneOf)("CommonJS", "ES")) } }), i("DeclareModuleExports", { visitor: ["typeAnnotation"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { typeAnnotation: (0, s.validateType)("TypeAnnotation") } }), i("DeclareTypeAlias", { visitor: ["id", "typeParameters", "right"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, s.validateType)("Identifier"), typeParameters: (0, s.validateOptionalType)("TypeParameterDeclaration"), right: (0, s.validateType)("FlowType") } }), i("DeclareOpaqueType", { visitor: ["id", "typeParameters", "supertype"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, s.validateType)("Identifier"), typeParameters: (0, s.validateOptionalType)("TypeParameterDeclaration"), supertype: (0, s.validateOptionalType)("FlowType"), impltype: (0, s.validateOptionalType)("FlowType") } }), i("DeclareVariable", { visitor: ["id"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, s.validateType)("Identifier") } }), i("DeclareExportDeclaration", { visitor: ["declaration", "specifiers", "source", "attributes"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: Object.assign({ declaration: (0, s.validateOptionalType)("Flow"), specifiers: (0, s.validateOptional)((0, s.arrayOfType)("ExportSpecifier", "ExportNamespaceSpecifier")), source: (0, s.validateOptionalType)("StringLiteral"), default: (0, s.validateOptional)((0, s.assertValueType)("boolean")) }, n.importAttributes) }), i("DeclareExportAllDeclaration", { visitor: ["source", "attributes"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: Object.assign({ source: (0, s.validateType)("StringLiteral"), exportKind: (0, s.validateOptional)((0, s.assertOneOf)("type", "value")) }, n.importAttributes) }), i("DeclaredPredicate", { visitor: ["value"], aliases: ["FlowPredicate"], fields: { value: (0, s.validateType)("Flow") } }), i("ExistsTypeAnnotation", { aliases: ["FlowType"] }), i("FunctionTypeAnnotation", { builder: ["typeParameters", "params", "rest", "returnType"], visitor: ["typeParameters", "this", "params", "rest", "returnType"], aliases: ["FlowType"], fields: { typeParameters: (0, s.validateOptionalType)("TypeParameterDeclaration"), params: (0, s.validateArrayOfType)("FunctionTypeParam"), rest: (0, s.validateOptionalType)("FunctionTypeParam"), this: (0, s.validateOptionalType)("FunctionTypeParam"), returnType: (0, s.validateType)("FlowType") } }), i("FunctionTypeParam", { visitor: ["name", "typeAnnotation"], fields: { name: (0, s.validateOptionalType)("Identifier"), typeAnnotation: (0, s.validateType)("FlowType"), optional: (0, s.validateOptional)((0, s.assertValueType)("boolean")) } }), i("GenericTypeAnnotation", { visitor: ["id", "typeParameters"], aliases: ["FlowType"], fields: { id: (0, s.validateType)("Identifier", "QualifiedTypeIdentifier"), typeParameters: (0, s.validateOptionalType)("TypeParameterInstantiation") } }), i("InferredPredicate", { aliases: ["FlowPredicate"] }), i("InterfaceExtends", { visitor: ["id", "typeParameters"], fields: { id: (0, s.validateType)("Identifier", "QualifiedTypeIdentifier"), typeParameters: (0, s.validateOptionalType)("TypeParameterInstantiation") } }), defineInterfaceishType("InterfaceDeclaration"), i("InterfaceTypeAnnotation", { visitor: ["extends", "body"], aliases: ["FlowType"], fields: { extends: (0, s.validateOptional)((0, s.arrayOfType)("InterfaceExtends")), body: (0, s.validateType)("ObjectTypeAnnotation") } }), i("IntersectionTypeAnnotation", { visitor: ["types"], aliases: ["FlowType"], fields: { types: (0, s.validate)((0, s.arrayOfType)("FlowType")) } }), i("MixedTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), i("EmptyTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), i("NullableTypeAnnotation", { visitor: ["typeAnnotation"], aliases: ["FlowType"], fields: { typeAnnotation: (0, s.validateType)("FlowType") } }), i("NumberLiteralTypeAnnotation", { builder: ["value"], aliases: ["FlowType"], fields: { value: (0, s.validate)((0, s.assertValueType)("number")) } }), i("NumberTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), i("ObjectTypeAnnotation", { visitor: ["properties", "indexers", "callProperties", "internalSlots"], aliases: ["FlowType"], builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"], fields: { properties: (0, s.validate)((0, s.arrayOfType)("ObjectTypeProperty", "ObjectTypeSpreadProperty")), indexers: { validate: (0, s.arrayOfType)("ObjectTypeIndexer"), optional: true, default: [] }, callProperties: { validate: (0, s.arrayOfType)("ObjectTypeCallProperty"), optional: true, default: [] }, internalSlots: { validate: (0, s.arrayOfType)("ObjectTypeInternalSlot"), optional: true, default: [] }, exact: { validate: (0, s.assertValueType)("boolean"), default: false }, inexact: (0, s.validateOptional)((0, s.assertValueType)("boolean")) } }), i("ObjectTypeInternalSlot", { visitor: ["id", "value"], builder: ["id", "value", "optional", "static", "method"], aliases: ["UserWhitespacable"], fields: { id: (0, s.validateType)("Identifier"), value: (0, s.validateType)("FlowType"), optional: (0, s.validate)((0, s.assertValueType)("boolean")), static: (0, s.validate)((0, s.assertValueType)("boolean")), method: (0, s.validate)((0, s.assertValueType)("boolean")) } }), i("ObjectTypeCallProperty", { visitor: ["value"], aliases: ["UserWhitespacable"], fields: { value: (0, s.validateType)("FlowType"), static: (0, s.validate)((0, s.assertValueType)("boolean")) } }), i("ObjectTypeIndexer", { visitor: ["variance", "id", "key", "value"], builder: ["id", "key", "value", "variance"], aliases: ["UserWhitespacable"], fields: { id: (0, s.validateOptionalType)("Identifier"), key: (0, s.validateType)("FlowType"), value: (0, s.validateType)("FlowType"), static: (0, s.validate)((0, s.assertValueType)("boolean")), variance: (0, s.validateOptionalType)("Variance") } }), i("ObjectTypeProperty", { visitor: ["key", "value", "variance"], aliases: ["UserWhitespacable"], fields: { key: (0, s.validateType)("Identifier", "StringLiteral"), value: (0, s.validateType)("FlowType"), kind: (0, s.validate)((0, s.assertOneOf)("init", "get", "set")), static: (0, s.validate)((0, s.assertValueType)("boolean")), proto: (0, s.validate)((0, s.assertValueType)("boolean")), optional: (0, s.validate)((0, s.assertValueType)("boolean")), variance: (0, s.validateOptionalType)("Variance"), method: (0, s.validate)((0, s.assertValueType)("boolean")) } }), i("ObjectTypeSpreadProperty", { visitor: ["argument"], aliases: ["UserWhitespacable"], fields: { argument: (0, s.validateType)("FlowType") } }), i("OpaqueType", { visitor: ["id", "typeParameters", "supertype", "impltype"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, s.validateType)("Identifier"), typeParameters: (0, s.validateOptionalType)("TypeParameterDeclaration"), supertype: (0, s.validateOptionalType)("FlowType"), impltype: (0, s.validateType)("FlowType") } }), i("QualifiedTypeIdentifier", { visitor: ["qualification", "id"], builder: ["id", "qualification"], fields: { id: (0, s.validateType)("Identifier"), qualification: (0, s.validateType)("Identifier", "QualifiedTypeIdentifier") } }), i("StringLiteralTypeAnnotation", { builder: ["value"], aliases: ["FlowType"], fields: { value: (0, s.validate)((0, s.assertValueType)("string")) } }), i("StringTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), i("SymbolTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), i("ThisTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), i("TupleTypeAnnotation", { visitor: ["types"], aliases: ["FlowType"], fields: { types: (0, s.validate)((0, s.arrayOfType)("FlowType")) } }), i("TypeofTypeAnnotation", { visitor: ["argument"], aliases: ["FlowType"], fields: { argument: (0, s.validateType)("FlowType") } }), i("TypeAlias", { visitor: ["id", "typeParameters", "right"], aliases: ["FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, s.validateType)("Identifier"), typeParameters: (0, s.validateOptionalType)("TypeParameterDeclaration"), right: (0, s.validateType)("FlowType") } }), i("TypeAnnotation", { visitor: ["typeAnnotation"], fields: { typeAnnotation: (0, s.validateType)("FlowType") } }), i("TypeCastExpression", { visitor: ["expression", "typeAnnotation"], aliases: ["ExpressionWrapper", "Expression"], fields: { expression: (0, s.validateType)("Expression"), typeAnnotation: (0, s.validateType)("TypeAnnotation") } }), i("TypeParameter", { visitor: ["bound", "default", "variance"], fields: { name: (0, s.validate)((0, s.assertValueType)("string")), bound: (0, s.validateOptionalType)("TypeAnnotation"), default: (0, s.validateOptionalType)("FlowType"), variance: (0, s.validateOptionalType)("Variance") } }), i("TypeParameterDeclaration", { visitor: ["params"], fields: { params: (0, s.validate)((0, s.arrayOfType)("TypeParameter")) } }), i("TypeParameterInstantiation", { visitor: ["params"], fields: { params: (0, s.validate)((0, s.arrayOfType)("FlowType")) } }), i("UnionTypeAnnotation", { visitor: ["types"], aliases: ["FlowType"], fields: { types: (0, s.validate)((0, s.arrayOfType)("FlowType")) } }), i("Variance", { builder: ["kind"], fields: { kind: (0, s.validate)((0, s.assertOneOf)("minus", "plus")) } }), i("VoidTypeAnnotation", { aliases: ["FlowType", "FlowBaseAnnotation"] }), i("EnumDeclaration", { aliases: ["Statement", "Declaration"], visitor: ["id", "body"], fields: { id: (0, s.validateType)("Identifier"), body: (0, s.validateType)("EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody") } }), i("EnumBooleanBody", { aliases: ["EnumBody"], visitor: ["members"], fields: { explicitType: (0, s.validate)((0, s.assertValueType)("boolean")), members: (0, s.validateArrayOfType)("EnumBooleanMember"), hasUnknownMembers: (0, s.validate)((0, s.assertValueType)("boolean")) } }), i("EnumNumberBody", { aliases: ["EnumBody"], visitor: ["members"], fields: { explicitType: (0, s.validate)((0, s.assertValueType)("boolean")), members: (0, s.validateArrayOfType)("EnumNumberMember"), hasUnknownMembers: (0, s.validate)((0, s.assertValueType)("boolean")) } }), i("EnumStringBody", { aliases: ["EnumBody"], visitor: ["members"], fields: { explicitType: (0, s.validate)((0, s.assertValueType)("boolean")), members: (0, s.validateArrayOfType)("EnumStringMember", "EnumDefaultedMember"), hasUnknownMembers: (0, s.validate)((0, s.assertValueType)("boolean")) } }), i("EnumSymbolBody", { aliases: ["EnumBody"], visitor: ["members"], fields: { members: (0, s.validateArrayOfType)("EnumDefaultedMember"), hasUnknownMembers: (0, s.validate)((0, s.assertValueType)("boolean")) } }), i("EnumBooleanMember", { aliases: ["EnumMember"], builder: ["id"], visitor: ["id", "init"], fields: { id: (0, s.validateType)("Identifier"), init: (0, s.validateType)("BooleanLiteral") } }), i("EnumNumberMember", { aliases: ["EnumMember"], visitor: ["id", "init"], fields: { id: (0, s.validateType)("Identifier"), init: (0, s.validateType)("NumericLiteral") } }), i("EnumStringMember", { aliases: ["EnumMember"], visitor: ["id", "init"], fields: { id: (0, s.validateType)("Identifier"), init: (0, s.validateType)("StringLiteral") } }), i("EnumDefaultedMember", { aliases: ["EnumMember"], visitor: ["id"], fields: { id: (0, s.validateType)("Identifier") } }), i("IndexedAccessType", { visitor: ["objectType", "indexType"], aliases: ["FlowType"], fields: { objectType: (0, s.validateType)("FlowType"), indexType: (0, s.validateType)("FlowType") } }), i("OptionalIndexedAccessType", { visitor: ["objectType", "indexType"], aliases: ["FlowType"], fields: { objectType: (0, s.validateType)("FlowType"), indexType: (0, s.validateType)("FlowType"), optional: (0, s.validate)((0, s.assertValueType)("boolean")) } });
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/definitions/index.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), Object.defineProperty(t2, "ALIAS_KEYS", { enumerable: true, get: function() {
          return n.ALIAS_KEYS;
        } }), Object.defineProperty(t2, "BUILDER_KEYS", { enumerable: true, get: function() {
          return n.BUILDER_KEYS;
        } }), Object.defineProperty(t2, "DEPRECATED_ALIASES", { enumerable: true, get: function() {
          return i.DEPRECATED_ALIASES;
        } }), Object.defineProperty(t2, "DEPRECATED_KEYS", { enumerable: true, get: function() {
          return n.DEPRECATED_KEYS;
        } }), Object.defineProperty(t2, "FLIPPED_ALIAS_KEYS", { enumerable: true, get: function() {
          return n.FLIPPED_ALIAS_KEYS;
        } }), Object.defineProperty(t2, "NODE_FIELDS", { enumerable: true, get: function() {
          return n.NODE_FIELDS;
        } }), Object.defineProperty(t2, "NODE_PARENT_VALIDATIONS", { enumerable: true, get: function() {
          return n.NODE_PARENT_VALIDATIONS;
        } }), Object.defineProperty(t2, "PLACEHOLDERS", { enumerable: true, get: function() {
          return s.PLACEHOLDERS;
        } }), Object.defineProperty(t2, "PLACEHOLDERS_ALIAS", { enumerable: true, get: function() {
          return s.PLACEHOLDERS_ALIAS;
        } }), Object.defineProperty(t2, "PLACEHOLDERS_FLIPPED_ALIAS", { enumerable: true, get: function() {
          return s.PLACEHOLDERS_FLIPPED_ALIAS;
        } }), t2.TYPES = void 0, Object.defineProperty(t2, "VISITOR_KEYS", { enumerable: true, get: function() {
          return n.VISITOR_KEYS;
        } }), r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/definitions/core.js"), r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/definitions/flow.js"), r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/definitions/jsx.js"), r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/definitions/misc.js"), r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/definitions/experimental.js"), r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/definitions/typescript.js");
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/definitions/utils.js"), s = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/definitions/placeholders.js"), i = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/definitions/deprecated-aliases.js");
        Object.keys(i.DEPRECATED_ALIASES).forEach((e3) => {
          n.FLIPPED_ALIAS_KEYS[e3] = n.FLIPPED_ALIAS_KEYS[i.DEPRECATED_ALIASES[e3]];
        });
        for (const { types: e3, set: t3 } of n.allExpandedTypes) for (const r3 of e3) {
          const e4 = n.FLIPPED_ALIAS_KEYS[r3];
          e4 ? e4.forEach(t3.add, t3) : t3.add(r3);
        }
        t2.TYPES = [].concat(Object.keys(n.VISITOR_KEYS), Object.keys(n.FLIPPED_ALIAS_KEYS), Object.keys(n.DEPRECATED_KEYS));
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/definitions/jsx.js": function(e2, t2, r2) {
        "use strict";
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/definitions/utils.js");
        const s = (0, n.defineAliasedType)("JSX");
        s("JSXAttribute", { visitor: ["name", "value"], aliases: ["Immutable"], fields: { name: { validate: (0, n.assertNodeType)("JSXIdentifier", "JSXNamespacedName") }, value: { optional: true, validate: (0, n.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer") } } }), s("JSXClosingElement", { visitor: ["name"], aliases: ["Immutable"], fields: { name: { validate: (0, n.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName") } } }), s("JSXElement", { builder: ["openingElement", "closingElement", "children", "selfClosing"], visitor: ["openingElement", "children", "closingElement"], aliases: ["Immutable", "Expression"], fields: Object.assign({ openingElement: { validate: (0, n.assertNodeType)("JSXOpeningElement") }, closingElement: { optional: true, validate: (0, n.assertNodeType)("JSXClosingElement") }, children: (0, n.validateArrayOfType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment") }, { selfClosing: { validate: (0, n.assertValueType)("boolean"), optional: true } }) }), s("JSXEmptyExpression", {}), s("JSXExpressionContainer", { visitor: ["expression"], aliases: ["Immutable"], fields: { expression: { validate: (0, n.assertNodeType)("Expression", "JSXEmptyExpression") } } }), s("JSXSpreadChild", { visitor: ["expression"], aliases: ["Immutable"], fields: { expression: { validate: (0, n.assertNodeType)("Expression") } } }), s("JSXIdentifier", { builder: ["name"], fields: { name: { validate: (0, n.assertValueType)("string") } } }), s("JSXMemberExpression", { visitor: ["object", "property"], fields: { object: { validate: (0, n.assertNodeType)("JSXMemberExpression", "JSXIdentifier") }, property: { validate: (0, n.assertNodeType)("JSXIdentifier") } } }), s("JSXNamespacedName", { visitor: ["namespace", "name"], fields: { namespace: { validate: (0, n.assertNodeType)("JSXIdentifier") }, name: { validate: (0, n.assertNodeType)("JSXIdentifier") } } }), s("JSXOpeningElement", { builder: ["name", "attributes", "selfClosing"], visitor: ["name", "typeParameters", "typeArguments", "attributes"], aliases: ["Immutable"], fields: Object.assign({ name: { validate: (0, n.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName") }, selfClosing: { default: false }, attributes: (0, n.validateArrayOfType)("JSXAttribute", "JSXSpreadAttribute"), typeArguments: { validate: (0, n.assertNodeType)("TypeParameterInstantiation"), optional: true } }, { typeParameters: { validate: (0, n.assertNodeType)("TSTypeParameterInstantiation"), optional: true } }) }), s("JSXSpreadAttribute", { visitor: ["argument"], fields: { argument: { validate: (0, n.assertNodeType)("Expression") } } }), s("JSXText", { aliases: ["Immutable"], builder: ["value"], fields: { value: { validate: (0, n.assertValueType)("string") } } }), s("JSXFragment", { builder: ["openingFragment", "closingFragment", "children"], visitor: ["openingFragment", "children", "closingFragment"], aliases: ["Immutable", "Expression"], fields: { openingFragment: { validate: (0, n.assertNodeType)("JSXOpeningFragment") }, closingFragment: { validate: (0, n.assertNodeType)("JSXClosingFragment") }, children: (0, n.validateArrayOfType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment") } }), s("JSXOpeningFragment", { aliases: ["Immutable"] }), s("JSXClosingFragment", { aliases: ["Immutable"] });
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/definitions/misc.js": function(e2, t2, r2) {
        "use strict";
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/definitions/utils.js"), s = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/definitions/placeholders.js"), i = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/definitions/core.js");
        const o = (0, n.defineAliasedType)("Miscellaneous");
        o("Noop", { visitor: [] }), o("Placeholder", { visitor: [], builder: ["expectedNode", "name"], fields: Object.assign({ name: { validate: (0, n.assertNodeType)("Identifier") }, expectedNode: { validate: (0, n.assertOneOf)(...s.PLACEHOLDERS) } }, (0, i.patternLikeCommon)()) }), o("V8IntrinsicIdentifier", { builder: ["name"], fields: { name: { validate: (0, n.assertValueType)("string") } } });
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/definitions/placeholders.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.PLACEHOLDERS_FLIPPED_ALIAS = t2.PLACEHOLDERS_ALIAS = t2.PLACEHOLDERS = void 0;
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/definitions/utils.js");
        const s = t2.PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBody", "Pattern"], i = t2.PLACEHOLDERS_ALIAS = { Declaration: ["Statement"], Pattern: ["PatternLike", "LVal"] };
        for (const e3 of s) {
          const t3 = n.ALIAS_KEYS[e3];
          null != t3 && t3.length && (i[e3] = t3);
        }
        const o = t2.PLACEHOLDERS_FLIPPED_ALIAS = {};
        Object.keys(i).forEach((e3) => {
          i[e3].forEach((t3) => {
            hasOwnProperty.call(o, t3) || (o[t3] = []), o[t3].push(e3);
          });
        });
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/definitions/typescript.js": function(e2, t2, r2) {
        "use strict";
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/definitions/utils.js"), s = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/definitions/core.js"), i = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/is.js");
        const o = (0, n.defineAliasedType)("TypeScript"), a = (0, n.assertValueType)("boolean"), tSFunctionTypeAnnotationCommon = () => ({ returnType: { validate: (0, n.assertNodeType)("TSTypeAnnotation", "Noop"), optional: true }, typeParameters: { validate: (0, n.assertNodeType)("TSTypeParameterDeclaration", "Noop"), optional: true } });
        o("TSParameterProperty", { aliases: ["LVal"], visitor: ["parameter"], fields: { accessibility: { validate: (0, n.assertOneOf)("public", "private", "protected"), optional: true }, readonly: { validate: (0, n.assertValueType)("boolean"), optional: true }, parameter: { validate: (0, n.assertNodeType)("Identifier", "AssignmentPattern") }, override: { validate: (0, n.assertValueType)("boolean"), optional: true }, decorators: { validate: (0, n.arrayOfType)("Decorator"), optional: true } } }), o("TSDeclareFunction", { aliases: ["Statement", "Declaration"], visitor: ["id", "typeParameters", "params", "returnType"], fields: Object.assign({}, (0, s.functionDeclarationCommon)(), tSFunctionTypeAnnotationCommon()) }), o("TSDeclareMethod", { visitor: ["decorators", "key", "typeParameters", "params", "returnType"], fields: Object.assign({}, (0, s.classMethodOrDeclareMethodCommon)(), tSFunctionTypeAnnotationCommon()) }), o("TSQualifiedName", { aliases: ["TSEntityName"], visitor: ["left", "right"], fields: { left: (0, n.validateType)("TSEntityName"), right: (0, n.validateType)("Identifier") } });
        const signatureDeclarationCommon = () => ({ typeParameters: (0, n.validateOptionalType)("TSTypeParameterDeclaration"), parameters: (0, n.validateArrayOfType)("ArrayPattern", "Identifier", "ObjectPattern", "RestElement"), typeAnnotation: (0, n.validateOptionalType)("TSTypeAnnotation") }), l = { aliases: ["TSTypeElement"], visitor: ["typeParameters", "parameters", "typeAnnotation"], fields: signatureDeclarationCommon() };
        o("TSCallSignatureDeclaration", l), o("TSConstructSignatureDeclaration", l);
        const namedTypeElementCommon = () => ({ key: (0, n.validateType)("Expression"), computed: { default: false }, optional: (0, n.validateOptional)(a) });
        o("TSPropertySignature", { aliases: ["TSTypeElement"], visitor: ["key", "typeAnnotation"], fields: Object.assign({}, namedTypeElementCommon(), { readonly: (0, n.validateOptional)(a), typeAnnotation: (0, n.validateOptionalType)("TSTypeAnnotation"), kind: { optional: true, validate: (0, n.assertOneOf)("get", "set") } }) }), o("TSMethodSignature", { aliases: ["TSTypeElement"], visitor: ["key", "typeParameters", "parameters", "typeAnnotation"], fields: Object.assign({}, signatureDeclarationCommon(), namedTypeElementCommon(), { kind: { validate: (0, n.assertOneOf)("method", "get", "set") } }) }), o("TSIndexSignature", { aliases: ["TSTypeElement"], visitor: ["parameters", "typeAnnotation"], fields: { readonly: (0, n.validateOptional)(a), static: (0, n.validateOptional)(a), parameters: (0, n.validateArrayOfType)("Identifier"), typeAnnotation: (0, n.validateOptionalType)("TSTypeAnnotation") } });
        const p = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];
        for (const e3 of p) o(e3, { aliases: ["TSType", "TSBaseType"], visitor: [], fields: {} });
        o("TSThisType", { aliases: ["TSType", "TSBaseType"], visitor: [], fields: {} });
        const c = { aliases: ["TSType"], visitor: ["typeParameters", "parameters", "typeAnnotation"] };
        o("TSFunctionType", Object.assign({}, c, { fields: signatureDeclarationCommon() })), o("TSConstructorType", Object.assign({}, c, { fields: Object.assign({}, signatureDeclarationCommon(), { abstract: (0, n.validateOptional)(a) }) })), o("TSTypeReference", { aliases: ["TSType"], visitor: ["typeName", "typeParameters"], fields: { typeName: (0, n.validateType)("TSEntityName"), typeParameters: (0, n.validateOptionalType)("TSTypeParameterInstantiation") } }), o("TSTypePredicate", { aliases: ["TSType"], visitor: ["parameterName", "typeAnnotation"], builder: ["parameterName", "typeAnnotation", "asserts"], fields: { parameterName: (0, n.validateType)("Identifier", "TSThisType"), typeAnnotation: (0, n.validateOptionalType)("TSTypeAnnotation"), asserts: (0, n.validateOptional)(a) } }), o("TSTypeQuery", { aliases: ["TSType"], visitor: ["exprName", "typeParameters"], fields: { exprName: (0, n.validateType)("TSEntityName", "TSImportType"), typeParameters: (0, n.validateOptionalType)("TSTypeParameterInstantiation") } }), o("TSTypeLiteral", { aliases: ["TSType"], visitor: ["members"], fields: { members: (0, n.validateArrayOfType)("TSTypeElement") } }), o("TSArrayType", { aliases: ["TSType"], visitor: ["elementType"], fields: { elementType: (0, n.validateType)("TSType") } }), o("TSTupleType", { aliases: ["TSType"], visitor: ["elementTypes"], fields: { elementTypes: (0, n.validateArrayOfType)("TSType", "TSNamedTupleMember") } }), o("TSOptionalType", { aliases: ["TSType"], visitor: ["typeAnnotation"], fields: { typeAnnotation: (0, n.validateType)("TSType") } }), o("TSRestType", { aliases: ["TSType"], visitor: ["typeAnnotation"], fields: { typeAnnotation: (0, n.validateType)("TSType") } }), o("TSNamedTupleMember", { visitor: ["label", "elementType"], builder: ["label", "elementType", "optional"], fields: { label: (0, n.validateType)("Identifier"), optional: { validate: a, default: false }, elementType: (0, n.validateType)("TSType") } });
        const u = { aliases: ["TSType"], visitor: ["types"], fields: { types: (0, n.validateArrayOfType)("TSType") } };
        o("TSUnionType", u), o("TSIntersectionType", u), o("TSConditionalType", { aliases: ["TSType"], visitor: ["checkType", "extendsType", "trueType", "falseType"], fields: { checkType: (0, n.validateType)("TSType"), extendsType: (0, n.validateType)("TSType"), trueType: (0, n.validateType)("TSType"), falseType: (0, n.validateType)("TSType") } }), o("TSInferType", { aliases: ["TSType"], visitor: ["typeParameter"], fields: { typeParameter: (0, n.validateType)("TSTypeParameter") } }), o("TSParenthesizedType", { aliases: ["TSType"], visitor: ["typeAnnotation"], fields: { typeAnnotation: (0, n.validateType)("TSType") } }), o("TSTypeOperator", { aliases: ["TSType"], visitor: ["typeAnnotation"], builder: ["typeAnnotation", "operator"], fields: { operator: { validate: (0, n.assertValueType)("string"), default: "keyof" }, typeAnnotation: (0, n.validateType)("TSType") } }), o("TSIndexedAccessType", { aliases: ["TSType"], visitor: ["objectType", "indexType"], fields: { objectType: (0, n.validateType)("TSType"), indexType: (0, n.validateType)("TSType") } }), o("TSMappedType", { aliases: ["TSType"], visitor: ["typeParameter", "nameType", "typeAnnotation"], builder: ["typeParameter", "typeAnnotation", "nameType"], fields: Object.assign({}, { typeParameter: (0, n.validateType)("TSTypeParameter") }, { readonly: (0, n.validateOptional)((0, n.assertOneOf)(true, false, "+", "-")), optional: (0, n.validateOptional)((0, n.assertOneOf)(true, false, "+", "-")), typeAnnotation: (0, n.validateOptionalType)("TSType"), nameType: (0, n.validateOptionalType)("TSType") }) }), o("TSTemplateLiteralType", { aliases: ["TSType", "TSBaseType"], visitor: ["quasis", "types"], fields: { quasis: (0, n.validateArrayOfType)("TemplateElement"), types: { validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("TSType")), function(e3, t3, r3) {
          if (e3.quasis.length !== r3.length + 1) throw new TypeError(`Number of ${e3.type} quasis should be exactly one more than the number of types.
Expected ${r3.length + 1} quasis but got ${e3.quasis.length}`);
        }) } } }), o("TSLiteralType", { aliases: ["TSType", "TSBaseType"], visitor: ["literal"], fields: { literal: { validate: (function() {
          const e3 = (0, n.assertNodeType)("NumericLiteral", "BigIntLiteral"), t3 = (0, n.assertOneOf)("-"), r3 = (0, n.assertNodeType)("NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral");
          function validator(n2, s2, o2) {
            (0, i.default)("UnaryExpression", o2) ? (t3(o2, "operator", o2.operator), e3(o2, "argument", o2.argument)) : r3(n2, s2, o2);
          }
          return validator.oneOfNodeTypes = ["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral", "UnaryExpression"], validator;
        })() } } }), o("TSExpressionWithTypeArguments", { aliases: ["TSType"], visitor: ["expression", "typeParameters"], fields: { expression: (0, n.validateType)("TSEntityName"), typeParameters: (0, n.validateOptionalType)("TSTypeParameterInstantiation") } }), o("TSInterfaceDeclaration", { aliases: ["Statement", "Declaration"], visitor: ["id", "typeParameters", "extends", "body"], fields: { declare: (0, n.validateOptional)(a), id: (0, n.validateType)("Identifier"), typeParameters: (0, n.validateOptionalType)("TSTypeParameterDeclaration"), extends: (0, n.validateOptional)((0, n.arrayOfType)("TSExpressionWithTypeArguments")), body: (0, n.validateType)("TSInterfaceBody") } }), o("TSInterfaceBody", { visitor: ["body"], fields: { body: (0, n.validateArrayOfType)("TSTypeElement") } }), o("TSTypeAliasDeclaration", { aliases: ["Statement", "Declaration"], visitor: ["id", "typeParameters", "typeAnnotation"], fields: { declare: (0, n.validateOptional)(a), id: (0, n.validateType)("Identifier"), typeParameters: (0, n.validateOptionalType)("TSTypeParameterDeclaration"), typeAnnotation: (0, n.validateType)("TSType") } }), o("TSInstantiationExpression", { aliases: ["Expression"], visitor: ["expression", "typeParameters"], fields: { expression: (0, n.validateType)("Expression"), typeParameters: (0, n.validateOptionalType)("TSTypeParameterInstantiation") } });
        const d = { aliases: ["Expression", "LVal", "PatternLike"], visitor: ["expression", "typeAnnotation"], fields: { expression: (0, n.validateType)("Expression"), typeAnnotation: (0, n.validateType)("TSType") } };
        o("TSAsExpression", d), o("TSSatisfiesExpression", d), o("TSTypeAssertion", { aliases: ["Expression", "LVal", "PatternLike"], visitor: ["typeAnnotation", "expression"], fields: { typeAnnotation: (0, n.validateType)("TSType"), expression: (0, n.validateType)("Expression") } }), o("TSEnumBody", { visitor: ["members"], fields: { members: (0, n.validateArrayOfType)("TSEnumMember") } }), o("TSEnumDeclaration", { aliases: ["Statement", "Declaration"], visitor: ["id", "members"], fields: { declare: (0, n.validateOptional)(a), const: (0, n.validateOptional)(a), id: (0, n.validateType)("Identifier"), members: (0, n.validateArrayOfType)("TSEnumMember"), initializer: (0, n.validateOptionalType)("Expression"), body: (0, n.validateOptionalType)("TSEnumBody") } }), o("TSEnumMember", { visitor: ["id", "initializer"], fields: { id: (0, n.validateType)("Identifier", "StringLiteral"), initializer: (0, n.validateOptionalType)("Expression") } }), o("TSModuleDeclaration", { aliases: ["Statement", "Declaration"], visitor: ["id", "body"], fields: Object.assign({ kind: { validate: (0, n.assertOneOf)("global", "module", "namespace") }, declare: (0, n.validateOptional)(a) }, { global: (0, n.validateOptional)(a) }, { id: (0, n.validateType)("Identifier", "StringLiteral"), body: (0, n.validateType)("TSModuleBlock", "TSModuleDeclaration") }) }), o("TSModuleBlock", { aliases: ["Scopable", "Block", "BlockParent", "FunctionParent"], visitor: ["body"], fields: { body: (0, n.validateArrayOfType)("Statement") } }), o("TSImportType", { aliases: ["TSType"], builder: ["argument", "qualifier", "typeParameters"], visitor: ["argument", "options", "qualifier", "typeParameters"], fields: { argument: (0, n.validateType)("StringLiteral"), qualifier: (0, n.validateOptionalType)("TSEntityName"), typeParameters: (0, n.validateOptionalType)("TSTypeParameterInstantiation"), options: { validate: (0, n.assertNodeType)("ObjectExpression"), optional: true } } }), o("TSImportEqualsDeclaration", { aliases: ["Statement", "Declaration"], visitor: ["id", "moduleReference"], fields: Object.assign({}, { isExport: (0, n.validate)(a) }, { id: (0, n.validateType)("Identifier"), moduleReference: (0, n.validateType)("TSEntityName", "TSExternalModuleReference"), importKind: { validate: (0, n.assertOneOf)("type", "value"), optional: true } }) }), o("TSExternalModuleReference", { visitor: ["expression"], fields: { expression: (0, n.validateType)("StringLiteral") } }), o("TSNonNullExpression", { aliases: ["Expression", "LVal", "PatternLike"], visitor: ["expression"], fields: { expression: (0, n.validateType)("Expression") } }), o("TSExportAssignment", { aliases: ["Statement"], visitor: ["expression"], fields: { expression: (0, n.validateType)("Expression") } }), o("TSNamespaceExportDeclaration", { aliases: ["Statement"], visitor: ["id"], fields: { id: (0, n.validateType)("Identifier") } }), o("TSTypeAnnotation", { visitor: ["typeAnnotation"], fields: { typeAnnotation: { validate: (0, n.assertNodeType)("TSType") } } }), o("TSTypeParameterInstantiation", { visitor: ["params"], fields: { params: (0, n.validateArrayOfType)("TSType") } }), o("TSTypeParameterDeclaration", { visitor: ["params"], fields: { params: (0, n.validateArrayOfType)("TSTypeParameter") } }), o("TSTypeParameter", { builder: ["constraint", "default", "name"], visitor: ["constraint", "default"], fields: { name: { validate: (0, n.assertValueType)("string") }, in: { validate: (0, n.assertValueType)("boolean"), optional: true }, out: { validate: (0, n.assertValueType)("boolean"), optional: true }, const: { validate: (0, n.assertValueType)("boolean"), optional: true }, constraint: { validate: (0, n.assertNodeType)("TSType"), optional: true }, default: { validate: (0, n.assertNodeType)("TSType"), optional: true } } });
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/definitions/utils.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.allExpandedTypes = t2.VISITOR_KEYS = t2.NODE_PARENT_VALIDATIONS = t2.NODE_FIELDS = t2.FLIPPED_ALIAS_KEYS = t2.DEPRECATED_KEYS = t2.BUILDER_KEYS = t2.ALIAS_KEYS = void 0, t2.arrayOf = arrayOf, t2.arrayOfType = arrayOfType, t2.assertEach = assertEach, t2.assertNodeOrValueType = function(...e3) {
          function validate2(t3, r3, i2) {
            const o2 = getType(i2);
            for (const a2 of e3) if (o2 === a2 || (0, n.default)(a2, i2)) return void (0, s.validateChild)(t3, r3, i2);
            throw new TypeError(`Property ${r3} of ${t3.type} expected node to be of a type ${JSON.stringify(e3)} but instead got ${JSON.stringify(null == i2 ? void 0 : i2.type)}`);
          }
          return validate2.oneOfNodeOrValueTypes = e3, validate2;
        }, t2.assertNodeType = assertNodeType, t2.assertOneOf = function(...e3) {
          function validate2(t3, r3, n2) {
            if (!e3.includes(n2)) throw new TypeError(`Property ${r3} expected value to be one of ${JSON.stringify(e3)} but got ${JSON.stringify(n2)}`);
          }
          return validate2.oneOf = e3, validate2;
        }, t2.assertOptionalChainStart = function() {
          return function(e3) {
            var t3;
            let r3 = e3;
            for (; e3; ) {
              const { type: e4 } = r3;
              if ("OptionalCallExpression" !== e4) {
                if ("OptionalMemberExpression" !== e4) break;
                if (r3.optional) return;
                r3 = r3.object;
              } else {
                if (r3.optional) return;
                r3 = r3.callee;
              }
            }
            throw new TypeError(`Non-optional ${e3.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${null == (t3 = r3) ? void 0 : t3.type}`);
          };
        }, t2.assertShape = function(e3) {
          const t3 = Object.keys(e3);
          function validate2(r3, n2, i2) {
            const o2 = [];
            for (const n3 of t3) try {
              (0, s.validateField)(r3, n3, i2[n3], e3[n3]);
            } catch (e4) {
              if (e4 instanceof TypeError) {
                o2.push(e4.message);
                continue;
              }
              throw e4;
            }
            if (o2.length) throw new TypeError(`Property ${n2} of ${r3.type} expected to have the following:
${o2.join("\n")}`);
          }
          return validate2.shapeOf = e3, validate2;
        }, t2.assertValueType = assertValueType, t2.chain = chain, t2.default = defineType, t2.defineAliasedType = function(...e3) {
          return (t3, r3 = {}) => {
            let n2 = r3.aliases;
            var s2;
            n2 || (r3.inherits && (n2 = null == (s2 = f[r3.inherits].aliases) ? void 0 : s2.slice()), null != n2 || (n2 = []), r3.aliases = n2);
            const i2 = e3.filter((e4) => !n2.includes(e4));
            n2.unshift(...i2), defineType(t3, r3);
          };
        }, t2.validate = validate, t2.validateArrayOfType = function(...e3) {
          return validate(arrayOfType(...e3));
        }, t2.validateOptional = function(e3) {
          return { validate: e3, optional: true };
        }, t2.validateOptionalType = function(...e3) {
          return { validate: assertNodeType(...e3), optional: true };
        }, t2.validateType = function(...e3) {
          return validate(assertNodeType(...e3));
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/is.js"), s = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/validate.js");
        const i = t2.VISITOR_KEYS = {}, o = t2.ALIAS_KEYS = {}, a = t2.FLIPPED_ALIAS_KEYS = {}, l = t2.NODE_FIELDS = {}, p = t2.BUILDER_KEYS = {}, c = t2.DEPRECATED_KEYS = {}, u = t2.NODE_PARENT_VALIDATIONS = {};
        function getType(e3) {
          return Array.isArray(e3) ? "array" : null === e3 ? "null" : typeof e3;
        }
        function validate(e3) {
          return { validate: e3 };
        }
        function arrayOf(e3) {
          return chain(assertValueType("array"), assertEach(e3));
        }
        function arrayOfType(...e3) {
          return arrayOf(assertNodeType(...e3));
        }
        function assertEach(e3) {
          const t3 = process.env.BABEL_TYPES_8_BREAKING ? s.validateChild : () => {
          };
          function validator(r3, n2, s2) {
            if (!Array.isArray(s2)) return;
            let i2 = 0;
            const o2 = { toString: () => `${n2}[${i2}]` };
            for (; i2 < s2.length; i2++) {
              const n3 = s2[i2];
              e3(r3, o2, n3), t3(r3, o2, n3);
            }
          }
          return validator.each = e3, validator;
        }
        const d = t2.allExpandedTypes = [];
        function assertNodeType(...e3) {
          const t3 = /* @__PURE__ */ new Set();
          function validate2(r3, i2, o2) {
            const a2 = null == o2 ? void 0 : o2.type;
            if (null != a2) {
              if (t3.has(a2)) return void (0, s.validateChild)(r3, i2, o2);
              if ("Placeholder" === a2) {
                for (const t4 of e3) if ((0, n.default)(t4, o2)) return void (0, s.validateChild)(r3, i2, o2);
              }
            }
            throw new TypeError(`Property ${i2} of ${r3.type} expected node to be of a type ${JSON.stringify(e3)} but instead got ${JSON.stringify(a2)}`);
          }
          return d.push({ types: e3, set: t3 }), validate2.oneOfNodeTypes = e3, validate2;
        }
        function assertValueType(e3) {
          function validate2(t3, r3, n2) {
            if (getType(n2) !== e3) throw new TypeError(`Property ${r3} expected type of ${e3} but got ${getType(n2)}`);
          }
          return validate2.type = e3, validate2;
        }
        function chain(...e3) {
          function validate2(...t3) {
            for (const r3 of e3) r3(...t3);
          }
          if (validate2.chainOf = e3, e3.length >= 2 && "type" in e3[0] && "array" === e3[0].type && !("each" in e3[1])) throw new Error('An assertValueType("array") validator can only be followed by an assertEach(...) validator.');
          return validate2;
        }
        const h = /* @__PURE__ */ new Set(["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"]), m = /* @__PURE__ */ new Set(["default", "optional", "deprecated", "validate"]), f = {};
        function defineType(e3, t3 = {}) {
          const r3 = t3.inherits && f[t3.inherits] || {};
          let n2 = t3.fields;
          if (!n2 && (n2 = {}, r3.fields)) {
            const e4 = Object.getOwnPropertyNames(r3.fields);
            for (const t4 of e4) {
              const e5 = r3.fields[t4], s3 = e5.default;
              if (Array.isArray(s3) ? s3.length > 0 : s3 && "object" == typeof s3) throw new Error("field defaults can only be primitives or empty arrays currently");
              n2[t4] = { default: Array.isArray(s3) ? [] : s3, optional: e5.optional, deprecated: e5.deprecated, validate: e5.validate };
            }
          }
          const s2 = t3.visitor || r3.visitor || [], d2 = t3.aliases || r3.aliases || [], y = t3.builder || r3.builder || t3.visitor || [];
          for (const r4 of Object.keys(t3)) if (!h.has(r4)) throw new Error(`Unknown type option "${r4}" on ${e3}`);
          t3.deprecatedAlias && (c[t3.deprecatedAlias] = e3);
          for (const e4 of s2.concat(y)) n2[e4] = n2[e4] || {};
          for (const t4 of Object.keys(n2)) {
            const r4 = n2[t4];
            void 0 === r4.default || y.includes(t4) || (r4.optional = true), void 0 === r4.default ? r4.default = null : r4.validate || null == r4.default || (r4.validate = assertValueType(getType(r4.default)));
            for (const n3 of Object.keys(r4)) if (!m.has(n3)) throw new Error(`Unknown field key "${n3}" on ${e3}.${t4}`);
          }
          i[e3] = t3.visitor = s2, p[e3] = t3.builder = y, l[e3] = t3.fields = n2, o[e3] = t3.aliases = d2, d2.forEach((t4) => {
            a[t4] = a[t4] || [], a[t4].push(e3);
          }), t3.validate && (u[e3] = t3.validate), f[e3] = t3;
        }
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/index.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true });
        var n = { react: true, assertNode: true, createTypeAnnotationBasedOnTypeof: true, createUnionTypeAnnotation: true, createFlowUnionType: true, createTSUnionType: true, cloneNode: true, clone: true, cloneDeep: true, cloneDeepWithoutLoc: true, cloneWithoutLoc: true, addComment: true, addComments: true, inheritInnerComments: true, inheritLeadingComments: true, inheritsComments: true, inheritTrailingComments: true, removeComments: true, ensureBlock: true, toBindingIdentifierName: true, toBlock: true, toComputedKey: true, toExpression: true, toIdentifier: true, toKeyAlias: true, toStatement: true, valueToNode: true, appendToMemberExpression: true, inherits: true, prependToMemberExpression: true, removeProperties: true, removePropertiesDeep: true, removeTypeDuplicates: true, getAssignmentIdentifiers: true, getBindingIdentifiers: true, getOuterBindingIdentifiers: true, getFunctionName: true, traverse: true, traverseFast: true, shallowEqual: true, is: true, isBinding: true, isBlockScoped: true, isImmutable: true, isLet: true, isNode: true, isNodesEquivalent: true, isPlaceholderType: true, isReferenced: true, isScope: true, isSpecifierDefault: true, isType: true, isValidES3Identifier: true, isValidIdentifier: true, isVar: true, matchesPattern: true, validate: true, buildMatchMemberExpression: true, __internal__deprecationWarning: true };
        Object.defineProperty(t2, "__internal__deprecationWarning", { enumerable: true, get: function() {
          return ye.default;
        } }), Object.defineProperty(t2, "addComment", { enumerable: true, get: function() {
          return x.default;
        } }), Object.defineProperty(t2, "addComments", { enumerable: true, get: function() {
          return v.default;
        } }), Object.defineProperty(t2, "appendToMemberExpression", { enumerable: true, get: function() {
          return B.default;
        } }), Object.defineProperty(t2, "assertNode", { enumerable: true, get: function() {
          return a.default;
        } }), Object.defineProperty(t2, "buildMatchMemberExpression", { enumerable: true, get: function() {
          return me.default;
        } }), Object.defineProperty(t2, "clone", { enumerable: true, get: function() {
          return f.default;
        } }), Object.defineProperty(t2, "cloneDeep", { enumerable: true, get: function() {
          return y.default;
        } }), Object.defineProperty(t2, "cloneDeepWithoutLoc", { enumerable: true, get: function() {
          return b.default;
        } }), Object.defineProperty(t2, "cloneNode", { enumerable: true, get: function() {
          return m.default;
        } }), Object.defineProperty(t2, "cloneWithoutLoc", { enumerable: true, get: function() {
          return g.default;
        } }), Object.defineProperty(t2, "createFlowUnionType", { enumerable: true, get: function() {
          return c.default;
        } }), Object.defineProperty(t2, "createTSUnionType", { enumerable: true, get: function() {
          return u.default;
        } }), Object.defineProperty(t2, "createTypeAnnotationBasedOnTypeof", { enumerable: true, get: function() {
          return p.default;
        } }), Object.defineProperty(t2, "createUnionTypeAnnotation", { enumerable: true, get: function() {
          return c.default;
        } }), Object.defineProperty(t2, "ensureBlock", { enumerable: true, get: function() {
          return w.default;
        } }), Object.defineProperty(t2, "getAssignmentIdentifiers", { enumerable: true, get: function() {
          return W.default;
        } }), Object.defineProperty(t2, "getBindingIdentifiers", { enumerable: true, get: function() {
          return q.default;
        } }), Object.defineProperty(t2, "getFunctionName", { enumerable: true, get: function() {
          return z.default;
        } }), Object.defineProperty(t2, "getOuterBindingIdentifiers", { enumerable: true, get: function() {
          return H.default;
        } }), Object.defineProperty(t2, "inheritInnerComments", { enumerable: true, get: function() {
          return E.default;
        } }), Object.defineProperty(t2, "inheritLeadingComments", { enumerable: true, get: function() {
          return T.default;
        } }), Object.defineProperty(t2, "inheritTrailingComments", { enumerable: true, get: function() {
          return P.default;
        } }), Object.defineProperty(t2, "inherits", { enumerable: true, get: function() {
          return R.default;
        } }), Object.defineProperty(t2, "inheritsComments", { enumerable: true, get: function() {
          return S.default;
        } }), Object.defineProperty(t2, "is", { enumerable: true, get: function() {
          return Y.default;
        } }), Object.defineProperty(t2, "isBinding", { enumerable: true, get: function() {
          return Q.default;
        } }), Object.defineProperty(t2, "isBlockScoped", { enumerable: true, get: function() {
          return Z.default;
        } }), Object.defineProperty(t2, "isImmutable", { enumerable: true, get: function() {
          return ee.default;
        } }), Object.defineProperty(t2, "isLet", { enumerable: true, get: function() {
          return te.default;
        } }), Object.defineProperty(t2, "isNode", { enumerable: true, get: function() {
          return re.default;
        } }), Object.defineProperty(t2, "isNodesEquivalent", { enumerable: true, get: function() {
          return ne.default;
        } }), Object.defineProperty(t2, "isPlaceholderType", { enumerable: true, get: function() {
          return se.default;
        } }), Object.defineProperty(t2, "isReferenced", { enumerable: true, get: function() {
          return ie.default;
        } }), Object.defineProperty(t2, "isScope", { enumerable: true, get: function() {
          return oe.default;
        } }), Object.defineProperty(t2, "isSpecifierDefault", { enumerable: true, get: function() {
          return ae.default;
        } }), Object.defineProperty(t2, "isType", { enumerable: true, get: function() {
          return le.default;
        } }), Object.defineProperty(t2, "isValidES3Identifier", { enumerable: true, get: function() {
          return pe.default;
        } }), Object.defineProperty(t2, "isValidIdentifier", { enumerable: true, get: function() {
          return ce.default;
        } }), Object.defineProperty(t2, "isVar", { enumerable: true, get: function() {
          return ue.default;
        } }), Object.defineProperty(t2, "matchesPattern", { enumerable: true, get: function() {
          return de.default;
        } }), Object.defineProperty(t2, "prependToMemberExpression", { enumerable: true, get: function() {
          return U.default;
        } }), t2.react = void 0, Object.defineProperty(t2, "removeComments", { enumerable: true, get: function() {
          return _.default;
        } }), Object.defineProperty(t2, "removeProperties", { enumerable: true, get: function() {
          return V.default;
        } }), Object.defineProperty(t2, "removePropertiesDeep", { enumerable: true, get: function() {
          return $.default;
        } }), Object.defineProperty(t2, "removeTypeDuplicates", { enumerable: true, get: function() {
          return K.default;
        } }), Object.defineProperty(t2, "shallowEqual", { enumerable: true, get: function() {
          return J.default;
        } }), Object.defineProperty(t2, "toBindingIdentifierName", { enumerable: true, get: function() {
          return I.default;
        } }), Object.defineProperty(t2, "toBlock", { enumerable: true, get: function() {
          return D.default;
        } }), Object.defineProperty(t2, "toComputedKey", { enumerable: true, get: function() {
          return k.default;
        } }), Object.defineProperty(t2, "toExpression", { enumerable: true, get: function() {
          return N.default;
        } }), Object.defineProperty(t2, "toIdentifier", { enumerable: true, get: function() {
          return O.default;
        } }), Object.defineProperty(t2, "toKeyAlias", { enumerable: true, get: function() {
          return j.default;
        } }), Object.defineProperty(t2, "toStatement", { enumerable: true, get: function() {
          return F.default;
        } }), Object.defineProperty(t2, "traverse", { enumerable: true, get: function() {
          return G.default;
        } }), Object.defineProperty(t2, "traverseFast", { enumerable: true, get: function() {
          return X.default;
        } }), Object.defineProperty(t2, "validate", { enumerable: true, get: function() {
          return he.default;
        } }), Object.defineProperty(t2, "valueToNode", { enumerable: true, get: function() {
          return L.default;
        } });
        var s = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/react/isReactComponent.js"), i = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/react/isCompatTag.js"), o = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/builders/react/buildChildren.js"), a = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/asserts/assertNode.js"), l = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/asserts/generated/index.js");
        Object.keys(l).forEach(function(e3) {
          "default" !== e3 && "__esModule" !== e3 && (Object.prototype.hasOwnProperty.call(n, e3) || e3 in t2 && t2[e3] === l[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
            return l[e3];
          } }));
        });
        var p = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js"), c = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js"), u = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js"), d = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/builders/productions.js");
        Object.keys(d).forEach(function(e3) {
          "default" !== e3 && "__esModule" !== e3 && (Object.prototype.hasOwnProperty.call(n, e3) || e3 in t2 && t2[e3] === d[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
            return d[e3];
          } }));
        });
        var h = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/builders/generated/index.js");
        Object.keys(h).forEach(function(e3) {
          "default" !== e3 && "__esModule" !== e3 && (Object.prototype.hasOwnProperty.call(n, e3) || e3 in t2 && t2[e3] === h[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
            return h[e3];
          } }));
        });
        var m = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/clone/cloneNode.js"), f = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/clone/clone.js"), y = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/clone/cloneDeep.js"), b = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js"), g = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/clone/cloneWithoutLoc.js"), x = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/comments/addComment.js"), v = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/comments/addComments.js"), E = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/comments/inheritInnerComments.js"), T = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/comments/inheritLeadingComments.js"), S = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/comments/inheritsComments.js"), P = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/comments/inheritTrailingComments.js"), _ = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/comments/removeComments.js"), A = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/constants/generated/index.js");
        Object.keys(A).forEach(function(e3) {
          "default" !== e3 && "__esModule" !== e3 && (Object.prototype.hasOwnProperty.call(n, e3) || e3 in t2 && t2[e3] === A[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
            return A[e3];
          } }));
        });
        var C = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/constants/index.js");
        Object.keys(C).forEach(function(e3) {
          "default" !== e3 && "__esModule" !== e3 && (Object.prototype.hasOwnProperty.call(n, e3) || e3 in t2 && t2[e3] === C[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
            return C[e3];
          } }));
        });
        var w = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/converters/ensureBlock.js"), I = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/converters/toBindingIdentifierName.js"), D = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/converters/toBlock.js"), k = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/converters/toComputedKey.js"), N = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/converters/toExpression.js"), O = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/converters/toIdentifier.js"), j = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/converters/toKeyAlias.js"), F = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/converters/toStatement.js"), L = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/converters/valueToNode.js"), M = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/definitions/index.js");
        Object.keys(M).forEach(function(e3) {
          "default" !== e3 && "__esModule" !== e3 && (Object.prototype.hasOwnProperty.call(n, e3) || e3 in t2 && t2[e3] === M[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
            return M[e3];
          } }));
        });
        var B = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/modifications/appendToMemberExpression.js"), R = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/modifications/inherits.js"), U = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/modifications/prependToMemberExpression.js"), V = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/modifications/removeProperties.js"), $ = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/modifications/removePropertiesDeep.js"), K = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js"), W = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/retrievers/getAssignmentIdentifiers.js"), q = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js"), H = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js"), z = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/retrievers/getFunctionName.js"), G = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/traverse/traverse.js");
        Object.keys(G).forEach(function(e3) {
          "default" !== e3 && "__esModule" !== e3 && (Object.prototype.hasOwnProperty.call(n, e3) || e3 in t2 && t2[e3] === G[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
            return G[e3];
          } }));
        });
        var X = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/traverse/traverseFast.js"), J = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/utils/shallowEqual.js"), Y = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/is.js"), Q = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/isBinding.js"), Z = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/isBlockScoped.js"), ee = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/isImmutable.js"), te = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/isLet.js"), re = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/isNode.js"), ne = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/isNodesEquivalent.js"), se = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/isPlaceholderType.js"), ie = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/isReferenced.js"), oe = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/isScope.js"), ae = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/isSpecifierDefault.js"), le = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/isType.js"), pe = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/isValidES3Identifier.js"), ce = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/isValidIdentifier.js"), ue = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/isVar.js"), de = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/matchesPattern.js"), he = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/validate.js"), me = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js"), fe = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/generated/index.js");
        Object.keys(fe).forEach(function(e3) {
          "default" !== e3 && "__esModule" !== e3 && (Object.prototype.hasOwnProperty.call(n, e3) || e3 in t2 && t2[e3] === fe[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
            return fe[e3];
          } }));
        });
        var ye = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/utils/deprecationWarning.js"), be = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/converters/toSequenceExpression.js");
        t2.react = { isReactComponent: s.default, isCompatTag: i.default, buildChildren: o.default };
        t2.toSequenceExpression = be.default, process.env.BABEL_TYPES_8_BREAKING && console.warn("BABEL_TYPES_8_BREAKING is not supported anymore. Use the latest Babel 8.0.0 pre-release instead!");
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/modifications/appendToMemberExpression.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3 = false) {
          return e3.object = (0, n.memberExpression)(e3.object, e3.property, e3.computed), e3.property = t3, e3.computed = !!r3, e3;
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/builders/generated/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function removeTypeDuplicates(e3) {
          const t3 = Array.from(e3), r3 = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Set(), o = [];
          for (let e4 = 0; e4 < t3.length; e4++) {
            const a = t3[e4];
            if (a && !o.includes(a)) {
              if ((0, n.isAnyTypeAnnotation)(a)) return [a];
              if ((0, n.isFlowBaseAnnotation)(a)) s.set(a.type, a);
              else if ((0, n.isUnionTypeAnnotation)(a)) i.has(a.types) || (t3.push(...a.types), i.add(a.types));
              else {
                if ((0, n.isGenericTypeAnnotation)(a)) {
                  const e5 = getQualifiedName(a.id);
                  if (r3.has(e5)) {
                    let t4 = r3.get(e5);
                    t4.typeParameters ? a.typeParameters && (t4.typeParameters.params.push(...a.typeParameters.params), t4.typeParameters.params = removeTypeDuplicates(t4.typeParameters.params)) : t4 = a.typeParameters;
                  } else r3.set(e5, a);
                  continue;
                }
                o.push(a);
              }
            }
          }
          for (const [, e4] of s) o.push(e4);
          for (const [, e4] of r3) o.push(e4);
          return o;
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/generated/index.js");
        function getQualifiedName(e3) {
          return (0, n.isIdentifier)(e3) ? e3.name : `${e3.id.name}.${getQualifiedName(e3.qualification)}`;
        }
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/modifications/inherits.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
          if (!e3 || !t3) return e3;
          for (const r3 of n.INHERIT_KEYS.optional) null == e3[r3] && (e3[r3] = t3[r3]);
          for (const r3 of Object.keys(t3)) "_" === r3[0] && "__clone" !== r3 && (e3[r3] = t3[r3]);
          for (const r3 of n.INHERIT_KEYS.force) e3[r3] = t3[r3];
          return (0, s.default)(e3, t3), e3;
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/constants/index.js"), s = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/comments/inheritsComments.js");
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/modifications/prependToMemberExpression.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
          if ((0, s.isSuper)(e3.object)) throw new Error("Cannot prepend node to super property access (`super.foo`).");
          return e3.object = (0, n.memberExpression)(t3, e3.object), e3;
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/builders/generated/index.js"), s = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/modifications/removeProperties.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3 = {}) {
          const r3 = t3.preserveComments ? s : i;
          for (const t4 of r3) null != e3[t4] && (e3[t4] = void 0);
          for (const t4 of Object.keys(e3)) "_" === t4[0] && null != e3[t4] && (e3[t4] = void 0);
          const n2 = Object.getOwnPropertySymbols(e3);
          for (const t4 of n2) e3[t4] = null;
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/constants/index.js");
        const s = ["tokens", "start", "end", "loc", "raw", "rawValue"], i = [...n.COMMENT_KEYS, "comments", ...s];
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/modifications/removePropertiesDeep.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
          return (0, n.default)(e3, s.default, t3), e3;
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/traverse/traverseFast.js"), s = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/modifications/removeProperties.js");
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function removeTypeDuplicates(e3) {
          const t3 = Array.from(e3), r3 = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Set(), o = [];
          for (let e4 = 0; e4 < t3.length; e4++) {
            const a = t3[e4];
            if (!a) continue;
            if (o.includes(a)) continue;
            if ((0, n.isTSAnyKeyword)(a)) return [a];
            if ((0, n.isTSBaseType)(a)) {
              s.set(a.type, a);
              continue;
            }
            if ((0, n.isTSUnionType)(a)) {
              i.has(a.types) || (t3.push(...a.types), i.add(a.types));
              continue;
            }
            const l = "typeParameters";
            if ((0, n.isTSTypeReference)(a) && a[l]) {
              const e5 = a[l], t4 = getQualifiedName(a.typeName);
              if (r3.has(t4)) {
                let n2 = r3.get(t4);
                const s2 = n2[l];
                s2 ? (s2.params.push(...e5.params), s2.params = removeTypeDuplicates(s2.params)) : n2 = e5;
              } else r3.set(t4, a);
              continue;
            }
            o.push(a);
          }
          for (const [, e4] of s) o.push(e4);
          for (const [, e4] of r3) o.push(e4);
          return o;
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/generated/index.js");
        function getQualifiedName(e3) {
          return (0, n.isIdentifier)(e3) ? e3.name : (0, n.isThisExpression)(e3) ? "this" : `${e3.right.name}.${getQualifiedName(e3.left)}`;
        }
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/retrievers/getAssignmentIdentifiers.js": function(e2, t2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
          const t3 = [].concat(e3), r2 = /* @__PURE__ */ Object.create(null);
          for (; t3.length; ) {
            const e4 = t3.pop();
            if (e4) switch (e4.type) {
              case "ArrayPattern":
                t3.push(...e4.elements);
                break;
              case "AssignmentExpression":
              case "AssignmentPattern":
              case "ForInStatement":
              case "ForOfStatement":
                t3.push(e4.left);
                break;
              case "ObjectPattern":
                t3.push(...e4.properties);
                break;
              case "ObjectProperty":
                t3.push(e4.value);
                break;
              case "RestElement":
              case "UpdateExpression":
                t3.push(e4.argument);
                break;
              case "UnaryExpression":
                "delete" === e4.operator && t3.push(e4.argument);
                break;
              case "Identifier":
                r2[e4.name] = e4;
            }
          }
          return r2;
        };
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = getBindingIdentifiers;
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/generated/index.js");
        function getBindingIdentifiers(e3, t3, r3, s) {
          const i = [].concat(e3), o = /* @__PURE__ */ Object.create(null);
          for (; i.length; ) {
            const e4 = i.shift();
            if (!e4) continue;
            if (s && ((0, n.isAssignmentExpression)(e4) || (0, n.isUnaryExpression)(e4) || (0, n.isUpdateExpression)(e4))) continue;
            if ((0, n.isIdentifier)(e4)) {
              if (t3) {
                (o[e4.name] = o[e4.name] || []).push(e4);
              } else o[e4.name] = e4;
              continue;
            }
            if ((0, n.isExportDeclaration)(e4) && !(0, n.isExportAllDeclaration)(e4)) {
              (0, n.isDeclaration)(e4.declaration) && i.push(e4.declaration);
              continue;
            }
            if (r3) {
              if ((0, n.isFunctionDeclaration)(e4)) {
                i.push(e4.id);
                continue;
              }
              if ((0, n.isFunctionExpression)(e4)) continue;
            }
            const a = getBindingIdentifiers.keys[e4.type];
            if (a) for (let t4 = 0; t4 < a.length; t4++) {
              const r4 = e4[a[t4]];
              r4 && (Array.isArray(r4) ? i.push(...r4) : i.push(r4));
            }
          }
          return o;
        }
        getBindingIdentifiers.keys = { DeclareClass: ["id"], DeclareFunction: ["id"], DeclareModule: ["id"], DeclareVariable: ["id"], DeclareInterface: ["id"], DeclareTypeAlias: ["id"], DeclareOpaqueType: ["id"], InterfaceDeclaration: ["id"], TypeAlias: ["id"], OpaqueType: ["id"], CatchClause: ["param"], LabeledStatement: ["label"], UnaryExpression: ["argument"], AssignmentExpression: ["left"], ImportSpecifier: ["local"], ImportNamespaceSpecifier: ["local"], ImportDefaultSpecifier: ["local"], ImportDeclaration: ["specifiers"], TSImportEqualsDeclaration: ["id"], ExportSpecifier: ["exported"], ExportNamespaceSpecifier: ["exported"], ExportDefaultSpecifier: ["exported"], FunctionDeclaration: ["id", "params"], FunctionExpression: ["id", "params"], ArrowFunctionExpression: ["params"], ObjectMethod: ["params"], ClassMethod: ["params"], ClassPrivateMethod: ["params"], ForInStatement: ["left"], ForOfStatement: ["left"], ClassDeclaration: ["id"], ClassExpression: ["id"], RestElement: ["argument"], UpdateExpression: ["argument"], ObjectProperty: ["value"], AssignmentPattern: ["left"], ArrayPattern: ["elements"], ObjectPattern: ["properties"], VariableDeclaration: ["declarations"], VariableDeclarator: ["id"] };
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/retrievers/getFunctionName.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
          if ("id" in e3 && e3.id) return { name: e3.id.name, originalNode: e3.id };
          let r3, s = "";
          (0, n.isObjectProperty)(t3, { value: e3 }) ? r3 = getObjectMemberKey(t3) : (0, n.isObjectMethod)(e3) || (0, n.isClassMethod)(e3) ? (r3 = getObjectMemberKey(e3), "get" === e3.kind ? s = "get " : "set" === e3.kind && (s = "set ")) : (0, n.isVariableDeclarator)(t3, { init: e3 }) ? r3 = t3.id : (0, n.isAssignmentExpression)(t3, { operator: "=", right: e3 }) && (r3 = t3.left);
          if (!r3) return null;
          const i = (0, n.isLiteral)(r3) ? (function(e4) {
            if ((0, n.isNullLiteral)(e4)) return "null";
            if ((0, n.isRegExpLiteral)(e4)) return `/${e4.pattern}/${e4.flags}`;
            if ((0, n.isTemplateLiteral)(e4)) return e4.quasis.map((e5) => e5.value.raw).join("");
            if (void 0 !== e4.value) return String(e4.value);
            return null;
          })(r3) : (0, n.isIdentifier)(r3) ? r3.name : (0, n.isPrivateName)(r3) ? r3.id.name : null;
          return null == i ? null : { name: s + i, originalNode: r3 };
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/generated/index.js");
        function getObjectMemberKey(e3) {
          if (!e3.computed || (0, n.isLiteral)(e3.key)) return e3.key;
        }
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js");
        t2.default = function(e3, t3) {
          return (0, n.default)(e3, t3, true);
        };
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/traverse/traverse.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3) {
          "function" == typeof t3 && (t3 = { enter: t3 });
          const { enter: n2, exit: s } = t3;
          traverseSimpleImpl(e3, n2, s, r3, []);
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/definitions/index.js");
        function traverseSimpleImpl(e3, t3, r3, s, i) {
          const o = n.VISITOR_KEYS[e3.type];
          if (o) {
            t3 && t3(e3, i, s);
            for (const n2 of o) {
              const o2 = e3[n2];
              if (Array.isArray(o2)) for (let a = 0; a < o2.length; a++) {
                const l = o2[a];
                l && (i.push({ node: e3, key: n2, index: a }), traverseSimpleImpl(l, t3, r3, s, i), i.pop());
              }
              else o2 && (i.push({ node: e3, key: n2 }), traverseSimpleImpl(o2, t3, r3, s, i), i.pop());
            }
            r3 && r3(e3, i, s);
          }
        }
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/traverse/traverseFast.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = traverseFast;
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/definitions/index.js");
        const s = /* @__PURE__ */ Symbol(), i = /* @__PURE__ */ Symbol();
        function traverseFast(e3, t3, r3) {
          if (!e3) return false;
          const o = n.VISITOR_KEYS[e3.type];
          if (!o) return false;
          const a = t3(e3, r3 = r3 || {});
          if (void 0 !== a) switch (a) {
            case s:
              return false;
            case i:
              return true;
          }
          for (const n2 of o) {
            const s2 = e3[n2];
            if (s2) {
              if (Array.isArray(s2)) {
                for (const e4 of s2) if (traverseFast(e4, t3, r3)) return true;
              } else if (traverseFast(s2, t3, r3)) return true;
            }
          }
          return false;
        }
        traverseFast.skip = s, traverseFast.stop = i;
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/utils/deprecationWarning.js": function(e2, t2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, n = "", s = e3) {
          if (r2.has(s)) return;
          r2.add(s);
          const { internal: i, trace: o } = (function(e4, t4) {
            const { stackTraceLimit: r3, prepareStackTrace: n2 } = Error;
            let s2;
            if (Error.stackTraceLimit = 1 + e4 + t4, Error.prepareStackTrace = function(e5, t5) {
              s2 = t5;
            }, new Error().stack, Error.stackTraceLimit = r3, Error.prepareStackTrace = n2, !s2) return { internal: false, trace: "" };
            const i2 = s2.slice(1 + e4, 1 + e4 + t4);
            return { internal: /[\\/]@babel[\\/]/.test(i2[1].getFileName()), trace: i2.map((e5) => `    at ${e5}`).join("\n") };
          })(1, 2);
          if (i) return;
          console.warn(`${n}\`${e3}\` has been deprecated, please migrate to \`${t3}\`
${o}`);
        };
        const r2 = /* @__PURE__ */ new Set();
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/utils/inherit.js": function(e2, t2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r2) {
          t3 && r2 && (t3[e3] = Array.from(new Set([].concat(t3[e3], r2[e3]).filter(Boolean))));
        };
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
          const r3 = e3.value.split(/\r\n|\n|\r/);
          let i = 0;
          for (let e4 = 0; e4 < r3.length; e4++) /[^ \t]/.exec(r3[e4]) && (i = e4);
          let o = "";
          for (let e4 = 0; e4 < r3.length; e4++) {
            const t4 = r3[e4], n2 = 0 === e4, s2 = e4 === r3.length - 1, a = e4 === i;
            let l = t4.replace(/\t/g, " ");
            n2 || (l = l.replace(/^ +/, "")), s2 || (l = l.replace(/ +$/, "")), l && (a || (l += " "), o += l);
          }
          o && t3.push((0, s.inherits)((0, n.stringLiteral)(o), e3));
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/builders/generated/index.js"), s = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/utils/shallowEqual.js": function(e2, t2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
          const r2 = Object.keys(t3);
          for (const n of r2) if (e3[n] !== t3[n]) return false;
          return true;
        };
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
          const r3 = e3.split(".");
          return (e4) => (0, n.default)(e4, r3, t3);
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/matchesPattern.js");
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/generated/index.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.isAccessor = function(e3, t3) {
          if (!e3) return false;
          if ("ClassAccessorProperty" !== e3.type) return false;
          return null == t3 || (0, n.default)(e3, t3);
        }, t2.isAnyTypeAnnotation = function(e3, t3) {
          return !!e3 && ("AnyTypeAnnotation" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isArgumentPlaceholder = function(e3, t3) {
          return !!e3 && ("ArgumentPlaceholder" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isArrayExpression = function(e3, t3) {
          return !!e3 && ("ArrayExpression" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isArrayPattern = function(e3, t3) {
          return !!e3 && ("ArrayPattern" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isArrayTypeAnnotation = function(e3, t3) {
          return !!e3 && ("ArrayTypeAnnotation" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isArrowFunctionExpression = function(e3, t3) {
          return !!e3 && ("ArrowFunctionExpression" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isAssignmentExpression = function(e3, t3) {
          return !!e3 && ("AssignmentExpression" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isAssignmentPattern = function(e3, t3) {
          return !!e3 && ("AssignmentPattern" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isAwaitExpression = function(e3, t3) {
          return !!e3 && ("AwaitExpression" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isBigIntLiteral = function(e3, t3) {
          return !!e3 && ("BigIntLiteral" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isBinary = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "BinaryExpression":
            case "LogicalExpression":
              break;
            default:
              return false;
          }
          return null == t3 || (0, n.default)(e3, t3);
        }, t2.isBinaryExpression = function(e3, t3) {
          return !!e3 && ("BinaryExpression" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isBindExpression = function(e3, t3) {
          return !!e3 && ("BindExpression" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isBlock = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "BlockStatement":
            case "Program":
            case "TSModuleBlock":
              break;
            case "Placeholder":
              if ("BlockStatement" === e3.expectedNode) break;
            default:
              return false;
          }
          return null == t3 || (0, n.default)(e3, t3);
        }, t2.isBlockParent = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "BlockStatement":
            case "CatchClause":
            case "DoWhileStatement":
            case "ForInStatement":
            case "ForStatement":
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "Program":
            case "ObjectMethod":
            case "SwitchStatement":
            case "WhileStatement":
            case "ArrowFunctionExpression":
            case "ForOfStatement":
            case "ClassMethod":
            case "ClassPrivateMethod":
            case "StaticBlock":
            case "TSModuleBlock":
              break;
            case "Placeholder":
              if ("BlockStatement" === e3.expectedNode) break;
            default:
              return false;
          }
          return null == t3 || (0, n.default)(e3, t3);
        }, t2.isBlockStatement = function(e3, t3) {
          return !!e3 && ("BlockStatement" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isBooleanLiteral = function(e3, t3) {
          return !!e3 && ("BooleanLiteral" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isBooleanLiteralTypeAnnotation = function(e3, t3) {
          return !!e3 && ("BooleanLiteralTypeAnnotation" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isBooleanTypeAnnotation = function(e3, t3) {
          return !!e3 && ("BooleanTypeAnnotation" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isBreakStatement = function(e3, t3) {
          return !!e3 && ("BreakStatement" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isCallExpression = function(e3, t3) {
          return !!e3 && ("CallExpression" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isCatchClause = function(e3, t3) {
          return !!e3 && ("CatchClause" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isClass = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "ClassExpression":
            case "ClassDeclaration":
              break;
            default:
              return false;
          }
          return null == t3 || (0, n.default)(e3, t3);
        }, t2.isClassAccessorProperty = function(e3, t3) {
          return !!e3 && ("ClassAccessorProperty" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isClassBody = function(e3, t3) {
          return !!e3 && ("ClassBody" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isClassDeclaration = function(e3, t3) {
          return !!e3 && ("ClassDeclaration" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isClassExpression = function(e3, t3) {
          return !!e3 && ("ClassExpression" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isClassImplements = function(e3, t3) {
          return !!e3 && ("ClassImplements" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isClassMethod = function(e3, t3) {
          return !!e3 && ("ClassMethod" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isClassPrivateMethod = function(e3, t3) {
          return !!e3 && ("ClassPrivateMethod" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isClassPrivateProperty = function(e3, t3) {
          return !!e3 && ("ClassPrivateProperty" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isClassProperty = function(e3, t3) {
          return !!e3 && ("ClassProperty" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isCompletionStatement = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "BreakStatement":
            case "ContinueStatement":
            case "ReturnStatement":
            case "ThrowStatement":
              break;
            default:
              return false;
          }
          return null == t3 || (0, n.default)(e3, t3);
        }, t2.isConditional = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "ConditionalExpression":
            case "IfStatement":
              break;
            default:
              return false;
          }
          return null == t3 || (0, n.default)(e3, t3);
        }, t2.isConditionalExpression = function(e3, t3) {
          return !!e3 && ("ConditionalExpression" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isContinueStatement = function(e3, t3) {
          return !!e3 && ("ContinueStatement" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isDebuggerStatement = function(e3, t3) {
          return !!e3 && ("DebuggerStatement" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isDecimalLiteral = function(e3, t3) {
          return !!e3 && ("DecimalLiteral" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isDeclaration = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "FunctionDeclaration":
            case "VariableDeclaration":
            case "ClassDeclaration":
            case "ExportAllDeclaration":
            case "ExportDefaultDeclaration":
            case "ExportNamedDeclaration":
            case "ImportDeclaration":
            case "DeclareClass":
            case "DeclareFunction":
            case "DeclareInterface":
            case "DeclareModule":
            case "DeclareModuleExports":
            case "DeclareTypeAlias":
            case "DeclareOpaqueType":
            case "DeclareVariable":
            case "DeclareExportDeclaration":
            case "DeclareExportAllDeclaration":
            case "InterfaceDeclaration":
            case "OpaqueType":
            case "TypeAlias":
            case "EnumDeclaration":
            case "TSDeclareFunction":
            case "TSInterfaceDeclaration":
            case "TSTypeAliasDeclaration":
            case "TSEnumDeclaration":
            case "TSModuleDeclaration":
            case "TSImportEqualsDeclaration":
              break;
            case "Placeholder":
              if ("Declaration" === e3.expectedNode) break;
            default:
              return false;
          }
          return null == t3 || (0, n.default)(e3, t3);
        }, t2.isDeclareClass = function(e3, t3) {
          return !!e3 && ("DeclareClass" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isDeclareExportAllDeclaration = function(e3, t3) {
          return !!e3 && ("DeclareExportAllDeclaration" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isDeclareExportDeclaration = function(e3, t3) {
          return !!e3 && ("DeclareExportDeclaration" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isDeclareFunction = function(e3, t3) {
          return !!e3 && ("DeclareFunction" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isDeclareInterface = function(e3, t3) {
          return !!e3 && ("DeclareInterface" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isDeclareModule = function(e3, t3) {
          return !!e3 && ("DeclareModule" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isDeclareModuleExports = function(e3, t3) {
          return !!e3 && ("DeclareModuleExports" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isDeclareOpaqueType = function(e3, t3) {
          return !!e3 && ("DeclareOpaqueType" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isDeclareTypeAlias = function(e3, t3) {
          return !!e3 && ("DeclareTypeAlias" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isDeclareVariable = function(e3, t3) {
          return !!e3 && ("DeclareVariable" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isDeclaredPredicate = function(e3, t3) {
          return !!e3 && ("DeclaredPredicate" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isDecorator = function(e3, t3) {
          return !!e3 && ("Decorator" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isDirective = function(e3, t3) {
          return !!e3 && ("Directive" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isDirectiveLiteral = function(e3, t3) {
          return !!e3 && ("DirectiveLiteral" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isDoExpression = function(e3, t3) {
          return !!e3 && ("DoExpression" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isDoWhileStatement = function(e3, t3) {
          return !!e3 && ("DoWhileStatement" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isEmptyStatement = function(e3, t3) {
          return !!e3 && ("EmptyStatement" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isEmptyTypeAnnotation = function(e3, t3) {
          return !!e3 && ("EmptyTypeAnnotation" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isEnumBody = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "EnumBooleanBody":
            case "EnumNumberBody":
            case "EnumStringBody":
            case "EnumSymbolBody":
              break;
            default:
              return false;
          }
          return null == t3 || (0, n.default)(e3, t3);
        }, t2.isEnumBooleanBody = function(e3, t3) {
          return !!e3 && ("EnumBooleanBody" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isEnumBooleanMember = function(e3, t3) {
          return !!e3 && ("EnumBooleanMember" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isEnumDeclaration = function(e3, t3) {
          return !!e3 && ("EnumDeclaration" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isEnumDefaultedMember = function(e3, t3) {
          return !!e3 && ("EnumDefaultedMember" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isEnumMember = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "EnumBooleanMember":
            case "EnumNumberMember":
            case "EnumStringMember":
            case "EnumDefaultedMember":
              break;
            default:
              return false;
          }
          return null == t3 || (0, n.default)(e3, t3);
        }, t2.isEnumNumberBody = function(e3, t3) {
          return !!e3 && ("EnumNumberBody" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isEnumNumberMember = function(e3, t3) {
          return !!e3 && ("EnumNumberMember" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isEnumStringBody = function(e3, t3) {
          return !!e3 && ("EnumStringBody" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isEnumStringMember = function(e3, t3) {
          return !!e3 && ("EnumStringMember" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isEnumSymbolBody = function(e3, t3) {
          return !!e3 && ("EnumSymbolBody" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isExistsTypeAnnotation = function(e3, t3) {
          return !!e3 && ("ExistsTypeAnnotation" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isExportAllDeclaration = function(e3, t3) {
          return !!e3 && ("ExportAllDeclaration" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isExportDeclaration = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "ExportAllDeclaration":
            case "ExportDefaultDeclaration":
            case "ExportNamedDeclaration":
              break;
            default:
              return false;
          }
          return null == t3 || (0, n.default)(e3, t3);
        }, t2.isExportDefaultDeclaration = function(e3, t3) {
          return !!e3 && ("ExportDefaultDeclaration" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isExportDefaultSpecifier = function(e3, t3) {
          return !!e3 && ("ExportDefaultSpecifier" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isExportNamedDeclaration = function(e3, t3) {
          return !!e3 && ("ExportNamedDeclaration" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isExportNamespaceSpecifier = function(e3, t3) {
          return !!e3 && ("ExportNamespaceSpecifier" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isExportSpecifier = function(e3, t3) {
          return !!e3 && ("ExportSpecifier" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isExpression = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "ArrayExpression":
            case "AssignmentExpression":
            case "BinaryExpression":
            case "CallExpression":
            case "ConditionalExpression":
            case "FunctionExpression":
            case "Identifier":
            case "StringLiteral":
            case "NumericLiteral":
            case "NullLiteral":
            case "BooleanLiteral":
            case "RegExpLiteral":
            case "LogicalExpression":
            case "MemberExpression":
            case "NewExpression":
            case "ObjectExpression":
            case "SequenceExpression":
            case "ParenthesizedExpression":
            case "ThisExpression":
            case "UnaryExpression":
            case "UpdateExpression":
            case "ArrowFunctionExpression":
            case "ClassExpression":
            case "ImportExpression":
            case "MetaProperty":
            case "Super":
            case "TaggedTemplateExpression":
            case "TemplateLiteral":
            case "YieldExpression":
            case "AwaitExpression":
            case "Import":
            case "BigIntLiteral":
            case "OptionalMemberExpression":
            case "OptionalCallExpression":
            case "TypeCastExpression":
            case "JSXElement":
            case "JSXFragment":
            case "BindExpression":
            case "DoExpression":
            case "RecordExpression":
            case "TupleExpression":
            case "DecimalLiteral":
            case "ModuleExpression":
            case "TopicReference":
            case "PipelineTopicExpression":
            case "PipelineBareFunction":
            case "PipelinePrimaryTopicReference":
            case "TSInstantiationExpression":
            case "TSAsExpression":
            case "TSSatisfiesExpression":
            case "TSTypeAssertion":
            case "TSNonNullExpression":
              break;
            case "Placeholder":
              switch (e3.expectedNode) {
                case "Expression":
                case "Identifier":
                case "StringLiteral":
                  break;
                default:
                  return false;
              }
              break;
            default:
              return false;
          }
          return null == t3 || (0, n.default)(e3, t3);
        }, t2.isExpressionStatement = function(e3, t3) {
          return !!e3 && ("ExpressionStatement" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isExpressionWrapper = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "ExpressionStatement":
            case "ParenthesizedExpression":
            case "TypeCastExpression":
              break;
            default:
              return false;
          }
          return null == t3 || (0, n.default)(e3, t3);
        }, t2.isFile = function(e3, t3) {
          return !!e3 && ("File" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isFlow = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "AnyTypeAnnotation":
            case "ArrayTypeAnnotation":
            case "BooleanTypeAnnotation":
            case "BooleanLiteralTypeAnnotation":
            case "NullLiteralTypeAnnotation":
            case "ClassImplements":
            case "DeclareClass":
            case "DeclareFunction":
            case "DeclareInterface":
            case "DeclareModule":
            case "DeclareModuleExports":
            case "DeclareTypeAlias":
            case "DeclareOpaqueType":
            case "DeclareVariable":
            case "DeclareExportDeclaration":
            case "DeclareExportAllDeclaration":
            case "DeclaredPredicate":
            case "ExistsTypeAnnotation":
            case "FunctionTypeAnnotation":
            case "FunctionTypeParam":
            case "GenericTypeAnnotation":
            case "InferredPredicate":
            case "InterfaceExtends":
            case "InterfaceDeclaration":
            case "InterfaceTypeAnnotation":
            case "IntersectionTypeAnnotation":
            case "MixedTypeAnnotation":
            case "EmptyTypeAnnotation":
            case "NullableTypeAnnotation":
            case "NumberLiteralTypeAnnotation":
            case "NumberTypeAnnotation":
            case "ObjectTypeAnnotation":
            case "ObjectTypeInternalSlot":
            case "ObjectTypeCallProperty":
            case "ObjectTypeIndexer":
            case "ObjectTypeProperty":
            case "ObjectTypeSpreadProperty":
            case "OpaqueType":
            case "QualifiedTypeIdentifier":
            case "StringLiteralTypeAnnotation":
            case "StringTypeAnnotation":
            case "SymbolTypeAnnotation":
            case "ThisTypeAnnotation":
            case "TupleTypeAnnotation":
            case "TypeofTypeAnnotation":
            case "TypeAlias":
            case "TypeAnnotation":
            case "TypeCastExpression":
            case "TypeParameter":
            case "TypeParameterDeclaration":
            case "TypeParameterInstantiation":
            case "UnionTypeAnnotation":
            case "Variance":
            case "VoidTypeAnnotation":
            case "EnumDeclaration":
            case "EnumBooleanBody":
            case "EnumNumberBody":
            case "EnumStringBody":
            case "EnumSymbolBody":
            case "EnumBooleanMember":
            case "EnumNumberMember":
            case "EnumStringMember":
            case "EnumDefaultedMember":
            case "IndexedAccessType":
            case "OptionalIndexedAccessType":
              break;
            default:
              return false;
          }
          return null == t3 || (0, n.default)(e3, t3);
        }, t2.isFlowBaseAnnotation = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "AnyTypeAnnotation":
            case "BooleanTypeAnnotation":
            case "NullLiteralTypeAnnotation":
            case "MixedTypeAnnotation":
            case "EmptyTypeAnnotation":
            case "NumberTypeAnnotation":
            case "StringTypeAnnotation":
            case "SymbolTypeAnnotation":
            case "ThisTypeAnnotation":
            case "VoidTypeAnnotation":
              break;
            default:
              return false;
          }
          return null == t3 || (0, n.default)(e3, t3);
        }, t2.isFlowDeclaration = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "DeclareClass":
            case "DeclareFunction":
            case "DeclareInterface":
            case "DeclareModule":
            case "DeclareModuleExports":
            case "DeclareTypeAlias":
            case "DeclareOpaqueType":
            case "DeclareVariable":
            case "DeclareExportDeclaration":
            case "DeclareExportAllDeclaration":
            case "InterfaceDeclaration":
            case "OpaqueType":
            case "TypeAlias":
              break;
            default:
              return false;
          }
          return null == t3 || (0, n.default)(e3, t3);
        }, t2.isFlowPredicate = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "DeclaredPredicate":
            case "InferredPredicate":
              break;
            default:
              return false;
          }
          return null == t3 || (0, n.default)(e3, t3);
        }, t2.isFlowType = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "AnyTypeAnnotation":
            case "ArrayTypeAnnotation":
            case "BooleanTypeAnnotation":
            case "BooleanLiteralTypeAnnotation":
            case "NullLiteralTypeAnnotation":
            case "ExistsTypeAnnotation":
            case "FunctionTypeAnnotation":
            case "GenericTypeAnnotation":
            case "InterfaceTypeAnnotation":
            case "IntersectionTypeAnnotation":
            case "MixedTypeAnnotation":
            case "EmptyTypeAnnotation":
            case "NullableTypeAnnotation":
            case "NumberLiteralTypeAnnotation":
            case "NumberTypeAnnotation":
            case "ObjectTypeAnnotation":
            case "StringLiteralTypeAnnotation":
            case "StringTypeAnnotation":
            case "SymbolTypeAnnotation":
            case "ThisTypeAnnotation":
            case "TupleTypeAnnotation":
            case "TypeofTypeAnnotation":
            case "UnionTypeAnnotation":
            case "VoidTypeAnnotation":
            case "IndexedAccessType":
            case "OptionalIndexedAccessType":
              break;
            default:
              return false;
          }
          return null == t3 || (0, n.default)(e3, t3);
        }, t2.isFor = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "ForInStatement":
            case "ForStatement":
            case "ForOfStatement":
              break;
            default:
              return false;
          }
          return null == t3 || (0, n.default)(e3, t3);
        }, t2.isForInStatement = function(e3, t3) {
          return !!e3 && ("ForInStatement" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isForOfStatement = function(e3, t3) {
          return !!e3 && ("ForOfStatement" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isForStatement = function(e3, t3) {
          return !!e3 && ("ForStatement" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isForXStatement = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "ForInStatement":
            case "ForOfStatement":
              break;
            default:
              return false;
          }
          return null == t3 || (0, n.default)(e3, t3);
        }, t2.isFunction = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ObjectMethod":
            case "ArrowFunctionExpression":
            case "ClassMethod":
            case "ClassPrivateMethod":
              break;
            default:
              return false;
          }
          return null == t3 || (0, n.default)(e3, t3);
        }, t2.isFunctionDeclaration = function(e3, t3) {
          return !!e3 && ("FunctionDeclaration" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isFunctionExpression = function(e3, t3) {
          return !!e3 && ("FunctionExpression" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isFunctionParameter = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "Identifier":
            case "RestElement":
            case "AssignmentPattern":
            case "ArrayPattern":
            case "ObjectPattern":
            case "VoidPattern":
              break;
            case "Placeholder":
              if ("Identifier" === e3.expectedNode) break;
            default:
              return false;
          }
          return null == t3 || (0, n.default)(e3, t3);
        }, t2.isFunctionParent = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ObjectMethod":
            case "ArrowFunctionExpression":
            case "ClassMethod":
            case "ClassPrivateMethod":
            case "StaticBlock":
            case "TSModuleBlock":
              break;
            default:
              return false;
          }
          return null == t3 || (0, n.default)(e3, t3);
        }, t2.isFunctionTypeAnnotation = function(e3, t3) {
          return !!e3 && ("FunctionTypeAnnotation" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isFunctionTypeParam = function(e3, t3) {
          return !!e3 && ("FunctionTypeParam" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isGenericTypeAnnotation = function(e3, t3) {
          return !!e3 && ("GenericTypeAnnotation" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isIdentifier = function(e3, t3) {
          return !!e3 && ("Identifier" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isIfStatement = function(e3, t3) {
          return !!e3 && ("IfStatement" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isImmutable = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "StringLiteral":
            case "NumericLiteral":
            case "NullLiteral":
            case "BooleanLiteral":
            case "BigIntLiteral":
            case "JSXAttribute":
            case "JSXClosingElement":
            case "JSXElement":
            case "JSXExpressionContainer":
            case "JSXSpreadChild":
            case "JSXOpeningElement":
            case "JSXText":
            case "JSXFragment":
            case "JSXOpeningFragment":
            case "JSXClosingFragment":
            case "DecimalLiteral":
              break;
            case "Placeholder":
              if ("StringLiteral" === e3.expectedNode) break;
            default:
              return false;
          }
          return null == t3 || (0, n.default)(e3, t3);
        }, t2.isImport = function(e3, t3) {
          return !!e3 && ("Import" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isImportAttribute = function(e3, t3) {
          return !!e3 && ("ImportAttribute" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isImportDeclaration = function(e3, t3) {
          return !!e3 && ("ImportDeclaration" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isImportDefaultSpecifier = function(e3, t3) {
          return !!e3 && ("ImportDefaultSpecifier" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isImportExpression = function(e3, t3) {
          return !!e3 && ("ImportExpression" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isImportNamespaceSpecifier = function(e3, t3) {
          return !!e3 && ("ImportNamespaceSpecifier" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isImportOrExportDeclaration = isImportOrExportDeclaration, t2.isImportSpecifier = function(e3, t3) {
          return !!e3 && ("ImportSpecifier" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isIndexedAccessType = function(e3, t3) {
          return !!e3 && ("IndexedAccessType" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isInferredPredicate = function(e3, t3) {
          return !!e3 && ("InferredPredicate" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isInterfaceDeclaration = function(e3, t3) {
          return !!e3 && ("InterfaceDeclaration" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isInterfaceExtends = function(e3, t3) {
          return !!e3 && ("InterfaceExtends" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isInterfaceTypeAnnotation = function(e3, t3) {
          return !!e3 && ("InterfaceTypeAnnotation" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isInterpreterDirective = function(e3, t3) {
          return !!e3 && ("InterpreterDirective" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isIntersectionTypeAnnotation = function(e3, t3) {
          return !!e3 && ("IntersectionTypeAnnotation" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isJSX = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "JSXAttribute":
            case "JSXClosingElement":
            case "JSXElement":
            case "JSXEmptyExpression":
            case "JSXExpressionContainer":
            case "JSXSpreadChild":
            case "JSXIdentifier":
            case "JSXMemberExpression":
            case "JSXNamespacedName":
            case "JSXOpeningElement":
            case "JSXSpreadAttribute":
            case "JSXText":
            case "JSXFragment":
            case "JSXOpeningFragment":
            case "JSXClosingFragment":
              break;
            default:
              return false;
          }
          return null == t3 || (0, n.default)(e3, t3);
        }, t2.isJSXAttribute = function(e3, t3) {
          return !!e3 && ("JSXAttribute" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isJSXClosingElement = function(e3, t3) {
          return !!e3 && ("JSXClosingElement" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isJSXClosingFragment = function(e3, t3) {
          return !!e3 && ("JSXClosingFragment" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isJSXElement = function(e3, t3) {
          return !!e3 && ("JSXElement" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isJSXEmptyExpression = function(e3, t3) {
          return !!e3 && ("JSXEmptyExpression" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isJSXExpressionContainer = function(e3, t3) {
          return !!e3 && ("JSXExpressionContainer" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isJSXFragment = function(e3, t3) {
          return !!e3 && ("JSXFragment" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isJSXIdentifier = function(e3, t3) {
          return !!e3 && ("JSXIdentifier" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isJSXMemberExpression = function(e3, t3) {
          return !!e3 && ("JSXMemberExpression" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isJSXNamespacedName = function(e3, t3) {
          return !!e3 && ("JSXNamespacedName" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isJSXOpeningElement = function(e3, t3) {
          return !!e3 && ("JSXOpeningElement" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isJSXOpeningFragment = function(e3, t3) {
          return !!e3 && ("JSXOpeningFragment" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isJSXSpreadAttribute = function(e3, t3) {
          return !!e3 && ("JSXSpreadAttribute" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isJSXSpreadChild = function(e3, t3) {
          return !!e3 && ("JSXSpreadChild" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isJSXText = function(e3, t3) {
          return !!e3 && ("JSXText" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isLVal = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "Identifier":
            case "MemberExpression":
            case "RestElement":
            case "AssignmentPattern":
            case "ArrayPattern":
            case "ObjectPattern":
            case "TSParameterProperty":
            case "TSAsExpression":
            case "TSSatisfiesExpression":
            case "TSTypeAssertion":
            case "TSNonNullExpression":
              break;
            case "Placeholder":
              switch (e3.expectedNode) {
                case "Pattern":
                case "Identifier":
                  break;
                default:
                  return false;
              }
              break;
            default:
              return false;
          }
          return null == t3 || (0, n.default)(e3, t3);
        }, t2.isLabeledStatement = function(e3, t3) {
          return !!e3 && ("LabeledStatement" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isLiteral = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "StringLiteral":
            case "NumericLiteral":
            case "NullLiteral":
            case "BooleanLiteral":
            case "RegExpLiteral":
            case "TemplateLiteral":
            case "BigIntLiteral":
            case "DecimalLiteral":
              break;
            case "Placeholder":
              if ("StringLiteral" === e3.expectedNode) break;
            default:
              return false;
          }
          return null == t3 || (0, n.default)(e3, t3);
        }, t2.isLogicalExpression = function(e3, t3) {
          return !!e3 && ("LogicalExpression" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isLoop = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "DoWhileStatement":
            case "ForInStatement":
            case "ForStatement":
            case "WhileStatement":
            case "ForOfStatement":
              break;
            default:
              return false;
          }
          return null == t3 || (0, n.default)(e3, t3);
        }, t2.isMemberExpression = function(e3, t3) {
          return !!e3 && ("MemberExpression" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isMetaProperty = function(e3, t3) {
          return !!e3 && ("MetaProperty" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isMethod = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "ObjectMethod":
            case "ClassMethod":
            case "ClassPrivateMethod":
              break;
            default:
              return false;
          }
          return null == t3 || (0, n.default)(e3, t3);
        }, t2.isMiscellaneous = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "Noop":
            case "Placeholder":
            case "V8IntrinsicIdentifier":
              break;
            default:
              return false;
          }
          return null == t3 || (0, n.default)(e3, t3);
        }, t2.isMixedTypeAnnotation = function(e3, t3) {
          return !!e3 && ("MixedTypeAnnotation" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isModuleDeclaration = function(e3, t3) {
          return (0, s.default)("isModuleDeclaration", "isImportOrExportDeclaration"), isImportOrExportDeclaration(e3, t3);
        }, t2.isModuleExpression = function(e3, t3) {
          return !!e3 && ("ModuleExpression" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isModuleSpecifier = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "ExportSpecifier":
            case "ImportDefaultSpecifier":
            case "ImportNamespaceSpecifier":
            case "ImportSpecifier":
            case "ExportNamespaceSpecifier":
            case "ExportDefaultSpecifier":
              break;
            default:
              return false;
          }
          return null == t3 || (0, n.default)(e3, t3);
        }, t2.isNewExpression = function(e3, t3) {
          return !!e3 && ("NewExpression" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isNoop = function(e3, t3) {
          return !!e3 && ("Noop" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isNullLiteral = function(e3, t3) {
          return !!e3 && ("NullLiteral" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isNullLiteralTypeAnnotation = function(e3, t3) {
          return !!e3 && ("NullLiteralTypeAnnotation" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isNullableTypeAnnotation = function(e3, t3) {
          return !!e3 && ("NullableTypeAnnotation" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isNumberLiteral = function(e3, t3) {
          return (0, s.default)("isNumberLiteral", "isNumericLiteral"), !!e3 && ("NumberLiteral" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isNumberLiteralTypeAnnotation = function(e3, t3) {
          return !!e3 && ("NumberLiteralTypeAnnotation" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isNumberTypeAnnotation = function(e3, t3) {
          return !!e3 && ("NumberTypeAnnotation" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isNumericLiteral = function(e3, t3) {
          return !!e3 && ("NumericLiteral" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isObjectExpression = function(e3, t3) {
          return !!e3 && ("ObjectExpression" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isObjectMember = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "ObjectMethod":
            case "ObjectProperty":
              break;
            default:
              return false;
          }
          return null == t3 || (0, n.default)(e3, t3);
        }, t2.isObjectMethod = function(e3, t3) {
          return !!e3 && ("ObjectMethod" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isObjectPattern = function(e3, t3) {
          return !!e3 && ("ObjectPattern" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isObjectProperty = function(e3, t3) {
          return !!e3 && ("ObjectProperty" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isObjectTypeAnnotation = function(e3, t3) {
          return !!e3 && ("ObjectTypeAnnotation" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isObjectTypeCallProperty = function(e3, t3) {
          return !!e3 && ("ObjectTypeCallProperty" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isObjectTypeIndexer = function(e3, t3) {
          return !!e3 && ("ObjectTypeIndexer" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isObjectTypeInternalSlot = function(e3, t3) {
          return !!e3 && ("ObjectTypeInternalSlot" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isObjectTypeProperty = function(e3, t3) {
          return !!e3 && ("ObjectTypeProperty" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isObjectTypeSpreadProperty = function(e3, t3) {
          return !!e3 && ("ObjectTypeSpreadProperty" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isOpaqueType = function(e3, t3) {
          return !!e3 && ("OpaqueType" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isOptionalCallExpression = function(e3, t3) {
          return !!e3 && ("OptionalCallExpression" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isOptionalIndexedAccessType = function(e3, t3) {
          return !!e3 && ("OptionalIndexedAccessType" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isOptionalMemberExpression = function(e3, t3) {
          return !!e3 && ("OptionalMemberExpression" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isParenthesizedExpression = function(e3, t3) {
          return !!e3 && ("ParenthesizedExpression" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isPattern = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "AssignmentPattern":
            case "ArrayPattern":
            case "ObjectPattern":
            case "VoidPattern":
              break;
            case "Placeholder":
              if ("Pattern" === e3.expectedNode) break;
            default:
              return false;
          }
          return null == t3 || (0, n.default)(e3, t3);
        }, t2.isPatternLike = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "Identifier":
            case "MemberExpression":
            case "RestElement":
            case "AssignmentPattern":
            case "ArrayPattern":
            case "ObjectPattern":
            case "VoidPattern":
            case "TSAsExpression":
            case "TSSatisfiesExpression":
            case "TSTypeAssertion":
            case "TSNonNullExpression":
              break;
            case "Placeholder":
              switch (e3.expectedNode) {
                case "Pattern":
                case "Identifier":
                  break;
                default:
                  return false;
              }
              break;
            default:
              return false;
          }
          return null == t3 || (0, n.default)(e3, t3);
        }, t2.isPipelineBareFunction = function(e3, t3) {
          return !!e3 && ("PipelineBareFunction" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isPipelinePrimaryTopicReference = function(e3, t3) {
          return !!e3 && ("PipelinePrimaryTopicReference" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isPipelineTopicExpression = function(e3, t3) {
          return !!e3 && ("PipelineTopicExpression" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isPlaceholder = function(e3, t3) {
          return !!e3 && ("Placeholder" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isPrivate = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "ClassPrivateProperty":
            case "ClassPrivateMethod":
            case "PrivateName":
              break;
            default:
              return false;
          }
          return null == t3 || (0, n.default)(e3, t3);
        }, t2.isPrivateName = function(e3, t3) {
          return !!e3 && ("PrivateName" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isProgram = function(e3, t3) {
          return !!e3 && ("Program" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isProperty = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "ObjectProperty":
            case "ClassProperty":
            case "ClassAccessorProperty":
            case "ClassPrivateProperty":
              break;
            default:
              return false;
          }
          return null == t3 || (0, n.default)(e3, t3);
        }, t2.isPureish = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "StringLiteral":
            case "NumericLiteral":
            case "NullLiteral":
            case "BooleanLiteral":
            case "RegExpLiteral":
            case "ArrowFunctionExpression":
            case "BigIntLiteral":
            case "DecimalLiteral":
              break;
            case "Placeholder":
              if ("StringLiteral" === e3.expectedNode) break;
            default:
              return false;
          }
          return null == t3 || (0, n.default)(e3, t3);
        }, t2.isQualifiedTypeIdentifier = function(e3, t3) {
          return !!e3 && ("QualifiedTypeIdentifier" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isRecordExpression = function(e3, t3) {
          return !!e3 && ("RecordExpression" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isRegExpLiteral = function(e3, t3) {
          return !!e3 && ("RegExpLiteral" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isRegexLiteral = function(e3, t3) {
          return (0, s.default)("isRegexLiteral", "isRegExpLiteral"), !!e3 && ("RegexLiteral" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isRestElement = function(e3, t3) {
          return !!e3 && ("RestElement" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isRestProperty = function(e3, t3) {
          return (0, s.default)("isRestProperty", "isRestElement"), !!e3 && ("RestProperty" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isReturnStatement = function(e3, t3) {
          return !!e3 && ("ReturnStatement" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isScopable = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "BlockStatement":
            case "CatchClause":
            case "DoWhileStatement":
            case "ForInStatement":
            case "ForStatement":
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "Program":
            case "ObjectMethod":
            case "SwitchStatement":
            case "WhileStatement":
            case "ArrowFunctionExpression":
            case "ClassExpression":
            case "ClassDeclaration":
            case "ForOfStatement":
            case "ClassMethod":
            case "ClassPrivateMethod":
            case "StaticBlock":
            case "TSModuleBlock":
              break;
            case "Placeholder":
              if ("BlockStatement" === e3.expectedNode) break;
            default:
              return false;
          }
          return null == t3 || (0, n.default)(e3, t3);
        }, t2.isSequenceExpression = function(e3, t3) {
          return !!e3 && ("SequenceExpression" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isSpreadElement = function(e3, t3) {
          return !!e3 && ("SpreadElement" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isSpreadProperty = function(e3, t3) {
          return (0, s.default)("isSpreadProperty", "isSpreadElement"), !!e3 && ("SpreadProperty" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isStandardized = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "ArrayExpression":
            case "AssignmentExpression":
            case "BinaryExpression":
            case "InterpreterDirective":
            case "Directive":
            case "DirectiveLiteral":
            case "BlockStatement":
            case "BreakStatement":
            case "CallExpression":
            case "CatchClause":
            case "ConditionalExpression":
            case "ContinueStatement":
            case "DebuggerStatement":
            case "DoWhileStatement":
            case "EmptyStatement":
            case "ExpressionStatement":
            case "File":
            case "ForInStatement":
            case "ForStatement":
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "Identifier":
            case "IfStatement":
            case "LabeledStatement":
            case "StringLiteral":
            case "NumericLiteral":
            case "NullLiteral":
            case "BooleanLiteral":
            case "RegExpLiteral":
            case "LogicalExpression":
            case "MemberExpression":
            case "NewExpression":
            case "Program":
            case "ObjectExpression":
            case "ObjectMethod":
            case "ObjectProperty":
            case "RestElement":
            case "ReturnStatement":
            case "SequenceExpression":
            case "ParenthesizedExpression":
            case "SwitchCase":
            case "SwitchStatement":
            case "ThisExpression":
            case "ThrowStatement":
            case "TryStatement":
            case "UnaryExpression":
            case "UpdateExpression":
            case "VariableDeclaration":
            case "VariableDeclarator":
            case "WhileStatement":
            case "WithStatement":
            case "AssignmentPattern":
            case "ArrayPattern":
            case "ArrowFunctionExpression":
            case "ClassBody":
            case "ClassExpression":
            case "ClassDeclaration":
            case "ExportAllDeclaration":
            case "ExportDefaultDeclaration":
            case "ExportNamedDeclaration":
            case "ExportSpecifier":
            case "ForOfStatement":
            case "ImportDeclaration":
            case "ImportDefaultSpecifier":
            case "ImportNamespaceSpecifier":
            case "ImportSpecifier":
            case "ImportExpression":
            case "MetaProperty":
            case "ClassMethod":
            case "ObjectPattern":
            case "SpreadElement":
            case "Super":
            case "TaggedTemplateExpression":
            case "TemplateElement":
            case "TemplateLiteral":
            case "YieldExpression":
            case "AwaitExpression":
            case "Import":
            case "BigIntLiteral":
            case "ExportNamespaceSpecifier":
            case "OptionalMemberExpression":
            case "OptionalCallExpression":
            case "ClassProperty":
            case "ClassAccessorProperty":
            case "ClassPrivateProperty":
            case "ClassPrivateMethod":
            case "PrivateName":
            case "StaticBlock":
            case "ImportAttribute":
              break;
            case "Placeholder":
              switch (e3.expectedNode) {
                case "Identifier":
                case "StringLiteral":
                case "BlockStatement":
                case "ClassBody":
                  break;
                default:
                  return false;
              }
              break;
            default:
              return false;
          }
          return null == t3 || (0, n.default)(e3, t3);
        }, t2.isStatement = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "BlockStatement":
            case "BreakStatement":
            case "ContinueStatement":
            case "DebuggerStatement":
            case "DoWhileStatement":
            case "EmptyStatement":
            case "ExpressionStatement":
            case "ForInStatement":
            case "ForStatement":
            case "FunctionDeclaration":
            case "IfStatement":
            case "LabeledStatement":
            case "ReturnStatement":
            case "SwitchStatement":
            case "ThrowStatement":
            case "TryStatement":
            case "VariableDeclaration":
            case "WhileStatement":
            case "WithStatement":
            case "ClassDeclaration":
            case "ExportAllDeclaration":
            case "ExportDefaultDeclaration":
            case "ExportNamedDeclaration":
            case "ForOfStatement":
            case "ImportDeclaration":
            case "DeclareClass":
            case "DeclareFunction":
            case "DeclareInterface":
            case "DeclareModule":
            case "DeclareModuleExports":
            case "DeclareTypeAlias":
            case "DeclareOpaqueType":
            case "DeclareVariable":
            case "DeclareExportDeclaration":
            case "DeclareExportAllDeclaration":
            case "InterfaceDeclaration":
            case "OpaqueType":
            case "TypeAlias":
            case "EnumDeclaration":
            case "TSDeclareFunction":
            case "TSInterfaceDeclaration":
            case "TSTypeAliasDeclaration":
            case "TSEnumDeclaration":
            case "TSModuleDeclaration":
            case "TSImportEqualsDeclaration":
            case "TSExportAssignment":
            case "TSNamespaceExportDeclaration":
              break;
            case "Placeholder":
              switch (e3.expectedNode) {
                case "Statement":
                case "Declaration":
                case "BlockStatement":
                  break;
                default:
                  return false;
              }
              break;
            default:
              return false;
          }
          return null == t3 || (0, n.default)(e3, t3);
        }, t2.isStaticBlock = function(e3, t3) {
          return !!e3 && ("StaticBlock" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isStringLiteral = function(e3, t3) {
          return !!e3 && ("StringLiteral" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isStringLiteralTypeAnnotation = function(e3, t3) {
          return !!e3 && ("StringLiteralTypeAnnotation" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isStringTypeAnnotation = function(e3, t3) {
          return !!e3 && ("StringTypeAnnotation" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isSuper = function(e3, t3) {
          return !!e3 && ("Super" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isSwitchCase = function(e3, t3) {
          return !!e3 && ("SwitchCase" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isSwitchStatement = function(e3, t3) {
          return !!e3 && ("SwitchStatement" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isSymbolTypeAnnotation = function(e3, t3) {
          return !!e3 && ("SymbolTypeAnnotation" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSAnyKeyword = function(e3, t3) {
          return !!e3 && ("TSAnyKeyword" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSArrayType = function(e3, t3) {
          return !!e3 && ("TSArrayType" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSAsExpression = function(e3, t3) {
          return !!e3 && ("TSAsExpression" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSBaseType = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "TSAnyKeyword":
            case "TSBooleanKeyword":
            case "TSBigIntKeyword":
            case "TSIntrinsicKeyword":
            case "TSNeverKeyword":
            case "TSNullKeyword":
            case "TSNumberKeyword":
            case "TSObjectKeyword":
            case "TSStringKeyword":
            case "TSSymbolKeyword":
            case "TSUndefinedKeyword":
            case "TSUnknownKeyword":
            case "TSVoidKeyword":
            case "TSThisType":
            case "TSTemplateLiteralType":
            case "TSLiteralType":
              break;
            default:
              return false;
          }
          return null == t3 || (0, n.default)(e3, t3);
        }, t2.isTSBigIntKeyword = function(e3, t3) {
          return !!e3 && ("TSBigIntKeyword" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSBooleanKeyword = function(e3, t3) {
          return !!e3 && ("TSBooleanKeyword" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSCallSignatureDeclaration = function(e3, t3) {
          return !!e3 && ("TSCallSignatureDeclaration" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSConditionalType = function(e3, t3) {
          return !!e3 && ("TSConditionalType" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSConstructSignatureDeclaration = function(e3, t3) {
          return !!e3 && ("TSConstructSignatureDeclaration" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSConstructorType = function(e3, t3) {
          return !!e3 && ("TSConstructorType" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSDeclareFunction = function(e3, t3) {
          return !!e3 && ("TSDeclareFunction" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSDeclareMethod = function(e3, t3) {
          return !!e3 && ("TSDeclareMethod" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSEntityName = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "Identifier":
            case "TSQualifiedName":
              break;
            case "Placeholder":
              if ("Identifier" === e3.expectedNode) break;
            default:
              return false;
          }
          return null == t3 || (0, n.default)(e3, t3);
        }, t2.isTSEnumBody = function(e3, t3) {
          return !!e3 && ("TSEnumBody" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSEnumDeclaration = function(e3, t3) {
          return !!e3 && ("TSEnumDeclaration" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSEnumMember = function(e3, t3) {
          return !!e3 && ("TSEnumMember" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSExportAssignment = function(e3, t3) {
          return !!e3 && ("TSExportAssignment" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSExpressionWithTypeArguments = function(e3, t3) {
          return !!e3 && ("TSExpressionWithTypeArguments" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSExternalModuleReference = function(e3, t3) {
          return !!e3 && ("TSExternalModuleReference" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSFunctionType = function(e3, t3) {
          return !!e3 && ("TSFunctionType" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSImportEqualsDeclaration = function(e3, t3) {
          return !!e3 && ("TSImportEqualsDeclaration" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSImportType = function(e3, t3) {
          return !!e3 && ("TSImportType" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSIndexSignature = function(e3, t3) {
          return !!e3 && ("TSIndexSignature" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSIndexedAccessType = function(e3, t3) {
          return !!e3 && ("TSIndexedAccessType" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSInferType = function(e3, t3) {
          return !!e3 && ("TSInferType" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSInstantiationExpression = function(e3, t3) {
          return !!e3 && ("TSInstantiationExpression" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSInterfaceBody = function(e3, t3) {
          return !!e3 && ("TSInterfaceBody" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSInterfaceDeclaration = function(e3, t3) {
          return !!e3 && ("TSInterfaceDeclaration" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSIntersectionType = function(e3, t3) {
          return !!e3 && ("TSIntersectionType" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSIntrinsicKeyword = function(e3, t3) {
          return !!e3 && ("TSIntrinsicKeyword" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSLiteralType = function(e3, t3) {
          return !!e3 && ("TSLiteralType" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSMappedType = function(e3, t3) {
          return !!e3 && ("TSMappedType" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSMethodSignature = function(e3, t3) {
          return !!e3 && ("TSMethodSignature" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSModuleBlock = function(e3, t3) {
          return !!e3 && ("TSModuleBlock" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSModuleDeclaration = function(e3, t3) {
          return !!e3 && ("TSModuleDeclaration" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSNamedTupleMember = function(e3, t3) {
          return !!e3 && ("TSNamedTupleMember" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSNamespaceExportDeclaration = function(e3, t3) {
          return !!e3 && ("TSNamespaceExportDeclaration" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSNeverKeyword = function(e3, t3) {
          return !!e3 && ("TSNeverKeyword" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSNonNullExpression = function(e3, t3) {
          return !!e3 && ("TSNonNullExpression" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSNullKeyword = function(e3, t3) {
          return !!e3 && ("TSNullKeyword" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSNumberKeyword = function(e3, t3) {
          return !!e3 && ("TSNumberKeyword" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSObjectKeyword = function(e3, t3) {
          return !!e3 && ("TSObjectKeyword" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSOptionalType = function(e3, t3) {
          return !!e3 && ("TSOptionalType" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSParameterProperty = function(e3, t3) {
          return !!e3 && ("TSParameterProperty" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSParenthesizedType = function(e3, t3) {
          return !!e3 && ("TSParenthesizedType" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSPropertySignature = function(e3, t3) {
          return !!e3 && ("TSPropertySignature" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSQualifiedName = function(e3, t3) {
          return !!e3 && ("TSQualifiedName" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSRestType = function(e3, t3) {
          return !!e3 && ("TSRestType" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSSatisfiesExpression = function(e3, t3) {
          return !!e3 && ("TSSatisfiesExpression" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSStringKeyword = function(e3, t3) {
          return !!e3 && ("TSStringKeyword" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSSymbolKeyword = function(e3, t3) {
          return !!e3 && ("TSSymbolKeyword" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSTemplateLiteralType = function(e3, t3) {
          return !!e3 && ("TSTemplateLiteralType" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSThisType = function(e3, t3) {
          return !!e3 && ("TSThisType" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSTupleType = function(e3, t3) {
          return !!e3 && ("TSTupleType" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSType = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "TSAnyKeyword":
            case "TSBooleanKeyword":
            case "TSBigIntKeyword":
            case "TSIntrinsicKeyword":
            case "TSNeverKeyword":
            case "TSNullKeyword":
            case "TSNumberKeyword":
            case "TSObjectKeyword":
            case "TSStringKeyword":
            case "TSSymbolKeyword":
            case "TSUndefinedKeyword":
            case "TSUnknownKeyword":
            case "TSVoidKeyword":
            case "TSThisType":
            case "TSFunctionType":
            case "TSConstructorType":
            case "TSTypeReference":
            case "TSTypePredicate":
            case "TSTypeQuery":
            case "TSTypeLiteral":
            case "TSArrayType":
            case "TSTupleType":
            case "TSOptionalType":
            case "TSRestType":
            case "TSUnionType":
            case "TSIntersectionType":
            case "TSConditionalType":
            case "TSInferType":
            case "TSParenthesizedType":
            case "TSTypeOperator":
            case "TSIndexedAccessType":
            case "TSMappedType":
            case "TSTemplateLiteralType":
            case "TSLiteralType":
            case "TSExpressionWithTypeArguments":
            case "TSImportType":
              break;
            default:
              return false;
          }
          return null == t3 || (0, n.default)(e3, t3);
        }, t2.isTSTypeAliasDeclaration = function(e3, t3) {
          return !!e3 && ("TSTypeAliasDeclaration" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSTypeAnnotation = function(e3, t3) {
          return !!e3 && ("TSTypeAnnotation" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSTypeAssertion = function(e3, t3) {
          return !!e3 && ("TSTypeAssertion" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSTypeElement = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "TSCallSignatureDeclaration":
            case "TSConstructSignatureDeclaration":
            case "TSPropertySignature":
            case "TSMethodSignature":
            case "TSIndexSignature":
              break;
            default:
              return false;
          }
          return null == t3 || (0, n.default)(e3, t3);
        }, t2.isTSTypeLiteral = function(e3, t3) {
          return !!e3 && ("TSTypeLiteral" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSTypeOperator = function(e3, t3) {
          return !!e3 && ("TSTypeOperator" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSTypeParameter = function(e3, t3) {
          return !!e3 && ("TSTypeParameter" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSTypeParameterDeclaration = function(e3, t3) {
          return !!e3 && ("TSTypeParameterDeclaration" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSTypeParameterInstantiation = function(e3, t3) {
          return !!e3 && ("TSTypeParameterInstantiation" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSTypePredicate = function(e3, t3) {
          return !!e3 && ("TSTypePredicate" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSTypeQuery = function(e3, t3) {
          return !!e3 && ("TSTypeQuery" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSTypeReference = function(e3, t3) {
          return !!e3 && ("TSTypeReference" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSUndefinedKeyword = function(e3, t3) {
          return !!e3 && ("TSUndefinedKeyword" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSUnionType = function(e3, t3) {
          return !!e3 && ("TSUnionType" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSUnknownKeyword = function(e3, t3) {
          return !!e3 && ("TSUnknownKeyword" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTSVoidKeyword = function(e3, t3) {
          return !!e3 && ("TSVoidKeyword" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTaggedTemplateExpression = function(e3, t3) {
          return !!e3 && ("TaggedTemplateExpression" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTemplateElement = function(e3, t3) {
          return !!e3 && ("TemplateElement" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTemplateLiteral = function(e3, t3) {
          return !!e3 && ("TemplateLiteral" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTerminatorless = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "BreakStatement":
            case "ContinueStatement":
            case "ReturnStatement":
            case "ThrowStatement":
            case "YieldExpression":
            case "AwaitExpression":
              break;
            default:
              return false;
          }
          return null == t3 || (0, n.default)(e3, t3);
        }, t2.isThisExpression = function(e3, t3) {
          return !!e3 && ("ThisExpression" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isThisTypeAnnotation = function(e3, t3) {
          return !!e3 && ("ThisTypeAnnotation" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isThrowStatement = function(e3, t3) {
          return !!e3 && ("ThrowStatement" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTopicReference = function(e3, t3) {
          return !!e3 && ("TopicReference" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTryStatement = function(e3, t3) {
          return !!e3 && ("TryStatement" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTupleExpression = function(e3, t3) {
          return !!e3 && ("TupleExpression" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTupleTypeAnnotation = function(e3, t3) {
          return !!e3 && ("TupleTypeAnnotation" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTypeAlias = function(e3, t3) {
          return !!e3 && ("TypeAlias" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTypeAnnotation = function(e3, t3) {
          return !!e3 && ("TypeAnnotation" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTypeCastExpression = function(e3, t3) {
          return !!e3 && ("TypeCastExpression" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTypeParameter = function(e3, t3) {
          return !!e3 && ("TypeParameter" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTypeParameterDeclaration = function(e3, t3) {
          return !!e3 && ("TypeParameterDeclaration" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTypeParameterInstantiation = function(e3, t3) {
          return !!e3 && ("TypeParameterInstantiation" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isTypeScript = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "TSParameterProperty":
            case "TSDeclareFunction":
            case "TSDeclareMethod":
            case "TSQualifiedName":
            case "TSCallSignatureDeclaration":
            case "TSConstructSignatureDeclaration":
            case "TSPropertySignature":
            case "TSMethodSignature":
            case "TSIndexSignature":
            case "TSAnyKeyword":
            case "TSBooleanKeyword":
            case "TSBigIntKeyword":
            case "TSIntrinsicKeyword":
            case "TSNeverKeyword":
            case "TSNullKeyword":
            case "TSNumberKeyword":
            case "TSObjectKeyword":
            case "TSStringKeyword":
            case "TSSymbolKeyword":
            case "TSUndefinedKeyword":
            case "TSUnknownKeyword":
            case "TSVoidKeyword":
            case "TSThisType":
            case "TSFunctionType":
            case "TSConstructorType":
            case "TSTypeReference":
            case "TSTypePredicate":
            case "TSTypeQuery":
            case "TSTypeLiteral":
            case "TSArrayType":
            case "TSTupleType":
            case "TSOptionalType":
            case "TSRestType":
            case "TSNamedTupleMember":
            case "TSUnionType":
            case "TSIntersectionType":
            case "TSConditionalType":
            case "TSInferType":
            case "TSParenthesizedType":
            case "TSTypeOperator":
            case "TSIndexedAccessType":
            case "TSMappedType":
            case "TSTemplateLiteralType":
            case "TSLiteralType":
            case "TSExpressionWithTypeArguments":
            case "TSInterfaceDeclaration":
            case "TSInterfaceBody":
            case "TSTypeAliasDeclaration":
            case "TSInstantiationExpression":
            case "TSAsExpression":
            case "TSSatisfiesExpression":
            case "TSTypeAssertion":
            case "TSEnumBody":
            case "TSEnumDeclaration":
            case "TSEnumMember":
            case "TSModuleDeclaration":
            case "TSModuleBlock":
            case "TSImportType":
            case "TSImportEqualsDeclaration":
            case "TSExternalModuleReference":
            case "TSNonNullExpression":
            case "TSExportAssignment":
            case "TSNamespaceExportDeclaration":
            case "TSTypeAnnotation":
            case "TSTypeParameterInstantiation":
            case "TSTypeParameterDeclaration":
            case "TSTypeParameter":
              break;
            default:
              return false;
          }
          return null == t3 || (0, n.default)(e3, t3);
        }, t2.isTypeofTypeAnnotation = function(e3, t3) {
          return !!e3 && ("TypeofTypeAnnotation" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isUnaryExpression = function(e3, t3) {
          return !!e3 && ("UnaryExpression" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isUnaryLike = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "UnaryExpression":
            case "SpreadElement":
              break;
            default:
              return false;
          }
          return null == t3 || (0, n.default)(e3, t3);
        }, t2.isUnionTypeAnnotation = function(e3, t3) {
          return !!e3 && ("UnionTypeAnnotation" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isUpdateExpression = function(e3, t3) {
          return !!e3 && ("UpdateExpression" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isUserWhitespacable = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "ObjectMethod":
            case "ObjectProperty":
            case "ObjectTypeInternalSlot":
            case "ObjectTypeCallProperty":
            case "ObjectTypeIndexer":
            case "ObjectTypeProperty":
            case "ObjectTypeSpreadProperty":
              break;
            default:
              return false;
          }
          return null == t3 || (0, n.default)(e3, t3);
        }, t2.isV8IntrinsicIdentifier = function(e3, t3) {
          return !!e3 && ("V8IntrinsicIdentifier" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isVariableDeclaration = function(e3, t3) {
          return !!e3 && ("VariableDeclaration" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isVariableDeclarator = function(e3, t3) {
          return !!e3 && ("VariableDeclarator" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isVariance = function(e3, t3) {
          return !!e3 && ("Variance" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isVoidPattern = function(e3, t3) {
          return !!e3 && ("VoidPattern" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isVoidTypeAnnotation = function(e3, t3) {
          return !!e3 && ("VoidTypeAnnotation" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isWhile = function(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "DoWhileStatement":
            case "WhileStatement":
              break;
            default:
              return false;
          }
          return null == t3 || (0, n.default)(e3, t3);
        }, t2.isWhileStatement = function(e3, t3) {
          return !!e3 && ("WhileStatement" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isWithStatement = function(e3, t3) {
          return !!e3 && ("WithStatement" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        }, t2.isYieldExpression = function(e3, t3) {
          return !!e3 && ("YieldExpression" === e3.type && (null == t3 || (0, n.default)(e3, t3)));
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/utils/shallowEqual.js"), s = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/utils/deprecationWarning.js");
        function isImportOrExportDeclaration(e3, t3) {
          if (!e3) return false;
          switch (e3.type) {
            case "ExportAllDeclaration":
            case "ExportDefaultDeclaration":
            case "ExportNamedDeclaration":
            case "ImportDeclaration":
              break;
            default:
              return false;
          }
          return null == t3 || (0, n.default)(e3, t3);
        }
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/is.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3) {
          if (!t3) return false;
          if (!(0, s.default)(t3.type, e3)) return !r3 && "Placeholder" === t3.type && e3 in o.FLIPPED_ALIAS_KEYS && (0, i.default)(t3.expectedNode, e3);
          return void 0 === r3 || (0, n.default)(t3, r3);
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/utils/shallowEqual.js"), s = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/isType.js"), i = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/isPlaceholderType.js"), o = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/definitions/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/isBinding.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3) {
          if (r3 && "Identifier" === e3.type && "ObjectProperty" === t3.type && "ObjectExpression" === r3.type) return false;
          const s = n.default.keys[t3.type];
          if (s) for (let r4 = 0; r4 < s.length; r4++) {
            const n2 = t3[s[r4]];
            if (Array.isArray(n2)) {
              if (n2.includes(e3)) return true;
            } else if (n2 === e3) return true;
          }
          return false;
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js");
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/isBlockScoped.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
          return (0, n.isFunctionDeclaration)(e3) || (0, n.isClassDeclaration)(e3) || (0, s.default)(e3);
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/generated/index.js"), s = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/isLet.js");
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/isImmutable.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
          if ((0, n.default)(e3.type, "Immutable")) return true;
          if ((0, s.isIdentifier)(e3)) return "undefined" === e3.name;
          return false;
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/isType.js"), s = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/generated/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/isLet.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
          return (0, n.isVariableDeclaration)(e3) && ("var" !== e3.kind || e3[s]);
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/generated/index.js"), s = /* @__PURE__ */ Symbol.for("var used to be block scoped");
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/isNode.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
          return !(!e3 || !n.VISITOR_KEYS[e3.type]);
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/definitions/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/isNodesEquivalent.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function isNodesEquivalent(e3, t3) {
          if ("object" != typeof e3 || "object" != typeof t3 || null == e3 || null == t3) return e3 === t3;
          if (e3.type !== t3.type) return false;
          const r3 = Object.keys(n.NODE_FIELDS[e3.type] || e3.type), s = n.VISITOR_KEYS[e3.type];
          for (const n2 of r3) {
            const r4 = e3[n2], i = t3[n2];
            if (typeof r4 != typeof i) return false;
            if (null != r4 || null != i) {
              if (null == r4 || null == i) return false;
              if (Array.isArray(r4)) {
                if (!Array.isArray(i)) return false;
                if (r4.length !== i.length) return false;
                for (let e4 = 0; e4 < r4.length; e4++) if (!isNodesEquivalent(r4[e4], i[e4])) return false;
              } else if ("object" != typeof r4 || null != s && s.includes(n2)) {
                if (!isNodesEquivalent(r4, i)) return false;
              } else for (const e4 of Object.keys(r4)) if (r4[e4] !== i[e4]) return false;
            }
          }
          return true;
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/definitions/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/isPlaceholderType.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
          if (e3 === t3) return true;
          const r3 = n.PLACEHOLDERS_ALIAS[e3];
          return !(null == r3 || !r3.includes(t3));
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/definitions/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/isReferenced.js": function(e2, t2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r2) {
          switch (t3.type) {
            case "MemberExpression":
            case "OptionalMemberExpression":
              return t3.property === e3 ? !!t3.computed : t3.object === e3;
            case "JSXMemberExpression":
              return t3.object === e3;
            case "VariableDeclarator":
              return t3.init === e3;
            case "ArrowFunctionExpression":
              return t3.body === e3;
            case "PrivateName":
            case "LabeledStatement":
            case "CatchClause":
            case "RestElement":
            case "BreakStatement":
            case "ContinueStatement":
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ExportNamespaceSpecifier":
            case "ExportDefaultSpecifier":
            case "ImportDefaultSpecifier":
            case "ImportNamespaceSpecifier":
            case "ImportSpecifier":
            case "ImportAttribute":
            case "JSXAttribute":
            case "ObjectPattern":
            case "ArrayPattern":
            case "MetaProperty":
              return false;
            case "ClassMethod":
            case "ClassPrivateMethod":
            case "ObjectMethod":
              return t3.key === e3 && !!t3.computed;
            case "ObjectProperty":
              return t3.key === e3 ? !!t3.computed : !r2 || "ObjectPattern" !== r2.type;
            case "ClassProperty":
            case "ClassAccessorProperty":
            case "TSPropertySignature":
              return t3.key !== e3 || !!t3.computed;
            case "ClassPrivateProperty":
            case "ObjectTypeProperty":
              return t3.key !== e3;
            case "ClassDeclaration":
            case "ClassExpression":
              return t3.superClass === e3;
            case "AssignmentExpression":
            case "AssignmentPattern":
              return t3.right === e3;
            case "ExportSpecifier":
              return (null == r2 || !r2.source) && t3.local === e3;
            case "TSEnumMember":
              return t3.id !== e3;
          }
          return true;
        };
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/isScope.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
          if ((0, n.isBlockStatement)(e3) && ((0, n.isFunction)(t3) || (0, n.isCatchClause)(t3))) return false;
          if ((0, n.isPattern)(e3) && ((0, n.isFunction)(t3) || (0, n.isCatchClause)(t3))) return true;
          return (0, n.isScopable)(e3);
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/generated/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/isSpecifierDefault.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
          return (0, n.isImportDefaultSpecifier)(e3) || (0, n.isIdentifier)(e3.imported || e3.exported, { name: "default" });
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/generated/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/isType.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
          if (e3 === t3) return true;
          if (null == e3) return false;
          if (n.ALIAS_KEYS[t3]) return false;
          const r3 = n.FLIPPED_ALIAS_KEYS[t3];
          return !(null == r3 || !r3.includes(e3));
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/definitions/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/isValidES3Identifier.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
          return (0, n.default)(e3) && !s.has(e3);
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/isValidIdentifier.js");
        const s = /* @__PURE__ */ new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile"]);
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/isValidIdentifier.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3 = true) {
          if ("string" != typeof e3) return false;
          if (t3 && ((0, n.isKeyword)(e3) || (0, n.isStrictReservedWord)(e3, true))) return false;
          return (0, n.isIdentifierName)(e3);
        };
        var n = r2("./node_modules/.pnpm/@babel+helper-validator-identifier@7.27.1/node_modules/@babel/helper-validator-identifier/lib/index.js");
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/isVar.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
          return (0, n.isVariableDeclaration)(e3, { kind: "var" }) && !e3[s];
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/generated/index.js"), s = /* @__PURE__ */ Symbol.for("var used to be block scoped");
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/matchesPattern.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3) {
          if (!isMemberExpressionLike(e3)) return false;
          const s = Array.isArray(t3) ? t3 : t3.split("."), i = [];
          let o;
          for (o = e3; isMemberExpressionLike(o); o = null != (a = o.object) ? a : o.meta) {
            var a;
            i.push(o.property);
          }
          if (i.push(o), i.length < s.length) return false;
          if (!r3 && i.length > s.length) return false;
          for (let e4 = 0, t4 = i.length - 1; e4 < s.length; e4++, t4--) {
            const r4 = i[t4];
            let o2;
            if ((0, n.isIdentifier)(r4)) o2 = r4.name;
            else if ((0, n.isStringLiteral)(r4)) o2 = r4.value;
            else if ((0, n.isThisExpression)(r4)) o2 = "this";
            else if ((0, n.isSuper)(r4)) o2 = "super";
            else {
              if (!(0, n.isPrivateName)(r4)) return false;
              o2 = "#" + r4.id.name;
            }
            if (s[e4] !== o2) return false;
          }
          return true;
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/generated/index.js");
        function isMemberExpressionLike(e3) {
          return (0, n.isMemberExpression)(e3) || (0, n.isMetaProperty)(e3);
        }
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/react/isCompatTag.js": function(e2, t2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
          return !!e3 && /^[a-z]/.test(e3);
        };
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/react/isReactComponent.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
        const n = (0, r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js").default)("React.Component");
        t2.default = n;
      }, "./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/validators/validate.js": function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3) {
          if (!e3) return;
          const s = n.NODE_FIELDS[e3.type];
          if (!s) return;
          const i = s[t3];
          validateField(e3, t3, r3, i), validateChild(e3, t3, r3);
        }, t2.validateChild = validateChild, t2.validateField = validateField, t2.validateInternal = function(e3, t3, r3, s, i) {
          if (null == e3 || !e3.validate) return;
          if (e3.optional && null == s) return;
          if (e3.validate(t3, r3, s), i) {
            var o;
            const e4 = s.type;
            if (null == e4) return;
            null == (o = n.NODE_PARENT_VALIDATIONS[e4]) || o.call(n.NODE_PARENT_VALIDATIONS, t3, r3, s);
          }
        };
        var n = r2("./node_modules/.pnpm/@babel+types@7.28.4/node_modules/@babel/types/lib/definitions/index.js");
        function validateField(e3, t3, r3, n2) {
          null != n2 && n2.validate && (n2.optional && null == r3 || n2.validate(e3, t3, r3));
        }
        function validateChild(e3, t3, r3) {
          var s;
          const i = null == r3 ? void 0 : r3.type;
          null != i && (null == (s = n.NODE_PARENT_VALIDATIONS[i]) || s.call(n.NODE_PARENT_VALIDATIONS, e3, t3, r3));
        }
      }, "./node_modules/.pnpm/json5@2.2.3/node_modules/json5/dist/index.mjs": function(e2, t2, r2) {
        "use strict";
        r2.r(t2), r2.d(t2, { default: () => T });
        var n = { Space_Separator: /[\u1680\u2000-\u200A\u202F\u205F\u3000]/, ID_Start: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/, ID_Continue: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/ }, s = { isSpaceSeparator: (e3) => "string" == typeof e3 && n.Space_Separator.test(e3), isIdStartChar: (e3) => "string" == typeof e3 && (e3 >= "a" && e3 <= "z" || e3 >= "A" && e3 <= "Z" || "$" === e3 || "_" === e3 || n.ID_Start.test(e3)), isIdContinueChar: (e3) => "string" == typeof e3 && (e3 >= "a" && e3 <= "z" || e3 >= "A" && e3 <= "Z" || e3 >= "0" && e3 <= "9" || "$" === e3 || "_" === e3 || "\u200C" === e3 || "\u200D" === e3 || n.ID_Continue.test(e3)), isDigit: (e3) => "string" == typeof e3 && /[0-9]/.test(e3), isHexDigit: (e3) => "string" == typeof e3 && /[0-9A-Fa-f]/.test(e3) };
        let i, o, a, l, p, c, u, d, h;
        function internalize(e3, t3, r3) {
          const n2 = e3[t3];
          if (null != n2 && "object" == typeof n2) if (Array.isArray(n2)) for (let e4 = 0; e4 < n2.length; e4++) {
            const t4 = String(e4), s2 = internalize(n2, t4, r3);
            void 0 === s2 ? delete n2[t4] : Object.defineProperty(n2, t4, { value: s2, writable: true, enumerable: true, configurable: true });
          }
          else for (const e4 in n2) {
            const t4 = internalize(n2, e4, r3);
            void 0 === t4 ? delete n2[e4] : Object.defineProperty(n2, e4, { value: t4, writable: true, enumerable: true, configurable: true });
          }
          return r3.call(e3, t3, n2);
        }
        let m, f, y, b, g;
        function lex() {
          for (m = "default", f = "", y = false, b = 1; ; ) {
            g = peek();
            const e3 = x[m]();
            if (e3) return e3;
          }
        }
        function peek() {
          if (i[l]) return String.fromCodePoint(i.codePointAt(l));
        }
        function read() {
          const e3 = peek();
          return "\n" === e3 ? (p++, c = 0) : e3 ? c += e3.length : c++, e3 && (l += e3.length), e3;
        }
        const x = { default() {
          switch (g) {
            case "	":
            case "\v":
            case "\f":
            case " ":
            case "\xA0":
            case "\uFEFF":
            case "\n":
            case "\r":
            case "\u2028":
            case "\u2029":
              return void read();
            case "/":
              return read(), void (m = "comment");
            case void 0:
              return read(), newToken("eof");
          }
          if (!s.isSpaceSeparator(g)) return x[o]();
          read();
        }, comment() {
          switch (g) {
            case "*":
              return read(), void (m = "multiLineComment");
            case "/":
              return read(), void (m = "singleLineComment");
          }
          throw invalidChar(read());
        }, multiLineComment() {
          switch (g) {
            case "*":
              return read(), void (m = "multiLineCommentAsterisk");
            case void 0:
              throw invalidChar(read());
          }
          read();
        }, multiLineCommentAsterisk() {
          switch (g) {
            case "*":
              return void read();
            case "/":
              return read(), void (m = "default");
            case void 0:
              throw invalidChar(read());
          }
          read(), m = "multiLineComment";
        }, singleLineComment() {
          switch (g) {
            case "\n":
            case "\r":
            case "\u2028":
            case "\u2029":
              return read(), void (m = "default");
            case void 0:
              return read(), newToken("eof");
          }
          read();
        }, value() {
          switch (g) {
            case "{":
            case "[":
              return newToken("punctuator", read());
            case "n":
              return read(), literal("ull"), newToken("null", null);
            case "t":
              return read(), literal("rue"), newToken("boolean", true);
            case "f":
              return read(), literal("alse"), newToken("boolean", false);
            case "-":
            case "+":
              return "-" === read() && (b = -1), void (m = "sign");
            case ".":
              return f = read(), void (m = "decimalPointLeading");
            case "0":
              return f = read(), void (m = "zero");
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
              return f = read(), void (m = "decimalInteger");
            case "I":
              return read(), literal("nfinity"), newToken("numeric", 1 / 0);
            case "N":
              return read(), literal("aN"), newToken("numeric", NaN);
            case '"':
            case "'":
              return y = '"' === read(), f = "", void (m = "string");
          }
          throw invalidChar(read());
        }, identifierNameStartEscape() {
          if ("u" !== g) throw invalidChar(read());
          read();
          const e3 = unicodeEscape();
          switch (e3) {
            case "$":
            case "_":
              break;
            default:
              if (!s.isIdStartChar(e3)) throw invalidIdentifier();
          }
          f += e3, m = "identifierName";
        }, identifierName() {
          switch (g) {
            case "$":
            case "_":
            case "\u200C":
            case "\u200D":
              return void (f += read());
            case "\\":
              return read(), void (m = "identifierNameEscape");
          }
          if (!s.isIdContinueChar(g)) return newToken("identifier", f);
          f += read();
        }, identifierNameEscape() {
          if ("u" !== g) throw invalidChar(read());
          read();
          const e3 = unicodeEscape();
          switch (e3) {
            case "$":
            case "_":
            case "\u200C":
            case "\u200D":
              break;
            default:
              if (!s.isIdContinueChar(e3)) throw invalidIdentifier();
          }
          f += e3, m = "identifierName";
        }, sign() {
          switch (g) {
            case ".":
              return f = read(), void (m = "decimalPointLeading");
            case "0":
              return f = read(), void (m = "zero");
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
              return f = read(), void (m = "decimalInteger");
            case "I":
              return read(), literal("nfinity"), newToken("numeric", b * (1 / 0));
            case "N":
              return read(), literal("aN"), newToken("numeric", NaN);
          }
          throw invalidChar(read());
        }, zero() {
          switch (g) {
            case ".":
              return f += read(), void (m = "decimalPoint");
            case "e":
            case "E":
              return f += read(), void (m = "decimalExponent");
            case "x":
            case "X":
              return f += read(), void (m = "hexadecimal");
          }
          return newToken("numeric", 0 * b);
        }, decimalInteger() {
          switch (g) {
            case ".":
              return f += read(), void (m = "decimalPoint");
            case "e":
            case "E":
              return f += read(), void (m = "decimalExponent");
          }
          if (!s.isDigit(g)) return newToken("numeric", b * Number(f));
          f += read();
        }, decimalPointLeading() {
          if (s.isDigit(g)) return f += read(), void (m = "decimalFraction");
          throw invalidChar(read());
        }, decimalPoint() {
          switch (g) {
            case "e":
            case "E":
              return f += read(), void (m = "decimalExponent");
          }
          return s.isDigit(g) ? (f += read(), void (m = "decimalFraction")) : newToken("numeric", b * Number(f));
        }, decimalFraction() {
          switch (g) {
            case "e":
            case "E":
              return f += read(), void (m = "decimalExponent");
          }
          if (!s.isDigit(g)) return newToken("numeric", b * Number(f));
          f += read();
        }, decimalExponent() {
          switch (g) {
            case "+":
            case "-":
              return f += read(), void (m = "decimalExponentSign");
          }
          if (s.isDigit(g)) return f += read(), void (m = "decimalExponentInteger");
          throw invalidChar(read());
        }, decimalExponentSign() {
          if (s.isDigit(g)) return f += read(), void (m = "decimalExponentInteger");
          throw invalidChar(read());
        }, decimalExponentInteger() {
          if (!s.isDigit(g)) return newToken("numeric", b * Number(f));
          f += read();
        }, hexadecimal() {
          if (s.isHexDigit(g)) return f += read(), void (m = "hexadecimalInteger");
          throw invalidChar(read());
        }, hexadecimalInteger() {
          if (!s.isHexDigit(g)) return newToken("numeric", b * Number(f));
          f += read();
        }, string() {
          switch (g) {
            case "\\":
              return read(), void (f += (function() {
                switch (peek()) {
                  case "b":
                    return read(), "\b";
                  case "f":
                    return read(), "\f";
                  case "n":
                    return read(), "\n";
                  case "r":
                    return read(), "\r";
                  case "t":
                    return read(), "	";
                  case "v":
                    return read(), "\v";
                  case "0":
                    if (read(), s.isDigit(peek())) throw invalidChar(read());
                    return "\0";
                  case "x":
                    return read(), (function() {
                      let e3 = "", t3 = peek();
                      if (!s.isHexDigit(t3)) throw invalidChar(read());
                      if (e3 += read(), t3 = peek(), !s.isHexDigit(t3)) throw invalidChar(read());
                      return e3 += read(), String.fromCodePoint(parseInt(e3, 16));
                    })();
                  case "u":
                    return read(), unicodeEscape();
                  case "\n":
                  case "\u2028":
                  case "\u2029":
                    return read(), "";
                  case "\r":
                    return read(), "\n" === peek() && read(), "";
                  case "1":
                  case "2":
                  case "3":
                  case "4":
                  case "5":
                  case "6":
                  case "7":
                  case "8":
                  case "9":
                  case void 0:
                    throw invalidChar(read());
                }
                return read();
              })());
            case '"':
              return y ? (read(), newToken("string", f)) : void (f += read());
            case "'":
              return y ? void (f += read()) : (read(), newToken("string", f));
            case "\n":
            case "\r":
              throw invalidChar(read());
            case "\u2028":
            case "\u2029":
              !(function(e3) {
                console.warn(`JSON5: '${formatChar(e3)}' in strings is not valid ECMAScript; consider escaping`);
              })(g);
              break;
            case void 0:
              throw invalidChar(read());
          }
          f += read();
        }, start() {
          switch (g) {
            case "{":
            case "[":
              return newToken("punctuator", read());
          }
          m = "value";
        }, beforePropertyName() {
          switch (g) {
            case "$":
            case "_":
              return f = read(), void (m = "identifierName");
            case "\\":
              return read(), void (m = "identifierNameStartEscape");
            case "}":
              return newToken("punctuator", read());
            case '"':
            case "'":
              return y = '"' === read(), void (m = "string");
          }
          if (s.isIdStartChar(g)) return f += read(), void (m = "identifierName");
          throw invalidChar(read());
        }, afterPropertyName() {
          if (":" === g) return newToken("punctuator", read());
          throw invalidChar(read());
        }, beforePropertyValue() {
          m = "value";
        }, afterPropertyValue() {
          switch (g) {
            case ",":
            case "}":
              return newToken("punctuator", read());
          }
          throw invalidChar(read());
        }, beforeArrayValue() {
          if ("]" === g) return newToken("punctuator", read());
          m = "value";
        }, afterArrayValue() {
          switch (g) {
            case ",":
            case "]":
              return newToken("punctuator", read());
          }
          throw invalidChar(read());
        }, end() {
          throw invalidChar(read());
        } };
        function newToken(e3, t3) {
          return { type: e3, value: t3, line: p, column: c };
        }
        function literal(e3) {
          for (const t3 of e3) {
            if (peek() !== t3) throw invalidChar(read());
            read();
          }
        }
        function unicodeEscape() {
          let e3 = "", t3 = 4;
          for (; t3-- > 0; ) {
            const t4 = peek();
            if (!s.isHexDigit(t4)) throw invalidChar(read());
            e3 += read();
          }
          return String.fromCodePoint(parseInt(e3, 16));
        }
        const v = { start() {
          if ("eof" === u.type) throw invalidEOF();
          push();
        }, beforePropertyName() {
          switch (u.type) {
            case "identifier":
            case "string":
              return d = u.value, void (o = "afterPropertyName");
            case "punctuator":
              return void pop();
            case "eof":
              throw invalidEOF();
          }
        }, afterPropertyName() {
          if ("eof" === u.type) throw invalidEOF();
          o = "beforePropertyValue";
        }, beforePropertyValue() {
          if ("eof" === u.type) throw invalidEOF();
          push();
        }, beforeArrayValue() {
          if ("eof" === u.type) throw invalidEOF();
          "punctuator" !== u.type || "]" !== u.value ? push() : pop();
        }, afterPropertyValue() {
          if ("eof" === u.type) throw invalidEOF();
          switch (u.value) {
            case ",":
              return void (o = "beforePropertyName");
            case "}":
              pop();
          }
        }, afterArrayValue() {
          if ("eof" === u.type) throw invalidEOF();
          switch (u.value) {
            case ",":
              return void (o = "beforeArrayValue");
            case "]":
              pop();
          }
        }, end() {
        } };
        function push() {
          let e3;
          switch (u.type) {
            case "punctuator":
              switch (u.value) {
                case "{":
                  e3 = {};
                  break;
                case "[":
                  e3 = [];
              }
              break;
            case "null":
            case "boolean":
            case "numeric":
            case "string":
              e3 = u.value;
          }
          if (void 0 === h) h = e3;
          else {
            const t3 = a[a.length - 1];
            Array.isArray(t3) ? t3.push(e3) : Object.defineProperty(t3, d, { value: e3, writable: true, enumerable: true, configurable: true });
          }
          if (null !== e3 && "object" == typeof e3) a.push(e3), o = Array.isArray(e3) ? "beforeArrayValue" : "beforePropertyName";
          else {
            const e4 = a[a.length - 1];
            o = null == e4 ? "end" : Array.isArray(e4) ? "afterArrayValue" : "afterPropertyValue";
          }
        }
        function pop() {
          a.pop();
          const e3 = a[a.length - 1];
          o = null == e3 ? "end" : Array.isArray(e3) ? "afterArrayValue" : "afterPropertyValue";
        }
        function invalidChar(e3) {
          return syntaxError(void 0 === e3 ? `JSON5: invalid end of input at ${p}:${c}` : `JSON5: invalid character '${formatChar(e3)}' at ${p}:${c}`);
        }
        function invalidEOF() {
          return syntaxError(`JSON5: invalid end of input at ${p}:${c}`);
        }
        function invalidIdentifier() {
          return c -= 5, syntaxError(`JSON5: invalid identifier character at ${p}:${c}`);
        }
        function formatChar(e3) {
          const t3 = { "'": "\\'", '"': '\\"', "\\": "\\\\", "\b": "\\b", "\f": "\\f", "\n": "\\n", "\r": "\\r", "	": "\\t", "\v": "\\v", "\0": "\\0", "\u2028": "\\u2028", "\u2029": "\\u2029" };
          if (t3[e3]) return t3[e3];
          if (e3 < " ") {
            const t4 = e3.charCodeAt(0).toString(16);
            return "\\x" + ("00" + t4).substring(t4.length);
          }
          return e3;
        }
        function syntaxError(e3) {
          const t3 = new SyntaxError(e3);
          return t3.lineNumber = p, t3.columnNumber = c, t3;
        }
        const E = { parse: function(e3, t3) {
          i = String(e3), o = "start", a = [], l = 0, p = 1, c = 0, u = void 0, d = void 0, h = void 0;
          do {
            u = lex(), v[o]();
          } while ("eof" !== u.type);
          return "function" == typeof t3 ? internalize({ "": h }, "", t3) : h;
        }, stringify: function(e3, t3, r3) {
          const n2 = [];
          let i2, o2, a2, l2 = "", p2 = "";
          if (null == t3 || "object" != typeof t3 || Array.isArray(t3) || (r3 = t3.space, a2 = t3.quote, t3 = t3.replacer), "function" == typeof t3) o2 = t3;
          else if (Array.isArray(t3)) {
            i2 = [];
            for (const e4 of t3) {
              let t4;
              "string" == typeof e4 ? t4 = e4 : ("number" == typeof e4 || e4 instanceof String || e4 instanceof Number) && (t4 = String(e4)), void 0 !== t4 && i2.indexOf(t4) < 0 && i2.push(t4);
            }
          }
          return r3 instanceof Number ? r3 = Number(r3) : r3 instanceof String && (r3 = String(r3)), "number" == typeof r3 ? r3 > 0 && (r3 = Math.min(10, Math.floor(r3)), p2 = "          ".substr(0, r3)) : "string" == typeof r3 && (p2 = r3.substr(0, 10)), serializeProperty("", { "": e3 });
          function serializeProperty(e4, t4) {
            let r4 = t4[e4];
            switch (null != r4 && ("function" == typeof r4.toJSON5 ? r4 = r4.toJSON5(e4) : "function" == typeof r4.toJSON && (r4 = r4.toJSON(e4))), o2 && (r4 = o2.call(t4, e4, r4)), r4 instanceof Number ? r4 = Number(r4) : r4 instanceof String ? r4 = String(r4) : r4 instanceof Boolean && (r4 = r4.valueOf()), r4) {
              case null:
                return "null";
              case true:
                return "true";
              case false:
                return "false";
            }
            return "string" == typeof r4 ? quoteString(r4) : "number" == typeof r4 ? String(r4) : "object" == typeof r4 ? Array.isArray(r4) ? (function(e5) {
              if (n2.indexOf(e5) >= 0) throw TypeError("Converting circular structure to JSON5");
              n2.push(e5);
              let t5 = l2;
              l2 += p2;
              let r5, s2 = [];
              for (let t6 = 0; t6 < e5.length; t6++) {
                const r6 = serializeProperty(String(t6), e5);
                s2.push(void 0 !== r6 ? r6 : "null");
              }
              if (0 === s2.length) r5 = "[]";
              else if ("" === p2) {
                r5 = "[" + s2.join(",") + "]";
              } else {
                let e6 = ",\n" + l2, n3 = s2.join(e6);
                r5 = "[\n" + l2 + n3 + ",\n" + t5 + "]";
              }
              return n2.pop(), l2 = t5, r5;
            })(r4) : (function(e5) {
              if (n2.indexOf(e5) >= 0) throw TypeError("Converting circular structure to JSON5");
              n2.push(e5);
              let t5 = l2;
              l2 += p2;
              let r5, s2 = i2 || Object.keys(e5), o3 = [];
              for (const t6 of s2) {
                const r6 = serializeProperty(t6, e5);
                if (void 0 !== r6) {
                  let e6 = serializeKey(t6) + ":";
                  "" !== p2 && (e6 += " "), e6 += r6, o3.push(e6);
                }
              }
              if (0 === o3.length) r5 = "{}";
              else {
                let e6;
                if ("" === p2) e6 = o3.join(","), r5 = "{" + e6 + "}";
                else {
                  let n3 = ",\n" + l2;
                  e6 = o3.join(n3), r5 = "{\n" + l2 + e6 + ",\n" + t5 + "}";
                }
              }
              return n2.pop(), l2 = t5, r5;
            })(r4) : void 0;
          }
          function quoteString(e4) {
            const t4 = { "'": 0.1, '"': 0.2 }, r4 = { "'": "\\'", '"': '\\"', "\\": "\\\\", "\b": "\\b", "\f": "\\f", "\n": "\\n", "\r": "\\r", "	": "\\t", "\v": "\\v", "\0": "\\0", "\u2028": "\\u2028", "\u2029": "\\u2029" };
            let n3 = "";
            for (let i4 = 0; i4 < e4.length; i4++) {
              const o3 = e4[i4];
              switch (o3) {
                case "'":
                case '"':
                  t4[o3]++, n3 += o3;
                  continue;
                case "\0":
                  if (s.isDigit(e4[i4 + 1])) {
                    n3 += "\\x00";
                    continue;
                  }
              }
              if (r4[o3]) n3 += r4[o3];
              else {
                if (o3 < " ") {
                  let e5 = o3.charCodeAt(0).toString(16);
                  n3 += "\\x" + ("00" + e5).substring(e5.length);
                  continue;
                }
                n3 += o3;
              }
            }
            const i3 = a2 || Object.keys(t4).reduce((e5, r5) => t4[e5] < t4[r5] ? e5 : r5);
            return n3 = n3.replace(new RegExp(i3, "g"), r4[i3]), i3 + n3 + i3;
          }
          function serializeKey(e4) {
            if (0 === e4.length) return quoteString(e4);
            const t4 = String.fromCodePoint(e4.codePointAt(0));
            if (!s.isIdStartChar(t4)) return quoteString(e4);
            for (let r4 = t4.length; r4 < e4.length; r4++) if (!s.isIdContinueChar(String.fromCodePoint(e4.codePointAt(r4)))) return quoteString(e4);
            return e4;
          }
        } };
        const T = E;
      }, "./stubs/babel-codeframe.mjs": function(e2, t2, r2) {
        "use strict";
        function codeFrameColumns() {
          return "";
        }
        r2.r(t2), r2.d(t2, { codeFrameColumns: () => codeFrameColumns });
      }, "./stubs/helper-compilation-targets.mjs": function(e2, t2, r2) {
        "use strict";
        function getTargets() {
          return {};
        }
        r2.r(t2), r2.d(t2, { default: () => getTargets });
      }, "./node_modules/.pnpm/@babel+helper-globals@7.28.0/node_modules/@babel/helper-globals/data/builtin-lower.json": function(e2) {
        "use strict";
        e2.exports = JSON.parse('["decodeURI","decodeURIComponent","encodeURI","encodeURIComponent","escape","eval","globalThis","isFinite","isNaN","parseFloat","parseInt","undefined","unescape"]');
      }, "./node_modules/.pnpm/@babel+helper-globals@7.28.0/node_modules/@babel/helper-globals/data/builtin-upper.json": function(e2) {
        "use strict";
        e2.exports = JSON.parse('["AggregateError","Array","ArrayBuffer","Atomics","BigInt","BigInt64Array","BigUint64Array","Boolean","DataView","Date","Error","EvalError","FinalizationRegistry","Float16Array","Float32Array","Float64Array","Function","Infinity","Int16Array","Int32Array","Int8Array","Intl","Iterator","JSON","Map","Math","NaN","Number","Object","Promise","Proxy","RangeError","ReferenceError","Reflect","RegExp","Set","SharedArrayBuffer","String","Symbol","SyntaxError","TypeError","Uint16Array","Uint32Array","Uint8Array","Uint8ClampedArray","URIError","WeakMap","WeakRef","WeakSet"]');
      }, "./node_modules/.pnpm/@babel+preset-typescript@7.27.1_@babel+core@7.28.4/node_modules/@babel/preset-typescript/package.json": function(e2) {
        "use strict";
        e2.exports = JSON.parse('{"name":"@babel/preset-typescript","version":"7.27.1","description":"Babel preset for TypeScript.","repository":{"type":"git","url":"https://github.com/babel/babel.git","directory":"packages/babel-preset-typescript"},"license":"MIT","publishConfig":{"access":"public"},"main":"./lib/index.js","keywords":["babel-preset","typescript"],"dependencies":{"@babel/helper-plugin-utils":"^7.27.1","@babel/helper-validator-option":"^7.27.1","@babel/plugin-syntax-jsx":"^7.27.1","@babel/plugin-transform-modules-commonjs":"^7.27.1","@babel/plugin-transform-typescript":"^7.27.1"},"peerDependencies":{"@babel/core":"^7.0.0-0"},"devDependencies":{"@babel/core":"^7.27.1","@babel/helper-plugin-test-runner":"^7.27.1"},"homepage":"https://babel.dev/docs/en/next/babel-preset-typescript","bugs":"https://github.com/babel/babel/issues?utf8=%E2%9C%93&q=is%3Aissue+label%3A%22area%3A%20typescript%22+is%3Aopen","engines":{"node":">=6.9.0"},"author":"The Babel Team (https://babel.dev/team)","type":"commonjs"}');
      } }, t = {};
      function __webpack_require__(r2) {
        var n = t[r2];
        if (void 0 !== n) return n.exports;
        var s = t[r2] = { id: r2, loaded: false, exports: {} };
        return e[r2].call(s.exports, s, s.exports, __webpack_require__), s.loaded = true, s.exports;
      }
      __webpack_require__.n = (e2) => {
        var t2 = e2 && e2.__esModule ? () => e2.default : () => e2;
        return __webpack_require__.d(t2, { a: t2 }), t2;
      }, __webpack_require__.d = (e2, t2) => {
        for (var r2 in t2) __webpack_require__.o(t2, r2) && !__webpack_require__.o(e2, r2) && Object.defineProperty(e2, r2, { enumerable: true, get: t2[r2] });
      }, __webpack_require__.o = (e2, t2) => Object.prototype.hasOwnProperty.call(e2, t2), __webpack_require__.r = (e2) => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e2, "__esModule", { value: true });
      }, __webpack_require__.nmd = (e2) => (e2.paths = [], e2.children || (e2.children = []), e2);
      var r = {};
      (() => {
        "use strict";
        __webpack_require__.d(r, { default: () => transform });
        var e2 = __webpack_require__("./node_modules/.pnpm/@babel+core@7.28.4/node_modules/@babel/core/lib/index.js"), t2 = __webpack_require__("./node_modules/.pnpm/@babel+plugin-proposal-decorators@7.28.0_@babel+core@7.28.4/node_modules/@babel/plugin-proposal-decorators/lib/index.js"), n = __webpack_require__("./node_modules/.pnpm/@babel+plugin-syntax-class-properties@7.12.13_@babel+core@7.28.4/node_modules/@babel/plugin-syntax-class-properties/lib/index.js"), s = __webpack_require__("./node_modules/.pnpm/@babel+plugin-syntax-import-assertions@7.27.1_@babel+core@7.28.4/node_modules/@babel/plugin-syntax-import-assertions/lib/index.js"), i = __webpack_require__("./node_modules/.pnpm/@babel+plugin-syntax-jsx@7.27.1_@babel+core@7.28.4/node_modules/@babel/plugin-syntax-jsx/lib/index.js"), o = __webpack_require__("./node_modules/.pnpm/@babel+plugin-transform-export-namespace-from@7.27.1_@babel+core@7.28.4/node_modules/@babel/plugin-transform-export-namespace-from/lib/index.js"), a = __webpack_require__("./node_modules/.pnpm/@babel+plugin-transform-react-jsx@7.27.1_@babel+core@7.28.4/node_modules/@babel/plugin-transform-react-jsx/lib/index.js"), l = __webpack_require__("./node_modules/.pnpm/@babel+plugin-transform-typescript@7.28.0_@babel+core@7.28.4/node_modules/@babel/plugin-transform-typescript/lib/index.js"), p = __webpack_require__("./node_modules/.pnpm/babel-plugin-parameter-decorator@1.0.16/node_modules/babel-plugin-parameter-decorator/lib/index.js"), c = __webpack_require__.n(p), u = __webpack_require__("./node_modules/.pnpm/@babel+helper-plugin-utils@7.27.1/node_modules/@babel/helper-plugin-utils/lib/index.js");
        function createParamDecorator(t3, r2, n2 = false) {
          return e2.types.decorator(e2.types.functionExpression(null, [e2.types.identifier("target"), e2.types.identifier("key")], e2.types.blockStatement([e2.types.returnStatement(e2.types.callExpression(r2, [e2.types.identifier("target"), e2.types.identifier(n2 ? "undefined" : "key"), e2.types.numericLiteral(t3)]))])));
        }
        function parameterVisitor(e3, t3) {
          if ("ClassMethod" !== t3.type) return;
          if ("ClassMethod" !== t3.node.type) return;
          if ("Identifier" !== t3.node.key.type) return;
          const r2 = t3, n2 = r2.get("params") || [];
          for (const t4 of n2) {
            if (null == ("Identifier" === t4.node.type || "ObjectPattern" === t4.node.type ? t4.node : "TSParameterProperty" === t4.node.type && "Identifier" === t4.node.parameter.type ? t4.node.parameter : null)) continue;
            let n3;
            for (const s2 of t4.node.decorators || []) "constructor" === r2.node.kind ? (n3 = createParamDecorator(t4.key, s2.expression, true), e3.node.decorators || (e3.node.decorators = []), e3.node.decorators.push(n3)) : (n3 = createParamDecorator(t4.key, s2.expression, false), r2.node.decorators || (r2.node.decorators = []), r2.node.decorators.push(n3));
            n3 && (t4.node.decorators = null);
          }
        }
        function createVoidZero() {
          return e2.types.unaryExpression("void", e2.types.numericLiteral(0));
        }
        function getTypedNode(e3) {
          return null == e3 ? null : "ClassProperty" === e3.type || "Identifier" === e3.type || "ObjectPattern" === e3.type ? e3 : "AssignmentPattern" === e3.type && "Identifier" === e3.left.type ? e3.left : "TSParameterProperty" === e3.type ? getTypedNode(e3.parameter) : null;
        }
        function serializeType(e3, t3) {
          const r2 = getTypedNode(t3);
          if (null == r2) return createVoidZero();
          if (!r2.typeAnnotation || "TSTypeAnnotation" !== r2.typeAnnotation.type) return createVoidZero();
          const n2 = r2.typeAnnotation.typeAnnotation;
          return serializeTypeNode(e3.node.id ? e3.node.id.name : "", n2);
        }
        function serializeTypeReferenceNode(t3, r2) {
          const n2 = serializeReference(r2.typeName);
          return isClassType(t3, n2) ? e2.types.identifier("Object") : e2.types.conditionalExpression(e2.types.binaryExpression("===", e2.types.unaryExpression("typeof", n2), e2.types.stringLiteral("undefined")), e2.types.identifier("Object"), e2.types.cloneDeep(n2));
        }
        function isClassType(e3, t3) {
          switch (t3.type) {
            case "Identifier":
              return t3.name === e3;
            case "MemberExpression":
              return isClassType(e3, t3.object);
            default:
              throw new Error(`The property expression at ${t3.start} is not valid as a Type to be used in Reflect.metadata`);
          }
        }
        function serializeReference(t3) {
          return "Identifier" === t3.type ? e2.types.identifier(t3.name) : e2.types.memberExpression(serializeReference(t3.left), t3.right);
        }
        function serializeTypeNode(t3, r2) {
          if (void 0 === r2) return e2.types.identifier("Object");
          switch (r2.type) {
            case "TSVoidKeyword":
            case "TSUndefinedKeyword":
            case "TSNullKeyword":
            case "TSNeverKeyword":
              return createVoidZero();
            case "TSParenthesizedType":
              return serializeTypeNode(t3, r2.typeAnnotation);
            case "TSFunctionType":
            case "TSConstructorType":
              return e2.types.identifier("Function");
            case "TSArrayType":
            case "TSTupleType":
              return e2.types.identifier("Array");
            case "TSTypePredicate":
            case "TSBooleanKeyword":
              return e2.types.identifier("Boolean");
            case "TSStringKeyword":
              return e2.types.identifier("String");
            case "TSObjectKeyword":
              return e2.types.identifier("Object");
            case "TSLiteralType":
              switch (r2.literal.type) {
                case "StringLiteral":
                  return e2.types.identifier("String");
                case "NumericLiteral":
                  return e2.types.identifier("Number");
                case "BooleanLiteral":
                  return e2.types.identifier("Boolean");
                default:
                  throw new Error("Bad type for decorator" + r2.literal);
              }
            case "TSNumberKeyword":
            case "TSBigIntKeyword":
              return e2.types.identifier("Number");
            case "TSSymbolKeyword":
              return e2.types.identifier("Symbol");
            case "TSTypeReference":
              return serializeTypeReferenceNode(t3, r2);
            case "TSIntersectionType":
            case "TSUnionType":
              return serializeTypeList(t3, r2.types);
            case "TSConditionalType":
              return serializeTypeList(t3, [r2.trueType, r2.falseType]);
            case "TSTypeQuery":
            case "TSTypeOperator":
            case "TSIndexedAccessType":
            case "TSMappedType":
            case "TSTypeLiteral":
            case "TSAnyKeyword":
            case "TSUnknownKeyword":
            case "TSThisType":
              break;
            default:
              throw new Error("Bad type for decorator");
          }
          return e2.types.identifier("Object");
        }
        function serializeTypeList(t3, r2) {
          let n2;
          for (let s2 of r2) {
            for (; "TSParenthesizedType" === s2.type; ) s2 = s2.typeAnnotation;
            if ("TSNeverKeyword" === s2.type) continue;
            if ("TSNullKeyword" === s2.type || "TSUndefinedKeyword" === s2.type) continue;
            const r3 = serializeTypeNode(t3, s2);
            if (e2.types.isIdentifier(r3) && "Object" === r3.name) return r3;
            if (n2) {
              if (!e2.types.isIdentifier(n2) || !e2.types.isIdentifier(r3) || n2.name !== r3.name) return e2.types.identifier("Object");
            } else n2 = r3;
          }
          return n2 || createVoidZero();
        }
        function createMetadataDesignDecorator(t3, r2) {
          return e2.types.decorator(e2.types.logicalExpression("||", e2.types.optionalCallExpression(e2.types.memberExpression(e2.types.identifier("Reflect"), e2.types.identifier("metadata")), [e2.types.stringLiteral(t3), r2], true), e2.types.arrowFunctionExpression([e2.types.identifier("t")], e2.types.identifier("t"))));
        }
        function metadataVisitor(t3, r2) {
          const n2 = r2.node, s2 = t3.node;
          switch (n2.type) {
            case "ClassMethod": {
              const r3 = "constructor" === n2.kind ? s2.decorators : n2.decorators;
              if (!r3 || 0 === r3.length) return;
              r3.push(createMetadataDesignDecorator("design:type", e2.types.identifier("Function"))), r3.push(createMetadataDesignDecorator("design:paramtypes", e2.types.arrayExpression(n2.params.map((e3) => serializeType(t3, e3)))));
              break;
            }
            case "ClassProperty":
              if (!n2.decorators || 0 === n2.decorators.length) return;
              if (!n2.typeAnnotation || "TSTypeAnnotation" !== n2.typeAnnotation.type) return;
              n2.decorators.push(createMetadataDesignDecorator("design:type", serializeType(t3, n2)));
          }
        }
        const d = (0, u.declare)((e3) => (e3.assertVersion(7), { visitor: { Program(e4) {
          e4.traverse({ ClassDeclaration(e5) {
            for (const t3 of e5.get("body").get("body")) "ClassMethod" !== t3.type && "ClassProperty" !== t3.type || (parameterVisitor(e5, t3), metadataVisitor(e5, t3));
            e5.parentPath.scope.crawl();
          } });
        } } }));
        function importMetaEnvPlugin({ template: e3, types: t3 }) {
          return { name: "@import-meta-env/babel", visitor: { Identifier(r2) {
            if (!t3.isIdentifier(r2)) return;
            if (!t3.isMemberExpression(r2.parentPath) && !t3.isOptionalMemberExpression(r2.parentPath)) return;
            if (!t3.isMemberExpression(r2.parentPath.node)) return;
            const n2 = r2.parentPath.node;
            if (!t3.isMetaProperty(n2.object)) return;
            const s2 = n2.object;
            "import" === s2.meta.name && "meta" === s2.property.name && "env" === n2.property.name && r2.parentPath.replaceWith(e3.expression.ast("process.env"));
          } } };
        }
        function importMetaResolvePlugin(e3) {
          return { name: "import-meta-resolve", visitor: { Program(e4) {
            const t3 = [];
            if (e4.traverse({ MemberExpression(e5) {
              const { node: r2 } = e5;
              "MetaProperty" === r2.object.type && "import" === r2.object.meta.name && "meta" === r2.object.property.name && "Identifier" === r2.property.type && "resolve" === r2.property.name && t3.push(e5);
            } }), 0 !== t3.length) for (const e5 of t3) e5.replaceWith({ type: "ExpressionStatement", expression: { type: "Identifier", name: "jitiESMResolve" } });
          } } };
        }
        var h = __webpack_require__("./node_modules/.pnpm/@babel+template@7.27.2/node_modules/@babel/template/lib/index.js");
        const m = /^[A-Za-z]:\//;
        function normalizeWindowsPath(e3 = "") {
          return e3 ? e3.replace(/\\/g, "/").replace(m, (e4) => e4.toUpperCase()) : e3;
        }
        const f = /^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Za-z]:[/\\]/, y = /^[A-Za-z]:$/;
        const pathe_M_eThtNZ_isAbsolute = function(e3) {
          return f.test(e3);
        }, pathe_M_eThtNZ_dirname = function(e3) {
          const t3 = normalizeWindowsPath(e3).replace(/\/$/, "").split("/").slice(0, -1);
          return 1 === t3.length && y.test(t3[0]) && (t3[0] += "/"), t3.join("/") || (pathe_M_eThtNZ_isAbsolute(e3) ? "/" : ".");
        };
        var b = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239], g = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], x = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC", v = { 3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile", 5: "class enum extends super const export import", 6: "enum", strict: "implements interface let package private protected public static yield", strictBind: "eval arguments" }, E = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this", T = { 5: E, "5module": E + " export import", 6: E + " const class extends export import super" }, S = /^in(stanceof)?$/, P = new RegExp("[" + x + "]"), _ = new RegExp("[" + x + "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65]");
        function isInAstralSet(e3, t3) {
          for (var r2 = 65536, n2 = 0; n2 < t3.length; n2 += 2) {
            if ((r2 += t3[n2]) > e3) return false;
            if ((r2 += t3[n2 + 1]) >= e3) return true;
          }
          return false;
        }
        function isIdentifierStart(e3, t3) {
          return e3 < 65 ? 36 === e3 : e3 < 91 || (e3 < 97 ? 95 === e3 : e3 < 123 || (e3 <= 65535 ? e3 >= 170 && P.test(String.fromCharCode(e3)) : false !== t3 && isInAstralSet(e3, g)));
        }
        function isIdentifierChar(e3, t3) {
          return e3 < 48 ? 36 === e3 : e3 < 58 || !(e3 < 65) && (e3 < 91 || (e3 < 97 ? 95 === e3 : e3 < 123 || (e3 <= 65535 ? e3 >= 170 && _.test(String.fromCharCode(e3)) : false !== t3 && (isInAstralSet(e3, g) || isInAstralSet(e3, b)))));
        }
        var acorn_TokenType = function(e3, t3) {
          void 0 === t3 && (t3 = {}), this.label = e3, this.keyword = t3.keyword, this.beforeExpr = !!t3.beforeExpr, this.startsExpr = !!t3.startsExpr, this.isLoop = !!t3.isLoop, this.isAssign = !!t3.isAssign, this.prefix = !!t3.prefix, this.postfix = !!t3.postfix, this.binop = t3.binop || null, this.updateContext = null;
        };
        function binop(e3, t3) {
          return new acorn_TokenType(e3, { beforeExpr: true, binop: t3 });
        }
        var A = { beforeExpr: true }, C = { startsExpr: true }, w = {};
        function kw(e3, t3) {
          return void 0 === t3 && (t3 = {}), t3.keyword = e3, w[e3] = new acorn_TokenType(e3, t3);
        }
        var I = { num: new acorn_TokenType("num", C), regexp: new acorn_TokenType("regexp", C), string: new acorn_TokenType("string", C), name: new acorn_TokenType("name", C), privateId: new acorn_TokenType("privateId", C), eof: new acorn_TokenType("eof"), bracketL: new acorn_TokenType("[", { beforeExpr: true, startsExpr: true }), bracketR: new acorn_TokenType("]"), braceL: new acorn_TokenType("{", { beforeExpr: true, startsExpr: true }), braceR: new acorn_TokenType("}"), parenL: new acorn_TokenType("(", { beforeExpr: true, startsExpr: true }), parenR: new acorn_TokenType(")"), comma: new acorn_TokenType(",", A), semi: new acorn_TokenType(";", A), colon: new acorn_TokenType(":", A), dot: new acorn_TokenType("."), question: new acorn_TokenType("?", A), questionDot: new acorn_TokenType("?."), arrow: new acorn_TokenType("=>", A), template: new acorn_TokenType("template"), invalidTemplate: new acorn_TokenType("invalidTemplate"), ellipsis: new acorn_TokenType("...", A), backQuote: new acorn_TokenType("`", C), dollarBraceL: new acorn_TokenType("${", { beforeExpr: true, startsExpr: true }), eq: new acorn_TokenType("=", { beforeExpr: true, isAssign: true }), assign: new acorn_TokenType("_=", { beforeExpr: true, isAssign: true }), incDec: new acorn_TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }), prefix: new acorn_TokenType("!/~", { beforeExpr: true, prefix: true, startsExpr: true }), logicalOR: binop("||", 1), logicalAND: binop("&&", 2), bitwiseOR: binop("|", 3), bitwiseXOR: binop("^", 4), bitwiseAND: binop("&", 5), equality: binop("==/!=/===/!==", 6), relational: binop("</>/<=/>=", 7), bitShift: binop("<</>>/>>>", 8), plusMin: new acorn_TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }), modulo: binop("%", 10), star: binop("*", 10), slash: binop("/", 10), starstar: new acorn_TokenType("**", { beforeExpr: true }), coalesce: binop("??", 1), _break: kw("break"), _case: kw("case", A), _catch: kw("catch"), _continue: kw("continue"), _debugger: kw("debugger"), _default: kw("default", A), _do: kw("do", { isLoop: true, beforeExpr: true }), _else: kw("else", A), _finally: kw("finally"), _for: kw("for", { isLoop: true }), _function: kw("function", C), _if: kw("if"), _return: kw("return", A), _switch: kw("switch"), _throw: kw("throw", A), _try: kw("try"), _var: kw("var"), _const: kw("const"), _while: kw("while", { isLoop: true }), _with: kw("with"), _new: kw("new", { beforeExpr: true, startsExpr: true }), _this: kw("this", C), _super: kw("super", C), _class: kw("class", C), _extends: kw("extends", A), _export: kw("export"), _import: kw("import", C), _null: kw("null", C), _true: kw("true", C), _false: kw("false", C), _in: kw("in", { beforeExpr: true, binop: 7 }), _instanceof: kw("instanceof", { beforeExpr: true, binop: 7 }), _typeof: kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true }), _void: kw("void", { beforeExpr: true, prefix: true, startsExpr: true }), _delete: kw("delete", { beforeExpr: true, prefix: true, startsExpr: true }) }, D = /\r\n?|\n|\u2028|\u2029/, k = new RegExp(D.source, "g");
        function isNewLine(e3) {
          return 10 === e3 || 13 === e3 || 8232 === e3 || 8233 === e3;
        }
        function nextLineBreak(e3, t3, r2) {
          void 0 === r2 && (r2 = e3.length);
          for (var n2 = t3; n2 < r2; n2++) {
            var s2 = e3.charCodeAt(n2);
            if (isNewLine(s2)) return n2 < r2 - 1 && 13 === s2 && 10 === e3.charCodeAt(n2 + 1) ? n2 + 2 : n2 + 1;
          }
          return -1;
        }
        var N = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/, O = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, j = Object.prototype, F = j.hasOwnProperty, L = j.toString, M = Object.hasOwn || function(e3, t3) {
          return F.call(e3, t3);
        }, B = Array.isArray || function(e3) {
          return "[object Array]" === L.call(e3);
        }, R = /* @__PURE__ */ Object.create(null);
        function wordsRegexp(e3) {
          return R[e3] || (R[e3] = new RegExp("^(?:" + e3.replace(/ /g, "|") + ")$"));
        }
        function codePointToString(e3) {
          return e3 <= 65535 ? String.fromCharCode(e3) : (e3 -= 65536, String.fromCharCode(55296 + (e3 >> 10), 56320 + (1023 & e3)));
        }
        var U = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/, acorn_Position = function(e3, t3) {
          this.line = e3, this.column = t3;
        };
        acorn_Position.prototype.offset = function(e3) {
          return new acorn_Position(this.line, this.column + e3);
        };
        var acorn_SourceLocation = function(e3, t3, r2) {
          this.start = t3, this.end = r2, null !== e3.sourceFile && (this.source = e3.sourceFile);
        };
        function getLineInfo(e3, t3) {
          for (var r2 = 1, n2 = 0; ; ) {
            var s2 = nextLineBreak(e3, n2, t3);
            if (s2 < 0) return new acorn_Position(r2, t3 - n2);
            ++r2, n2 = s2;
          }
        }
        var V = { ecmaVersion: null, sourceType: "script", onInsertedSemicolon: null, onTrailingComma: null, allowReserved: null, allowReturnOutsideFunction: false, allowImportExportEverywhere: false, allowAwaitOutsideFunction: null, allowSuperOutsideMethod: null, allowHashBang: false, checkPrivateFields: true, locations: false, onToken: null, onComment: null, ranges: false, program: null, sourceFile: null, directSourceFile: null, preserveParens: false }, $ = false;
        function getOptions(e3) {
          var t3 = {};
          for (var r2 in V) t3[r2] = e3 && M(e3, r2) ? e3[r2] : V[r2];
          if ("latest" === t3.ecmaVersion ? t3.ecmaVersion = 1e8 : null == t3.ecmaVersion ? (!$ && "object" == typeof console && console.warn && ($ = true, console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.")), t3.ecmaVersion = 11) : t3.ecmaVersion >= 2015 && (t3.ecmaVersion -= 2009), null == t3.allowReserved && (t3.allowReserved = t3.ecmaVersion < 5), e3 && null != e3.allowHashBang || (t3.allowHashBang = t3.ecmaVersion >= 14), B(t3.onToken)) {
            var n2 = t3.onToken;
            t3.onToken = function(e4) {
              return n2.push(e4);
            };
          }
          return B(t3.onComment) && (t3.onComment = /* @__PURE__ */ (function(e4, t4) {
            return function(r3, n3, s2, i2, o2, a2) {
              var l2 = { type: r3 ? "Block" : "Line", value: n3, start: s2, end: i2 };
              e4.locations && (l2.loc = new acorn_SourceLocation(this, o2, a2)), e4.ranges && (l2.range = [s2, i2]), t4.push(l2);
            };
          })(t3, t3.onComment)), t3;
        }
        var K = 256, W = 259;
        function functionFlags(e3, t3) {
          return 2 | (e3 ? 4 : 0) | (t3 ? 8 : 0);
        }
        var acorn_Parser = function(e3, t3, r2) {
          this.options = e3 = getOptions(e3), this.sourceFile = e3.sourceFile, this.keywords = wordsRegexp(T[e3.ecmaVersion >= 6 ? 6 : "module" === e3.sourceType ? "5module" : 5]);
          var n2 = "";
          true !== e3.allowReserved && (n2 = v[e3.ecmaVersion >= 6 ? 6 : 5 === e3.ecmaVersion ? 5 : 3], "module" === e3.sourceType && (n2 += " await")), this.reservedWords = wordsRegexp(n2);
          var s2 = (n2 ? n2 + " " : "") + v.strict;
          this.reservedWordsStrict = wordsRegexp(s2), this.reservedWordsStrictBind = wordsRegexp(s2 + " " + v.strictBind), this.input = String(t3), this.containsEsc = false, r2 ? (this.pos = r2, this.lineStart = this.input.lastIndexOf("\n", r2 - 1) + 1, this.curLine = this.input.slice(0, this.lineStart).split(D).length) : (this.pos = this.lineStart = 0, this.curLine = 1), this.type = I.eof, this.value = null, this.start = this.end = this.pos, this.startLoc = this.endLoc = this.curPosition(), this.lastTokEndLoc = this.lastTokStartLoc = null, this.lastTokStart = this.lastTokEnd = this.pos, this.context = this.initialContext(), this.exprAllowed = true, this.inModule = "module" === e3.sourceType, this.strict = this.inModule || this.strictDirective(this.pos), this.potentialArrowAt = -1, this.potentialArrowInForAwait = false, this.yieldPos = this.awaitPos = this.awaitIdentPos = 0, this.labels = [], this.undefinedExports = /* @__PURE__ */ Object.create(null), 0 === this.pos && e3.allowHashBang && "#!" === this.input.slice(0, 2) && this.skipLineComment(2), this.scopeStack = [], this.enterScope(1), this.regexpState = null, this.privateNameStack = [];
        }, q = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, allowNewDotTarget: { configurable: true }, inClassStaticBlock: { configurable: true } };
        acorn_Parser.prototype.parse = function() {
          var e3 = this.options.program || this.startNode();
          return this.nextToken(), this.parseTopLevel(e3);
        }, q.inFunction.get = function() {
          return (2 & this.currentVarScope().flags) > 0;
        }, q.inGenerator.get = function() {
          return (8 & this.currentVarScope().flags) > 0;
        }, q.inAsync.get = function() {
          return (4 & this.currentVarScope().flags) > 0;
        }, q.canAwait.get = function() {
          for (var e3 = this.scopeStack.length - 1; e3 >= 0; e3--) {
            var t3 = this.scopeStack[e3].flags;
            if (768 & t3) return false;
            if (2 & t3) return (4 & t3) > 0;
          }
          return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
        }, q.allowSuper.get = function() {
          return (64 & this.currentThisScope().flags) > 0 || this.options.allowSuperOutsideMethod;
        }, q.allowDirectSuper.get = function() {
          return (128 & this.currentThisScope().flags) > 0;
        }, q.treatFunctionsAsVar.get = function() {
          return this.treatFunctionsAsVarInScope(this.currentScope());
        }, q.allowNewDotTarget.get = function() {
          for (var e3 = this.scopeStack.length - 1; e3 >= 0; e3--) {
            var t3 = this.scopeStack[e3].flags;
            if (768 & t3 || 2 & t3 && !(16 & t3)) return true;
          }
          return false;
        }, q.inClassStaticBlock.get = function() {
          return (this.currentVarScope().flags & K) > 0;
        }, acorn_Parser.extend = function() {
          for (var e3 = [], t3 = arguments.length; t3--; ) e3[t3] = arguments[t3];
          for (var r2 = this, n2 = 0; n2 < e3.length; n2++) r2 = e3[n2](r2);
          return r2;
        }, acorn_Parser.parse = function(e3, t3) {
          return new this(t3, e3).parse();
        }, acorn_Parser.parseExpressionAt = function(e3, t3, r2) {
          var n2 = new this(r2, e3, t3);
          return n2.nextToken(), n2.parseExpression();
        }, acorn_Parser.tokenizer = function(e3, t3) {
          return new this(t3, e3);
        }, Object.defineProperties(acorn_Parser.prototype, q);
        var H = acorn_Parser.prototype, z = /^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/;
        H.strictDirective = function(e3) {
          if (this.options.ecmaVersion < 5) return false;
          for (; ; ) {
            O.lastIndex = e3, e3 += O.exec(this.input)[0].length;
            var t3 = z.exec(this.input.slice(e3));
            if (!t3) return false;
            if ("use strict" === (t3[1] || t3[2])) {
              O.lastIndex = e3 + t3[0].length;
              var r2 = O.exec(this.input), n2 = r2.index + r2[0].length, s2 = this.input.charAt(n2);
              return ";" === s2 || "}" === s2 || D.test(r2[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(s2) || "!" === s2 && "=" === this.input.charAt(n2 + 1));
            }
            e3 += t3[0].length, O.lastIndex = e3, e3 += O.exec(this.input)[0].length, ";" === this.input[e3] && e3++;
          }
        }, H.eat = function(e3) {
          return this.type === e3 && (this.next(), true);
        }, H.isContextual = function(e3) {
          return this.type === I.name && this.value === e3 && !this.containsEsc;
        }, H.eatContextual = function(e3) {
          return !!this.isContextual(e3) && (this.next(), true);
        }, H.expectContextual = function(e3) {
          this.eatContextual(e3) || this.unexpected();
        }, H.canInsertSemicolon = function() {
          return this.type === I.eof || this.type === I.braceR || D.test(this.input.slice(this.lastTokEnd, this.start));
        }, H.insertSemicolon = function() {
          if (this.canInsertSemicolon()) return this.options.onInsertedSemicolon && this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc), true;
        }, H.semicolon = function() {
          this.eat(I.semi) || this.insertSemicolon() || this.unexpected();
        }, H.afterTrailingComma = function(e3, t3) {
          if (this.type === e3) return this.options.onTrailingComma && this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc), t3 || this.next(), true;
        }, H.expect = function(e3) {
          this.eat(e3) || this.unexpected();
        }, H.unexpected = function(e3) {
          this.raise(null != e3 ? e3 : this.start, "Unexpected token");
        };
        var acorn_DestructuringErrors = function() {
          this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
        };
        H.checkPatternErrors = function(e3, t3) {
          if (e3) {
            e3.trailingComma > -1 && this.raiseRecoverable(e3.trailingComma, "Comma is not permitted after the rest element");
            var r2 = t3 ? e3.parenthesizedAssign : e3.parenthesizedBind;
            r2 > -1 && this.raiseRecoverable(r2, t3 ? "Assigning to rvalue" : "Parenthesized pattern");
          }
        }, H.checkExpressionErrors = function(e3, t3) {
          if (!e3) return false;
          var r2 = e3.shorthandAssign, n2 = e3.doubleProto;
          if (!t3) return r2 >= 0 || n2 >= 0;
          r2 >= 0 && this.raise(r2, "Shorthand property assignments are valid only in destructuring patterns"), n2 >= 0 && this.raiseRecoverable(n2, "Redefinition of __proto__ property");
        }, H.checkYieldAwaitInDefaultParams = function() {
          this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos) && this.raise(this.yieldPos, "Yield expression cannot be a default value"), this.awaitPos && this.raise(this.awaitPos, "Await expression cannot be a default value");
        }, H.isSimpleAssignTarget = function(e3) {
          return "ParenthesizedExpression" === e3.type ? this.isSimpleAssignTarget(e3.expression) : "Identifier" === e3.type || "MemberExpression" === e3.type;
        };
        var G = acorn_Parser.prototype;
        G.parseTopLevel = function(e3) {
          var t3 = /* @__PURE__ */ Object.create(null);
          for (e3.body || (e3.body = []); this.type !== I.eof; ) {
            var r2 = this.parseStatement(null, true, t3);
            e3.body.push(r2);
          }
          if (this.inModule) for (var n2 = 0, s2 = Object.keys(this.undefinedExports); n2 < s2.length; n2 += 1) {
            var i2 = s2[n2];
            this.raiseRecoverable(this.undefinedExports[i2].start, "Export '" + i2 + "' is not defined");
          }
          return this.adaptDirectivePrologue(e3.body), this.next(), e3.sourceType = this.options.sourceType, this.finishNode(e3, "Program");
        };
        var X = { kind: "loop" }, J = { kind: "switch" };
        G.isLet = function(e3) {
          if (this.options.ecmaVersion < 6 || !this.isContextual("let")) return false;
          O.lastIndex = this.pos;
          var t3 = O.exec(this.input), r2 = this.pos + t3[0].length, n2 = this.input.charCodeAt(r2);
          if (91 === n2 || 92 === n2) return true;
          if (e3) return false;
          if (123 === n2 || n2 > 55295 && n2 < 56320) return true;
          if (isIdentifierStart(n2, true)) {
            for (var s2 = r2 + 1; isIdentifierChar(n2 = this.input.charCodeAt(s2), true); ) ++s2;
            if (92 === n2 || n2 > 55295 && n2 < 56320) return true;
            var i2 = this.input.slice(r2, s2);
            if (!S.test(i2)) return true;
          }
          return false;
        }, G.isAsyncFunction = function() {
          if (this.options.ecmaVersion < 8 || !this.isContextual("async")) return false;
          O.lastIndex = this.pos;
          var e3, t3 = O.exec(this.input), r2 = this.pos + t3[0].length;
          return !(D.test(this.input.slice(this.pos, r2)) || "function" !== this.input.slice(r2, r2 + 8) || r2 + 8 !== this.input.length && (isIdentifierChar(e3 = this.input.charCodeAt(r2 + 8)) || e3 > 55295 && e3 < 56320));
        }, G.isUsingKeyword = function(e3, t3) {
          if (this.options.ecmaVersion < 17 || !this.isContextual(e3 ? "await" : "using")) return false;
          O.lastIndex = this.pos;
          var r2 = O.exec(this.input), n2 = this.pos + r2[0].length;
          if (D.test(this.input.slice(this.pos, n2))) return false;
          if (e3) {
            var s2, i2 = n2 + 5;
            if ("using" !== this.input.slice(n2, i2) || i2 === this.input.length || isIdentifierChar(s2 = this.input.charCodeAt(i2)) || s2 > 55295 && s2 < 56320) return false;
            O.lastIndex = i2;
            var o2 = O.exec(this.input);
            if (o2 && D.test(this.input.slice(i2, i2 + o2[0].length))) return false;
          }
          if (t3) {
            var a2, l2 = n2 + 2;
            if (!("of" !== this.input.slice(n2, l2) || l2 !== this.input.length && (isIdentifierChar(a2 = this.input.charCodeAt(l2)) || a2 > 55295 && a2 < 56320))) return false;
          }
          var p2 = this.input.charCodeAt(n2);
          return isIdentifierStart(p2, true) || 92 === p2;
        }, G.isAwaitUsing = function(e3) {
          return this.isUsingKeyword(true, e3);
        }, G.isUsing = function(e3) {
          return this.isUsingKeyword(false, e3);
        }, G.parseStatement = function(e3, t3, r2) {
          var n2, s2 = this.type, i2 = this.startNode();
          switch (this.isLet(e3) && (s2 = I._var, n2 = "let"), s2) {
            case I._break:
            case I._continue:
              return this.parseBreakContinueStatement(i2, s2.keyword);
            case I._debugger:
              return this.parseDebuggerStatement(i2);
            case I._do:
              return this.parseDoStatement(i2);
            case I._for:
              return this.parseForStatement(i2);
            case I._function:
              return e3 && (this.strict || "if" !== e3 && "label" !== e3) && this.options.ecmaVersion >= 6 && this.unexpected(), this.parseFunctionStatement(i2, false, !e3);
            case I._class:
              return e3 && this.unexpected(), this.parseClass(i2, true);
            case I._if:
              return this.parseIfStatement(i2);
            case I._return:
              return this.parseReturnStatement(i2);
            case I._switch:
              return this.parseSwitchStatement(i2);
            case I._throw:
              return this.parseThrowStatement(i2);
            case I._try:
              return this.parseTryStatement(i2);
            case I._const:
            case I._var:
              return n2 = n2 || this.value, e3 && "var" !== n2 && this.unexpected(), this.parseVarStatement(i2, n2);
            case I._while:
              return this.parseWhileStatement(i2);
            case I._with:
              return this.parseWithStatement(i2);
            case I.braceL:
              return this.parseBlock(true, i2);
            case I.semi:
              return this.parseEmptyStatement(i2);
            case I._export:
            case I._import:
              if (this.options.ecmaVersion > 10 && s2 === I._import) {
                O.lastIndex = this.pos;
                var o2 = O.exec(this.input), a2 = this.pos + o2[0].length, l2 = this.input.charCodeAt(a2);
                if (40 === l2 || 46 === l2) return this.parseExpressionStatement(i2, this.parseExpression());
              }
              return this.options.allowImportExportEverywhere || (t3 || this.raise(this.start, "'import' and 'export' may only appear at the top level"), this.inModule || this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'")), s2 === I._import ? this.parseImport(i2) : this.parseExport(i2, r2);
            default:
              if (this.isAsyncFunction()) return e3 && this.unexpected(), this.next(), this.parseFunctionStatement(i2, true, !e3);
              var p2 = this.isAwaitUsing(false) ? "await using" : this.isUsing(false) ? "using" : null;
              if (p2) return t3 && "script" === this.options.sourceType && this.raise(this.start, "Using declaration cannot appear in the top level when source type is `script`"), "await using" === p2 && (this.canAwait || this.raise(this.start, "Await using cannot appear outside of async function"), this.next()), this.next(), this.parseVar(i2, false, p2), this.semicolon(), this.finishNode(i2, "VariableDeclaration");
              var c2 = this.value, u2 = this.parseExpression();
              return s2 === I.name && "Identifier" === u2.type && this.eat(I.colon) ? this.parseLabeledStatement(i2, c2, u2, e3) : this.parseExpressionStatement(i2, u2);
          }
        }, G.parseBreakContinueStatement = function(e3, t3) {
          var r2 = "break" === t3;
          this.next(), this.eat(I.semi) || this.insertSemicolon() ? e3.label = null : this.type !== I.name ? this.unexpected() : (e3.label = this.parseIdent(), this.semicolon());
          for (var n2 = 0; n2 < this.labels.length; ++n2) {
            var s2 = this.labels[n2];
            if (null == e3.label || s2.name === e3.label.name) {
              if (null != s2.kind && (r2 || "loop" === s2.kind)) break;
              if (e3.label && r2) break;
            }
          }
          return n2 === this.labels.length && this.raise(e3.start, "Unsyntactic " + t3), this.finishNode(e3, r2 ? "BreakStatement" : "ContinueStatement");
        }, G.parseDebuggerStatement = function(e3) {
          return this.next(), this.semicolon(), this.finishNode(e3, "DebuggerStatement");
        }, G.parseDoStatement = function(e3) {
          return this.next(), this.labels.push(X), e3.body = this.parseStatement("do"), this.labels.pop(), this.expect(I._while), e3.test = this.parseParenExpression(), this.options.ecmaVersion >= 6 ? this.eat(I.semi) : this.semicolon(), this.finishNode(e3, "DoWhileStatement");
        }, G.parseForStatement = function(e3) {
          this.next();
          var t3 = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
          if (this.labels.push(X), this.enterScope(0), this.expect(I.parenL), this.type === I.semi) return t3 > -1 && this.unexpected(t3), this.parseFor(e3, null);
          var r2 = this.isLet();
          if (this.type === I._var || this.type === I._const || r2) {
            var n2 = this.startNode(), s2 = r2 ? "let" : this.value;
            return this.next(), this.parseVar(n2, true, s2), this.finishNode(n2, "VariableDeclaration"), this.parseForAfterInit(e3, n2, t3);
          }
          var i2 = this.isContextual("let"), o2 = false, a2 = this.isUsing(true) ? "using" : this.isAwaitUsing(true) ? "await using" : null;
          if (a2) {
            var l2 = this.startNode();
            return this.next(), "await using" === a2 && this.next(), this.parseVar(l2, true, a2), this.finishNode(l2, "VariableDeclaration"), this.parseForAfterInit(e3, l2, t3);
          }
          var p2 = this.containsEsc, c2 = new acorn_DestructuringErrors(), u2 = this.start, d2 = t3 > -1 ? this.parseExprSubscripts(c2, "await") : this.parseExpression(true, c2);
          return this.type === I._in || (o2 = this.options.ecmaVersion >= 6 && this.isContextual("of")) ? (t3 > -1 ? (this.type === I._in && this.unexpected(t3), e3.await = true) : o2 && this.options.ecmaVersion >= 8 && (d2.start !== u2 || p2 || "Identifier" !== d2.type || "async" !== d2.name ? this.options.ecmaVersion >= 9 && (e3.await = false) : this.unexpected()), i2 && o2 && this.raise(d2.start, "The left-hand side of a for-of loop may not start with 'let'."), this.toAssignable(d2, false, c2), this.checkLValPattern(d2), this.parseForIn(e3, d2)) : (this.checkExpressionErrors(c2, true), t3 > -1 && this.unexpected(t3), this.parseFor(e3, d2));
        }, G.parseForAfterInit = function(e3, t3, r2) {
          return (this.type === I._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && 1 === t3.declarations.length ? (this.options.ecmaVersion >= 9 && (this.type === I._in ? r2 > -1 && this.unexpected(r2) : e3.await = r2 > -1), this.parseForIn(e3, t3)) : (r2 > -1 && this.unexpected(r2), this.parseFor(e3, t3));
        }, G.parseFunctionStatement = function(e3, t3, r2) {
          return this.next(), this.parseFunction(e3, Q | (r2 ? 0 : Z), false, t3);
        }, G.parseIfStatement = function(e3) {
          return this.next(), e3.test = this.parseParenExpression(), e3.consequent = this.parseStatement("if"), e3.alternate = this.eat(I._else) ? this.parseStatement("if") : null, this.finishNode(e3, "IfStatement");
        }, G.parseReturnStatement = function(e3) {
          return this.inFunction || this.options.allowReturnOutsideFunction || this.raise(this.start, "'return' outside of function"), this.next(), this.eat(I.semi) || this.insertSemicolon() ? e3.argument = null : (e3.argument = this.parseExpression(), this.semicolon()), this.finishNode(e3, "ReturnStatement");
        }, G.parseSwitchStatement = function(e3) {
          var t3;
          this.next(), e3.discriminant = this.parseParenExpression(), e3.cases = [], this.expect(I.braceL), this.labels.push(J), this.enterScope(0);
          for (var r2 = false; this.type !== I.braceR; ) if (this.type === I._case || this.type === I._default) {
            var n2 = this.type === I._case;
            t3 && this.finishNode(t3, "SwitchCase"), e3.cases.push(t3 = this.startNode()), t3.consequent = [], this.next(), n2 ? t3.test = this.parseExpression() : (r2 && this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"), r2 = true, t3.test = null), this.expect(I.colon);
          } else t3 || this.unexpected(), t3.consequent.push(this.parseStatement(null));
          return this.exitScope(), t3 && this.finishNode(t3, "SwitchCase"), this.next(), this.labels.pop(), this.finishNode(e3, "SwitchStatement");
        }, G.parseThrowStatement = function(e3) {
          return this.next(), D.test(this.input.slice(this.lastTokEnd, this.start)) && this.raise(this.lastTokEnd, "Illegal newline after throw"), e3.argument = this.parseExpression(), this.semicolon(), this.finishNode(e3, "ThrowStatement");
        };
        var Y = [];
        G.parseCatchClauseParam = function() {
          var e3 = this.parseBindingAtom(), t3 = "Identifier" === e3.type;
          return this.enterScope(t3 ? 32 : 0), this.checkLValPattern(e3, t3 ? 4 : 2), this.expect(I.parenR), e3;
        }, G.parseTryStatement = function(e3) {
          if (this.next(), e3.block = this.parseBlock(), e3.handler = null, this.type === I._catch) {
            var t3 = this.startNode();
            this.next(), this.eat(I.parenL) ? t3.param = this.parseCatchClauseParam() : (this.options.ecmaVersion < 10 && this.unexpected(), t3.param = null, this.enterScope(0)), t3.body = this.parseBlock(false), this.exitScope(), e3.handler = this.finishNode(t3, "CatchClause");
          }
          return e3.finalizer = this.eat(I._finally) ? this.parseBlock() : null, e3.handler || e3.finalizer || this.raise(e3.start, "Missing catch or finally clause"), this.finishNode(e3, "TryStatement");
        }, G.parseVarStatement = function(e3, t3, r2) {
          return this.next(), this.parseVar(e3, false, t3, r2), this.semicolon(), this.finishNode(e3, "VariableDeclaration");
        }, G.parseWhileStatement = function(e3) {
          return this.next(), e3.test = this.parseParenExpression(), this.labels.push(X), e3.body = this.parseStatement("while"), this.labels.pop(), this.finishNode(e3, "WhileStatement");
        }, G.parseWithStatement = function(e3) {
          return this.strict && this.raise(this.start, "'with' in strict mode"), this.next(), e3.object = this.parseParenExpression(), e3.body = this.parseStatement("with"), this.finishNode(e3, "WithStatement");
        }, G.parseEmptyStatement = function(e3) {
          return this.next(), this.finishNode(e3, "EmptyStatement");
        }, G.parseLabeledStatement = function(e3, t3, r2, n2) {
          for (var s2 = 0, i2 = this.labels; s2 < i2.length; s2 += 1) {
            i2[s2].name === t3 && this.raise(r2.start, "Label '" + t3 + "' is already declared");
          }
          for (var o2 = this.type.isLoop ? "loop" : this.type === I._switch ? "switch" : null, a2 = this.labels.length - 1; a2 >= 0; a2--) {
            var l2 = this.labels[a2];
            if (l2.statementStart !== e3.start) break;
            l2.statementStart = this.start, l2.kind = o2;
          }
          return this.labels.push({ name: t3, kind: o2, statementStart: this.start }), e3.body = this.parseStatement(n2 ? -1 === n2.indexOf("label") ? n2 + "label" : n2 : "label"), this.labels.pop(), e3.label = r2, this.finishNode(e3, "LabeledStatement");
        }, G.parseExpressionStatement = function(e3, t3) {
          return e3.expression = t3, this.semicolon(), this.finishNode(e3, "ExpressionStatement");
        }, G.parseBlock = function(e3, t3, r2) {
          for (void 0 === e3 && (e3 = true), void 0 === t3 && (t3 = this.startNode()), t3.body = [], this.expect(I.braceL), e3 && this.enterScope(0); this.type !== I.braceR; ) {
            var n2 = this.parseStatement(null);
            t3.body.push(n2);
          }
          return r2 && (this.strict = false), this.next(), e3 && this.exitScope(), this.finishNode(t3, "BlockStatement");
        }, G.parseFor = function(e3, t3) {
          return e3.init = t3, this.expect(I.semi), e3.test = this.type === I.semi ? null : this.parseExpression(), this.expect(I.semi), e3.update = this.type === I.parenR ? null : this.parseExpression(), this.expect(I.parenR), e3.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(e3, "ForStatement");
        }, G.parseForIn = function(e3, t3) {
          var r2 = this.type === I._in;
          return this.next(), "VariableDeclaration" === t3.type && null != t3.declarations[0].init && (!r2 || this.options.ecmaVersion < 8 || this.strict || "var" !== t3.kind || "Identifier" !== t3.declarations[0].id.type) && this.raise(t3.start, (r2 ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"), e3.left = t3, e3.right = r2 ? this.parseExpression() : this.parseMaybeAssign(), this.expect(I.parenR), e3.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(e3, r2 ? "ForInStatement" : "ForOfStatement");
        }, G.parseVar = function(e3, t3, r2, n2) {
          for (e3.declarations = [], e3.kind = r2; ; ) {
            var s2 = this.startNode();
            if (this.parseVarId(s2, r2), this.eat(I.eq) ? s2.init = this.parseMaybeAssign(t3) : n2 || "const" !== r2 || this.type === I._in || this.options.ecmaVersion >= 6 && this.isContextual("of") ? n2 || "using" !== r2 && "await using" !== r2 || !(this.options.ecmaVersion >= 17) || this.type === I._in || this.isContextual("of") ? n2 || "Identifier" === s2.id.type || t3 && (this.type === I._in || this.isContextual("of")) ? s2.init = null : this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value") : this.raise(this.lastTokEnd, "Missing initializer in " + r2 + " declaration") : this.unexpected(), e3.declarations.push(this.finishNode(s2, "VariableDeclarator")), !this.eat(I.comma)) break;
          }
          return e3;
        }, G.parseVarId = function(e3, t3) {
          e3.id = "using" === t3 || "await using" === t3 ? this.parseIdent() : this.parseBindingAtom(), this.checkLValPattern(e3.id, "var" === t3 ? 1 : 2, false);
        };
        var Q = 1, Z = 2;
        function isPrivateNameConflicted(e3, t3) {
          var r2 = t3.key.name, n2 = e3[r2], s2 = "true";
          return "MethodDefinition" !== t3.type || "get" !== t3.kind && "set" !== t3.kind || (s2 = (t3.static ? "s" : "i") + t3.kind), "iget" === n2 && "iset" === s2 || "iset" === n2 && "iget" === s2 || "sget" === n2 && "sset" === s2 || "sset" === n2 && "sget" === s2 ? (e3[r2] = "true", false) : !!n2 || (e3[r2] = s2, false);
        }
        function checkKeyName(e3, t3) {
          var r2 = e3.computed, n2 = e3.key;
          return !r2 && ("Identifier" === n2.type && n2.name === t3 || "Literal" === n2.type && n2.value === t3);
        }
        G.parseFunction = function(e3, t3, r2, n2, s2) {
          this.initFunction(e3), (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !n2) && (this.type === I.star && t3 & Z && this.unexpected(), e3.generator = this.eat(I.star)), this.options.ecmaVersion >= 8 && (e3.async = !!n2), t3 & Q && (e3.id = 4 & t3 && this.type !== I.name ? null : this.parseIdent(), !e3.id || t3 & Z || this.checkLValSimple(e3.id, this.strict || e3.generator || e3.async ? this.treatFunctionsAsVar ? 1 : 2 : 3));
          var i2 = this.yieldPos, o2 = this.awaitPos, a2 = this.awaitIdentPos;
          return this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(functionFlags(e3.async, e3.generator)), t3 & Q || (e3.id = this.type === I.name ? this.parseIdent() : null), this.parseFunctionParams(e3), this.parseFunctionBody(e3, r2, false, s2), this.yieldPos = i2, this.awaitPos = o2, this.awaitIdentPos = a2, this.finishNode(e3, t3 & Q ? "FunctionDeclaration" : "FunctionExpression");
        }, G.parseFunctionParams = function(e3) {
          this.expect(I.parenL), e3.params = this.parseBindingList(I.parenR, false, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams();
        }, G.parseClass = function(e3, t3) {
          this.next();
          var r2 = this.strict;
          this.strict = true, this.parseClassId(e3, t3), this.parseClassSuper(e3);
          var n2 = this.enterClassBody(), s2 = this.startNode(), i2 = false;
          for (s2.body = [], this.expect(I.braceL); this.type !== I.braceR; ) {
            var o2 = this.parseClassElement(null !== e3.superClass);
            o2 && (s2.body.push(o2), "MethodDefinition" === o2.type && "constructor" === o2.kind ? (i2 && this.raiseRecoverable(o2.start, "Duplicate constructor in the same class"), i2 = true) : o2.key && "PrivateIdentifier" === o2.key.type && isPrivateNameConflicted(n2, o2) && this.raiseRecoverable(o2.key.start, "Identifier '#" + o2.key.name + "' has already been declared"));
          }
          return this.strict = r2, this.next(), e3.body = this.finishNode(s2, "ClassBody"), this.exitClassBody(), this.finishNode(e3, t3 ? "ClassDeclaration" : "ClassExpression");
        }, G.parseClassElement = function(e3) {
          if (this.eat(I.semi)) return null;
          var t3 = this.options.ecmaVersion, r2 = this.startNode(), n2 = "", s2 = false, i2 = false, o2 = "method", a2 = false;
          if (this.eatContextual("static")) {
            if (t3 >= 13 && this.eat(I.braceL)) return this.parseClassStaticBlock(r2), r2;
            this.isClassElementNameStart() || this.type === I.star ? a2 = true : n2 = "static";
          }
          if (r2.static = a2, !n2 && t3 >= 8 && this.eatContextual("async") && (!this.isClassElementNameStart() && this.type !== I.star || this.canInsertSemicolon() ? n2 = "async" : i2 = true), !n2 && (t3 >= 9 || !i2) && this.eat(I.star) && (s2 = true), !n2 && !i2 && !s2) {
            var l2 = this.value;
            (this.eatContextual("get") || this.eatContextual("set")) && (this.isClassElementNameStart() ? o2 = l2 : n2 = l2);
          }
          if (n2 ? (r2.computed = false, r2.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc), r2.key.name = n2, this.finishNode(r2.key, "Identifier")) : this.parseClassElementName(r2), t3 < 13 || this.type === I.parenL || "method" !== o2 || s2 || i2) {
            var p2 = !r2.static && checkKeyName(r2, "constructor"), c2 = p2 && e3;
            p2 && "method" !== o2 && this.raise(r2.key.start, "Constructor can't have get/set modifier"), r2.kind = p2 ? "constructor" : o2, this.parseClassMethod(r2, s2, i2, c2);
          } else this.parseClassField(r2);
          return r2;
        }, G.isClassElementNameStart = function() {
          return this.type === I.name || this.type === I.privateId || this.type === I.num || this.type === I.string || this.type === I.bracketL || this.type.keyword;
        }, G.parseClassElementName = function(e3) {
          this.type === I.privateId ? ("constructor" === this.value && this.raise(this.start, "Classes can't have an element named '#constructor'"), e3.computed = false, e3.key = this.parsePrivateIdent()) : this.parsePropertyName(e3);
        }, G.parseClassMethod = function(e3, t3, r2, n2) {
          var s2 = e3.key;
          "constructor" === e3.kind ? (t3 && this.raise(s2.start, "Constructor can't be a generator"), r2 && this.raise(s2.start, "Constructor can't be an async method")) : e3.static && checkKeyName(e3, "prototype") && this.raise(s2.start, "Classes may not have a static property named prototype");
          var i2 = e3.value = this.parseMethod(t3, r2, n2);
          return "get" === e3.kind && 0 !== i2.params.length && this.raiseRecoverable(i2.start, "getter should have no params"), "set" === e3.kind && 1 !== i2.params.length && this.raiseRecoverable(i2.start, "setter should have exactly one param"), "set" === e3.kind && "RestElement" === i2.params[0].type && this.raiseRecoverable(i2.params[0].start, "Setter cannot use rest params"), this.finishNode(e3, "MethodDefinition");
        }, G.parseClassField = function(e3) {
          return checkKeyName(e3, "constructor") ? this.raise(e3.key.start, "Classes can't have a field named 'constructor'") : e3.static && checkKeyName(e3, "prototype") && this.raise(e3.key.start, "Classes can't have a static field named 'prototype'"), this.eat(I.eq) ? (this.enterScope(576), e3.value = this.parseMaybeAssign(), this.exitScope()) : e3.value = null, this.semicolon(), this.finishNode(e3, "PropertyDefinition");
        }, G.parseClassStaticBlock = function(e3) {
          e3.body = [];
          var t3 = this.labels;
          for (this.labels = [], this.enterScope(320); this.type !== I.braceR; ) {
            var r2 = this.parseStatement(null);
            e3.body.push(r2);
          }
          return this.next(), this.exitScope(), this.labels = t3, this.finishNode(e3, "StaticBlock");
        }, G.parseClassId = function(e3, t3) {
          this.type === I.name ? (e3.id = this.parseIdent(), t3 && this.checkLValSimple(e3.id, 2, false)) : (true === t3 && this.unexpected(), e3.id = null);
        }, G.parseClassSuper = function(e3) {
          e3.superClass = this.eat(I._extends) ? this.parseExprSubscripts(null, false) : null;
        }, G.enterClassBody = function() {
          var e3 = { declared: /* @__PURE__ */ Object.create(null), used: [] };
          return this.privateNameStack.push(e3), e3.declared;
        }, G.exitClassBody = function() {
          var e3 = this.privateNameStack.pop(), t3 = e3.declared, r2 = e3.used;
          if (this.options.checkPrivateFields) for (var n2 = this.privateNameStack.length, s2 = 0 === n2 ? null : this.privateNameStack[n2 - 1], i2 = 0; i2 < r2.length; ++i2) {
            var o2 = r2[i2];
            M(t3, o2.name) || (s2 ? s2.used.push(o2) : this.raiseRecoverable(o2.start, "Private field '#" + o2.name + "' must be declared in an enclosing class"));
          }
        }, G.parseExportAllDeclaration = function(e3, t3) {
          return this.options.ecmaVersion >= 11 && (this.eatContextual("as") ? (e3.exported = this.parseModuleExportName(), this.checkExport(t3, e3.exported, this.lastTokStart)) : e3.exported = null), this.expectContextual("from"), this.type !== I.string && this.unexpected(), e3.source = this.parseExprAtom(), this.options.ecmaVersion >= 16 && (e3.attributes = this.parseWithClause()), this.semicolon(), this.finishNode(e3, "ExportAllDeclaration");
        }, G.parseExport = function(e3, t3) {
          if (this.next(), this.eat(I.star)) return this.parseExportAllDeclaration(e3, t3);
          if (this.eat(I._default)) return this.checkExport(t3, "default", this.lastTokStart), e3.declaration = this.parseExportDefaultDeclaration(), this.finishNode(e3, "ExportDefaultDeclaration");
          if (this.shouldParseExportStatement()) e3.declaration = this.parseExportDeclaration(e3), "VariableDeclaration" === e3.declaration.type ? this.checkVariableExport(t3, e3.declaration.declarations) : this.checkExport(t3, e3.declaration.id, e3.declaration.id.start), e3.specifiers = [], e3.source = null, this.options.ecmaVersion >= 16 && (e3.attributes = []);
          else {
            if (e3.declaration = null, e3.specifiers = this.parseExportSpecifiers(t3), this.eatContextual("from")) this.type !== I.string && this.unexpected(), e3.source = this.parseExprAtom(), this.options.ecmaVersion >= 16 && (e3.attributes = this.parseWithClause());
            else {
              for (var r2 = 0, n2 = e3.specifiers; r2 < n2.length; r2 += 1) {
                var s2 = n2[r2];
                this.checkUnreserved(s2.local), this.checkLocalExport(s2.local), "Literal" === s2.local.type && this.raise(s2.local.start, "A string literal cannot be used as an exported binding without `from`.");
              }
              e3.source = null, this.options.ecmaVersion >= 16 && (e3.attributes = []);
            }
            this.semicolon();
          }
          return this.finishNode(e3, "ExportNamedDeclaration");
        }, G.parseExportDeclaration = function(e3) {
          return this.parseStatement(null);
        }, G.parseExportDefaultDeclaration = function() {
          var e3;
          if (this.type === I._function || (e3 = this.isAsyncFunction())) {
            var t3 = this.startNode();
            return this.next(), e3 && this.next(), this.parseFunction(t3, 4 | Q, false, e3);
          }
          if (this.type === I._class) {
            var r2 = this.startNode();
            return this.parseClass(r2, "nullableID");
          }
          var n2 = this.parseMaybeAssign();
          return this.semicolon(), n2;
        }, G.checkExport = function(e3, t3, r2) {
          e3 && ("string" != typeof t3 && (t3 = "Identifier" === t3.type ? t3.name : t3.value), M(e3, t3) && this.raiseRecoverable(r2, "Duplicate export '" + t3 + "'"), e3[t3] = true);
        }, G.checkPatternExport = function(e3, t3) {
          var r2 = t3.type;
          if ("Identifier" === r2) this.checkExport(e3, t3, t3.start);
          else if ("ObjectPattern" === r2) for (var n2 = 0, s2 = t3.properties; n2 < s2.length; n2 += 1) {
            var i2 = s2[n2];
            this.checkPatternExport(e3, i2);
          }
          else if ("ArrayPattern" === r2) for (var o2 = 0, a2 = t3.elements; o2 < a2.length; o2 += 1) {
            var l2 = a2[o2];
            l2 && this.checkPatternExport(e3, l2);
          }
          else "Property" === r2 ? this.checkPatternExport(e3, t3.value) : "AssignmentPattern" === r2 ? this.checkPatternExport(e3, t3.left) : "RestElement" === r2 && this.checkPatternExport(e3, t3.argument);
        }, G.checkVariableExport = function(e3, t3) {
          if (e3) for (var r2 = 0, n2 = t3; r2 < n2.length; r2 += 1) {
            var s2 = n2[r2];
            this.checkPatternExport(e3, s2.id);
          }
        }, G.shouldParseExportStatement = function() {
          return "var" === this.type.keyword || "const" === this.type.keyword || "class" === this.type.keyword || "function" === this.type.keyword || this.isLet() || this.isAsyncFunction();
        }, G.parseExportSpecifier = function(e3) {
          var t3 = this.startNode();
          return t3.local = this.parseModuleExportName(), t3.exported = this.eatContextual("as") ? this.parseModuleExportName() : t3.local, this.checkExport(e3, t3.exported, t3.exported.start), this.finishNode(t3, "ExportSpecifier");
        }, G.parseExportSpecifiers = function(e3) {
          var t3 = [], r2 = true;
          for (this.expect(I.braceL); !this.eat(I.braceR); ) {
            if (r2) r2 = false;
            else if (this.expect(I.comma), this.afterTrailingComma(I.braceR)) break;
            t3.push(this.parseExportSpecifier(e3));
          }
          return t3;
        }, G.parseImport = function(e3) {
          return this.next(), this.type === I.string ? (e3.specifiers = Y, e3.source = this.parseExprAtom()) : (e3.specifiers = this.parseImportSpecifiers(), this.expectContextual("from"), e3.source = this.type === I.string ? this.parseExprAtom() : this.unexpected()), this.options.ecmaVersion >= 16 && (e3.attributes = this.parseWithClause()), this.semicolon(), this.finishNode(e3, "ImportDeclaration");
        }, G.parseImportSpecifier = function() {
          var e3 = this.startNode();
          return e3.imported = this.parseModuleExportName(), this.eatContextual("as") ? e3.local = this.parseIdent() : (this.checkUnreserved(e3.imported), e3.local = e3.imported), this.checkLValSimple(e3.local, 2), this.finishNode(e3, "ImportSpecifier");
        }, G.parseImportDefaultSpecifier = function() {
          var e3 = this.startNode();
          return e3.local = this.parseIdent(), this.checkLValSimple(e3.local, 2), this.finishNode(e3, "ImportDefaultSpecifier");
        }, G.parseImportNamespaceSpecifier = function() {
          var e3 = this.startNode();
          return this.next(), this.expectContextual("as"), e3.local = this.parseIdent(), this.checkLValSimple(e3.local, 2), this.finishNode(e3, "ImportNamespaceSpecifier");
        }, G.parseImportSpecifiers = function() {
          var e3 = [], t3 = true;
          if (this.type === I.name && (e3.push(this.parseImportDefaultSpecifier()), !this.eat(I.comma))) return e3;
          if (this.type === I.star) return e3.push(this.parseImportNamespaceSpecifier()), e3;
          for (this.expect(I.braceL); !this.eat(I.braceR); ) {
            if (t3) t3 = false;
            else if (this.expect(I.comma), this.afterTrailingComma(I.braceR)) break;
            e3.push(this.parseImportSpecifier());
          }
          return e3;
        }, G.parseWithClause = function() {
          var e3 = [];
          if (!this.eat(I._with)) return e3;
          this.expect(I.braceL);
          for (var t3 = {}, r2 = true; !this.eat(I.braceR); ) {
            if (r2) r2 = false;
            else if (this.expect(I.comma), this.afterTrailingComma(I.braceR)) break;
            var n2 = this.parseImportAttribute(), s2 = "Identifier" === n2.key.type ? n2.key.name : n2.key.value;
            M(t3, s2) && this.raiseRecoverable(n2.key.start, "Duplicate attribute key '" + s2 + "'"), t3[s2] = true, e3.push(n2);
          }
          return e3;
        }, G.parseImportAttribute = function() {
          var e3 = this.startNode();
          return e3.key = this.type === I.string ? this.parseExprAtom() : this.parseIdent("never" !== this.options.allowReserved), this.expect(I.colon), this.type !== I.string && this.unexpected(), e3.value = this.parseExprAtom(), this.finishNode(e3, "ImportAttribute");
        }, G.parseModuleExportName = function() {
          if (this.options.ecmaVersion >= 13 && this.type === I.string) {
            var e3 = this.parseLiteral(this.value);
            return U.test(e3.value) && this.raise(e3.start, "An export name cannot include a lone surrogate."), e3;
          }
          return this.parseIdent(true);
        }, G.adaptDirectivePrologue = function(e3) {
          for (var t3 = 0; t3 < e3.length && this.isDirectiveCandidate(e3[t3]); ++t3) e3[t3].directive = e3[t3].expression.raw.slice(1, -1);
        }, G.isDirectiveCandidate = function(e3) {
          return this.options.ecmaVersion >= 5 && "ExpressionStatement" === e3.type && "Literal" === e3.expression.type && "string" == typeof e3.expression.value && ('"' === this.input[e3.start] || "'" === this.input[e3.start]);
        };
        var ee = acorn_Parser.prototype;
        ee.toAssignable = function(e3, t3, r2) {
          if (this.options.ecmaVersion >= 6 && e3) switch (e3.type) {
            case "Identifier":
              this.inAsync && "await" === e3.name && this.raise(e3.start, "Cannot use 'await' as identifier inside an async function");
              break;
            case "ObjectPattern":
            case "ArrayPattern":
            case "AssignmentPattern":
            case "RestElement":
              break;
            case "ObjectExpression":
              e3.type = "ObjectPattern", r2 && this.checkPatternErrors(r2, true);
              for (var n2 = 0, s2 = e3.properties; n2 < s2.length; n2 += 1) {
                var i2 = s2[n2];
                this.toAssignable(i2, t3), "RestElement" !== i2.type || "ArrayPattern" !== i2.argument.type && "ObjectPattern" !== i2.argument.type || this.raise(i2.argument.start, "Unexpected token");
              }
              break;
            case "Property":
              "init" !== e3.kind && this.raise(e3.key.start, "Object pattern can't contain getter or setter"), this.toAssignable(e3.value, t3);
              break;
            case "ArrayExpression":
              e3.type = "ArrayPattern", r2 && this.checkPatternErrors(r2, true), this.toAssignableList(e3.elements, t3);
              break;
            case "SpreadElement":
              e3.type = "RestElement", this.toAssignable(e3.argument, t3), "AssignmentPattern" === e3.argument.type && this.raise(e3.argument.start, "Rest elements cannot have a default value");
              break;
            case "AssignmentExpression":
              "=" !== e3.operator && this.raise(e3.left.end, "Only '=' operator can be used for specifying default value."), e3.type = "AssignmentPattern", delete e3.operator, this.toAssignable(e3.left, t3);
              break;
            case "ParenthesizedExpression":
              this.toAssignable(e3.expression, t3, r2);
              break;
            case "ChainExpression":
              this.raiseRecoverable(e3.start, "Optional chaining cannot appear in left-hand side");
              break;
            case "MemberExpression":
              if (!t3) break;
            default:
              this.raise(e3.start, "Assigning to rvalue");
          }
          else r2 && this.checkPatternErrors(r2, true);
          return e3;
        }, ee.toAssignableList = function(e3, t3) {
          for (var r2 = e3.length, n2 = 0; n2 < r2; n2++) {
            var s2 = e3[n2];
            s2 && this.toAssignable(s2, t3);
          }
          if (r2) {
            var i2 = e3[r2 - 1];
            6 === this.options.ecmaVersion && t3 && i2 && "RestElement" === i2.type && "Identifier" !== i2.argument.type && this.unexpected(i2.argument.start);
          }
          return e3;
        }, ee.parseSpread = function(e3) {
          var t3 = this.startNode();
          return this.next(), t3.argument = this.parseMaybeAssign(false, e3), this.finishNode(t3, "SpreadElement");
        }, ee.parseRestBinding = function() {
          var e3 = this.startNode();
          return this.next(), 6 === this.options.ecmaVersion && this.type !== I.name && this.unexpected(), e3.argument = this.parseBindingAtom(), this.finishNode(e3, "RestElement");
        }, ee.parseBindingAtom = function() {
          if (this.options.ecmaVersion >= 6) switch (this.type) {
            case I.bracketL:
              var e3 = this.startNode();
              return this.next(), e3.elements = this.parseBindingList(I.bracketR, true, true), this.finishNode(e3, "ArrayPattern");
            case I.braceL:
              return this.parseObj(true);
          }
          return this.parseIdent();
        }, ee.parseBindingList = function(e3, t3, r2, n2) {
          for (var s2 = [], i2 = true; !this.eat(e3); ) if (i2 ? i2 = false : this.expect(I.comma), t3 && this.type === I.comma) s2.push(null);
          else {
            if (r2 && this.afterTrailingComma(e3)) break;
            if (this.type === I.ellipsis) {
              var o2 = this.parseRestBinding();
              this.parseBindingListItem(o2), s2.push(o2), this.type === I.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"), this.expect(e3);
              break;
            }
            s2.push(this.parseAssignableListItem(n2));
          }
          return s2;
        }, ee.parseAssignableListItem = function(e3) {
          var t3 = this.parseMaybeDefault(this.start, this.startLoc);
          return this.parseBindingListItem(t3), t3;
        }, ee.parseBindingListItem = function(e3) {
          return e3;
        }, ee.parseMaybeDefault = function(e3, t3, r2) {
          if (r2 = r2 || this.parseBindingAtom(), this.options.ecmaVersion < 6 || !this.eat(I.eq)) return r2;
          var n2 = this.startNodeAt(e3, t3);
          return n2.left = r2, n2.right = this.parseMaybeAssign(), this.finishNode(n2, "AssignmentPattern");
        }, ee.checkLValSimple = function(e3, t3, r2) {
          void 0 === t3 && (t3 = 0);
          var n2 = 0 !== t3;
          switch (e3.type) {
            case "Identifier":
              this.strict && this.reservedWordsStrictBind.test(e3.name) && this.raiseRecoverable(e3.start, (n2 ? "Binding " : "Assigning to ") + e3.name + " in strict mode"), n2 && (2 === t3 && "let" === e3.name && this.raiseRecoverable(e3.start, "let is disallowed as a lexically bound name"), r2 && (M(r2, e3.name) && this.raiseRecoverable(e3.start, "Argument name clash"), r2[e3.name] = true), 5 !== t3 && this.declareName(e3.name, t3, e3.start));
              break;
            case "ChainExpression":
              this.raiseRecoverable(e3.start, "Optional chaining cannot appear in left-hand side");
              break;
            case "MemberExpression":
              n2 && this.raiseRecoverable(e3.start, "Binding member expression");
              break;
            case "ParenthesizedExpression":
              return n2 && this.raiseRecoverable(e3.start, "Binding parenthesized expression"), this.checkLValSimple(e3.expression, t3, r2);
            default:
              this.raise(e3.start, (n2 ? "Binding" : "Assigning to") + " rvalue");
          }
        }, ee.checkLValPattern = function(e3, t3, r2) {
          switch (void 0 === t3 && (t3 = 0), e3.type) {
            case "ObjectPattern":
              for (var n2 = 0, s2 = e3.properties; n2 < s2.length; n2 += 1) {
                var i2 = s2[n2];
                this.checkLValInnerPattern(i2, t3, r2);
              }
              break;
            case "ArrayPattern":
              for (var o2 = 0, a2 = e3.elements; o2 < a2.length; o2 += 1) {
                var l2 = a2[o2];
                l2 && this.checkLValInnerPattern(l2, t3, r2);
              }
              break;
            default:
              this.checkLValSimple(e3, t3, r2);
          }
        }, ee.checkLValInnerPattern = function(e3, t3, r2) {
          switch (void 0 === t3 && (t3 = 0), e3.type) {
            case "Property":
              this.checkLValInnerPattern(e3.value, t3, r2);
              break;
            case "AssignmentPattern":
              this.checkLValPattern(e3.left, t3, r2);
              break;
            case "RestElement":
              this.checkLValPattern(e3.argument, t3, r2);
              break;
            default:
              this.checkLValPattern(e3, t3, r2);
          }
        };
        var acorn_TokContext = function(e3, t3, r2, n2, s2) {
          this.token = e3, this.isExpr = !!t3, this.preserveSpace = !!r2, this.override = n2, this.generator = !!s2;
        }, te = { b_stat: new acorn_TokContext("{", false), b_expr: new acorn_TokContext("{", true), b_tmpl: new acorn_TokContext("${", false), p_stat: new acorn_TokContext("(", false), p_expr: new acorn_TokContext("(", true), q_tmpl: new acorn_TokContext("`", true, true, function(e3) {
          return e3.tryReadTemplateToken();
        }), f_stat: new acorn_TokContext("function", false), f_expr: new acorn_TokContext("function", true), f_expr_gen: new acorn_TokContext("function", true, false, null, true), f_gen: new acorn_TokContext("function", false, false, null, true) }, re = acorn_Parser.prototype;
        re.initialContext = function() {
          return [te.b_stat];
        }, re.curContext = function() {
          return this.context[this.context.length - 1];
        }, re.braceIsBlock = function(e3) {
          var t3 = this.curContext();
          return t3 === te.f_expr || t3 === te.f_stat || (e3 !== I.colon || t3 !== te.b_stat && t3 !== te.b_expr ? e3 === I._return || e3 === I.name && this.exprAllowed ? D.test(this.input.slice(this.lastTokEnd, this.start)) : e3 === I._else || e3 === I.semi || e3 === I.eof || e3 === I.parenR || e3 === I.arrow || (e3 === I.braceL ? t3 === te.b_stat : e3 !== I._var && e3 !== I._const && e3 !== I.name && !this.exprAllowed) : !t3.isExpr);
        }, re.inGeneratorContext = function() {
          for (var e3 = this.context.length - 1; e3 >= 1; e3--) {
            var t3 = this.context[e3];
            if ("function" === t3.token) return t3.generator;
          }
          return false;
        }, re.updateContext = function(e3) {
          var t3, r2 = this.type;
          r2.keyword && e3 === I.dot ? this.exprAllowed = false : (t3 = r2.updateContext) ? t3.call(this, e3) : this.exprAllowed = r2.beforeExpr;
        }, re.overrideContext = function(e3) {
          this.curContext() !== e3 && (this.context[this.context.length - 1] = e3);
        }, I.parenR.updateContext = I.braceR.updateContext = function() {
          if (1 !== this.context.length) {
            var e3 = this.context.pop();
            e3 === te.b_stat && "function" === this.curContext().token && (e3 = this.context.pop()), this.exprAllowed = !e3.isExpr;
          } else this.exprAllowed = true;
        }, I.braceL.updateContext = function(e3) {
          this.context.push(this.braceIsBlock(e3) ? te.b_stat : te.b_expr), this.exprAllowed = true;
        }, I.dollarBraceL.updateContext = function() {
          this.context.push(te.b_tmpl), this.exprAllowed = true;
        }, I.parenL.updateContext = function(e3) {
          var t3 = e3 === I._if || e3 === I._for || e3 === I._with || e3 === I._while;
          this.context.push(t3 ? te.p_stat : te.p_expr), this.exprAllowed = true;
        }, I.incDec.updateContext = function() {
        }, I._function.updateContext = I._class.updateContext = function(e3) {
          !e3.beforeExpr || e3 === I._else || e3 === I.semi && this.curContext() !== te.p_stat || e3 === I._return && D.test(this.input.slice(this.lastTokEnd, this.start)) || (e3 === I.colon || e3 === I.braceL) && this.curContext() === te.b_stat ? this.context.push(te.f_stat) : this.context.push(te.f_expr), this.exprAllowed = false;
        }, I.colon.updateContext = function() {
          "function" === this.curContext().token && this.context.pop(), this.exprAllowed = true;
        }, I.backQuote.updateContext = function() {
          this.curContext() === te.q_tmpl ? this.context.pop() : this.context.push(te.q_tmpl), this.exprAllowed = false;
        }, I.star.updateContext = function(e3) {
          if (e3 === I._function) {
            var t3 = this.context.length - 1;
            this.context[t3] === te.f_expr ? this.context[t3] = te.f_expr_gen : this.context[t3] = te.f_gen;
          }
          this.exprAllowed = true;
        }, I.name.updateContext = function(e3) {
          var t3 = false;
          this.options.ecmaVersion >= 6 && e3 !== I.dot && ("of" === this.value && !this.exprAllowed || "yield" === this.value && this.inGeneratorContext()) && (t3 = true), this.exprAllowed = t3;
        };
        var ne = acorn_Parser.prototype;
        function isLocalVariableAccess(e3) {
          return "Identifier" === e3.type || "ParenthesizedExpression" === e3.type && isLocalVariableAccess(e3.expression);
        }
        function isPrivateFieldAccess(e3) {
          return "MemberExpression" === e3.type && "PrivateIdentifier" === e3.property.type || "ChainExpression" === e3.type && isPrivateFieldAccess(e3.expression) || "ParenthesizedExpression" === e3.type && isPrivateFieldAccess(e3.expression);
        }
        ne.checkPropClash = function(e3, t3, r2) {
          if (!(this.options.ecmaVersion >= 9 && "SpreadElement" === e3.type || this.options.ecmaVersion >= 6 && (e3.computed || e3.method || e3.shorthand))) {
            var n2, s2 = e3.key;
            switch (s2.type) {
              case "Identifier":
                n2 = s2.name;
                break;
              case "Literal":
                n2 = String(s2.value);
                break;
              default:
                return;
            }
            var i2 = e3.kind;
            if (this.options.ecmaVersion >= 6) "__proto__" === n2 && "init" === i2 && (t3.proto && (r2 ? r2.doubleProto < 0 && (r2.doubleProto = s2.start) : this.raiseRecoverable(s2.start, "Redefinition of __proto__ property")), t3.proto = true);
            else {
              var o2 = t3[n2 = "$" + n2];
              if (o2) ("init" === i2 ? this.strict && o2.init || o2.get || o2.set : o2.init || o2[i2]) && this.raiseRecoverable(s2.start, "Redefinition of property");
              else o2 = t3[n2] = { init: false, get: false, set: false };
              o2[i2] = true;
            }
          }
        }, ne.parseExpression = function(e3, t3) {
          var r2 = this.start, n2 = this.startLoc, s2 = this.parseMaybeAssign(e3, t3);
          if (this.type === I.comma) {
            var i2 = this.startNodeAt(r2, n2);
            for (i2.expressions = [s2]; this.eat(I.comma); ) i2.expressions.push(this.parseMaybeAssign(e3, t3));
            return this.finishNode(i2, "SequenceExpression");
          }
          return s2;
        }, ne.parseMaybeAssign = function(e3, t3, r2) {
          if (this.isContextual("yield")) {
            if (this.inGenerator) return this.parseYield(e3);
            this.exprAllowed = false;
          }
          var n2 = false, s2 = -1, i2 = -1, o2 = -1;
          t3 ? (s2 = t3.parenthesizedAssign, i2 = t3.trailingComma, o2 = t3.doubleProto, t3.parenthesizedAssign = t3.trailingComma = -1) : (t3 = new acorn_DestructuringErrors(), n2 = true);
          var a2 = this.start, l2 = this.startLoc;
          this.type !== I.parenL && this.type !== I.name || (this.potentialArrowAt = this.start, this.potentialArrowInForAwait = "await" === e3);
          var p2 = this.parseMaybeConditional(e3, t3);
          if (r2 && (p2 = r2.call(this, p2, a2, l2)), this.type.isAssign) {
            var c2 = this.startNodeAt(a2, l2);
            return c2.operator = this.value, this.type === I.eq && (p2 = this.toAssignable(p2, false, t3)), n2 || (t3.parenthesizedAssign = t3.trailingComma = t3.doubleProto = -1), t3.shorthandAssign >= p2.start && (t3.shorthandAssign = -1), this.type === I.eq ? this.checkLValPattern(p2) : this.checkLValSimple(p2), c2.left = p2, this.next(), c2.right = this.parseMaybeAssign(e3), o2 > -1 && (t3.doubleProto = o2), this.finishNode(c2, "AssignmentExpression");
          }
          return n2 && this.checkExpressionErrors(t3, true), s2 > -1 && (t3.parenthesizedAssign = s2), i2 > -1 && (t3.trailingComma = i2), p2;
        }, ne.parseMaybeConditional = function(e3, t3) {
          var r2 = this.start, n2 = this.startLoc, s2 = this.parseExprOps(e3, t3);
          if (this.checkExpressionErrors(t3)) return s2;
          if (this.eat(I.question)) {
            var i2 = this.startNodeAt(r2, n2);
            return i2.test = s2, i2.consequent = this.parseMaybeAssign(), this.expect(I.colon), i2.alternate = this.parseMaybeAssign(e3), this.finishNode(i2, "ConditionalExpression");
          }
          return s2;
        }, ne.parseExprOps = function(e3, t3) {
          var r2 = this.start, n2 = this.startLoc, s2 = this.parseMaybeUnary(t3, false, false, e3);
          return this.checkExpressionErrors(t3) || s2.start === r2 && "ArrowFunctionExpression" === s2.type ? s2 : this.parseExprOp(s2, r2, n2, -1, e3);
        }, ne.parseExprOp = function(e3, t3, r2, n2, s2) {
          var i2 = this.type.binop;
          if (null != i2 && (!s2 || this.type !== I._in) && i2 > n2) {
            var o2 = this.type === I.logicalOR || this.type === I.logicalAND, a2 = this.type === I.coalesce;
            a2 && (i2 = I.logicalAND.binop);
            var l2 = this.value;
            this.next();
            var p2 = this.start, c2 = this.startLoc, u2 = this.parseExprOp(this.parseMaybeUnary(null, false, false, s2), p2, c2, i2, s2), d2 = this.buildBinary(t3, r2, e3, u2, l2, o2 || a2);
            return (o2 && this.type === I.coalesce || a2 && (this.type === I.logicalOR || this.type === I.logicalAND)) && this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses"), this.parseExprOp(d2, t3, r2, n2, s2);
          }
          return e3;
        }, ne.buildBinary = function(e3, t3, r2, n2, s2, i2) {
          "PrivateIdentifier" === n2.type && this.raise(n2.start, "Private identifier can only be left side of binary expression");
          var o2 = this.startNodeAt(e3, t3);
          return o2.left = r2, o2.operator = s2, o2.right = n2, this.finishNode(o2, i2 ? "LogicalExpression" : "BinaryExpression");
        }, ne.parseMaybeUnary = function(e3, t3, r2, n2) {
          var s2, i2 = this.start, o2 = this.startLoc;
          if (this.isContextual("await") && this.canAwait) s2 = this.parseAwait(n2), t3 = true;
          else if (this.type.prefix) {
            var a2 = this.startNode(), l2 = this.type === I.incDec;
            a2.operator = this.value, a2.prefix = true, this.next(), a2.argument = this.parseMaybeUnary(null, true, l2, n2), this.checkExpressionErrors(e3, true), l2 ? this.checkLValSimple(a2.argument) : this.strict && "delete" === a2.operator && isLocalVariableAccess(a2.argument) ? this.raiseRecoverable(a2.start, "Deleting local variable in strict mode") : "delete" === a2.operator && isPrivateFieldAccess(a2.argument) ? this.raiseRecoverable(a2.start, "Private fields can not be deleted") : t3 = true, s2 = this.finishNode(a2, l2 ? "UpdateExpression" : "UnaryExpression");
          } else if (t3 || this.type !== I.privateId) {
            if (s2 = this.parseExprSubscripts(e3, n2), this.checkExpressionErrors(e3)) return s2;
            for (; this.type.postfix && !this.canInsertSemicolon(); ) {
              var p2 = this.startNodeAt(i2, o2);
              p2.operator = this.value, p2.prefix = false, p2.argument = s2, this.checkLValSimple(s2), this.next(), s2 = this.finishNode(p2, "UpdateExpression");
            }
          } else (n2 || 0 === this.privateNameStack.length) && this.options.checkPrivateFields && this.unexpected(), s2 = this.parsePrivateIdent(), this.type !== I._in && this.unexpected();
          return r2 || !this.eat(I.starstar) ? s2 : t3 ? void this.unexpected(this.lastTokStart) : this.buildBinary(i2, o2, s2, this.parseMaybeUnary(null, false, false, n2), "**", false);
        }, ne.parseExprSubscripts = function(e3, t3) {
          var r2 = this.start, n2 = this.startLoc, s2 = this.parseExprAtom(e3, t3);
          if ("ArrowFunctionExpression" === s2.type && ")" !== this.input.slice(this.lastTokStart, this.lastTokEnd)) return s2;
          var i2 = this.parseSubscripts(s2, r2, n2, false, t3);
          return e3 && "MemberExpression" === i2.type && (e3.parenthesizedAssign >= i2.start && (e3.parenthesizedAssign = -1), e3.parenthesizedBind >= i2.start && (e3.parenthesizedBind = -1), e3.trailingComma >= i2.start && (e3.trailingComma = -1)), i2;
        }, ne.parseSubscripts = function(e3, t3, r2, n2, s2) {
          for (var i2 = this.options.ecmaVersion >= 8 && "Identifier" === e3.type && "async" === e3.name && this.lastTokEnd === e3.end && !this.canInsertSemicolon() && e3.end - e3.start === 5 && this.potentialArrowAt === e3.start, o2 = false; ; ) {
            var a2 = this.parseSubscript(e3, t3, r2, n2, i2, o2, s2);
            if (a2.optional && (o2 = true), a2 === e3 || "ArrowFunctionExpression" === a2.type) {
              if (o2) {
                var l2 = this.startNodeAt(t3, r2);
                l2.expression = a2, a2 = this.finishNode(l2, "ChainExpression");
              }
              return a2;
            }
            e3 = a2;
          }
        }, ne.shouldParseAsyncArrow = function() {
          return !this.canInsertSemicolon() && this.eat(I.arrow);
        }, ne.parseSubscriptAsyncArrow = function(e3, t3, r2, n2) {
          return this.parseArrowExpression(this.startNodeAt(e3, t3), r2, true, n2);
        }, ne.parseSubscript = function(e3, t3, r2, n2, s2, i2, o2) {
          var a2 = this.options.ecmaVersion >= 11, l2 = a2 && this.eat(I.questionDot);
          n2 && l2 && this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
          var p2 = this.eat(I.bracketL);
          if (p2 || l2 && this.type !== I.parenL && this.type !== I.backQuote || this.eat(I.dot)) {
            var c2 = this.startNodeAt(t3, r2);
            c2.object = e3, p2 ? (c2.property = this.parseExpression(), this.expect(I.bracketR)) : this.type === I.privateId && "Super" !== e3.type ? c2.property = this.parsePrivateIdent() : c2.property = this.parseIdent("never" !== this.options.allowReserved), c2.computed = !!p2, a2 && (c2.optional = l2), e3 = this.finishNode(c2, "MemberExpression");
          } else if (!n2 && this.eat(I.parenL)) {
            var u2 = new acorn_DestructuringErrors(), d2 = this.yieldPos, h2 = this.awaitPos, m2 = this.awaitIdentPos;
            this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0;
            var f2 = this.parseExprList(I.parenR, this.options.ecmaVersion >= 8, false, u2);
            if (s2 && !l2 && this.shouldParseAsyncArrow()) return this.checkPatternErrors(u2, false), this.checkYieldAwaitInDefaultParams(), this.awaitIdentPos > 0 && this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"), this.yieldPos = d2, this.awaitPos = h2, this.awaitIdentPos = m2, this.parseSubscriptAsyncArrow(t3, r2, f2, o2);
            this.checkExpressionErrors(u2, true), this.yieldPos = d2 || this.yieldPos, this.awaitPos = h2 || this.awaitPos, this.awaitIdentPos = m2 || this.awaitIdentPos;
            var y2 = this.startNodeAt(t3, r2);
            y2.callee = e3, y2.arguments = f2, a2 && (y2.optional = l2), e3 = this.finishNode(y2, "CallExpression");
          } else if (this.type === I.backQuote) {
            (l2 || i2) && this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
            var b2 = this.startNodeAt(t3, r2);
            b2.tag = e3, b2.quasi = this.parseTemplate({ isTagged: true }), e3 = this.finishNode(b2, "TaggedTemplateExpression");
          }
          return e3;
        }, ne.parseExprAtom = function(e3, t3, r2) {
          this.type === I.slash && this.readRegexp();
          var n2, s2 = this.potentialArrowAt === this.start;
          switch (this.type) {
            case I._super:
              return this.allowSuper || this.raise(this.start, "'super' keyword outside a method"), n2 = this.startNode(), this.next(), this.type !== I.parenL || this.allowDirectSuper || this.raise(n2.start, "super() call outside constructor of a subclass"), this.type !== I.dot && this.type !== I.bracketL && this.type !== I.parenL && this.unexpected(), this.finishNode(n2, "Super");
            case I._this:
              return n2 = this.startNode(), this.next(), this.finishNode(n2, "ThisExpression");
            case I.name:
              var i2 = this.start, o2 = this.startLoc, a2 = this.containsEsc, l2 = this.parseIdent(false);
              if (this.options.ecmaVersion >= 8 && !a2 && "async" === l2.name && !this.canInsertSemicolon() && this.eat(I._function)) return this.overrideContext(te.f_expr), this.parseFunction(this.startNodeAt(i2, o2), 0, false, true, t3);
              if (s2 && !this.canInsertSemicolon()) {
                if (this.eat(I.arrow)) return this.parseArrowExpression(this.startNodeAt(i2, o2), [l2], false, t3);
                if (this.options.ecmaVersion >= 8 && "async" === l2.name && this.type === I.name && !a2 && (!this.potentialArrowInForAwait || "of" !== this.value || this.containsEsc)) return l2 = this.parseIdent(false), !this.canInsertSemicolon() && this.eat(I.arrow) || this.unexpected(), this.parseArrowExpression(this.startNodeAt(i2, o2), [l2], true, t3);
              }
              return l2;
            case I.regexp:
              var p2 = this.value;
              return (n2 = this.parseLiteral(p2.value)).regex = { pattern: p2.pattern, flags: p2.flags }, n2;
            case I.num:
            case I.string:
              return this.parseLiteral(this.value);
            case I._null:
            case I._true:
            case I._false:
              return (n2 = this.startNode()).value = this.type === I._null ? null : this.type === I._true, n2.raw = this.type.keyword, this.next(), this.finishNode(n2, "Literal");
            case I.parenL:
              var c2 = this.start, u2 = this.parseParenAndDistinguishExpression(s2, t3);
              return e3 && (e3.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(u2) && (e3.parenthesizedAssign = c2), e3.parenthesizedBind < 0 && (e3.parenthesizedBind = c2)), u2;
            case I.bracketL:
              return n2 = this.startNode(), this.next(), n2.elements = this.parseExprList(I.bracketR, true, true, e3), this.finishNode(n2, "ArrayExpression");
            case I.braceL:
              return this.overrideContext(te.b_expr), this.parseObj(false, e3);
            case I._function:
              return n2 = this.startNode(), this.next(), this.parseFunction(n2, 0);
            case I._class:
              return this.parseClass(this.startNode(), false);
            case I._new:
              return this.parseNew();
            case I.backQuote:
              return this.parseTemplate();
            case I._import:
              return this.options.ecmaVersion >= 11 ? this.parseExprImport(r2) : this.unexpected();
            default:
              return this.parseExprAtomDefault();
          }
        }, ne.parseExprAtomDefault = function() {
          this.unexpected();
        }, ne.parseExprImport = function(e3) {
          var t3 = this.startNode();
          if (this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword import"), this.next(), this.type === I.parenL && !e3) return this.parseDynamicImport(t3);
          if (this.type === I.dot) {
            var r2 = this.startNodeAt(t3.start, t3.loc && t3.loc.start);
            return r2.name = "import", t3.meta = this.finishNode(r2, "Identifier"), this.parseImportMeta(t3);
          }
          this.unexpected();
        }, ne.parseDynamicImport = function(e3) {
          if (this.next(), e3.source = this.parseMaybeAssign(), this.options.ecmaVersion >= 16) this.eat(I.parenR) ? e3.options = null : (this.expect(I.comma), this.afterTrailingComma(I.parenR) ? e3.options = null : (e3.options = this.parseMaybeAssign(), this.eat(I.parenR) || (this.expect(I.comma), this.afterTrailingComma(I.parenR) || this.unexpected())));
          else if (!this.eat(I.parenR)) {
            var t3 = this.start;
            this.eat(I.comma) && this.eat(I.parenR) ? this.raiseRecoverable(t3, "Trailing comma is not allowed in import()") : this.unexpected(t3);
          }
          return this.finishNode(e3, "ImportExpression");
        }, ne.parseImportMeta = function(e3) {
          this.next();
          var t3 = this.containsEsc;
          return e3.property = this.parseIdent(true), "meta" !== e3.property.name && this.raiseRecoverable(e3.property.start, "The only valid meta property for import is 'import.meta'"), t3 && this.raiseRecoverable(e3.start, "'import.meta' must not contain escaped characters"), "module" === this.options.sourceType || this.options.allowImportExportEverywhere || this.raiseRecoverable(e3.start, "Cannot use 'import.meta' outside a module"), this.finishNode(e3, "MetaProperty");
        }, ne.parseLiteral = function(e3) {
          var t3 = this.startNode();
          return t3.value = e3, t3.raw = this.input.slice(this.start, this.end), 110 === t3.raw.charCodeAt(t3.raw.length - 1) && (t3.bigint = null != t3.value ? t3.value.toString() : t3.raw.slice(0, -1).replace(/_/g, "")), this.next(), this.finishNode(t3, "Literal");
        }, ne.parseParenExpression = function() {
          this.expect(I.parenL);
          var e3 = this.parseExpression();
          return this.expect(I.parenR), e3;
        }, ne.shouldParseArrow = function(e3) {
          return !this.canInsertSemicolon();
        }, ne.parseParenAndDistinguishExpression = function(e3, t3) {
          var r2, n2 = this.start, s2 = this.startLoc, i2 = this.options.ecmaVersion >= 8;
          if (this.options.ecmaVersion >= 6) {
            this.next();
            var o2, a2 = this.start, l2 = this.startLoc, p2 = [], c2 = true, u2 = false, d2 = new acorn_DestructuringErrors(), h2 = this.yieldPos, m2 = this.awaitPos;
            for (this.yieldPos = 0, this.awaitPos = 0; this.type !== I.parenR; ) {
              if (c2 ? c2 = false : this.expect(I.comma), i2 && this.afterTrailingComma(I.parenR, true)) {
                u2 = true;
                break;
              }
              if (this.type === I.ellipsis) {
                o2 = this.start, p2.push(this.parseParenItem(this.parseRestBinding())), this.type === I.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
                break;
              }
              p2.push(this.parseMaybeAssign(false, d2, this.parseParenItem));
            }
            var f2 = this.lastTokEnd, y2 = this.lastTokEndLoc;
            if (this.expect(I.parenR), e3 && this.shouldParseArrow(p2) && this.eat(I.arrow)) return this.checkPatternErrors(d2, false), this.checkYieldAwaitInDefaultParams(), this.yieldPos = h2, this.awaitPos = m2, this.parseParenArrowList(n2, s2, p2, t3);
            p2.length && !u2 || this.unexpected(this.lastTokStart), o2 && this.unexpected(o2), this.checkExpressionErrors(d2, true), this.yieldPos = h2 || this.yieldPos, this.awaitPos = m2 || this.awaitPos, p2.length > 1 ? ((r2 = this.startNodeAt(a2, l2)).expressions = p2, this.finishNodeAt(r2, "SequenceExpression", f2, y2)) : r2 = p2[0];
          } else r2 = this.parseParenExpression();
          if (this.options.preserveParens) {
            var b2 = this.startNodeAt(n2, s2);
            return b2.expression = r2, this.finishNode(b2, "ParenthesizedExpression");
          }
          return r2;
        }, ne.parseParenItem = function(e3) {
          return e3;
        }, ne.parseParenArrowList = function(e3, t3, r2, n2) {
          return this.parseArrowExpression(this.startNodeAt(e3, t3), r2, false, n2);
        };
        var se = [];
        ne.parseNew = function() {
          this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword new");
          var e3 = this.startNode();
          if (this.next(), this.options.ecmaVersion >= 6 && this.type === I.dot) {
            var t3 = this.startNodeAt(e3.start, e3.loc && e3.loc.start);
            t3.name = "new", e3.meta = this.finishNode(t3, "Identifier"), this.next();
            var r2 = this.containsEsc;
            return e3.property = this.parseIdent(true), "target" !== e3.property.name && this.raiseRecoverable(e3.property.start, "The only valid meta property for new is 'new.target'"), r2 && this.raiseRecoverable(e3.start, "'new.target' must not contain escaped characters"), this.allowNewDotTarget || this.raiseRecoverable(e3.start, "'new.target' can only be used in functions and class static block"), this.finishNode(e3, "MetaProperty");
          }
          var n2 = this.start, s2 = this.startLoc;
          return e3.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), n2, s2, true, false), this.eat(I.parenL) ? e3.arguments = this.parseExprList(I.parenR, this.options.ecmaVersion >= 8, false) : e3.arguments = se, this.finishNode(e3, "NewExpression");
        }, ne.parseTemplateElement = function(e3) {
          var t3 = e3.isTagged, r2 = this.startNode();
          return this.type === I.invalidTemplate ? (t3 || this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal"), r2.value = { raw: this.value.replace(/\r\n?/g, "\n"), cooked: null }) : r2.value = { raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"), cooked: this.value }, this.next(), r2.tail = this.type === I.backQuote, this.finishNode(r2, "TemplateElement");
        }, ne.parseTemplate = function(e3) {
          void 0 === e3 && (e3 = {});
          var t3 = e3.isTagged;
          void 0 === t3 && (t3 = false);
          var r2 = this.startNode();
          this.next(), r2.expressions = [];
          var n2 = this.parseTemplateElement({ isTagged: t3 });
          for (r2.quasis = [n2]; !n2.tail; ) this.type === I.eof && this.raise(this.pos, "Unterminated template literal"), this.expect(I.dollarBraceL), r2.expressions.push(this.parseExpression()), this.expect(I.braceR), r2.quasis.push(n2 = this.parseTemplateElement({ isTagged: t3 }));
          return this.next(), this.finishNode(r2, "TemplateLiteral");
        }, ne.isAsyncProp = function(e3) {
          return !e3.computed && "Identifier" === e3.key.type && "async" === e3.key.name && (this.type === I.name || this.type === I.num || this.type === I.string || this.type === I.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === I.star) && !D.test(this.input.slice(this.lastTokEnd, this.start));
        }, ne.parseObj = function(e3, t3) {
          var r2 = this.startNode(), n2 = true, s2 = {};
          for (r2.properties = [], this.next(); !this.eat(I.braceR); ) {
            if (n2) n2 = false;
            else if (this.expect(I.comma), this.options.ecmaVersion >= 5 && this.afterTrailingComma(I.braceR)) break;
            var i2 = this.parseProperty(e3, t3);
            e3 || this.checkPropClash(i2, s2, t3), r2.properties.push(i2);
          }
          return this.finishNode(r2, e3 ? "ObjectPattern" : "ObjectExpression");
        }, ne.parseProperty = function(e3, t3) {
          var r2, n2, s2, i2, o2 = this.startNode();
          if (this.options.ecmaVersion >= 9 && this.eat(I.ellipsis)) return e3 ? (o2.argument = this.parseIdent(false), this.type === I.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"), this.finishNode(o2, "RestElement")) : (o2.argument = this.parseMaybeAssign(false, t3), this.type === I.comma && t3 && t3.trailingComma < 0 && (t3.trailingComma = this.start), this.finishNode(o2, "SpreadElement"));
          this.options.ecmaVersion >= 6 && (o2.method = false, o2.shorthand = false, (e3 || t3) && (s2 = this.start, i2 = this.startLoc), e3 || (r2 = this.eat(I.star)));
          var a2 = this.containsEsc;
          return this.parsePropertyName(o2), !e3 && !a2 && this.options.ecmaVersion >= 8 && !r2 && this.isAsyncProp(o2) ? (n2 = true, r2 = this.options.ecmaVersion >= 9 && this.eat(I.star), this.parsePropertyName(o2)) : n2 = false, this.parsePropertyValue(o2, e3, r2, n2, s2, i2, t3, a2), this.finishNode(o2, "Property");
        }, ne.parseGetterSetter = function(e3) {
          var t3 = e3.key.name;
          this.parsePropertyName(e3), e3.value = this.parseMethod(false), e3.kind = t3;
          var r2 = "get" === e3.kind ? 0 : 1;
          if (e3.value.params.length !== r2) {
            var n2 = e3.value.start;
            "get" === e3.kind ? this.raiseRecoverable(n2, "getter should have no params") : this.raiseRecoverable(n2, "setter should have exactly one param");
          } else "set" === e3.kind && "RestElement" === e3.value.params[0].type && this.raiseRecoverable(e3.value.params[0].start, "Setter cannot use rest params");
        }, ne.parsePropertyValue = function(e3, t3, r2, n2, s2, i2, o2, a2) {
          (r2 || n2) && this.type === I.colon && this.unexpected(), this.eat(I.colon) ? (e3.value = t3 ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, o2), e3.kind = "init") : this.options.ecmaVersion >= 6 && this.type === I.parenL ? (t3 && this.unexpected(), e3.method = true, e3.value = this.parseMethod(r2, n2), e3.kind = "init") : t3 || a2 || !(this.options.ecmaVersion >= 5) || e3.computed || "Identifier" !== e3.key.type || "get" !== e3.key.name && "set" !== e3.key.name || this.type === I.comma || this.type === I.braceR || this.type === I.eq ? this.options.ecmaVersion >= 6 && !e3.computed && "Identifier" === e3.key.type ? ((r2 || n2) && this.unexpected(), this.checkUnreserved(e3.key), "await" !== e3.key.name || this.awaitIdentPos || (this.awaitIdentPos = s2), t3 ? e3.value = this.parseMaybeDefault(s2, i2, this.copyNode(e3.key)) : this.type === I.eq && o2 ? (o2.shorthandAssign < 0 && (o2.shorthandAssign = this.start), e3.value = this.parseMaybeDefault(s2, i2, this.copyNode(e3.key))) : e3.value = this.copyNode(e3.key), e3.kind = "init", e3.shorthand = true) : this.unexpected() : ((r2 || n2) && this.unexpected(), this.parseGetterSetter(e3));
        }, ne.parsePropertyName = function(e3) {
          if (this.options.ecmaVersion >= 6) {
            if (this.eat(I.bracketL)) return e3.computed = true, e3.key = this.parseMaybeAssign(), this.expect(I.bracketR), e3.key;
            e3.computed = false;
          }
          return e3.key = this.type === I.num || this.type === I.string ? this.parseExprAtom() : this.parseIdent("never" !== this.options.allowReserved);
        }, ne.initFunction = function(e3) {
          e3.id = null, this.options.ecmaVersion >= 6 && (e3.generator = e3.expression = false), this.options.ecmaVersion >= 8 && (e3.async = false);
        }, ne.parseMethod = function(e3, t3, r2) {
          var n2 = this.startNode(), s2 = this.yieldPos, i2 = this.awaitPos, o2 = this.awaitIdentPos;
          return this.initFunction(n2), this.options.ecmaVersion >= 6 && (n2.generator = e3), this.options.ecmaVersion >= 8 && (n2.async = !!t3), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(64 | functionFlags(t3, n2.generator) | (r2 ? 128 : 0)), this.expect(I.parenL), n2.params = this.parseBindingList(I.parenR, false, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams(), this.parseFunctionBody(n2, false, true, false), this.yieldPos = s2, this.awaitPos = i2, this.awaitIdentPos = o2, this.finishNode(n2, "FunctionExpression");
        }, ne.parseArrowExpression = function(e3, t3, r2, n2) {
          var s2 = this.yieldPos, i2 = this.awaitPos, o2 = this.awaitIdentPos;
          return this.enterScope(16 | functionFlags(r2, false)), this.initFunction(e3), this.options.ecmaVersion >= 8 && (e3.async = !!r2), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, e3.params = this.toAssignableList(t3, true), this.parseFunctionBody(e3, true, false, n2), this.yieldPos = s2, this.awaitPos = i2, this.awaitIdentPos = o2, this.finishNode(e3, "ArrowFunctionExpression");
        }, ne.parseFunctionBody = function(e3, t3, r2, n2) {
          var s2 = t3 && this.type !== I.braceL, i2 = this.strict, o2 = false;
          if (s2) e3.body = this.parseMaybeAssign(n2), e3.expression = true, this.checkParams(e3, false);
          else {
            var a2 = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(e3.params);
            i2 && !a2 || (o2 = this.strictDirective(this.end)) && a2 && this.raiseRecoverable(e3.start, "Illegal 'use strict' directive in function with non-simple parameter list");
            var l2 = this.labels;
            this.labels = [], o2 && (this.strict = true), this.checkParams(e3, !i2 && !o2 && !t3 && !r2 && this.isSimpleParamList(e3.params)), this.strict && e3.id && this.checkLValSimple(e3.id, 5), e3.body = this.parseBlock(false, void 0, o2 && !i2), e3.expression = false, this.adaptDirectivePrologue(e3.body.body), this.labels = l2;
          }
          this.exitScope();
        }, ne.isSimpleParamList = function(e3) {
          for (var t3 = 0, r2 = e3; t3 < r2.length; t3 += 1) {
            if ("Identifier" !== r2[t3].type) return false;
          }
          return true;
        }, ne.checkParams = function(e3, t3) {
          for (var r2 = /* @__PURE__ */ Object.create(null), n2 = 0, s2 = e3.params; n2 < s2.length; n2 += 1) {
            var i2 = s2[n2];
            this.checkLValInnerPattern(i2, 1, t3 ? null : r2);
          }
        }, ne.parseExprList = function(e3, t3, r2, n2) {
          for (var s2 = [], i2 = true; !this.eat(e3); ) {
            if (i2) i2 = false;
            else if (this.expect(I.comma), t3 && this.afterTrailingComma(e3)) break;
            var o2 = void 0;
            r2 && this.type === I.comma ? o2 = null : this.type === I.ellipsis ? (o2 = this.parseSpread(n2), n2 && this.type === I.comma && n2.trailingComma < 0 && (n2.trailingComma = this.start)) : o2 = this.parseMaybeAssign(false, n2), s2.push(o2);
          }
          return s2;
        }, ne.checkUnreserved = function(e3) {
          var t3 = e3.start, r2 = e3.end, n2 = e3.name;
          (this.inGenerator && "yield" === n2 && this.raiseRecoverable(t3, "Cannot use 'yield' as identifier inside a generator"), this.inAsync && "await" === n2 && this.raiseRecoverable(t3, "Cannot use 'await' as identifier inside an async function"), this.currentThisScope().flags & W || "arguments" !== n2 || this.raiseRecoverable(t3, "Cannot use 'arguments' in class field initializer"), !this.inClassStaticBlock || "arguments" !== n2 && "await" !== n2 || this.raise(t3, "Cannot use " + n2 + " in class static initialization block"), this.keywords.test(n2) && this.raise(t3, "Unexpected keyword '" + n2 + "'"), this.options.ecmaVersion < 6 && -1 !== this.input.slice(t3, r2).indexOf("\\")) || (this.strict ? this.reservedWordsStrict : this.reservedWords).test(n2) && (this.inAsync || "await" !== n2 || this.raiseRecoverable(t3, "Cannot use keyword 'await' outside an async function"), this.raiseRecoverable(t3, "The keyword '" + n2 + "' is reserved"));
        }, ne.parseIdent = function(e3) {
          var t3 = this.parseIdentNode();
          return this.next(!!e3), this.finishNode(t3, "Identifier"), e3 || (this.checkUnreserved(t3), "await" !== t3.name || this.awaitIdentPos || (this.awaitIdentPos = t3.start)), t3;
        }, ne.parseIdentNode = function() {
          var e3 = this.startNode();
          return this.type === I.name ? e3.name = this.value : this.type.keyword ? (e3.name = this.type.keyword, "class" !== e3.name && "function" !== e3.name || this.lastTokEnd === this.lastTokStart + 1 && 46 === this.input.charCodeAt(this.lastTokStart) || this.context.pop(), this.type = I.name) : this.unexpected(), e3;
        }, ne.parsePrivateIdent = function() {
          var e3 = this.startNode();
          return this.type === I.privateId ? e3.name = this.value : this.unexpected(), this.next(), this.finishNode(e3, "PrivateIdentifier"), this.options.checkPrivateFields && (0 === this.privateNameStack.length ? this.raise(e3.start, "Private field '#" + e3.name + "' must be declared in an enclosing class") : this.privateNameStack[this.privateNameStack.length - 1].used.push(e3)), e3;
        }, ne.parseYield = function(e3) {
          this.yieldPos || (this.yieldPos = this.start);
          var t3 = this.startNode();
          return this.next(), this.type === I.semi || this.canInsertSemicolon() || this.type !== I.star && !this.type.startsExpr ? (t3.delegate = false, t3.argument = null) : (t3.delegate = this.eat(I.star), t3.argument = this.parseMaybeAssign(e3)), this.finishNode(t3, "YieldExpression");
        }, ne.parseAwait = function(e3) {
          this.awaitPos || (this.awaitPos = this.start);
          var t3 = this.startNode();
          return this.next(), t3.argument = this.parseMaybeUnary(null, true, false, e3), this.finishNode(t3, "AwaitExpression");
        };
        var ie = acorn_Parser.prototype;
        ie.raise = function(e3, t3) {
          var r2 = getLineInfo(this.input, e3);
          t3 += " (" + r2.line + ":" + r2.column + ")", this.sourceFile && (t3 += " in " + this.sourceFile);
          var n2 = new SyntaxError(t3);
          throw n2.pos = e3, n2.loc = r2, n2.raisedAt = this.pos, n2;
        }, ie.raiseRecoverable = ie.raise, ie.curPosition = function() {
          if (this.options.locations) return new acorn_Position(this.curLine, this.pos - this.lineStart);
        };
        var oe = acorn_Parser.prototype, acorn_Scope = function(e3) {
          this.flags = e3, this.var = [], this.lexical = [], this.functions = [];
        };
        oe.enterScope = function(e3) {
          this.scopeStack.push(new acorn_Scope(e3));
        }, oe.exitScope = function() {
          this.scopeStack.pop();
        }, oe.treatFunctionsAsVarInScope = function(e3) {
          return 2 & e3.flags || !this.inModule && 1 & e3.flags;
        }, oe.declareName = function(e3, t3, r2) {
          var n2 = false;
          if (2 === t3) {
            var s2 = this.currentScope();
            n2 = s2.lexical.indexOf(e3) > -1 || s2.functions.indexOf(e3) > -1 || s2.var.indexOf(e3) > -1, s2.lexical.push(e3), this.inModule && 1 & s2.flags && delete this.undefinedExports[e3];
          } else if (4 === t3) {
            this.currentScope().lexical.push(e3);
          } else if (3 === t3) {
            var i2 = this.currentScope();
            n2 = this.treatFunctionsAsVar ? i2.lexical.indexOf(e3) > -1 : i2.lexical.indexOf(e3) > -1 || i2.var.indexOf(e3) > -1, i2.functions.push(e3);
          } else for (var o2 = this.scopeStack.length - 1; o2 >= 0; --o2) {
            var a2 = this.scopeStack[o2];
            if (a2.lexical.indexOf(e3) > -1 && !(32 & a2.flags && a2.lexical[0] === e3) || !this.treatFunctionsAsVarInScope(a2) && a2.functions.indexOf(e3) > -1) {
              n2 = true;
              break;
            }
            if (a2.var.push(e3), this.inModule && 1 & a2.flags && delete this.undefinedExports[e3], a2.flags & W) break;
          }
          n2 && this.raiseRecoverable(r2, "Identifier '" + e3 + "' has already been declared");
        }, oe.checkLocalExport = function(e3) {
          -1 === this.scopeStack[0].lexical.indexOf(e3.name) && -1 === this.scopeStack[0].var.indexOf(e3.name) && (this.undefinedExports[e3.name] = e3);
        }, oe.currentScope = function() {
          return this.scopeStack[this.scopeStack.length - 1];
        }, oe.currentVarScope = function() {
          for (var e3 = this.scopeStack.length - 1; ; e3--) {
            var t3 = this.scopeStack[e3];
            if (771 & t3.flags) return t3;
          }
        }, oe.currentThisScope = function() {
          for (var e3 = this.scopeStack.length - 1; ; e3--) {
            var t3 = this.scopeStack[e3];
            if (771 & t3.flags && !(16 & t3.flags)) return t3;
          }
        };
        var acorn_Node = function(e3, t3, r2) {
          this.type = "", this.start = t3, this.end = 0, e3.options.locations && (this.loc = new acorn_SourceLocation(e3, r2)), e3.options.directSourceFile && (this.sourceFile = e3.options.directSourceFile), e3.options.ranges && (this.range = [t3, 0]);
        }, ae = acorn_Parser.prototype;
        function finishNodeAt(e3, t3, r2, n2) {
          return e3.type = t3, e3.end = r2, this.options.locations && (e3.loc.end = n2), this.options.ranges && (e3.range[1] = r2), e3;
        }
        ae.startNode = function() {
          return new acorn_Node(this, this.start, this.startLoc);
        }, ae.startNodeAt = function(e3, t3) {
          return new acorn_Node(this, e3, t3);
        }, ae.finishNode = function(e3, t3) {
          return finishNodeAt.call(this, e3, t3, this.lastTokEnd, this.lastTokEndLoc);
        }, ae.finishNodeAt = function(e3, t3, r2, n2) {
          return finishNodeAt.call(this, e3, t3, r2, n2);
        }, ae.copyNode = function(e3) {
          var t3 = new acorn_Node(this, e3.start, this.startLoc);
          for (var r2 in e3) t3[r2] = e3[r2];
          return t3;
        };
        var le = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS", pe = le + " Extended_Pictographic", ce = pe + " EBase EComp EMod EPres ExtPict", ue = { 9: le, 10: pe, 11: pe, 12: ce, 13: ce, 14: ce }, de = { 9: "", 10: "", 11: "", 12: "", 13: "", 14: "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji" }, he = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu", me = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb", fe = me + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd", ye = fe + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho", be = ye + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi", ge = be + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith", xe = { 9: me, 10: fe, 11: ye, 12: be, 13: ge, 14: ge + " Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz" }, ve = {};
        function buildUnicodeData(e3) {
          var t3 = ve[e3] = { binary: wordsRegexp(ue[e3] + " " + he), binaryOfStrings: wordsRegexp(de[e3]), nonBinary: { General_Category: wordsRegexp(he), Script: wordsRegexp(xe[e3]) } };
          t3.nonBinary.Script_Extensions = t3.nonBinary.Script, t3.nonBinary.gc = t3.nonBinary.General_Category, t3.nonBinary.sc = t3.nonBinary.Script, t3.nonBinary.scx = t3.nonBinary.Script_Extensions;
        }
        for (var Ee = 0, Te = [9, 10, 11, 12, 13, 14]; Ee < Te.length; Ee += 1) {
          buildUnicodeData(Te[Ee]);
        }
        var Se = acorn_Parser.prototype, acorn_BranchID = function(e3, t3) {
          this.parent = e3, this.base = t3 || this;
        };
        acorn_BranchID.prototype.separatedFrom = function(e3) {
          for (var t3 = this; t3; t3 = t3.parent) for (var r2 = e3; r2; r2 = r2.parent) if (t3.base === r2.base && t3 !== r2) return true;
          return false;
        }, acorn_BranchID.prototype.sibling = function() {
          return new acorn_BranchID(this.parent, this.base);
        };
        var acorn_RegExpValidationState = function(e3) {
          this.parser = e3, this.validFlags = "gim" + (e3.options.ecmaVersion >= 6 ? "uy" : "") + (e3.options.ecmaVersion >= 9 ? "s" : "") + (e3.options.ecmaVersion >= 13 ? "d" : "") + (e3.options.ecmaVersion >= 15 ? "v" : ""), this.unicodeProperties = ve[e3.options.ecmaVersion >= 14 ? 14 : e3.options.ecmaVersion], this.source = "", this.flags = "", this.start = 0, this.switchU = false, this.switchV = false, this.switchN = false, this.pos = 0, this.lastIntValue = 0, this.lastStringValue = "", this.lastAssertionIsQuantifiable = false, this.numCapturingParens = 0, this.maxBackReference = 0, this.groupNames = /* @__PURE__ */ Object.create(null), this.backReferenceNames = [], this.branchID = null;
        };
        function isRegularExpressionModifier(e3) {
          return 105 === e3 || 109 === e3 || 115 === e3;
        }
        function isSyntaxCharacter(e3) {
          return 36 === e3 || e3 >= 40 && e3 <= 43 || 46 === e3 || 63 === e3 || e3 >= 91 && e3 <= 94 || e3 >= 123 && e3 <= 125;
        }
        function isControlLetter(e3) {
          return e3 >= 65 && e3 <= 90 || e3 >= 97 && e3 <= 122;
        }
        acorn_RegExpValidationState.prototype.reset = function(e3, t3, r2) {
          var n2 = -1 !== r2.indexOf("v"), s2 = -1 !== r2.indexOf("u");
          this.start = 0 | e3, this.source = t3 + "", this.flags = r2, n2 && this.parser.options.ecmaVersion >= 15 ? (this.switchU = true, this.switchV = true, this.switchN = true) : (this.switchU = s2 && this.parser.options.ecmaVersion >= 6, this.switchV = false, this.switchN = s2 && this.parser.options.ecmaVersion >= 9);
        }, acorn_RegExpValidationState.prototype.raise = function(e3) {
          this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + e3);
        }, acorn_RegExpValidationState.prototype.at = function(e3, t3) {
          void 0 === t3 && (t3 = false);
          var r2 = this.source, n2 = r2.length;
          if (e3 >= n2) return -1;
          var s2 = r2.charCodeAt(e3);
          if (!t3 && !this.switchU || s2 <= 55295 || s2 >= 57344 || e3 + 1 >= n2) return s2;
          var i2 = r2.charCodeAt(e3 + 1);
          return i2 >= 56320 && i2 <= 57343 ? (s2 << 10) + i2 - 56613888 : s2;
        }, acorn_RegExpValidationState.prototype.nextIndex = function(e3, t3) {
          void 0 === t3 && (t3 = false);
          var r2 = this.source, n2 = r2.length;
          if (e3 >= n2) return n2;
          var s2, i2 = r2.charCodeAt(e3);
          return !t3 && !this.switchU || i2 <= 55295 || i2 >= 57344 || e3 + 1 >= n2 || (s2 = r2.charCodeAt(e3 + 1)) < 56320 || s2 > 57343 ? e3 + 1 : e3 + 2;
        }, acorn_RegExpValidationState.prototype.current = function(e3) {
          return void 0 === e3 && (e3 = false), this.at(this.pos, e3);
        }, acorn_RegExpValidationState.prototype.lookahead = function(e3) {
          return void 0 === e3 && (e3 = false), this.at(this.nextIndex(this.pos, e3), e3);
        }, acorn_RegExpValidationState.prototype.advance = function(e3) {
          void 0 === e3 && (e3 = false), this.pos = this.nextIndex(this.pos, e3);
        }, acorn_RegExpValidationState.prototype.eat = function(e3, t3) {
          return void 0 === t3 && (t3 = false), this.current(t3) === e3 && (this.advance(t3), true);
        }, acorn_RegExpValidationState.prototype.eatChars = function(e3, t3) {
          void 0 === t3 && (t3 = false);
          for (var r2 = this.pos, n2 = 0, s2 = e3; n2 < s2.length; n2 += 1) {
            var i2 = s2[n2], o2 = this.at(r2, t3);
            if (-1 === o2 || o2 !== i2) return false;
            r2 = this.nextIndex(r2, t3);
          }
          return this.pos = r2, true;
        }, Se.validateRegExpFlags = function(e3) {
          for (var t3 = e3.validFlags, r2 = e3.flags, n2 = false, s2 = false, i2 = 0; i2 < r2.length; i2++) {
            var o2 = r2.charAt(i2);
            -1 === t3.indexOf(o2) && this.raise(e3.start, "Invalid regular expression flag"), r2.indexOf(o2, i2 + 1) > -1 && this.raise(e3.start, "Duplicate regular expression flag"), "u" === o2 && (n2 = true), "v" === o2 && (s2 = true);
          }
          this.options.ecmaVersion >= 15 && n2 && s2 && this.raise(e3.start, "Invalid regular expression flag");
        }, Se.validateRegExpPattern = function(e3) {
          this.regexp_pattern(e3), !e3.switchN && this.options.ecmaVersion >= 9 && (function(e4) {
            for (var t3 in e4) return true;
            return false;
          })(e3.groupNames) && (e3.switchN = true, this.regexp_pattern(e3));
        }, Se.regexp_pattern = function(e3) {
          e3.pos = 0, e3.lastIntValue = 0, e3.lastStringValue = "", e3.lastAssertionIsQuantifiable = false, e3.numCapturingParens = 0, e3.maxBackReference = 0, e3.groupNames = /* @__PURE__ */ Object.create(null), e3.backReferenceNames.length = 0, e3.branchID = null, this.regexp_disjunction(e3), e3.pos !== e3.source.length && (e3.eat(41) && e3.raise("Unmatched ')'"), (e3.eat(93) || e3.eat(125)) && e3.raise("Lone quantifier brackets")), e3.maxBackReference > e3.numCapturingParens && e3.raise("Invalid escape");
          for (var t3 = 0, r2 = e3.backReferenceNames; t3 < r2.length; t3 += 1) {
            var n2 = r2[t3];
            e3.groupNames[n2] || e3.raise("Invalid named capture referenced");
          }
        }, Se.regexp_disjunction = function(e3) {
          var t3 = this.options.ecmaVersion >= 16;
          for (t3 && (e3.branchID = new acorn_BranchID(e3.branchID, null)), this.regexp_alternative(e3); e3.eat(124); ) t3 && (e3.branchID = e3.branchID.sibling()), this.regexp_alternative(e3);
          t3 && (e3.branchID = e3.branchID.parent), this.regexp_eatQuantifier(e3, true) && e3.raise("Nothing to repeat"), e3.eat(123) && e3.raise("Lone quantifier brackets");
        }, Se.regexp_alternative = function(e3) {
          for (; e3.pos < e3.source.length && this.regexp_eatTerm(e3); ) ;
        }, Se.regexp_eatTerm = function(e3) {
          return this.regexp_eatAssertion(e3) ? (e3.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(e3) && e3.switchU && e3.raise("Invalid quantifier"), true) : !!(e3.switchU ? this.regexp_eatAtom(e3) : this.regexp_eatExtendedAtom(e3)) && (this.regexp_eatQuantifier(e3), true);
        }, Se.regexp_eatAssertion = function(e3) {
          var t3 = e3.pos;
          if (e3.lastAssertionIsQuantifiable = false, e3.eat(94) || e3.eat(36)) return true;
          if (e3.eat(92)) {
            if (e3.eat(66) || e3.eat(98)) return true;
            e3.pos = t3;
          }
          if (e3.eat(40) && e3.eat(63)) {
            var r2 = false;
            if (this.options.ecmaVersion >= 9 && (r2 = e3.eat(60)), e3.eat(61) || e3.eat(33)) return this.regexp_disjunction(e3), e3.eat(41) || e3.raise("Unterminated group"), e3.lastAssertionIsQuantifiable = !r2, true;
          }
          return e3.pos = t3, false;
        }, Se.regexp_eatQuantifier = function(e3, t3) {
          return void 0 === t3 && (t3 = false), !!this.regexp_eatQuantifierPrefix(e3, t3) && (e3.eat(63), true);
        }, Se.regexp_eatQuantifierPrefix = function(e3, t3) {
          return e3.eat(42) || e3.eat(43) || e3.eat(63) || this.regexp_eatBracedQuantifier(e3, t3);
        }, Se.regexp_eatBracedQuantifier = function(e3, t3) {
          var r2 = e3.pos;
          if (e3.eat(123)) {
            var n2 = 0, s2 = -1;
            if (this.regexp_eatDecimalDigits(e3) && (n2 = e3.lastIntValue, e3.eat(44) && this.regexp_eatDecimalDigits(e3) && (s2 = e3.lastIntValue), e3.eat(125))) return -1 !== s2 && s2 < n2 && !t3 && e3.raise("numbers out of order in {} quantifier"), true;
            e3.switchU && !t3 && e3.raise("Incomplete quantifier"), e3.pos = r2;
          }
          return false;
        }, Se.regexp_eatAtom = function(e3) {
          return this.regexp_eatPatternCharacters(e3) || e3.eat(46) || this.regexp_eatReverseSolidusAtomEscape(e3) || this.regexp_eatCharacterClass(e3) || this.regexp_eatUncapturingGroup(e3) || this.regexp_eatCapturingGroup(e3);
        }, Se.regexp_eatReverseSolidusAtomEscape = function(e3) {
          var t3 = e3.pos;
          if (e3.eat(92)) {
            if (this.regexp_eatAtomEscape(e3)) return true;
            e3.pos = t3;
          }
          return false;
        }, Se.regexp_eatUncapturingGroup = function(e3) {
          var t3 = e3.pos;
          if (e3.eat(40)) {
            if (e3.eat(63)) {
              if (this.options.ecmaVersion >= 16) {
                var r2 = this.regexp_eatModifiers(e3), n2 = e3.eat(45);
                if (r2 || n2) {
                  for (var s2 = 0; s2 < r2.length; s2++) {
                    var i2 = r2.charAt(s2);
                    r2.indexOf(i2, s2 + 1) > -1 && e3.raise("Duplicate regular expression modifiers");
                  }
                  if (n2) {
                    var o2 = this.regexp_eatModifiers(e3);
                    r2 || o2 || 58 !== e3.current() || e3.raise("Invalid regular expression modifiers");
                    for (var a2 = 0; a2 < o2.length; a2++) {
                      var l2 = o2.charAt(a2);
                      (o2.indexOf(l2, a2 + 1) > -1 || r2.indexOf(l2) > -1) && e3.raise("Duplicate regular expression modifiers");
                    }
                  }
                }
              }
              if (e3.eat(58)) {
                if (this.regexp_disjunction(e3), e3.eat(41)) return true;
                e3.raise("Unterminated group");
              }
            }
            e3.pos = t3;
          }
          return false;
        }, Se.regexp_eatCapturingGroup = function(e3) {
          if (e3.eat(40)) {
            if (this.options.ecmaVersion >= 9 ? this.regexp_groupSpecifier(e3) : 63 === e3.current() && e3.raise("Invalid group"), this.regexp_disjunction(e3), e3.eat(41)) return e3.numCapturingParens += 1, true;
            e3.raise("Unterminated group");
          }
          return false;
        }, Se.regexp_eatModifiers = function(e3) {
          for (var t3 = "", r2 = 0; -1 !== (r2 = e3.current()) && isRegularExpressionModifier(r2); ) t3 += codePointToString(r2), e3.advance();
          return t3;
        }, Se.regexp_eatExtendedAtom = function(e3) {
          return e3.eat(46) || this.regexp_eatReverseSolidusAtomEscape(e3) || this.regexp_eatCharacterClass(e3) || this.regexp_eatUncapturingGroup(e3) || this.regexp_eatCapturingGroup(e3) || this.regexp_eatInvalidBracedQuantifier(e3) || this.regexp_eatExtendedPatternCharacter(e3);
        }, Se.regexp_eatInvalidBracedQuantifier = function(e3) {
          return this.regexp_eatBracedQuantifier(e3, true) && e3.raise("Nothing to repeat"), false;
        }, Se.regexp_eatSyntaxCharacter = function(e3) {
          var t3 = e3.current();
          return !!isSyntaxCharacter(t3) && (e3.lastIntValue = t3, e3.advance(), true);
        }, Se.regexp_eatPatternCharacters = function(e3) {
          for (var t3 = e3.pos, r2 = 0; -1 !== (r2 = e3.current()) && !isSyntaxCharacter(r2); ) e3.advance();
          return e3.pos !== t3;
        }, Se.regexp_eatExtendedPatternCharacter = function(e3) {
          var t3 = e3.current();
          return !(-1 === t3 || 36 === t3 || t3 >= 40 && t3 <= 43 || 46 === t3 || 63 === t3 || 91 === t3 || 94 === t3 || 124 === t3) && (e3.advance(), true);
        }, Se.regexp_groupSpecifier = function(e3) {
          if (e3.eat(63)) {
            this.regexp_eatGroupName(e3) || e3.raise("Invalid group");
            var t3 = this.options.ecmaVersion >= 16, r2 = e3.groupNames[e3.lastStringValue];
            if (r2) if (t3) for (var n2 = 0, s2 = r2; n2 < s2.length; n2 += 1) {
              s2[n2].separatedFrom(e3.branchID) || e3.raise("Duplicate capture group name");
            }
            else e3.raise("Duplicate capture group name");
            t3 ? (r2 || (e3.groupNames[e3.lastStringValue] = [])).push(e3.branchID) : e3.groupNames[e3.lastStringValue] = true;
          }
        }, Se.regexp_eatGroupName = function(e3) {
          if (e3.lastStringValue = "", e3.eat(60)) {
            if (this.regexp_eatRegExpIdentifierName(e3) && e3.eat(62)) return true;
            e3.raise("Invalid capture group name");
          }
          return false;
        }, Se.regexp_eatRegExpIdentifierName = function(e3) {
          if (e3.lastStringValue = "", this.regexp_eatRegExpIdentifierStart(e3)) {
            for (e3.lastStringValue += codePointToString(e3.lastIntValue); this.regexp_eatRegExpIdentifierPart(e3); ) e3.lastStringValue += codePointToString(e3.lastIntValue);
            return true;
          }
          return false;
        }, Se.regexp_eatRegExpIdentifierStart = function(e3) {
          var t3 = e3.pos, r2 = this.options.ecmaVersion >= 11, n2 = e3.current(r2);
          return e3.advance(r2), 92 === n2 && this.regexp_eatRegExpUnicodeEscapeSequence(e3, r2) && (n2 = e3.lastIntValue), (function(e4) {
            return isIdentifierStart(e4, true) || 36 === e4 || 95 === e4;
          })(n2) ? (e3.lastIntValue = n2, true) : (e3.pos = t3, false);
        }, Se.regexp_eatRegExpIdentifierPart = function(e3) {
          var t3 = e3.pos, r2 = this.options.ecmaVersion >= 11, n2 = e3.current(r2);
          return e3.advance(r2), 92 === n2 && this.regexp_eatRegExpUnicodeEscapeSequence(e3, r2) && (n2 = e3.lastIntValue), (function(e4) {
            return isIdentifierChar(e4, true) || 36 === e4 || 95 === e4 || 8204 === e4 || 8205 === e4;
          })(n2) ? (e3.lastIntValue = n2, true) : (e3.pos = t3, false);
        }, Se.regexp_eatAtomEscape = function(e3) {
          return !!(this.regexp_eatBackReference(e3) || this.regexp_eatCharacterClassEscape(e3) || this.regexp_eatCharacterEscape(e3) || e3.switchN && this.regexp_eatKGroupName(e3)) || (e3.switchU && (99 === e3.current() && e3.raise("Invalid unicode escape"), e3.raise("Invalid escape")), false);
        }, Se.regexp_eatBackReference = function(e3) {
          var t3 = e3.pos;
          if (this.regexp_eatDecimalEscape(e3)) {
            var r2 = e3.lastIntValue;
            if (e3.switchU) return r2 > e3.maxBackReference && (e3.maxBackReference = r2), true;
            if (r2 <= e3.numCapturingParens) return true;
            e3.pos = t3;
          }
          return false;
        }, Se.regexp_eatKGroupName = function(e3) {
          if (e3.eat(107)) {
            if (this.regexp_eatGroupName(e3)) return e3.backReferenceNames.push(e3.lastStringValue), true;
            e3.raise("Invalid named reference");
          }
          return false;
        }, Se.regexp_eatCharacterEscape = function(e3) {
          return this.regexp_eatControlEscape(e3) || this.regexp_eatCControlLetter(e3) || this.regexp_eatZero(e3) || this.regexp_eatHexEscapeSequence(e3) || this.regexp_eatRegExpUnicodeEscapeSequence(e3, false) || !e3.switchU && this.regexp_eatLegacyOctalEscapeSequence(e3) || this.regexp_eatIdentityEscape(e3);
        }, Se.regexp_eatCControlLetter = function(e3) {
          var t3 = e3.pos;
          if (e3.eat(99)) {
            if (this.regexp_eatControlLetter(e3)) return true;
            e3.pos = t3;
          }
          return false;
        }, Se.regexp_eatZero = function(e3) {
          return 48 === e3.current() && !isDecimalDigit(e3.lookahead()) && (e3.lastIntValue = 0, e3.advance(), true);
        }, Se.regexp_eatControlEscape = function(e3) {
          var t3 = e3.current();
          return 116 === t3 ? (e3.lastIntValue = 9, e3.advance(), true) : 110 === t3 ? (e3.lastIntValue = 10, e3.advance(), true) : 118 === t3 ? (e3.lastIntValue = 11, e3.advance(), true) : 102 === t3 ? (e3.lastIntValue = 12, e3.advance(), true) : 114 === t3 && (e3.lastIntValue = 13, e3.advance(), true);
        }, Se.regexp_eatControlLetter = function(e3) {
          var t3 = e3.current();
          return !!isControlLetter(t3) && (e3.lastIntValue = t3 % 32, e3.advance(), true);
        }, Se.regexp_eatRegExpUnicodeEscapeSequence = function(e3, t3) {
          void 0 === t3 && (t3 = false);
          var r2, n2 = e3.pos, s2 = t3 || e3.switchU;
          if (e3.eat(117)) {
            if (this.regexp_eatFixedHexDigits(e3, 4)) {
              var i2 = e3.lastIntValue;
              if (s2 && i2 >= 55296 && i2 <= 56319) {
                var o2 = e3.pos;
                if (e3.eat(92) && e3.eat(117) && this.regexp_eatFixedHexDigits(e3, 4)) {
                  var a2 = e3.lastIntValue;
                  if (a2 >= 56320 && a2 <= 57343) return e3.lastIntValue = 1024 * (i2 - 55296) + (a2 - 56320) + 65536, true;
                }
                e3.pos = o2, e3.lastIntValue = i2;
              }
              return true;
            }
            if (s2 && e3.eat(123) && this.regexp_eatHexDigits(e3) && e3.eat(125) && ((r2 = e3.lastIntValue) >= 0 && r2 <= 1114111)) return true;
            s2 && e3.raise("Invalid unicode escape"), e3.pos = n2;
          }
          return false;
        }, Se.regexp_eatIdentityEscape = function(e3) {
          if (e3.switchU) return !!this.regexp_eatSyntaxCharacter(e3) || !!e3.eat(47) && (e3.lastIntValue = 47, true);
          var t3 = e3.current();
          return !(99 === t3 || e3.switchN && 107 === t3) && (e3.lastIntValue = t3, e3.advance(), true);
        }, Se.regexp_eatDecimalEscape = function(e3) {
          e3.lastIntValue = 0;
          var t3 = e3.current();
          if (t3 >= 49 && t3 <= 57) {
            do {
              e3.lastIntValue = 10 * e3.lastIntValue + (t3 - 48), e3.advance();
            } while ((t3 = e3.current()) >= 48 && t3 <= 57);
            return true;
          }
          return false;
        };
        function isUnicodePropertyNameCharacter(e3) {
          return isControlLetter(e3) || 95 === e3;
        }
        function isUnicodePropertyValueCharacter(e3) {
          return isUnicodePropertyNameCharacter(e3) || isDecimalDigit(e3);
        }
        function isDecimalDigit(e3) {
          return e3 >= 48 && e3 <= 57;
        }
        function isHexDigit(e3) {
          return e3 >= 48 && e3 <= 57 || e3 >= 65 && e3 <= 70 || e3 >= 97 && e3 <= 102;
        }
        function hexToInt(e3) {
          return e3 >= 65 && e3 <= 70 ? e3 - 65 + 10 : e3 >= 97 && e3 <= 102 ? e3 - 97 + 10 : e3 - 48;
        }
        function isOctalDigit(e3) {
          return e3 >= 48 && e3 <= 55;
        }
        Se.regexp_eatCharacterClassEscape = function(e3) {
          var t3 = e3.current();
          if (/* @__PURE__ */ (function(e4) {
            return 100 === e4 || 68 === e4 || 115 === e4 || 83 === e4 || 119 === e4 || 87 === e4;
          })(t3)) return e3.lastIntValue = -1, e3.advance(), 1;
          var r2 = false;
          if (e3.switchU && this.options.ecmaVersion >= 9 && ((r2 = 80 === t3) || 112 === t3)) {
            var n2;
            if (e3.lastIntValue = -1, e3.advance(), e3.eat(123) && (n2 = this.regexp_eatUnicodePropertyValueExpression(e3)) && e3.eat(125)) return r2 && 2 === n2 && e3.raise("Invalid property name"), n2;
            e3.raise("Invalid property name");
          }
          return 0;
        }, Se.regexp_eatUnicodePropertyValueExpression = function(e3) {
          var t3 = e3.pos;
          if (this.regexp_eatUnicodePropertyName(e3) && e3.eat(61)) {
            var r2 = e3.lastStringValue;
            if (this.regexp_eatUnicodePropertyValue(e3)) {
              var n2 = e3.lastStringValue;
              return this.regexp_validateUnicodePropertyNameAndValue(e3, r2, n2), 1;
            }
          }
          if (e3.pos = t3, this.regexp_eatLoneUnicodePropertyNameOrValue(e3)) {
            var s2 = e3.lastStringValue;
            return this.regexp_validateUnicodePropertyNameOrValue(e3, s2);
          }
          return 0;
        }, Se.regexp_validateUnicodePropertyNameAndValue = function(e3, t3, r2) {
          M(e3.unicodeProperties.nonBinary, t3) || e3.raise("Invalid property name"), e3.unicodeProperties.nonBinary[t3].test(r2) || e3.raise("Invalid property value");
        }, Se.regexp_validateUnicodePropertyNameOrValue = function(e3, t3) {
          return e3.unicodeProperties.binary.test(t3) ? 1 : e3.switchV && e3.unicodeProperties.binaryOfStrings.test(t3) ? 2 : void e3.raise("Invalid property name");
        }, Se.regexp_eatUnicodePropertyName = function(e3) {
          var t3 = 0;
          for (e3.lastStringValue = ""; isUnicodePropertyNameCharacter(t3 = e3.current()); ) e3.lastStringValue += codePointToString(t3), e3.advance();
          return "" !== e3.lastStringValue;
        }, Se.regexp_eatUnicodePropertyValue = function(e3) {
          var t3 = 0;
          for (e3.lastStringValue = ""; isUnicodePropertyValueCharacter(t3 = e3.current()); ) e3.lastStringValue += codePointToString(t3), e3.advance();
          return "" !== e3.lastStringValue;
        }, Se.regexp_eatLoneUnicodePropertyNameOrValue = function(e3) {
          return this.regexp_eatUnicodePropertyValue(e3);
        }, Se.regexp_eatCharacterClass = function(e3) {
          if (e3.eat(91)) {
            var t3 = e3.eat(94), r2 = this.regexp_classContents(e3);
            return e3.eat(93) || e3.raise("Unterminated character class"), t3 && 2 === r2 && e3.raise("Negated character class may contain strings"), true;
          }
          return false;
        }, Se.regexp_classContents = function(e3) {
          return 93 === e3.current() ? 1 : e3.switchV ? this.regexp_classSetExpression(e3) : (this.regexp_nonEmptyClassRanges(e3), 1);
        }, Se.regexp_nonEmptyClassRanges = function(e3) {
          for (; this.regexp_eatClassAtom(e3); ) {
            var t3 = e3.lastIntValue;
            if (e3.eat(45) && this.regexp_eatClassAtom(e3)) {
              var r2 = e3.lastIntValue;
              !e3.switchU || -1 !== t3 && -1 !== r2 || e3.raise("Invalid character class"), -1 !== t3 && -1 !== r2 && t3 > r2 && e3.raise("Range out of order in character class");
            }
          }
        }, Se.regexp_eatClassAtom = function(e3) {
          var t3 = e3.pos;
          if (e3.eat(92)) {
            if (this.regexp_eatClassEscape(e3)) return true;
            if (e3.switchU) {
              var r2 = e3.current();
              (99 === r2 || isOctalDigit(r2)) && e3.raise("Invalid class escape"), e3.raise("Invalid escape");
            }
            e3.pos = t3;
          }
          var n2 = e3.current();
          return 93 !== n2 && (e3.lastIntValue = n2, e3.advance(), true);
        }, Se.regexp_eatClassEscape = function(e3) {
          var t3 = e3.pos;
          if (e3.eat(98)) return e3.lastIntValue = 8, true;
          if (e3.switchU && e3.eat(45)) return e3.lastIntValue = 45, true;
          if (!e3.switchU && e3.eat(99)) {
            if (this.regexp_eatClassControlLetter(e3)) return true;
            e3.pos = t3;
          }
          return this.regexp_eatCharacterClassEscape(e3) || this.regexp_eatCharacterEscape(e3);
        }, Se.regexp_classSetExpression = function(e3) {
          var t3, r2 = 1;
          if (this.regexp_eatClassSetRange(e3)) ;
          else if (t3 = this.regexp_eatClassSetOperand(e3)) {
            2 === t3 && (r2 = 2);
            for (var n2 = e3.pos; e3.eatChars([38, 38]); ) 38 !== e3.current() && (t3 = this.regexp_eatClassSetOperand(e3)) ? 2 !== t3 && (r2 = 1) : e3.raise("Invalid character in character class");
            if (n2 !== e3.pos) return r2;
            for (; e3.eatChars([45, 45]); ) this.regexp_eatClassSetOperand(e3) || e3.raise("Invalid character in character class");
            if (n2 !== e3.pos) return r2;
          } else e3.raise("Invalid character in character class");
          for (; ; ) if (!this.regexp_eatClassSetRange(e3)) {
            if (!(t3 = this.regexp_eatClassSetOperand(e3))) return r2;
            2 === t3 && (r2 = 2);
          }
        }, Se.regexp_eatClassSetRange = function(e3) {
          var t3 = e3.pos;
          if (this.regexp_eatClassSetCharacter(e3)) {
            var r2 = e3.lastIntValue;
            if (e3.eat(45) && this.regexp_eatClassSetCharacter(e3)) {
              var n2 = e3.lastIntValue;
              return -1 !== r2 && -1 !== n2 && r2 > n2 && e3.raise("Range out of order in character class"), true;
            }
            e3.pos = t3;
          }
          return false;
        }, Se.regexp_eatClassSetOperand = function(e3) {
          return this.regexp_eatClassSetCharacter(e3) ? 1 : this.regexp_eatClassStringDisjunction(e3) || this.regexp_eatNestedClass(e3);
        }, Se.regexp_eatNestedClass = function(e3) {
          var t3 = e3.pos;
          if (e3.eat(91)) {
            var r2 = e3.eat(94), n2 = this.regexp_classContents(e3);
            if (e3.eat(93)) return r2 && 2 === n2 && e3.raise("Negated character class may contain strings"), n2;
            e3.pos = t3;
          }
          if (e3.eat(92)) {
            var s2 = this.regexp_eatCharacterClassEscape(e3);
            if (s2) return s2;
            e3.pos = t3;
          }
          return null;
        }, Se.regexp_eatClassStringDisjunction = function(e3) {
          var t3 = e3.pos;
          if (e3.eatChars([92, 113])) {
            if (e3.eat(123)) {
              var r2 = this.regexp_classStringDisjunctionContents(e3);
              if (e3.eat(125)) return r2;
            } else e3.raise("Invalid escape");
            e3.pos = t3;
          }
          return null;
        }, Se.regexp_classStringDisjunctionContents = function(e3) {
          for (var t3 = this.regexp_classString(e3); e3.eat(124); ) 2 === this.regexp_classString(e3) && (t3 = 2);
          return t3;
        }, Se.regexp_classString = function(e3) {
          for (var t3 = 0; this.regexp_eatClassSetCharacter(e3); ) t3++;
          return 1 === t3 ? 1 : 2;
        }, Se.regexp_eatClassSetCharacter = function(e3) {
          var t3 = e3.pos;
          if (e3.eat(92)) return !(!this.regexp_eatCharacterEscape(e3) && !this.regexp_eatClassSetReservedPunctuator(e3)) || (e3.eat(98) ? (e3.lastIntValue = 8, true) : (e3.pos = t3, false));
          var r2 = e3.current();
          return !(r2 < 0 || r2 === e3.lookahead() && (function(e4) {
            return 33 === e4 || e4 >= 35 && e4 <= 38 || e4 >= 42 && e4 <= 44 || 46 === e4 || e4 >= 58 && e4 <= 64 || 94 === e4 || 96 === e4 || 126 === e4;
          })(r2)) && (!(function(e4) {
            return 40 === e4 || 41 === e4 || 45 === e4 || 47 === e4 || e4 >= 91 && e4 <= 93 || e4 >= 123 && e4 <= 125;
          })(r2) && (e3.advance(), e3.lastIntValue = r2, true));
        }, Se.regexp_eatClassSetReservedPunctuator = function(e3) {
          var t3 = e3.current();
          return !!(function(e4) {
            return 33 === e4 || 35 === e4 || 37 === e4 || 38 === e4 || 44 === e4 || 45 === e4 || e4 >= 58 && e4 <= 62 || 64 === e4 || 96 === e4 || 126 === e4;
          })(t3) && (e3.lastIntValue = t3, e3.advance(), true);
        }, Se.regexp_eatClassControlLetter = function(e3) {
          var t3 = e3.current();
          return !(!isDecimalDigit(t3) && 95 !== t3) && (e3.lastIntValue = t3 % 32, e3.advance(), true);
        }, Se.regexp_eatHexEscapeSequence = function(e3) {
          var t3 = e3.pos;
          if (e3.eat(120)) {
            if (this.regexp_eatFixedHexDigits(e3, 2)) return true;
            e3.switchU && e3.raise("Invalid escape"), e3.pos = t3;
          }
          return false;
        }, Se.regexp_eatDecimalDigits = function(e3) {
          var t3 = e3.pos, r2 = 0;
          for (e3.lastIntValue = 0; isDecimalDigit(r2 = e3.current()); ) e3.lastIntValue = 10 * e3.lastIntValue + (r2 - 48), e3.advance();
          return e3.pos !== t3;
        }, Se.regexp_eatHexDigits = function(e3) {
          var t3 = e3.pos, r2 = 0;
          for (e3.lastIntValue = 0; isHexDigit(r2 = e3.current()); ) e3.lastIntValue = 16 * e3.lastIntValue + hexToInt(r2), e3.advance();
          return e3.pos !== t3;
        }, Se.regexp_eatLegacyOctalEscapeSequence = function(e3) {
          if (this.regexp_eatOctalDigit(e3)) {
            var t3 = e3.lastIntValue;
            if (this.regexp_eatOctalDigit(e3)) {
              var r2 = e3.lastIntValue;
              t3 <= 3 && this.regexp_eatOctalDigit(e3) ? e3.lastIntValue = 64 * t3 + 8 * r2 + e3.lastIntValue : e3.lastIntValue = 8 * t3 + r2;
            } else e3.lastIntValue = t3;
            return true;
          }
          return false;
        }, Se.regexp_eatOctalDigit = function(e3) {
          var t3 = e3.current();
          return isOctalDigit(t3) ? (e3.lastIntValue = t3 - 48, e3.advance(), true) : (e3.lastIntValue = 0, false);
        }, Se.regexp_eatFixedHexDigits = function(e3, t3) {
          var r2 = e3.pos;
          e3.lastIntValue = 0;
          for (var n2 = 0; n2 < t3; ++n2) {
            var s2 = e3.current();
            if (!isHexDigit(s2)) return e3.pos = r2, false;
            e3.lastIntValue = 16 * e3.lastIntValue + hexToInt(s2), e3.advance();
          }
          return true;
        };
        var acorn_Token = function(e3) {
          this.type = e3.type, this.value = e3.value, this.start = e3.start, this.end = e3.end, e3.options.locations && (this.loc = new acorn_SourceLocation(e3, e3.startLoc, e3.endLoc)), e3.options.ranges && (this.range = [e3.start, e3.end]);
        }, Pe = acorn_Parser.prototype;
        function stringToBigInt(e3) {
          return "function" != typeof BigInt ? null : BigInt(e3.replace(/_/g, ""));
        }
        Pe.next = function(e3) {
          !e3 && this.type.keyword && this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword), this.options.onToken && this.options.onToken(new acorn_Token(this)), this.lastTokEnd = this.end, this.lastTokStart = this.start, this.lastTokEndLoc = this.endLoc, this.lastTokStartLoc = this.startLoc, this.nextToken();
        }, Pe.getToken = function() {
          return this.next(), new acorn_Token(this);
        }, "undefined" != typeof Symbol && (Pe[Symbol.iterator] = function() {
          var e3 = this;
          return { next: function() {
            var t3 = e3.getToken();
            return { done: t3.type === I.eof, value: t3 };
          } };
        }), Pe.nextToken = function() {
          var e3 = this.curContext();
          return e3 && e3.preserveSpace || this.skipSpace(), this.start = this.pos, this.options.locations && (this.startLoc = this.curPosition()), this.pos >= this.input.length ? this.finishToken(I.eof) : e3.override ? e3.override(this) : void this.readToken(this.fullCharCodeAtPos());
        }, Pe.readToken = function(e3) {
          return isIdentifierStart(e3, this.options.ecmaVersion >= 6) || 92 === e3 ? this.readWord() : this.getTokenFromCode(e3);
        }, Pe.fullCharCodeAtPos = function() {
          var e3 = this.input.charCodeAt(this.pos);
          if (e3 <= 55295 || e3 >= 56320) return e3;
          var t3 = this.input.charCodeAt(this.pos + 1);
          return t3 <= 56319 || t3 >= 57344 ? e3 : (e3 << 10) + t3 - 56613888;
        }, Pe.skipBlockComment = function() {
          var e3 = this.options.onComment && this.curPosition(), t3 = this.pos, r2 = this.input.indexOf("*/", this.pos += 2);
          if (-1 === r2 && this.raise(this.pos - 2, "Unterminated comment"), this.pos = r2 + 2, this.options.locations) for (var n2 = void 0, s2 = t3; (n2 = nextLineBreak(this.input, s2, this.pos)) > -1; ) ++this.curLine, s2 = this.lineStart = n2;
          this.options.onComment && this.options.onComment(true, this.input.slice(t3 + 2, r2), t3, this.pos, e3, this.curPosition());
        }, Pe.skipLineComment = function(e3) {
          for (var t3 = this.pos, r2 = this.options.onComment && this.curPosition(), n2 = this.input.charCodeAt(this.pos += e3); this.pos < this.input.length && !isNewLine(n2); ) n2 = this.input.charCodeAt(++this.pos);
          this.options.onComment && this.options.onComment(false, this.input.slice(t3 + e3, this.pos), t3, this.pos, r2, this.curPosition());
        }, Pe.skipSpace = function() {
          e: for (; this.pos < this.input.length; ) {
            var e3 = this.input.charCodeAt(this.pos);
            switch (e3) {
              case 32:
              case 160:
                ++this.pos;
                break;
              case 13:
                10 === this.input.charCodeAt(this.pos + 1) && ++this.pos;
              case 10:
              case 8232:
              case 8233:
                ++this.pos, this.options.locations && (++this.curLine, this.lineStart = this.pos);
                break;
              case 47:
                switch (this.input.charCodeAt(this.pos + 1)) {
                  case 42:
                    this.skipBlockComment();
                    break;
                  case 47:
                    this.skipLineComment(2);
                    break;
                  default:
                    break e;
                }
                break;
              default:
                if (!(e3 > 8 && e3 < 14 || e3 >= 5760 && N.test(String.fromCharCode(e3)))) break e;
                ++this.pos;
            }
          }
        }, Pe.finishToken = function(e3, t3) {
          this.end = this.pos, this.options.locations && (this.endLoc = this.curPosition());
          var r2 = this.type;
          this.type = e3, this.value = t3, this.updateContext(r2);
        }, Pe.readToken_dot = function() {
          var e3 = this.input.charCodeAt(this.pos + 1);
          if (e3 >= 48 && e3 <= 57) return this.readNumber(true);
          var t3 = this.input.charCodeAt(this.pos + 2);
          return this.options.ecmaVersion >= 6 && 46 === e3 && 46 === t3 ? (this.pos += 3, this.finishToken(I.ellipsis)) : (++this.pos, this.finishToken(I.dot));
        }, Pe.readToken_slash = function() {
          var e3 = this.input.charCodeAt(this.pos + 1);
          return this.exprAllowed ? (++this.pos, this.readRegexp()) : 61 === e3 ? this.finishOp(I.assign, 2) : this.finishOp(I.slash, 1);
        }, Pe.readToken_mult_modulo_exp = function(e3) {
          var t3 = this.input.charCodeAt(this.pos + 1), r2 = 1, n2 = 42 === e3 ? I.star : I.modulo;
          return this.options.ecmaVersion >= 7 && 42 === e3 && 42 === t3 && (++r2, n2 = I.starstar, t3 = this.input.charCodeAt(this.pos + 2)), 61 === t3 ? this.finishOp(I.assign, r2 + 1) : this.finishOp(n2, r2);
        }, Pe.readToken_pipe_amp = function(e3) {
          var t3 = this.input.charCodeAt(this.pos + 1);
          if (t3 === e3) {
            if (this.options.ecmaVersion >= 12) {
              if (61 === this.input.charCodeAt(this.pos + 2)) return this.finishOp(I.assign, 3);
            }
            return this.finishOp(124 === e3 ? I.logicalOR : I.logicalAND, 2);
          }
          return 61 === t3 ? this.finishOp(I.assign, 2) : this.finishOp(124 === e3 ? I.bitwiseOR : I.bitwiseAND, 1);
        }, Pe.readToken_caret = function() {
          return 61 === this.input.charCodeAt(this.pos + 1) ? this.finishOp(I.assign, 2) : this.finishOp(I.bitwiseXOR, 1);
        }, Pe.readToken_plus_min = function(e3) {
          var t3 = this.input.charCodeAt(this.pos + 1);
          return t3 === e3 ? 45 !== t3 || this.inModule || 62 !== this.input.charCodeAt(this.pos + 2) || 0 !== this.lastTokEnd && !D.test(this.input.slice(this.lastTokEnd, this.pos)) ? this.finishOp(I.incDec, 2) : (this.skipLineComment(3), this.skipSpace(), this.nextToken()) : 61 === t3 ? this.finishOp(I.assign, 2) : this.finishOp(I.plusMin, 1);
        }, Pe.readToken_lt_gt = function(e3) {
          var t3 = this.input.charCodeAt(this.pos + 1), r2 = 1;
          return t3 === e3 ? (r2 = 62 === e3 && 62 === this.input.charCodeAt(this.pos + 2) ? 3 : 2, 61 === this.input.charCodeAt(this.pos + r2) ? this.finishOp(I.assign, r2 + 1) : this.finishOp(I.bitShift, r2)) : 33 !== t3 || 60 !== e3 || this.inModule || 45 !== this.input.charCodeAt(this.pos + 2) || 45 !== this.input.charCodeAt(this.pos + 3) ? (61 === t3 && (r2 = 2), this.finishOp(I.relational, r2)) : (this.skipLineComment(4), this.skipSpace(), this.nextToken());
        }, Pe.readToken_eq_excl = function(e3) {
          var t3 = this.input.charCodeAt(this.pos + 1);
          return 61 === t3 ? this.finishOp(I.equality, 61 === this.input.charCodeAt(this.pos + 2) ? 3 : 2) : 61 === e3 && 62 === t3 && this.options.ecmaVersion >= 6 ? (this.pos += 2, this.finishToken(I.arrow)) : this.finishOp(61 === e3 ? I.eq : I.prefix, 1);
        }, Pe.readToken_question = function() {
          var e3 = this.options.ecmaVersion;
          if (e3 >= 11) {
            var t3 = this.input.charCodeAt(this.pos + 1);
            if (46 === t3) {
              var r2 = this.input.charCodeAt(this.pos + 2);
              if (r2 < 48 || r2 > 57) return this.finishOp(I.questionDot, 2);
            }
            if (63 === t3) {
              if (e3 >= 12) {
                if (61 === this.input.charCodeAt(this.pos + 2)) return this.finishOp(I.assign, 3);
              }
              return this.finishOp(I.coalesce, 2);
            }
          }
          return this.finishOp(I.question, 1);
        }, Pe.readToken_numberSign = function() {
          var e3 = 35;
          if (this.options.ecmaVersion >= 13 && (++this.pos, isIdentifierStart(e3 = this.fullCharCodeAtPos(), true) || 92 === e3)) return this.finishToken(I.privateId, this.readWord1());
          this.raise(this.pos, "Unexpected character '" + codePointToString(e3) + "'");
        }, Pe.getTokenFromCode = function(e3) {
          switch (e3) {
            case 46:
              return this.readToken_dot();
            case 40:
              return ++this.pos, this.finishToken(I.parenL);
            case 41:
              return ++this.pos, this.finishToken(I.parenR);
            case 59:
              return ++this.pos, this.finishToken(I.semi);
            case 44:
              return ++this.pos, this.finishToken(I.comma);
            case 91:
              return ++this.pos, this.finishToken(I.bracketL);
            case 93:
              return ++this.pos, this.finishToken(I.bracketR);
            case 123:
              return ++this.pos, this.finishToken(I.braceL);
            case 125:
              return ++this.pos, this.finishToken(I.braceR);
            case 58:
              return ++this.pos, this.finishToken(I.colon);
            case 96:
              if (this.options.ecmaVersion < 6) break;
              return ++this.pos, this.finishToken(I.backQuote);
            case 48:
              var t3 = this.input.charCodeAt(this.pos + 1);
              if (120 === t3 || 88 === t3) return this.readRadixNumber(16);
              if (this.options.ecmaVersion >= 6) {
                if (111 === t3 || 79 === t3) return this.readRadixNumber(8);
                if (98 === t3 || 66 === t3) return this.readRadixNumber(2);
              }
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
              return this.readNumber(false);
            case 34:
            case 39:
              return this.readString(e3);
            case 47:
              return this.readToken_slash();
            case 37:
            case 42:
              return this.readToken_mult_modulo_exp(e3);
            case 124:
            case 38:
              return this.readToken_pipe_amp(e3);
            case 94:
              return this.readToken_caret();
            case 43:
            case 45:
              return this.readToken_plus_min(e3);
            case 60:
            case 62:
              return this.readToken_lt_gt(e3);
            case 61:
            case 33:
              return this.readToken_eq_excl(e3);
            case 63:
              return this.readToken_question();
            case 126:
              return this.finishOp(I.prefix, 1);
            case 35:
              return this.readToken_numberSign();
          }
          this.raise(this.pos, "Unexpected character '" + codePointToString(e3) + "'");
        }, Pe.finishOp = function(e3, t3) {
          var r2 = this.input.slice(this.pos, this.pos + t3);
          return this.pos += t3, this.finishToken(e3, r2);
        }, Pe.readRegexp = function() {
          for (var e3, t3, r2 = this.pos; ; ) {
            this.pos >= this.input.length && this.raise(r2, "Unterminated regular expression");
            var n2 = this.input.charAt(this.pos);
            if (D.test(n2) && this.raise(r2, "Unterminated regular expression"), e3) e3 = false;
            else {
              if ("[" === n2) t3 = true;
              else if ("]" === n2 && t3) t3 = false;
              else if ("/" === n2 && !t3) break;
              e3 = "\\" === n2;
            }
            ++this.pos;
          }
          var s2 = this.input.slice(r2, this.pos);
          ++this.pos;
          var i2 = this.pos, o2 = this.readWord1();
          this.containsEsc && this.unexpected(i2);
          var a2 = this.regexpState || (this.regexpState = new acorn_RegExpValidationState(this));
          a2.reset(r2, s2, o2), this.validateRegExpFlags(a2), this.validateRegExpPattern(a2);
          var l2 = null;
          try {
            l2 = new RegExp(s2, o2);
          } catch (e4) {
          }
          return this.finishToken(I.regexp, { pattern: s2, flags: o2, value: l2 });
        }, Pe.readInt = function(e3, t3, r2) {
          for (var n2 = this.options.ecmaVersion >= 12 && void 0 === t3, s2 = r2 && 48 === this.input.charCodeAt(this.pos), i2 = this.pos, o2 = 0, a2 = 0, l2 = 0, p2 = null == t3 ? 1 / 0 : t3; l2 < p2; ++l2, ++this.pos) {
            var c2 = this.input.charCodeAt(this.pos), u2 = void 0;
            if (n2 && 95 === c2) s2 && this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals"), 95 === a2 && this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore"), 0 === l2 && this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits"), a2 = c2;
            else {
              if ((u2 = c2 >= 97 ? c2 - 97 + 10 : c2 >= 65 ? c2 - 65 + 10 : c2 >= 48 && c2 <= 57 ? c2 - 48 : 1 / 0) >= e3) break;
              a2 = c2, o2 = o2 * e3 + u2;
            }
          }
          return n2 && 95 === a2 && this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits"), this.pos === i2 || null != t3 && this.pos - i2 !== t3 ? null : o2;
        }, Pe.readRadixNumber = function(e3) {
          var t3 = this.pos;
          this.pos += 2;
          var r2 = this.readInt(e3);
          return null == r2 && this.raise(this.start + 2, "Expected number in radix " + e3), this.options.ecmaVersion >= 11 && 110 === this.input.charCodeAt(this.pos) ? (r2 = stringToBigInt(this.input.slice(t3, this.pos)), ++this.pos) : isIdentifierStart(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(I.num, r2);
        }, Pe.readNumber = function(e3) {
          var t3 = this.pos;
          e3 || null !== this.readInt(10, void 0, true) || this.raise(t3, "Invalid number");
          var r2 = this.pos - t3 >= 2 && 48 === this.input.charCodeAt(t3);
          r2 && this.strict && this.raise(t3, "Invalid number");
          var n2 = this.input.charCodeAt(this.pos);
          if (!r2 && !e3 && this.options.ecmaVersion >= 11 && 110 === n2) {
            var s2 = stringToBigInt(this.input.slice(t3, this.pos));
            return ++this.pos, isIdentifierStart(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(I.num, s2);
          }
          r2 && /[89]/.test(this.input.slice(t3, this.pos)) && (r2 = false), 46 !== n2 || r2 || (++this.pos, this.readInt(10), n2 = this.input.charCodeAt(this.pos)), 69 !== n2 && 101 !== n2 || r2 || (43 !== (n2 = this.input.charCodeAt(++this.pos)) && 45 !== n2 || ++this.pos, null === this.readInt(10) && this.raise(t3, "Invalid number")), isIdentifierStart(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number");
          var i2, o2 = (i2 = this.input.slice(t3, this.pos), r2 ? parseInt(i2, 8) : parseFloat(i2.replace(/_/g, "")));
          return this.finishToken(I.num, o2);
        }, Pe.readCodePoint = function() {
          var e3;
          if (123 === this.input.charCodeAt(this.pos)) {
            this.options.ecmaVersion < 6 && this.unexpected();
            var t3 = ++this.pos;
            e3 = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos), ++this.pos, e3 > 1114111 && this.invalidStringToken(t3, "Code point out of bounds");
          } else e3 = this.readHexChar(4);
          return e3;
        }, Pe.readString = function(e3) {
          for (var t3 = "", r2 = ++this.pos; ; ) {
            this.pos >= this.input.length && this.raise(this.start, "Unterminated string constant");
            var n2 = this.input.charCodeAt(this.pos);
            if (n2 === e3) break;
            92 === n2 ? (t3 += this.input.slice(r2, this.pos), t3 += this.readEscapedChar(false), r2 = this.pos) : 8232 === n2 || 8233 === n2 ? (this.options.ecmaVersion < 10 && this.raise(this.start, "Unterminated string constant"), ++this.pos, this.options.locations && (this.curLine++, this.lineStart = this.pos)) : (isNewLine(n2) && this.raise(this.start, "Unterminated string constant"), ++this.pos);
          }
          return t3 += this.input.slice(r2, this.pos++), this.finishToken(I.string, t3);
        };
        var _e = {};
        Pe.tryReadTemplateToken = function() {
          this.inTemplateElement = true;
          try {
            this.readTmplToken();
          } catch (e3) {
            if (e3 !== _e) throw e3;
            this.readInvalidTemplateToken();
          }
          this.inTemplateElement = false;
        }, Pe.invalidStringToken = function(e3, t3) {
          if (this.inTemplateElement && this.options.ecmaVersion >= 9) throw _e;
          this.raise(e3, t3);
        }, Pe.readTmplToken = function() {
          for (var e3 = "", t3 = this.pos; ; ) {
            this.pos >= this.input.length && this.raise(this.start, "Unterminated template");
            var r2 = this.input.charCodeAt(this.pos);
            if (96 === r2 || 36 === r2 && 123 === this.input.charCodeAt(this.pos + 1)) return this.pos !== this.start || this.type !== I.template && this.type !== I.invalidTemplate ? (e3 += this.input.slice(t3, this.pos), this.finishToken(I.template, e3)) : 36 === r2 ? (this.pos += 2, this.finishToken(I.dollarBraceL)) : (++this.pos, this.finishToken(I.backQuote));
            if (92 === r2) e3 += this.input.slice(t3, this.pos), e3 += this.readEscapedChar(true), t3 = this.pos;
            else if (isNewLine(r2)) {
              switch (e3 += this.input.slice(t3, this.pos), ++this.pos, r2) {
                case 13:
                  10 === this.input.charCodeAt(this.pos) && ++this.pos;
                case 10:
                  e3 += "\n";
                  break;
                default:
                  e3 += String.fromCharCode(r2);
              }
              this.options.locations && (++this.curLine, this.lineStart = this.pos), t3 = this.pos;
            } else ++this.pos;
          }
        }, Pe.readInvalidTemplateToken = function() {
          for (; this.pos < this.input.length; this.pos++) switch (this.input[this.pos]) {
            case "\\":
              ++this.pos;
              break;
            case "$":
              if ("{" !== this.input[this.pos + 1]) break;
            case "`":
              return this.finishToken(I.invalidTemplate, this.input.slice(this.start, this.pos));
            case "\r":
              "\n" === this.input[this.pos + 1] && ++this.pos;
            case "\n":
            case "\u2028":
            case "\u2029":
              ++this.curLine, this.lineStart = this.pos + 1;
          }
          this.raise(this.start, "Unterminated template");
        }, Pe.readEscapedChar = function(e3) {
          var t3 = this.input.charCodeAt(++this.pos);
          switch (++this.pos, t3) {
            case 110:
              return "\n";
            case 114:
              return "\r";
            case 120:
              return String.fromCharCode(this.readHexChar(2));
            case 117:
              return codePointToString(this.readCodePoint());
            case 116:
              return "	";
            case 98:
              return "\b";
            case 118:
              return "\v";
            case 102:
              return "\f";
            case 13:
              10 === this.input.charCodeAt(this.pos) && ++this.pos;
            case 10:
              return this.options.locations && (this.lineStart = this.pos, ++this.curLine), "";
            case 56:
            case 57:
              if (this.strict && this.invalidStringToken(this.pos - 1, "Invalid escape sequence"), e3) {
                var r2 = this.pos - 1;
                this.invalidStringToken(r2, "Invalid escape sequence in template string");
              }
            default:
              if (t3 >= 48 && t3 <= 55) {
                var n2 = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0], s2 = parseInt(n2, 8);
                return s2 > 255 && (n2 = n2.slice(0, -1), s2 = parseInt(n2, 8)), this.pos += n2.length - 1, t3 = this.input.charCodeAt(this.pos), "0" === n2 && 56 !== t3 && 57 !== t3 || !this.strict && !e3 || this.invalidStringToken(this.pos - 1 - n2.length, e3 ? "Octal literal in template string" : "Octal literal in strict mode"), String.fromCharCode(s2);
              }
              return isNewLine(t3) ? (this.options.locations && (this.lineStart = this.pos, ++this.curLine), "") : String.fromCharCode(t3);
          }
        }, Pe.readHexChar = function(e3) {
          var t3 = this.pos, r2 = this.readInt(16, e3);
          return null === r2 && this.invalidStringToken(t3, "Bad character escape sequence"), r2;
        }, Pe.readWord1 = function() {
          this.containsEsc = false;
          for (var e3 = "", t3 = true, r2 = this.pos, n2 = this.options.ecmaVersion >= 6; this.pos < this.input.length; ) {
            var s2 = this.fullCharCodeAtPos();
            if (isIdentifierChar(s2, n2)) this.pos += s2 <= 65535 ? 1 : 2;
            else {
              if (92 !== s2) break;
              this.containsEsc = true, e3 += this.input.slice(r2, this.pos);
              var i2 = this.pos;
              117 !== this.input.charCodeAt(++this.pos) && this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"), ++this.pos;
              var o2 = this.readCodePoint();
              (t3 ? isIdentifierStart : isIdentifierChar)(o2, n2) || this.invalidStringToken(i2, "Invalid Unicode escape"), e3 += codePointToString(o2), r2 = this.pos;
            }
            t3 = false;
          }
          return e3 + this.input.slice(r2, this.pos);
        }, Pe.readWord = function() {
          var e3 = this.readWord1(), t3 = I.name;
          return this.keywords.test(e3) && (t3 = w[e3]), this.finishToken(t3, e3);
        };
        acorn_Parser.acorn = { Parser: acorn_Parser, version: "8.15.0", defaultOptions: V, Position: acorn_Position, SourceLocation: acorn_SourceLocation, getLineInfo, Node: acorn_Node, TokenType: acorn_TokenType, tokTypes: I, keywordTypes: w, TokContext: acorn_TokContext, tokContexts: te, isIdentifierChar, isIdentifierStart, Token: acorn_Token, isNewLine, lineBreak: D, lineBreakG: k, nonASCIIwhitespace: N };
        const Ae = require("node:module"), Ce = (require("node:fs"), require("node:url")), we = require("node:assert"), Ie = (require("node:process"), require("node:path"), require("node:v8")), De = require("node:util");
        new Set(Ae.builtinModules);
        function normalizeSlash(e3) {
          return e3.replace(/\\/g, "/");
        }
        const ke = {}.hasOwnProperty, Ne = /^([A-Z][a-z\d]*)+$/, Oe = /* @__PURE__ */ new Set(["string", "function", "number", "object", "Function", "Object", "boolean", "bigint", "symbol"]), je = {};
        function formatList(e3, t3 = "and") {
          return e3.length < 3 ? e3.join(` ${t3} `) : `${e3.slice(0, -1).join(", ")}, ${t3} ${e3[e3.length - 1]}`;
        }
        const Fe = /* @__PURE__ */ new Map();
        let Le;
        function createError(e3, t3, r2) {
          return Fe.set(e3, t3), /* @__PURE__ */ (function(e4, t4) {
            return NodeError;
            function NodeError(...r3) {
              const n2 = Error.stackTraceLimit;
              isErrorStackTraceLimitWritable() && (Error.stackTraceLimit = 0);
              const s2 = new e4();
              isErrorStackTraceLimitWritable() && (Error.stackTraceLimit = n2);
              const i2 = (function(e5, t5, r4) {
                const n3 = Fe.get(e5);
                if (we(void 0 !== n3, "expected `message` to be found"), "function" == typeof n3) return we(n3.length <= t5.length, `Code: ${e5}; The provided arguments length (${t5.length}) does not match the required ones (${n3.length}).`), Reflect.apply(n3, r4, t5);
                const s3 = /%[dfijoOs]/g;
                let i3 = 0;
                for (; null !== s3.exec(n3); ) i3++;
                return we(i3 === t5.length, `Code: ${e5}; The provided arguments length (${t5.length}) does not match the required ones (${i3}).`), 0 === t5.length ? n3 : (t5.unshift(n3), Reflect.apply(De.format, null, t5));
              })(t4, r3, s2);
              return Object.defineProperties(s2, { message: { value: i2, enumerable: false, writable: true, configurable: true }, toString: { value() {
                return `${this.name} [${t4}]: ${this.message}`;
              }, enumerable: false, writable: true, configurable: true } }), Me(s2), s2.code = t4, s2;
            }
          })(r2, e3);
        }
        function isErrorStackTraceLimitWritable() {
          try {
            if (Ie.startupSnapshot.isBuildingSnapshot()) return false;
          } catch {
          }
          const e3 = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit");
          return void 0 === e3 ? Object.isExtensible(Error) : ke.call(e3, "writable") && void 0 !== e3.writable ? e3.writable : void 0 !== e3.set;
        }
        je.ERR_INVALID_ARG_TYPE = createError("ERR_INVALID_ARG_TYPE", (e3, t3, r2) => {
          we("string" == typeof e3, "'name' must be a string"), Array.isArray(t3) || (t3 = [t3]);
          let n2 = "The ";
          if (e3.endsWith(" argument")) n2 += `${e3} `;
          else {
            const t4 = e3.includes(".") ? "property" : "argument";
            n2 += `"${e3}" ${t4} `;
          }
          n2 += "must be ";
          const s2 = [], i2 = [], o2 = [];
          for (const e4 of t3) we("string" == typeof e4, "All expected entries have to be of type string"), Oe.has(e4) ? s2.push(e4.toLowerCase()) : null === Ne.exec(e4) ? (we("object" !== e4, 'The value "object" should be written as "Object"'), o2.push(e4)) : i2.push(e4);
          if (i2.length > 0) {
            const e4 = s2.indexOf("object");
            -1 !== e4 && (s2.slice(e4, 1), i2.push("Object"));
          }
          return s2.length > 0 && (n2 += `${s2.length > 1 ? "one of type" : "of type"} ${formatList(s2, "or")}`, (i2.length > 0 || o2.length > 0) && (n2 += " or ")), i2.length > 0 && (n2 += `an instance of ${formatList(i2, "or")}`, o2.length > 0 && (n2 += " or ")), o2.length > 0 && (o2.length > 1 ? n2 += `one of ${formatList(o2, "or")}` : (o2[0].toLowerCase() !== o2[0] && (n2 += "an "), n2 += `${o2[0]}`)), n2 += `. Received ${(function(e4) {
            if (null == e4) return String(e4);
            if ("function" == typeof e4 && e4.name) return `function ${e4.name}`;
            if ("object" == typeof e4) return e4.constructor && e4.constructor.name ? `an instance of ${e4.constructor.name}` : `${(0, De.inspect)(e4, { depth: -1 })}`;
            let t4 = (0, De.inspect)(e4, { colors: false });
            t4.length > 28 && (t4 = `${t4.slice(0, 25)}...`);
            return `type ${typeof e4} (${t4})`;
          })(r2)}`, n2;
        }, TypeError), je.ERR_INVALID_MODULE_SPECIFIER = createError("ERR_INVALID_MODULE_SPECIFIER", (e3, t3, r2 = void 0) => `Invalid module "${e3}" ${t3}${r2 ? ` imported from ${r2}` : ""}`, TypeError), je.ERR_INVALID_PACKAGE_CONFIG = createError("ERR_INVALID_PACKAGE_CONFIG", (e3, t3, r2) => `Invalid package config ${e3}${t3 ? ` while importing ${t3}` : ""}${r2 ? `. ${r2}` : ""}`, Error), je.ERR_INVALID_PACKAGE_TARGET = createError("ERR_INVALID_PACKAGE_TARGET", (e3, t3, r2, n2 = false, s2 = void 0) => {
          const i2 = "string" == typeof r2 && !n2 && r2.length > 0 && !r2.startsWith("./");
          return "." === t3 ? (we(false === n2), `Invalid "exports" main target ${JSON.stringify(r2)} defined in the package config ${e3}package.json${s2 ? ` imported from ${s2}` : ""}${i2 ? '; targets must start with "./"' : ""}`) : `Invalid "${n2 ? "imports" : "exports"}" target ${JSON.stringify(r2)} defined for '${t3}' in the package config ${e3}package.json${s2 ? ` imported from ${s2}` : ""}${i2 ? '; targets must start with "./"' : ""}`;
        }, Error), je.ERR_MODULE_NOT_FOUND = createError("ERR_MODULE_NOT_FOUND", (e3, t3, r2 = false) => `Cannot find ${r2 ? "module" : "package"} '${e3}' imported from ${t3}`, Error), je.ERR_NETWORK_IMPORT_DISALLOWED = createError("ERR_NETWORK_IMPORT_DISALLOWED", "import of '%s' by %s is not supported: %s", Error), je.ERR_PACKAGE_IMPORT_NOT_DEFINED = createError("ERR_PACKAGE_IMPORT_NOT_DEFINED", (e3, t3, r2) => `Package import specifier "${e3}" is not defined${t3 ? ` in package ${t3}package.json` : ""} imported from ${r2}`, TypeError), je.ERR_PACKAGE_PATH_NOT_EXPORTED = createError("ERR_PACKAGE_PATH_NOT_EXPORTED", (e3, t3, r2 = void 0) => "." === t3 ? `No "exports" main defined in ${e3}package.json${r2 ? ` imported from ${r2}` : ""}` : `Package subpath '${t3}' is not defined by "exports" in ${e3}package.json${r2 ? ` imported from ${r2}` : ""}`, Error), je.ERR_UNSUPPORTED_DIR_IMPORT = createError("ERR_UNSUPPORTED_DIR_IMPORT", "Directory import '%s' is not supported resolving ES modules imported from %s", Error), je.ERR_UNSUPPORTED_RESOLVE_REQUEST = createError("ERR_UNSUPPORTED_RESOLVE_REQUEST", 'Failed to resolve module specifier "%s" from "%s": Invalid relative URL or base scheme is not hierarchical.', TypeError), je.ERR_UNKNOWN_FILE_EXTENSION = createError("ERR_UNKNOWN_FILE_EXTENSION", (e3, t3) => `Unknown file extension "${e3}" for ${t3}`, TypeError), je.ERR_INVALID_ARG_VALUE = createError("ERR_INVALID_ARG_VALUE", (e3, t3, r2 = "is invalid") => {
          let n2 = (0, De.inspect)(t3);
          n2.length > 128 && (n2 = `${n2.slice(0, 128)}...`);
          return `The ${e3.includes(".") ? "property" : "argument"} '${e3}' ${r2}. Received ${n2}`;
        }, TypeError);
        const Me = (function(e3) {
          const t3 = "__node_internal_" + e3.name;
          return Object.defineProperty(e3, "name", { value: t3 }), e3;
        })(function(e3) {
          const t3 = isErrorStackTraceLimitWritable();
          return t3 && (Le = Error.stackTraceLimit, Error.stackTraceLimit = Number.POSITIVE_INFINITY), Error.captureStackTrace(e3), t3 && (Error.stackTraceLimit = Le), e3;
        });
        const { ERR_INVALID_PACKAGE_CONFIG: Be } = je;
        /* @__PURE__ */ new Map();
        const { ERR_UNKNOWN_FILE_EXTENSION: Re } = je;
        RegExp.prototype[Symbol.replace];
        const { ERR_INVALID_MODULE_SPECIFIER: Ue, ERR_INVALID_PACKAGE_CONFIG: Ve, ERR_INVALID_PACKAGE_TARGET: $e, ERR_MODULE_NOT_FOUND: Ke, ERR_PACKAGE_IMPORT_NOT_DEFINED: We, ERR_PACKAGE_PATH_NOT_EXPORTED: qe, ERR_UNSUPPORTED_DIR_IMPORT: He, ERR_UNSUPPORTED_RESOLVE_REQUEST: ze } = je;
        /* @__PURE__ */ new Set();
        function fileURLToPath(e3) {
          return "string" != typeof e3 || e3.startsWith("file://") ? normalizeSlash((0, Ce.fileURLToPath)(e3)) : normalizeSlash(e3);
        }
        function pathToFileURL(e3) {
          return (0, Ce.pathToFileURL)(fileURLToPath(e3)).toString();
        }
        function importMetaPathsPlugin(e3, t3) {
          return { name: "import-meta-paths", visitor: { Program(e4) {
            const r2 = [], n2 = [], s2 = [];
            e4.traverse({ MemberExpression(e5) {
              const { node: t4 } = e5;
              if ("MetaProperty" === t4.object.type && "import" === t4.object.meta.name && "meta" === t4.object.property.name && "Identifier" === t4.property.type) switch (t4.property.name) {
                case "url":
                  r2.push(e5);
                  break;
                case "dirname":
                  n2.push(e5);
                  break;
                case "filename":
                  s2.push(e5);
              }
            } });
            for (const e5 of r2) e5.replaceWith(h.smart.ast`${t3.filename ? JSON.stringify(pathToFileURL(t3.filename)) : "require('url').pathToFileURL(__filename).toString()"}`);
            for (const e5 of n2) e5.replaceWith(h.smart.ast`${t3.filename ? JSON.stringify(pathe_M_eThtNZ_dirname(fileURLToPath(pathToFileURL(t3.filename)))) : "__dirname"}`);
            for (const e5 of s2) e5.replaceWith(h.smart.ast`${t3.filename ? JSON.stringify(fileURLToPath(pathToFileURL(t3.filename))) : "__filename"}`);
          } } };
        }
        var Ge = __webpack_require__("./node_modules/.pnpm/@babel+helper-module-imports@7.27.1/node_modules/@babel/helper-module-imports/lib/index.js"), Xe = __webpack_require__("./node_modules/.pnpm/@babel+helper-module-transforms@7.28.3_@babel+core@7.28.4/node_modules/@babel/helper-module-transforms/lib/index.js"), Je = __webpack_require__("./node_modules/.pnpm/@babel+helper-simple-access@7.27.1/node_modules/@babel/helper-simple-access/lib/index.js");
        function transformDynamicImport(t3, r2, n2) {
          t3.replaceWith((0, Xe.buildDynamicImport)(t3.node, true, false, (t4) => ((t5, r3, n3) => {
            const s2 = e2.template.expression.ast`jitiImport(${t5})`;
            return n3 ? s2 : e2.types.callExpression(e2.types.memberExpression(s2, e2.types.identifier("then")), [e2.types.arrowFunctionExpression([e2.types.identifier("m")], e2.types.callExpression(r3.addHelper("interopRequireWildcard"), [e2.types.identifier("m")]))]);
          })(t4, n2, r2)));
        }
        const Ye = "@babel/plugin-transform-modules-commonjs/customWrapperPlugin";
        function findMap(e3, t3) {
          if (e3) for (const r2 of e3) {
            const e4 = t3(r2);
            if (null != e4) return e4;
          }
        }
        const Qe = (0, u.declare)((t3, r2) => {
          const { strictNamespace: n2 = false, mjsStrictNamespace: s2 = n2, allowTopLevelThis: i2, strict: o2, strictMode: a2, noInterop: l2, importInterop: p2, lazy: c2 = false, allowCommonJSExports: u2 = true, loose: d2 = false, async: h2 = false } = r2, m2 = t3.assumption("constantReexports") ?? d2, f2 = t3.assumption("enumerableModuleMeta") ?? d2, y2 = t3.assumption("noIncompleteNsImportDetection") ?? false;
          if (!("boolean" == typeof c2 || "function" == typeof c2 || Array.isArray(c2) && c2.every((e3) => "string" == typeof e3))) throw new Error(".lazy must be a boolean, array of strings, or a function");
          if ("boolean" != typeof n2) throw new TypeError(".strictNamespace must be a boolean, or undefined");
          if ("boolean" != typeof s2) throw new TypeError(".mjsStrictNamespace must be a boolean, or undefined");
          const getAssertion = (t4) => e2.template.expression.ast`
    (function(){
      throw new Error(
        "The CommonJS '" + "${t4}" + "' variable is not available in ES6 modules." +
        "Consider setting setting sourceType:script or sourceType:unambiguous in your " +
        "Babel config for this file.");
    })()
  `, b2 = { ReferencedIdentifier(e3) {
            const t4 = e3.node.name;
            if ("module" !== t4 && "exports" !== t4) return;
            const r3 = e3.scope.getBinding(t4);
            this.scope.getBinding(t4) !== r3 || e3.parentPath.isObjectProperty({ value: e3.node }) && e3.parentPath.parentPath.isObjectPattern() || e3.parentPath.isAssignmentExpression({ left: e3.node }) || e3.isAssignmentExpression({ left: e3.node }) || e3.replaceWith(getAssertion(t4));
          }, UpdateExpression(t4) {
            const r3 = t4.get("argument");
            if (!r3.isIdentifier()) return;
            const n3 = r3.node.name;
            if ("module" !== n3 && "exports" !== n3) return;
            const s3 = t4.scope.getBinding(n3);
            this.scope.getBinding(n3) === s3 && t4.replaceWith(e2.types.assignmentExpression(t4.node.operator[0] + "=", r3.node, getAssertion(n3)));
          }, AssignmentExpression(t4) {
            const r3 = t4.get("left");
            if (r3.isIdentifier()) {
              const n3 = r3.node.name;
              if ("module" !== n3 && "exports" !== n3) return;
              const s3 = t4.scope.getBinding(n3);
              if (this.scope.getBinding(n3) !== s3) return;
              const i3 = t4.get("right");
              i3.replaceWith(e2.types.sequenceExpression([i3.node, getAssertion(n3)]));
            } else if (r3.isPattern()) {
              const n3 = r3.getOuterBindingIdentifiers(), s3 = Object.keys(n3).find((e3) => ("module" === e3 || "exports" === e3) && this.scope.getBinding(e3) === t4.scope.getBinding(e3));
              if (s3) {
                const r4 = t4.get("right");
                r4.replaceWith(e2.types.sequenceExpression([r4.node, getAssertion(s3)]));
              }
            }
          } };
          return { name: "transform-modules-commonjs", pre() {
            this.file.set("@babel/plugin-transform-modules-*", "commonjs"), c2 && (function(e3, t4) {
              let r3 = e3.get(Ye);
              r3 || e3.set(Ye, r3 = []), r3.push(t4);
            })(this.file, /* @__PURE__ */ ((t4) => ({ name: "babel-plugin-transform-modules-commonjs/lazy", version: "7.24.7", getWrapperPayload: (e3, r3) => (0, Xe.isSideEffectImport)(r3) || r3.reexportAll ? null : true === t4 ? e3.includes(".") ? null : "lazy/function" : Array.isArray(t4) ? t4.includes(e3) ? "lazy/function" : null : "function" == typeof t4 ? t4(e3) ? "lazy/function" : null : void 0, buildRequireWrapper(t5, r3, n3, s3) {
              if ("lazy/function" === n3) return !!s3 && e2.template.statement.ast`
        function ${t5}() {
          const data = ${r3};
          ${t5} = function(){ return data; };
          return data;
        }
      `;
            }, wrapReference(t5, r3) {
              if ("lazy/function" === r3) return e2.types.callExpression(t5, []);
            } }))(c2));
          }, visitor: { ["CallExpression" + (t3.types.importExpression ? "|ImportExpression" : "")](t4) {
            if (t4.isCallExpression() && !e2.types.isImport(t4.node.callee)) return;
            let { scope: r3 } = t4;
            do {
              r3.rename("require");
            } while (r3 = r3.parent);
            transformDynamicImport(t4, l2, this.file);
          }, Program: { exit(t4, d3) {
            if (!(0, Ge.isModule)(t4)) return;
            t4.scope.rename("exports"), t4.scope.rename("module"), t4.scope.rename("require"), t4.scope.rename("__filename"), t4.scope.rename("__dirname"), u2 || (process.env.BABEL_8_BREAKING ? (0, Je.default)(t4, /* @__PURE__ */ new Set(["module", "exports"])) : (0, Je.default)(t4, /* @__PURE__ */ new Set(["module", "exports"]), false), t4.traverse(b2, { scope: t4.scope }));
            let g2 = (0, Xe.getModuleName)(this.file.opts, r2);
            g2 && (g2 = e2.types.stringLiteral(g2));
            const x2 = (function(e3) {
              const t5 = e3.get(Ye);
              return { getWrapperPayload: (...e4) => findMap(t5, (t6) => t6.getWrapperPayload?.(...e4)), wrapReference: (...e4) => findMap(t5, (t6) => t6.wrapReference?.(...e4)), buildRequireWrapper: (...e4) => findMap(t5, (t6) => t6.buildRequireWrapper?.(...e4)) };
            })(this.file), { meta: v2, headers: E2 } = (0, Xe.rewriteModuleStatementsAndPrepareHeader)(t4, { exportName: "exports", constantReexports: m2, enumerableModuleMeta: f2, strict: o2, strictMode: a2, allowTopLevelThis: i2, noInterop: l2, importInterop: p2, wrapReference: x2.wrapReference, getWrapperPayload: x2.getWrapperPayload, esNamespaceOnly: "string" == typeof d3.filename && /\.mjs$/.test(d3.filename) ? s2 : n2, noIncompleteNsImportDetection: y2, filename: this.file.opts.filename });
            for (const [r3, n3] of v2.source) {
              const s3 = h2 ? e2.types.awaitExpression(e2.types.callExpression(e2.types.identifier("jitiImport"), [e2.types.stringLiteral(r3)])) : e2.types.callExpression(e2.types.identifier("require"), [e2.types.stringLiteral(r3)]);
              let i3;
              if ((0, Xe.isSideEffectImport)(n3)) {
                if (c2 && "function" === n3.wrap) throw new Error("Assertion failure");
                i3 = e2.types.expressionStatement(s3);
              } else {
                const r4 = (0, Xe.wrapInterop)(t4, s3, n3.interop) || s3;
                if (n3.wrap) {
                  const e3 = x2.buildRequireWrapper(n3.name, r4, n3.wrap, n3.referenced);
                  if (false === e3) continue;
                  i3 = e3;
                }
                i3 ??= e2.template.statement.ast`
                var ${n3.name} = ${r4};
              `;
              }
              i3.loc = n3.loc, E2.push(i3, ...(0, Xe.buildNamespaceInitStatements)(v2, n3, m2, x2.wrapReference));
            }
            (0, Xe.ensureStatementsHoisted)(E2), t4.unshiftContainer("body", E2), t4.get("body").forEach((e3) => {
              E2.includes(e3.node) && e3.isVariableDeclaration() && e3.scope.registerDeclaration(e3);
            });
          } } } };
        });
        function transform(r2) {
          const p2 = { babelrc: false, configFile: false, compact: false, retainLines: "boolean" != typeof r2.retainLines || r2.retainLines, filename: "", cwd: "/", ...r2.babel, plugins: [[Qe, { allowTopLevelThis: true, noInterop: !r2.interopDefault, async: r2.async }], [importMetaPathsPlugin, { filename: r2.filename }], [importMetaEnvPlugin], [importMetaResolvePlugin], [n.default], [o.default]] };
          r2.jsx && p2.plugins.push([i.default], [a.default, Object.assign({}, r2.jsx)]), r2.ts && (p2.plugins.push([l.default, { allowDeclareFields: true, isTSX: r2.jsx && /\.[cm]?tsx$/.test(r2.filename || "") }]), p2.plugins.unshift([d], [t2.default, { legacy: true }]), p2.plugins.push(c(), s.default)), r2.babel && Array.isArray(r2.babel.plugins) && p2.plugins?.push(...r2.babel.plugins);
          try {
            return { code: (0, e2.transformSync)(r2.source, p2)?.code || "" };
          } catch (e3) {
            return { error: e3, code: "exports.__JITI_ERROR__ = " + JSON.stringify({ filename: r2.filename, line: e3.loc?.line || 0, column: e3.loc?.column || 0, code: e3.code?.replace("BABEL_", "").replace("PARSE_ERROR", "ParseError"), message: e3.message?.replace("/: ", "").replace(/\(.+\)\s*$/, "") }) };
          }
        }
      })(), module2.exports = r.default;
    })();
  }
});

// node_modules/jiti/lib/jiti.cjs
var { createRequire } = require("node:module");
var _createJiti = require_jiti();
function onError(err) {
  throw err;
}
var nativeImport = (id) => import(id);
var _transform;
function lazyTransform(...args) {
  if (!_transform) {
    _transform = require_babel();
  }
  return _transform(...args);
}
function createJiti(id, opts = {}) {
  if (!opts.transform) {
    opts = { ...opts, transform: lazyTransform };
  }
  return _createJiti(id, opts, {
    onError,
    nativeImport,
    createRequire
  });
}
module.exports = createJiti;
module.exports.createJiti = createJiti;
module.exports.version = '2.6.1';
